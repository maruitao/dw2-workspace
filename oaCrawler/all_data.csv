,title,author,link,content,time
0,Wotalk在Windows 10中有时无法启动的解决方法,康廷,http://180.168.156.212:2262/wecenter/?/question/45,今天碰到Wotalk无法启动的现象，我的系统是Win10。经过一番设置，找到了解决方法：1、在Wotalk的图标右键鼠标，点击属性。2、设置为win7兼容模式，并以管理员身份启动。点击确定，再双击Wotalk图标，就能启动了！,6 天前
1,思考：人工智能时代，我们能做点什么？,杨木春,http://180.168.156.212:2262/wecenter/?/question/44,1、档案管理机器人： 别人已经开始了，我们是否除了入出库外，可以考虑库房综合，整理盘点，等等，这个应该可以做！特别是已经上了RFID的应该可以实现的，我们引入一个机器人开发系统，我想我们也可以追赶上这个潮流。2、菜场服务机器人：各地菜场我们做了很多是否可以规划一个菜场服务机器人菜场门口迎宾，人员统计，菜价查询，帮忙称重......我们想的还很多我们能做多少呢？这些可是能很快丰富我们专利库的应该！人工智能，希望我们能迎头赶上！写在2018年产品规划之前的思考！共勉！,2017/10/17
2,2018校招在线考试手机版源码模板,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9305,素材源于互联网，改造后的版本适配手机，同时增加了上一题，下一题，以及计时器等相关样式风格kaoshi-system.zip,2017/10/13
3,2018校招在线考试登录窗口源码,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9304,该设计来源于互联网，改造后的版本适配移动终端。login-windows.zip,2017/10/13
4,基于openresty使用Lua语言开发，实现动态upstream控制nginx节点,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9303,实现nginx节点动态控制与监测涉及内容：1、Lua语言2、openresty平台3、nginx4、etcd系统常规项目可以使用reloadcong文件实现硬重载。一般硬件负载均衡器都含有强大的后台配置界面，实现节点池可视化操作；本文是一种技术尝试，旨在实现软件负载均衡器界面可配置化，实现节点可检测，以及全天无缝升级系统，该项技术目前暂未运用到我司实际项目中。详见附件，如公司有熟悉Lua语言或openresty平台的同事可以留言，或直接联系软件技术管理部。安装openresty及动态upstream.docx,2017/9/30
5,NAS存储-------NFS与CIFS协议分析,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9302,NAS存储-------NFSCIFS协议1、CIFS---Windows系统的文件Microsoft推出SMB(servermessageblock)后，进一步发展，使其扩展到Internet上，成为commoninternetfilesystem。CIFS采用C/S模式，基本网络协议：TCP/IP和IPX/SPX；两种资源访问模式：（1）sharelevelsecurity：所有用户的共享资源访问口令是相同的，主要在win9x中使用；（2）userlevelsecuryt：WinNT以后的OS只提供ULS，用于必须提供正确的U/P，并且每个用户权限可以是不同的。C/S的交互模式：类似与三次握手；三个交互：（1）协议选择：双方选择合适的协议进行交互；（2）身份验证：按选定的协议登录server，由server对client进行身份验证；（3）资源获取：认证通过后，server和client进行交互，进行文件读写等操作。注意：相同winOS中，所有机器都是对等的，扮演双重角色，可以作server，也可以是client。CIFS是一种协议，和具体的OS关系不大，Unix在安装samba后可以使用CIFS；2、NAS之文件系统之NFS-----Linux类系统文件挂载NFS：sun公司1984年推出，基于RPC构建，依靠UnixOS。目的：通过网络连接来共享servers上的Files和Data。基本原理：server借助NFS导出一个或多个可供远程客户端共享的目的，客户端mountserver上的目录，实现对文件资源的共享。客户端借助RPC对服务器提出服务请求。NFS是带Cache的，提高访问效率。NFS的服务器提供三个关键守护进程：portmap，mounted，nfsd（1）portmap――监听固定端口，提供RPC服务，将TCP/IP的协议端口映射为RPC程序号；（2）nfsd――根据客户需求启动文件系统请求服务守护进程，处理用户需求；（3）mounted――发送文件句柄给客户端的mount进程。其它进程nfsiod：用于提供IO吞吐率。NFS特点：(1)无状态协议；(2)支持故障自恢复功能；可实现容错、容灾功能；3、NFS和CIFS网络文件系统NFS（NetworkFileSystem，网络文件系统）是当前主流异构平台共享文件系统之一。主要应用在UNIX环境下。最早是由SUNmicrosystem开发，现在能够支持在不同类型的系统之间通过网络进行文件共享，广泛应用在FreeBSD、SCO、Solaris等等异构操作系统平台，允许一个系统在网络上与他人共享目录和文件。通过使用NFS，用户和程序可以象访问本地文件一样访问远端系统上的文件，使得每个计算机的节点能够像使用本地资源一样方便的使用网上资源。换言之，NFS可用于不同类型计算机、操作系统、网络架构和传输协议运行环境中的网络文件远程访问和共享。NFS的工作原理是使用客户端/服务器架构，由一个客户端程序和服务器程序组成。服务器程序向其它计算机提供对文件系统的访问，其过程就叫做“输出”。NFS客户端程序对共享文件系统进行访问时，把它们从NFS服务器“输送”出来。文件通常以“块”为单位进行传输，其尺寸是8K（虽然它可能会将操作分成更小尺寸的分片）。NFS传输协议用于服务器和客户机之间的文件访问和共享的通信，从而使客户机远程的访问保存在存储设备上的数据。CIFS(CommonInternetFileSystem，公共互联网文件系统)是当前主流异构平台共享文件系统之一。主要应用在NT/Windows环境下，是由Microsoft公司开发。其工作原理是让CIFS协议运行与TCP/IP通信协议之上，让Unix计算机可以在网络邻居上被Windows计算机看到。共享文件系统特点：1、异构平台下的文件共享：不同平台下的多个客户端可以很容易的共享NAS中的同一个文件。2、充分利用现有的LAN网络结构，保护现有投资。3、冗余安装，使用和管理都很方便，实现即插即用。4、广泛的连接性：由于基于IP/Ethernet以及标准的NFS和CIFS，可以适应复杂的网络环境。5、内部资源的整合：可以将内部的磁盘整合成一个统一的存储池，以卷的方式提供给不同的用户，每一个卷可以格式化成不同的文件系统。6、允许应用进程打开一个远地文件，并能够在该文件的某一个特定的位置上开始读写数据。NFS可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件，在网络上传送的只是少量的修改数据。需要注意的是，CIFS和NFS虽然统一也是文件系统（FileSystem），但它并不能用于在磁盘中存储和管理数据，它定义的是通过TCP/IP网络传输文件时的文件组织格式和数据传输方式。利用CIFS和NFS共享文件实际涉及到两次的文件系统转换。客户端从服务器端申请一个文件时，服务器端首先从本地读出文件（本地文件系统格式），并以NFS/CIFS的格式封装成IP报文并发送给客户端。客户端收到IP报文以后，把文件存储于本地磁盘中（本地文件系统格式）。4、存储系统与文件系统提到NAS，通常会想到传统的NAS设备，它具有自己的文件系统，具有较大的存储容量，具有一定的文件管理和服务功能。NAS设备和客户端之间通过IP网络连接，基于NFS/CIFS协议在不同平台之间共享文件，数据的传输以文件为组织单位。虽然NAS设备常被认为是一种存储架构，但NAS设备最核心的东西实际上在存储之外，那就是文件管理服务。从功能上来看，传统NAS设备就是一个带有DAS存储的文件服务器。从数据的IO路径来看，它的数据IO发生在NAS设备内部，这种架构与DAS毫无分别。而事实上，很多NAS设备内部的文件服务模块与磁盘之间是通过SCSI总线连接的。至于通过NFS/CIFS共享文件，完全属于高层协议通信，根本就不在数据IO路径上，所以数据的传输不可能以块来组织。正是由于这种功能上的重叠，在SAN出现以后，NAS头设备（或NAS网关）逐渐发展起来，NASoverSAN的方案越来越多，NAS回归了其文件服务的本质。由此可知，NAS与一般的应用主机在网络层次上的位置是相同的，为了在磁盘中存储数据，就必须要建立文件系统。有的NAS设备采用专有文件系统，而有的NAS设备则直接借用其操作系统支持的文件系统。由于不同的OS平台之间文件系统不兼容，所以NAS设备和客户端之间就采用通用的NFS/CIFS来共享文件。至于SAN，它提供给应用主机的就是一块未建立文件系统的“虚拟磁盘”。在上面建立什么样的文件系统，完全由主机操作系统确定。CIFS与NFS协议分析.doc,2017/9/30
6,2018校园招聘H5源码,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9301,"动画均为CSS3动画效果JS框架基于zepto，里面使用了两套Slider,一套为PageSlider用于控制上下滑动，一套为swiper用于控制左右滑动。详见附件ces_zpces_zp.zip",2017/9/30
7,东方通TongWeb5.0配置优化及问题处理PPT,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9300,内含配置文档和一份使用手册TongWeb5.0配置优化及问题处理_.pptTongWeb5.0用户使用手册_.pdf,2017/9/30
8,关于普通网页微信分享带有缩略图的实现,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9299,"新版微信已经不支持非JSSDK的其他自定义分享内容了.....也就是说：想要普通页面链接分享出来带有logo，带图分享必须要有公众号（而且是认证过的号），而非网友说的默认首张大图准备材料：1、一个分享的页面（定制功能的页面或系统入口）2、一个认证过的微信公众号（订阅号或者服务号都可以 /wiki%...01084）（appID,appsecret，需要将网页对应的域名、IP添加到白名单中）3、需要一个后台能够提供签名认证，实时返回signature值4、至于页面中获取signature值在wxJSAPI中调用，使用ajax还时传统的方式无所谓了详见附件（内含sdk+readme）！如果不想怎么麻烦，页面功能也不定制出来的，那就简单一点直接用公众号做出的页面分享吧。weixin.zip",2017/9/30
9,sqlserver将查询结果导出Excel,洪柯,http://180.168.156.212:2262/wecenter/?/question/39,,2017/6/15
10,机器学习入门之一图哦也版（一）算法总览,王国栋,http://180.168.156.212:2262/wecenter/?/article/9298,机器学习入门偏难，包括我在内，很多人总觉得无从下手。所以我准备把自己艰难的入门过程记录下来。供自己回顾、反思、进步。如果能帮助到需要的人，深感荣幸。=================================================================计划针对常用的算法做一些自己的理解和分析，达到如下目标：我知道这个算法是什么我知道这个算法能干什么，能参与到哪些场景中如果有可能，我想深入了解下这个算法原理写个例子那就很棒了。=================================================================本次更新目录：（一）算法总览：梳理当前机器学习的算法，列出总览和学习路线。下次计划更新：卷积神经网络（CNN）==================================================================这篇流水账性质的文档，使用Mindjet脑图编辑，中间可能使用文字、图片、手画图来进行记录。最终导出为单独的一个html文件，方便保存查看。查看脑图总览，可以点击index.html右上角“算法总览表”（一）算法总览：梳理当前机器学习的算法，列出总览和学习路线。.rar,2017/8/15
11,ambari-server搭建分享--ambari搭建 (二),康龙,http://180.168.156.212:2262/wecenter/?/article/9297,"搭建有两种方式,1.采用在线方式下载搭建,2.采用离线环境搭建一.检查仓库是否可用二.安装ambari-server三.配置ambari-server此步骤会配置JDK,MYSQL元数据库等.四.查看并启动ambari-server五.启动成功后访问ambarihttp://ip:8080即可,机器重启后会自动启动此次分享为ambari-server搭建，后续分享ambari-server如何使用HDP离线搭建hadoop集群生态环境.",2017/8/3
12,ambari-server搭建分享--准备离线环境(一),康龙,http://180.168.156.212:2262/wecenter/?/question/43,"1.下载HDP/HDP-UTLS/ambari-server文件如:在Centos6下tarxfambari-2.1.0-centos6.tar.gz-C/var/www/html/tarxfHDP-2.3.0.0-centos6-rpm.tar.gz-C/var/www/html/tarxfHDP-UTILS-1.1.0.20-centos6.tar.gz-C/var/www/html/2.修改ambari.repo及hdp.repo/hdp-utils文件中的离线路径如:#VERSION_NUMBER=2.6.0.3[HDP-2.6.0.3]name=HDP-HDP-2.6.0.3baseurl=file:///var/www/html/ambari/HDP-2.6.0.3-centos6-rpm/HDP/centos6gpgcheck=1gpgkey=file:///var/www/html/ambari/HDP-2.6.0.3-centos6-rpm/HDP/centos6/RPM-GPG-KEY/RPM-GPG-KEY-Jenkinsenabled=1priority=13.配置好后,测试是否可以访问离线文件.4.接下来就可以进行离线搭建ambari-server及HDP环境了",2017/8/3
13,一次关于hadoop平台迁移的分享,康龙,http://180.168.156.212:2262/wecenter/?/article/9296,"此次迁移事件的缘由是因为测试环境的HADOOP部署在VM上,导致大量数据访问操作时IO不够,造成假死现象,故此造成了一次平台迁移的惨案......由于百度上搜到的资料大部分都是数据迁移或是目录迁移,关于平台整体迁移并没有太多有用的资料,最终研究了一天后终于将平台及数据进行了迁移,现将此次迁移部分操作,分享给大家,同时也寻求更好的办法.言归正传由于测试环境的hadoopio等不够,将要进行迁移到实机环境,三个从节点一个主节点全部安装在了VM上,又没有进行docker,导致多个节点迁移比较复杂数据比较凌乱,并且不好进行平台迁移,由于时间太紧最终选择了几种办法后,使用了最笨但是也是最有效的方法进行了迁移工作,如各位同事有更好的办法,我可前来向您求教.将要迁移的hadoop平台4个节点接下来简称A.目标hadoop平台暂时只有一个主节点接下来简称B.将A平台文件进行备份,scp到新的Linux机器B上.在B上创建与A相同的环境.在BLinux上进行安装mysql元数据库.将A元数据库进行备份,scp得到B机器上还原.由于B暂时只给提供了一台实体机,导致只能将NAMENODE/DATANODE等服务,暂时全部配置在B平台上.将A平台拷贝到B平台上的SSH文件进行清空,否则会导致无法启动,hadoop会认为为欺诈用户．将ｈｄｆｓｎａｍｅｎｏｄｅ进行格式化．由于只有一个主节点，只能将ｓｌａｖｅｓ配置ｄａｔａｎｏｄｅ以便跑ｍａｐｒｅｄｕｃｅ以上步骤全部操作完成后主节点部分工作已完成，子节点相对来说就简单很多了，接下来准备ｈｄｆｓ迁移数据．在网上参考了几种方法最终选择了ｄｉｓｔｃｐ同步方式进行迁移ｈｄｆｓ文件．以下是官方示例：bash＄hadoopdistcphdfs://nn1:8020/foo/bar\hdfs://nn2:8020/bar/foobash$hadoopdistcphdfs://nn1:8020/foo/a\hdfs://nn1:8020/foo/b\hdfs://nn2:8020/bar/foobash$hadoopdistcp-fhdfs://nn1:8020/srclist\hdfs://nn2:8020/bar/foo官方给出的示例可以看出都是采用hdfs方式在集群之间拷贝,并不适用跨集群之间的拷贝,并且此次实际情况是集群对单机的迁移拷贝.最终我采用了hftp的方式进行迁移拷贝,需要注意的是源目标要采用50070端口,如有修改则使用修改后的端口hadoopdistcphftp://****:50070/home/***/***/***/warehouse/home/***/***/***/warehouse最终第一个mapreduce5:23秒进行完成.注:由于时间比较紧,此次数据迁移并没有考虑数据倾斜,只是将数据进行准确迁移,迁移到实机后,用三台虚机与一台实机,同样的环境,同样的网络,计算速度竟然提升了20多倍...以上是此次hadoop迁移其中的一部分.如果有对大数据框架等感兴趣的同事,大家可以一起学习进步,我也是小白一枚,希望能够得到大家的带领哈哈,共同进步.接下来我将会分享一些在设计此套大数据框架的经验,及使用,还有BI系统插件式框架集成二次开发,ETL工具配合大数据使用集成二次开发,调度系统,等.纯手敲,,,,,,纯手敲,,,,,,纯手敲,,,,,,",2017/6/25
14,上海2017年职称申报,陆晓蕾,http://180.168.156.212:2262/wecenter/?/question/40,,2017/6/20
15,oracle11g自动备份,路斌,http://180.168.156.212:2262/wecenter/?/question/37,,2017/6/14
16,关于saas云平台在线问题收集的想法,李宏辉,http://180.168.156.212:2262/wecenter/?/question/38,今天公司同事在使用vscode编辑器进行编写代码，然后看了下才发现这一年来TypeScript竟然如此盛行，微软与Google达成JavaScript框架合作：共同打造的Angular2让我一下子懵圈，感觉之前AngularJS以及ionicFramework白学了。在使用vscode的时候发现这个编辑器的又下脚几个快捷功能倒是不错，特别是那个smile图标以前我们开发的产品都是面向独立用户、局域网用户或者政务网用户，现在我们的外网系统越来越多，以前只有普通的网站，现在由于云平台的加入，我们的产品经理应该也要开始着手考虑收集用户使用的意见了。,2017/6/14
17,从瀚高数据库在Spring事务报错到Spring的事务机制简析,胡正,http://180.168.156.212:2262/wecenter/?/article/9295,"系统管理平台4.0小组在使用瀚高数据库的时候，后台报了个错误ERROR:currenttransactionisaborted,commandsignoreduntilendoftransactionblock而在其它数据库系统上均没问题这个问题，于是就对这个问题进行了一下百度。国产的瀚高数据库其本质是开源数据库PostgreSQL的商业化版本，因此这个问题在PostgreSQL上也能重现其原因在于PostgreSQL特殊的事务控制原理：当事务过程中前一个SQL语句执行失败后，如果不进行及时进行处理（回滚），后续的SQL执行就会失败！以查询建表场景为例，先查询表，如果表不存在，则创建表：selectcount(*)fromt_id_sequence;createtablet_id_sequence(id_namevarchar(50)notnull,maxvalbigintnotnull);对于其它数据库而已（以mysql为实验对象），select的执行失败并不影响create的执行：但是对于PostgreSQL而言，create就会执行失败：正常情况下，Spring的事务处理是通过异常抛出，由事务管理器catch后进行rollback，如果异常不抛出，那么Spring会认为没有异常，从而进行正常的commit操作。在实际场景中经常会有这样的情况，需要执行一个操作，如果失败了执行另外一个补救操作。对于上述情况，一般我们就在Spring中直接捕捉这个异常，然后执行补救操作。但是对于PostgreSQL，异常如果不进行commit/rollback，那么之后的SQL就会执行失败这时就需要对补救操作进行独立事务管理，通过Spring事务的传播属性实现。默认情况下，事务注解@Transactional使用的传播属性（Propagation）是默认的REQUIRED，即有事务就加入，没有就新启一个这样的配置能保证事务的一致性。而对于补救操作而言，需要的是另外一个不受影响的事务，于是就有了REQUIRES_NEW。重新创建一个新事务执行操作，而不影响原有的事务。于是新的代码产生了：运行后发现依然报错，createTable并没有启用新事务，为什么呢？原来Spring的AOP机制（包括事务管理和其它拦截器）有一个潜规则：被Spring的AOP增强的类，在同一个类的内部方法调用时，其被调用方法上的增强通知将不起作用。对于事务管理器而言：在同一个类内部方法调用时，被调用方法上的@Transactional注解不生效。于是，只能在外部调用。原来的checkTable和createTable方法不变：在外部的另一个类中调用进行调用：这样问题就完美的解决了。总结一下：1、对于瀚高这种基于PostgreSQL的数据库而言，无法像其它数据库一样忽略执行失败的SQL而进行下一步操作；2、在Spring事务环境中，可以通过Propagation.REQUIRES_NEW指定独立事务来解决；3、使用了不同事务配置的方法必须使用外部调用方式，内部调用时被调用方不生效。",2017/6/8
18,关于携程一篇文章“干货 | 图形验证码在携程的实践之路”的杂想,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9294,携程公众号昨天（6-5）推送了一篇文章“干货|图形验证码在携程的实践之路”，其实我平时基本很少看推文，看了后发现有一些感受，就索性记录了下来文章地址如下，有想看的可以点进去： 最后的最后，应该到总结部分了，化作一句话“路还很长，既然还没有选择停下来，那就记得走下去”。,2017/6/6
19,项目总结,薄军,http://180.168.156.212:2262/wecenter/?/article/9293,工作小结.docx,2017/5/26
20,数据采集工具在项目中的应用总结（上）,邹少怀,http://180.168.156.212:2262/wecenter/?/article/9292,"在重要产品追溯项目中，我们要打造一个省级平台，该平台要采集多个城市平台的数据，由于各个城市平台的建设单位不一样，产品规格各不相同，基于这样一个背景，需要打造一个灵活的，可适配的数据采集工具来解决此类问题。数据采集工具总体分三部分：客户端、调度层、服务端客户端工具介绍：PentahoDataIntegration又称kettle，它支持准备及融合数据，为业务创建一幅完整的画面，以进行更好的分析。完整的数据集成平台为任何来源的终端用户提供精确的，可实时分析的数据。由于可视化工具消除了编码并减小了复杂度，kettle将大数据和所有的数据源放在了商业和IT用户最容易获得的位置，降低了IT实施和运维的难度。功能描述：提供拖拽式开发的简单可视化设计器，开发人员使用可视化工具能最大限度的缩减代码，并且达到更高的效率。拖拽可视化设计方法?图形提取-转换-加载(ETL)工具，以常规方式来加载和处理数据源?丰富的预建组件库能访问和转换来自广泛数据源的数据?动态转换，使用变量决定映射域，验证和改进规则?集成调试器用以检测和调试任务执行过程?完整的可视化开发工具可以消除SQL编码下面讲述食安研究院研发团队在项目中的具体做法：首先，连接数据库，动态绑定kettle运行参数，并且在Java中调用,：调用kettle的ktr文件的Java代码如下：其次,表数据输入的过程：再次，在数据传输过程中改名、改类型：接下来，数据传输过程中可以自定义转换处理:再然后，插入一个转换过程中用Javascript脚本生成UUID的例子：最后，考虑到直连对方数据库，可能会产生不可知的异常或者传输过程中断开的情况，我们采用了先导出到以日期分隔的多个XML中间文件暂存的转换模式：总结，经过如上的客户端数据一些关键动作，我们大致可以覆盖采集过程中的重点需求，随着我们项目的持续深入进行，技术探索也将继续。",2017/5/25
21,一次系统性能问题的处理过程,陈雷,http://180.168.156.212:2262/wecenter/?/question/36,由于应用程序代码存在内存泄露，导致了本次性能故障。顺便也对数据库进行了索引优化，记录一下供以后参考。数据库：SQlServer2008中间件：Tomcat7详见附件。,2017/5/25
22,Coral组件库4.0演示,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9291,演示地址:点击打开，如果没有登录请先登录【有功能性问题请在下方留言，也可以直接在产品专区直接发帖，也可以直接联系研发中心吴晓明，谢谢】组件库产品简介我司在多年J2EE软件开发经验积累的基础上，吸收国外先进的设计思想和设计模式，建立了全公司范围的组件库（ComponentLibrary），初步实现了基于组件的软件开发。据统计，一个20人月的中小型项目在应用组件库之后，可以节约15%左右的工作量，进度缩短20%。下图所示为我司组件库的逻辑架构：从上图可以看出，中信组件库（CESCoral）包括js组件、icon图标、css组件、tag组件的各个层面。组件库通过引用JspTagFile（自定义标签），统一各组件调用方法，专注“通用需求”，定制“个性需求”，使组件库更加便于复用、便于扩展、易于集成，具有良好继承性和扩展性的类基础架构，封装了产品研发项目和应用开发项目界面中共性的功能，大大简化了开发过程。中信组件库的目录结构如下：Coral4.0提供了完善的二次开发手册和例子程序，并在公司上百个中型以上的项目和产品中得到应用，为项目和产品的按期交付、保证质量起到了保驾护航的作用。我们专门针对组件库开发了演示平台，所有组件的API以及典型事例源码都可以从演示平台上查看。下图所示为组件库演示平台：、采用基础组件平台，能为用户带来以下几方面的好处：1.完全按照基于组件的软件开发思想设计实现，为应用软件的开发奠定了强壮的基础架构；2.包含30+控件，所有控件的方法调用都采用统一的接口，统一的规则，方便开发人员使用，部分组件展示效果如下；3.所提供的基础组件久经考验，可以放心在项目中复用，避免了在应用开发过程中“重复发明同一个轮子”；4.组件是对历史项目经验的总结和提炼，使后续项目实施不但能够继承以前项目的成功经验和亮点功能，而且可以保证系统的性能和稳定性；5.由于用户单位的承建方较多，如果所有的开发商都基于组件进行开发，还能够起到规范软件开发的目的，统一技术架构；6.成熟组件的应用，减少了对程序员的依赖性，大大降低了系统后期的维护工作量和维护风险。7.在coral4.X版本下支持组件皮肤定制，实现“一键换肤”的功能，例如下图按钮可以通过皮肤定制实现不同的风格：,2017/5/19
23,信息发布平台5.0演示,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9290,演示地址:点击打开（需要登录），如果没有登录请先登录用户名/密码superadmin/000000【有功能性问题请在下方留言，也可以直接在产品专区直接发帖，也可以直接联系研发中心产品经理魏爱红，谢谢】1、信息发布平台5.0基于当前内容管理发展现状和信息发布平台现有产品存在的不足，建立一套全新的信息发布平台5.0产品是我司在内容管理领域发展的必然要求，新的技术架构及新思维结构的融入必将解决困扰现有客户和实施人员的难题，并为我司维护现有客户和开拓新的客户市场提供强有力的产品保证。2、产品功能框架信息发布平台5.0产品功能主要包括网站系统的前台建站和后台内容管理，其功能模块主要包括：建站管理、内容管理、资源管理、功能组件、互动交流、统计分析、系统管理七大模块。3、网络架构本系统主要会用到三种部署方式：集中式、分布式、一体化式。在这三种模式中集中式是我们最常见的，把所有应用部署在同一台服务器上，但由于考虑发布出来的站点访问的更佳性能，服务器部署方式为：反向代理服务器（apache/nginx）+多应用服务器（如：多个tomcat/东方通等）方式。分布式方式主要是为了增加并发数与访问性能。集中式方式考虑有些用户会把信息发布平台部署在内网使用，而发布出去的内容部署在外网上，故此我们需要将站点进行导出与导入，可以采用网闸进行定时同步或采用移动硬盘进行人工数据同步。三种具体的部署方式分别如下图所示：集中模式：分布模式：一体化模式：4、系统架构本系统集成系统管理平台3.6、工作流平台3.0、全文检索引擎1.0和Coral4.0.2组件，其中系统管理平台、工作流平台和全文检索引擎属于应用层面的集成，Coral4.0.2主要表示层的使用。5、信息发布平台3.5(历史版本)6、简要概述信息发布平台就是负责从信息采集录入、信息处理、信息浏览一直到信息撤销等维护过程的信息处理的应用平台，目前的版本是基于J2EE技术架构，采用中间件开发技术（浏览器/中间件/服务器三层架构），将表示层、业务逻辑层和数据层分离，并且吸收了工作流平台、系统管理平台的设计思想，具有高性能、跨平台、易升级、可扩展等突出优点，可以真正实现信息类型自定义、发布流程自定义和显示自定义。7、系统架构8、更新说明，3.5已停止更新（出库为5.0以上版本）,2017/5/19
24,使用Curator进行Quartz的锁管理,胡正,http://180.168.156.212:2262/wecenter/?/article/9289,在Quartz中，采用的是org.quartz.impl.jdbcjobstore.Semaphore接口来进行锁管理，保证在分布式多节点情况下仅有单个节点执行任务。其原理简单的说，就是：各节点上的ClusterManager线程尝试获取锁，当有一方获取成功后，则有该节点获取执行任务的永久权限。当该节点挂了之后，由其它的节点重新抢占锁。默认的情况下，提供了基于数据库方式，如下图：一般情况下，StdRowLockSemaphore（使用selectforupdate来锁定）和UpdateLockRowSemaphore（update之后不进行commit）就够了。但是对于数据库集群的情况下却可能存在问题（主要是达梦）：在主备和读写分离等情况下，有可能存在不同节点读取了不同的数据库，从而造成锁失败的情况，因此需要通过其它方式：1、独立的单节点数据库，专门进行Quartz的数据管理；2、其它带分布式锁机制的软件，如Zookeeper、Redis等；这里采用的是Zookeeper，利用ApacheCurator进行锁管理。Curator是zookeeper中的类似于guava对于java的意义一样，提供了丰富的封装，异常处理，提供了fluent编程模型，提供了master选举，分布式锁，分布式基数，分布式barrier，可以很方便的为日常生产所使用。Curator提供了多种锁的方式：可重入锁SharedReentrantLock不可重入锁SharedLock可重入读写锁SharedReentrantReadWriteLock信号量SharedSemaphore多锁对象MultiSharedLock我采用了信号量Semaphore方式实现锁，代码片段如下：获取锁：释放锁：锁管理器：初始化Curator：获取锁：信号量方式的实现原理是：InterProcessSemaphoreMutex内置了一个仅允许1个Lease（租约）的信号量实现类InterProcessSemaphoreV2。当第一个调用acquire时会返回唯一的那一个Lease，后续的调用会阻塞直至超时，这样就能保证同时只有一个只有信号量。代码见附件：Semaphore.zip,2017/5/18
25,系统管理平台4.0演示,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9288,系统管理平台4.0版本演示地址:点击打开（需要登录），如果没有登录请先登录用户名/密码superadmin/000000【有功能性问题请在下方留言，也可以直接在产品专区直接发帖，也可以直接联系研发中心产品经理朱超，谢谢】1、产品简介各类软件产品及项目都需要系统管理平台为其提供用户权限、组织结构管理等各方面的支持，而不同的产品和项目在系统管理的需求方面虽各有千秋但大部分功能均有其通用性，如果每次都将系统管理作为项目的某个模块进行开发将会重复耗费大量的人力财力，因此，开发一款通用型的系统管理平台将其集成到公司各类产品及项目中去已成为大势所趋。而我司的系统管理平台是一款后台管理平台软件，可复用于公司各类业务产品及项目。为各类软件产品提供用户管理、授权管理、组织管理等系统后台支持。2、产品功能框架系统管理平台主要实现对用户、系统资源、人员权限的维护功能，同时提供组织、日志、配置等系统设置功能。各功能模块都以组件的形式体现，系统的功能框架如下：3、产品功能结构系统的功能结构图如下：4、产品界面布局产品的界面布局追求简洁性、一致性、易用性和用户的防错性，版块导航按钮直观地展示了系统管理平台的各大版块，点击版块导航内的按钮便可跳转到相应的版块内，并且左侧的结构区内容也会随之显示为该版块内的各项结构内容。5、功能组件化的设计思路系统管理平台4.0的各项功能都以组件化的模式进行开发，用户可以根据自身的业务需要决定自己的系统管理平台由哪几个功能版块组成。6、产品特色?“三员分立”的安全策略支持符合国标BMB20-2007《涉及国家秘密的信息系统分级保护管理规范》的“三员分立”安全机制。系统内将权限管理的操作权、审核权与审计权分由三类不同的角色分别掌控，分别是系统管理员、安全管理员、系统审计员。其中三种角色相互独立，不可兼任，通过合理配置和运用决策权、审核权、监督权，以解决某些方面权力过于集中且缺乏有效监督、执行不力等问题。?适用于独立单位和集团企业的分级管理机制分级管理概念源于大型集团制企业的分权制，集团分子公司、事业单位处室/局级可独立管理人员/角色等数据，可以为组织的每一层级设立对应的管理员。管理员的管理层级允许跨单位组织，上级管理员可以为下级管理员灵活地设置对应的管理层级，系统管理平台的分级管理机制既适用于大型集团企业，又适用于小型的独立型企业。?针对针对SAAS云平台的多租户、多系统管理策略每一个租户都是一家独立租用我们云平台产品的企业，他们的企业管理模式各不相同，不同的企业拥有自己独立的组织机构和授权模式，同时也可能上线多套信息系统。在系统管理平台4.0中，一家租户下，多套信息系统实现统一用户权限管理，同样，一套信息系统也可供多家用户租用，一家租户可租用多套信息系统，并且租户间实现用户权限管理隔离。,2017/5/18
26,达梦数据库手册,许奕,http://180.168.156.212:2262/wecenter/?/article/9284,DM7_SQL.pdfDM7_DBA.pdf,2017/5/16
27,2017年4月工作小结,许奕,http://180.168.156.212:2262/wecenter/?/article/9283,,2017/5/16
28,关于信息发布平台用户注册实名遐想,魏爱红,http://180.168.156.212:2262/wecenter/?/question/34,今天准备到万恶的CSDN上准备下一个东西，突然发现不能下了，如图所示：需要强行手机验证了，关于所有互联网应用注册必须实名去年国家确实说过然后好奇地点开了“根据《互联网用户账号名称管理规定》”，看了一下规定，如下：下面的落款日期2017-4-17日，也是刚刚加的，我想以后我们给政府单位做网站，涉及用户注册也会涉及实名吧？应该在不久的将来。同时又想到：以后开发网站，不可能给每家都配一个短信猫或者邮件服务器去认证吧？然后又认真的看了下CSDN手机验证的页面：竟然采用了让用户自己发一条短信去验证；而不是时下最流行的：用户向服务器发送一个请求，然后由CSDN发一个验证码过来，根据返回值来验证确实是你自己的手机。CSDN竟然连短信的成本都不想出，厉害！同时我又想：1、信息发布平台是不是需要升级，增加实名验证功能？2、公司可以在云平台上搭建一个实名验证的服务了，以后供我们的网站客户统一去验证实名了，当然这个服务以后是可以包装成增值服务的，一旦开通这个服务，以后这个平台也可以默默地替我们收集实名用户信息了，再则每一个互联网用户输入查询的内容，我们都可以默默地跟踪记录收集，这个行为意义就更久远了我想对于产品功能的挖掘与延伸，要比重复做某个产品的意义要深远的多注：当然如果把第2点实现了，我想背后利用到的技术也是很庞大的如果你有高见，请留言吧！诚然技术有高低，但思想可以超前！,2017/5/9
29,人人都是产品经理,杨安荣,http://180.168.156.212:2262/wecenter/?/question/27,在人人都想做“产品经理”今天，产品经理到底是干嘛的？需要哪些技能？作为门外汉的我，先贡献一下本书，期待有同样好奇心的小伙伴，能一起了解下概念，入个门？,2017/4/26
30,国家电子文件管理“十三五”规划,马来娣,http://180.168.156.212:2262/wecenter/?/question/26,这么牛叉的文件不仔细看、认真读真的太浪费了！,2017/4/26
31,zabbix前端php和java混合开发模式研究,张二伟,http://180.168.156.212:2262/wecenter/?/question/25,zabbix前端界面功能全部是用php开发的，由于我司没有php技术开发力量，拟采用我们擅长的java开发技术进行zabbix功能的扩展。这里涉及到一个问题，就是我们开发的系统如何与zabbix的php前端无缝融合。本文两个部分进行介绍：一、java系统基于2016技术框架实现zabbix认证二、通过nginx将java系统和zabbix系统进行融合详细参看附件,2017/4/25
32,关于apache（nginx）+tomcat集群请求超时重试导致的数据多次提交问题,李宏辉,http://180.168.156.212:2262/wecenter/?/question/24,我们在使用apache或者Nginx前端加多个tomcat的架构中，由于容灾特性的存在，当某个操作不能在一个tomcat中正常处理时，apache会尝试把请求转发到另外一个tomcat去处理。在一般情况下，这种特性能很好地满足我们容灾的要求。但是，当碰到一些操作非常耗时，大于apache中配置的超时时间时，它就会被apache重新转发到其他tomcat去执行，从而导致了重复提交。如何避免这种问题呢，可以以下其中一种方式。1、配置apache与tomcat之间的超时时间为无限长（0），或者把超时时间配置得足够长。2、配置apache为请求只处理一次，不重复重试。3、如果是nginx，可以根据不同的操作（get、post）来配置不同的超时策略。,2017/4/19
33,李大总监的论坛、知识库全新改版，来凑个热闹,马来娣,http://180.168.156.212:2262/wecenter/?/question/23,《华为基本法》第二十六条顾客价值观的演变趋势引导着我们的产品方向。我们保证按销售额的10%拨付研发经费，有必要且可能时还将加大拨付的比例。,2017/4/13
34,2017年三月公司技术分会场报道V2.0,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9265,"3.25-26的培训内容则是实实在在技术培训专场，产品技术管理中心特地网罗公司牛人大咖，他们或许是颜值爆表的“小鲜肉”，或许是高高在上的“主席”，或许是足够接地气的屌丝范，或许是地道的码农，但他们有个通性：技术足够牛逼！组织方也是打破以往外聘惯例，全都选用内部匠心人才担任本次讲师。除了配有牛逼的讲师团队外，还有麻辣毒舌评委助阵，并且他们的身份都不容小觑哦，分别是：研发中心总经理—路斌、产品技术管理中心技术总监—李宏辉、档案研究院院长—季德超；评委团的职责就是要对讲师们的课程客观的予以评价，至于点评的内容不是简单的灌输技术鸡汤，而是“毒鸡汤”，越犀利越有针对性才是亮点所在。并且结合评委们的综合打分+参训学员的评估意见，最终会推选出“最佳讲师”*1名，“优秀讲师”*2名，并有奖金以资鼓励。培训前期，也将参训学员划分成了7组，全程要认真聆听讲师们的授课内容，需要结合课程内容与讲师们进行良性互动，他们可以主动回答讲师上课的提问，也可以在课程结束后发问。对于积极发言的学员都会给予一张扑克牌予以积分，第一天根据扑克牌的张数来决定小组的排名，张数最多的积10分，依次类推8,6,4,3,2,1；为了眷顾排名在后的小组可以逆袭，第二天则根据扑克牌的点数来决定小组排名，点数最大的积10分（其他依次类推），根据两天积分的总成绩选择排名靠前的三组，进行三甲争霸，PK内容主要也是围绕两天培训内容展开。Ps:为了保证公平、公正，讲师团队自立门户单独围坐一组，让学员们可以充分发挥自己的提问权，放心、大胆的去挑战讲师的知识领域。PS：当然，不踊跃发言的都会有惩罚~~下面细细回味下我们的牛人大咖和他们的课程:当家花旦No.1：王国栋（背景资料：来自研发中心），打着92年小鲜肉的旗号开始了《java漫谈》课程的分享。在座的程序员们对java应该一点不陌生，王老师则通过一些非常让人迷惑的简单问题，带领学员们深入理解java这种双类型语言的魅力与困惑。王老师风趣幽默的讲解风格，无疑将培训的氛围推到一个小高潮。评委点评：王老师从工作中一些不引起注意的小问题逐步讲起，引人入胜，有足够的讲师范，够型，美中不足的是如果能够更多的切合实际开发工作中遇到的问题进行归类分析，那课程的价值就更高。当家花旦No.2：陈雷（背景资料：来自智慧政务事业部），陈老师来自广东，不远千里给大家分享题为“《基于ES构建全文检索应用》”培训，课程主要介绍了elasticsearch的容灾、负载均衡等优秀特征，通过demo介绍了查询、关联查询、聚合函数、高亮匹配词等检索语法的使用。陈老师的授课风格还是典型的技术男风格，相信现场还是能俘虏不少技术男的青睐→→讲师点评：软件示例准备的最充分，没有之一，全程以大家熟悉的数据库操作方式为对比进行一一讲解，通俗易懂；但专家现场指出的关于大文件转换与创建索引、检索摘要标记等问题回答地都不够漂亮，也证实了该技术应用到真实项目中还有很多有待处理的难题。当家花旦No.3：邹少怀（背景资料：来自食安研究院），才貌双全在他身上展现的淋漓尽致，他分享的课程题为“《数据建模》”，为大家科普了数据建模的概念，以及如何梳理概念模型覆盖企业的核心业务。通过一个个生动的实例，展示了系统分析和设计的全过程，提供了一整套的方法论，是需求落地必不可少的重要组成部分。专家点评：近年来公司方法论第一人，方法论解读显得略微枯燥，多个案例讲解也降低了课程的可理解性，如果能够结合一个完整案例进行全程分析，定会有让人意犹未尽的感觉。当家花旦No.4：胡正（背景资料：来自研发中心），这次培训也是TMT大咖成员们的切磋分享会，彰显看家本领。胡老师分享的内容为“《Dubbo基础讲解》”，主要为大家介绍Dubbo分布式服务框架的基础、使用和现状。与Spring完美整合，其远程方法调用，就像调用本地方法一样，只需简单配置，没有任何API侵入，也对注册中心、服务提供者、服务消费者、监控中心的配置和开发进行了简单的讲解。专家点评：姿态低，课程开口小，终结了多年来自己的口头禅“没什么好讲的，最多20分钟”，堪称全场进步最大的一名讲师。当家花旦No.5：许奕（背景资料：来自政法研究院），说许老师是95年的小鲜肉，大家或许都会相信，丝毫看不出他已经是项目身经百战的“老古董”；他分享的课程“《一种基于国产化的高并发框架设计》”也是相当的接地气，以江苏“518项目”（公司目前最大纯软件项目）的实际案例，为大家介绍和分享如何设计一个基于国产化的高并发框架。讲师点评：公司国产化项目第一人，以真实项目为主题，完整地讲解了大型项目的始末，全场关注度最高也是得到认可度最高的项目。当家花旦No.6：方俊新（背景资料：来自创新实验室），鹰学院长期合作的讲师之一，授课对他而言已经驾轻技熟。最最最重要的是：也是92年小鲜肉一枚。这次他分享的内容为“《持续集成》”，针对jenkins的简单配置使用，浅显易懂的让一个初学者从入门到整个部署流水线的配置与了。专家点评：讲解内容主体以介绍为主，结合公司“产品、项目多，人手紧”的现状，外加自动化测试的鸿沟，离实际运用还有较长的路要走，但考虑到公司未来可持续集成的引路人和推广人理应给予鼓励。当家花旦No.7：刘冬（背景资料：来自档案研究院），刘老师可谓地道的码农代表，用心备课尽心上课耐心答疑解惑。他分享的“《自然语言处理》”，告诉大家咱们要做的事情就是机器学习中的一小部门自然语言处理，要让计算机读懂人类的语言，使人与计算机进行交互。专家点评：天津范十足，掌握语义分析不是一朝一夕，希望在后续持续努力，希望今后对于语义处理的专业性也能像天津味一样地道。当家花旦No.8：胡东平（背景资料：来自研发中心），胡老师就是传说中百闻不如一见的主席范的人物，分享的课程也是有别于软件的课程，带领大家认知一番《智农云终端原理及应用》，不仅光说，直接带道具现场演练；胡主席说了之所以带来这个课题的分享也是源于物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。智农云终端是连接感知网络与传统通信网络的纽带。可谓“听君一节课，胜读十年书”，现场互动参与也到了小高潮。专家点评：公司弃软从硬第一人，一只神奇的灯泡揭开了智农云终端的神秘面纱，台上一小时背后隐藏了一个团队过去一年里的持续努力与探索，对于未知的探索和执着值得大家学习。当家花旦No.9：张二伟（背景资料：来自研发中心），分享内容“《关于监控那些事》”，现今，公司IT基础设施变得越来越复杂，从底层硬件、网络设备到操作系统，从数据库、中间件到各类业务系统，任何地方出现问题都会导致业务中断，运维人员面临着严峻挑战。如何及时发现并纠正潜在的问题？基于开源监控软件zabbix，提出了一种解决思路，并辅以实战案例，力求让大家在最短的时间内掌握监控这门技术。专家点评：程序猿永远认为自己的代码是正确的，运行环境没有问题也是毋庸置疑的，但现实总是残酷的，对于突发事件其实我们是有办法监测和提前感知的，没接触不代表没有，没有用过不代表没用，但可惜的是张老师全程讲解显得无激情、缺亮点，授课技巧还需要像其他讲师学习，但用事实告诉我们利用成熟工具能简化工作，避免麻烦。当家花旦No.10：薄军（背景资料：智农发展事业部部门经理），薄老师的课程“《区块链初讲》”，更为准确的说是区域链的交流会。通过对区块链的概述、基础架构和应用，分享给大家：区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术在互联网时代的创新应用模式。专家点评：近两年区域链大热，可以适当研究，但一定要结合我司的业务深入进去，寻找是否存在适合我们自己的应用场景，而不是盲目追随，停留在理论研究中，也不是弄出一个“HelloWorld”那么简单。整场培训下来，评委们点评独到犀利，分析透彻，现场氛围可谓跌宕起伏，高潮不断，笑声不断。十位讲师，各个技术武艺高深，给学员们带来了别一番的视觉和视听盛宴，评选过程中意外不断，波折不断，分歧不断（至于为什么如此波折，当然是我们的大咖们实力都太强大，难分秋色），最终百般艰难的出炉了我们的三甲花旦，探花：胡东平，榜眼：许奕，状元：王国栋（堪称屌丝逆袭正传）。七组学员们也是争锋对决，在白热化的争夺中，也产生了小组名次，分别是：第一名：第3小组（吕世富、王少强、康龙、周倩、方艳宾、刘鹏举、程杰、于兴兵、郭磊、陈前）第二名：第2小组（杨苏妹、何锦晔、滕树宝、沈少华、胡碧涵、范超育、陈超棋、夏灵敏、倪钱龙、何清华）第三名：第7小组（刘恒亮、马玉荣、余礼华、刘美华、张殷豪、刘合增、王庆明、龚晓兵、陈厚刚、许鑫运）培训不仅是讲师练兵的大比拼，学员们也是相互切磋PK、展示自我知识技能的一个平台，对于我们而言更多注重的还是知识的分享与积累，感谢这群可爱的伪“90”鲜肉讲师们，也感谢我们全程陪伴的麻辣评委，也感谢组织方的用心组织，陪伴大家度过别一般的烟花三月。最后借用王国栋老师的一段话送给所有的技术人员，以致共勉！",2017/4/13
35,域名跳转到春秋等网站的解决方法,康廷,http://180.168.156.212:2262/wecenter/?/article/9258,有时候路由器会被病毒感染，出现网站域名被劫持、网站dns被劫持等，会出现域名跳转到春秋等网站的现象。解决方法：用写字板打开C:\Windows\System32\drivers\etc文件夹的hosts文件加入以下代码，10.10.34.22oa.cesgroup.com.cn10.10.36.50zsk.cesgroup.com.cn10.10.32.33pm.cesgroup.com.cn10.10.32.1marketing.cesgroup.com.cn10.10.32.20stats.cesgroup.com.cn10.10.32.23scm.cesgroup.com.cn10.10.32.3pmis.cesgroup.com.cn10.10.32.32archives.cesgroup.com.cn10.10.32.24it.cesgroup.com.cn10.10.32.4hr.cesgroup.com.cn10.1.2.3mail.cesgroup.com.cn10.10.34.44exam.cesgroup.com.cn10.10.34.73icms.cesgroup.com.cn保存关闭。重启，就好了。,2017/3/27
36,国办函〔2016〕108号 互联网+政务服务技术体系建设指南,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9257,对互联网+智慧政务和网上服务大厅电子文件归档都很有参考价值的规范。“互联网+政务服务”技术体系建设指南（附录）.docx“互联网+政务服务”技术体系建设指南.docx国办函〔2016〕108号互联网+政务服务技术体系建设指南图解.pdf,2017/1/15
37,安装Exchange2010时报错一例处理方法,章俊1,http://180.168.156.212:2262/wecenter/?/article/9256,"（特殊问题，一般情况下客户IT环境不会碰到）问题现象：在安装Exchange2010的时候，出现准备组织架构报错，报错信息如下：Microsoft.Exchange.Data.Directory.SystemConfiguration.ResourceBookingConfig'couldnotbefoundon<Domain_Controller_Name>.处理方法：Toresolvethisproblem,manuallycreatetheResourceSchemaobject.Todothis,followthesesteps:ClickStart,clickRun,typeadsiedit.msc,andthenpressENTER.Locatethefollowinglocation:CN=GlobalSettings,CN=<OrganizationName>,CN=MicrosoftExchange,CN=Services,CN=Configuration,DC=<Domain>,DC=<suffix>Right-clickCN=GlobalSettings,clickNewObjectandthenclickNext.ClicktoselectthemsExchangeResourceSchemaclassinthetextbox,andthenclickNext.IntheValuefield,typeResourceSchema.NoteThisoperationcreatestheResourceSchemaobject.Right-clicktheResourceSchemaobject,clickProperties,andthenclickmsExchVersion.SetthevalueofthemsExchVersionattributeto4535486012416.再次运行exchange安装程序，组织架构准备通过。",2016/12/28
38,美国：2016-2045年新兴科技趋势报告,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9255,基本上你能想到的新技术、黑科技都在里面了。可惜本人已经年过40，即使有幸看到这些技术的落地，也已经风烛残年，没什么奔头了。美国：2016-2045年新兴科技趋势报告.pdf,2016/12/14
39,2016中国大数据产业发展现状报告,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9254,附件来自微信。中国大数据产业发展现状报告.pdf,2016/12/14
40,大数据标准化白皮书（2016），今年最有价值技术文档，没有之一,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9253,不管你接受还是不接受，大数据时代已经来临……大数据标准化白皮书（2016）.pdf,2016/12/12
41,千呼万唤始出来：电子文件归档与电子档案管理规范完成修订，正式发布，,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9252,原标准号：GB/T18894-2002新标准号：GB/T18894-2016电子文件归档与电子档案管理规范（报批稿）.pdf,2016/11/15
42,关于复旦大学2017年在职研究生（MSE）,居晨,http://180.168.156.212:2262/wecenter/?/article/9251,各位同仁，复旦大学2017年继续招收和培养互联网+方向硕士研究生，有兴趣的可以了解下附件内容。（ps：统考的报名截止时间为2016年10月31日）互联网+方向2017年招生简章.pdf,2016/10/27
43,1024程序员节,何长江,http://180.168.156.212:2262/wecenter/?/article/9250,1024程序员节1024是2的十次方，二进制计数的基本计量单位之一。程序员(英文Programmer)是从事程序开发、维护的专业人员。<br>程序员就像是一个个1024，以最低调、踏实、核心的功能模块搭建起这个科技世界。1GB=1024M，而1GB与1级谐音，也有一级棒的意思。<br>以一个节日的形式，向通过coding改变世界，也以实际行动在浮躁的世界里，固执地坚持自己对于知识、技术和创新追求的程序员们表示致敬。,2016/10/24
44,重磅发布：最高人民法院 最高人民检察院 公安部关于办理刑事案件收集提取和审查判断电子数据若干问题的规定,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9249,第二十二条对电子数据是否真实，应当着重审查以下内容：（一）是否移送原始存储介质；在原始存储介质无法封存、不便移动时，有无说明原因，并注明收集、提取过程及原始存储介质的存放地点或者电子数据的来源等情况；（二）电子数据是否具有数字签名、数字证书等特殊标识；（三）电子数据的收集、提取过程是否可以重现；（四）电子数据如有增加、删除、修改等情形的，是否附有说明；（五）电子数据的完整性是否可以保证。最高人民法院最高人民检察院公安部关于办理刑事案件收集提取和审查判断电子数据若干问题的规定.docx,2016/10/19
45,微信小程序内测号被炒到300万！百度唏嘘不已,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9248,作为国内第一大APP，微信的每一次重大更新都会改变人们的生活。前几天，微信小程序开始内测，引发业内人士纷纷关注。什么是微信小程序呢？简单来说，有了小程序以后，你不再需要安装各种App。衣服可以在微信里买，游戏可以在微信里玩，上路可以用微信导航，甚至是电影也可以在微信里看。你需要做的只是简单地添加几个图标而已。因为首批官方仅放出了200个测试名额，由于太过稀缺。最近有传言称，一个具备小程序内测的公众号，竟然被炒到了300万！其实，微信小程序并不是新东西。早在3年前，百度就发布了类似的“轻应用”。据中科院计算机所研究员张云泉表示，两者如出一辙。“小程序和轻应用在功能和技术上是一样的，不同的是轻应用是依托于搜索，而小程序是依托于微信。”但是3年过去了，并没有看出轻应用玩出了什么新花样。尽管我们在百度上搜索路线，就会直接出现嘀嘀打车或者百度地图，十分方便。但这并不是百度所希望达到的目的。百度当年所希望的跟现在的微信小程序一样，抢占入口。在张云泉看来，它提前3年却并不成功就在于“百度是被动的，因为APP的围墙，让百度丧失了很多流量，它希望轻应用能让用户回来。而现在微信最不缺的就是用户，并不是微信小程序有多高端，而是微信有着8亿用户。”除了腾讯、百度，国外的IT巨头也在进行类似尝试。比如谷歌一直希望将Chrome浏览器变成一个超级网页App平台；苹果iOS10的iMessage，可发送表情包、跟朋友玩小游戏和分享其他应用信息；而Facebook也在自己的通讯工具Messager上推出了简单的应用开发接口，让用户直接通过聊天窗口完成打车和订餐等操作。,2016/10/14
46,优秀农业物联网案例介绍（来自农业部网站）,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9247,分为大田种植、设施园艺、畜禽养殖、水产养殖和综合五类。附件是大田种植类案例。优秀农业物联网案例介绍（大田种植）.docx,2016/10/9
47,如何查看Linux发行版本信息,章俊1,http://180.168.156.212:2262/wecenter/?/article/9246,可使用以下命令查看当前Linux系统发行版本信息#lsb_release-a在输出的结果中，【DistributorID】及【Description】值代表发行版本【Release】值代表具体发行版本号,2016/9/30
48,用命令查看wifi连接密码,章俊1,http://180.168.156.212:2262/wecenter/?/article/9245,"windows平台下，可以使用下面的命令来查看wifi连接密码（包括活动状态和不活动状态的）c:\>netshwlanshowprofilesname=""ces-wifi""key=clear输出的结果中，查看【安全设置】的<关键内容>中的值。详细输出结果如下：接口WLAN上的配置文件CES-WIFI:=======================================================================已应用:所有用户配置文件配置文件信息-------------------版本:1类型:无线局域网名称:CES-WIFI控制选项:连接模式:自动连接网络广播:只在网络广播时连接AutoSwitch:请勿切换到其他网络连接设置---------------------SSID数目:1SSID名称:“CES-WIFI”网络类型:结构无线电类型:[任何无线电类型]供应商扩展名:不存在安全设置-----------------身份验证:WPA2-个人密码:CCMP安全密钥:存在关键内容:51077677费用设置-------------费用:无限制阻塞:否接近数据限制:否过量数据限制:否漫游:否费用来源:默认",2016/9/30
49,中信学院培训PPT：高可用性的WEB集群与负载均衡应用方案,张二伟,http://180.168.156.212:2262/wecenter/?/article/9244,中信学院培训PPT，参看附件：高可用性的WEB集群与负载均衡应用方案高可用性的WEB集群与负载均衡应用方案.pptx,2016/9/28
50,[有奖征名]给我一个好名字，还你一份大礼！,胡绪汉,http://180.168.156.212:2262/wecenter/?/article/9243,信息发展档案托管中心要换新名字啦！换什么呢？现邀请聪明机智的你一起参与，给我们档案托管中心一个“高大上”“有内涵”“低调又奢华”的名字。档案托管是指客户单位将本单位的档案委托给我司档案托管中心保管，由我司档案托管中心按合同约定为其提供相关服务，其所有权、使用权仍属托管客户。我司依托在档案行业的全产业链服务实力，在自有产权库房基础上组建了档案托管中心。我司档案托管中心——为客户单位创造商业价值：客户单位每月只要花费较少的资金就能拥有属于自己单位的专属档案库房，完全可以按客户单位的需求，采取自管或代管的方式；高标准的甲级、乙级库房，可以由客户单位自行选择，可替代客户单位自建库房；异地文件与电子文档保管服务，客户可以有效地实现对自身公司信息财产的保护，防范单位内部员工偷窃档案信息的风险；文档异地保管服务，让客户单位只需租用小一些的办公室就可以满足日常办公的需要，也可以让原来用于存放文档的空间创造更多商业价值，同时减少单位基础建设的资金浪费；高标准的档案保管库房确保档案实体安全，有专业的保安队伍与先进的消防措施也会大大降低或防范风险的发生。凸显我司的行业优势：一是不少托管企业是租赁库房，具有库房迁移风险和租费涨价风险，我司具有自有产权的托管库房，没有此类风险；二是丰富的档案行业实践经验，我司是以档案为主题的上市公司，从事档案资源管理十多年；三是具有强大的档案技术研发团队，我司设有档案研究院，重要研究档案行业新课题、新科技及市场态势；四是具有档案管理全行业流程服务经验，即从档案产生、档案收集、档案分类整理，到档案信息化、档案库房建设的全流程服务。我司自主研发的“档案托管系统”的测试运行并上线使用，将为客户单位及时掌握托管档案信息，包括档案出入库、归库、借阅登记，原件派送、取回，客户信息、合同信息、入库批次管理，库房管理、温湿度、架位信息等，并随时利用托管档案信息提供条件和便利，也为客户档案信息的安全利用提供更加可靠的保障；同时，该系统也是我司档案工作人员进行托管档案管理的先进技术手段和管理平台，并为将来我司实现托管档案的线上线下体系化管理奠定良好的技术基础。“高大上”“有内涵”的靓名将有助于我司档案托管新业务的快速拓展。现特邀请我司全体员工共同为“她”命名，请公司各位员工积极参与和支持！,2016/9/26
51,程序设计大赛初选后的随感,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9242,"来中信至今，这是第二次参与竞赛的筹备工作。虽然暂时能做的只是些琐碎的协助工作，但不得不感慨自己的运气有多好！能借着“工作人员”这个便利身份观听到整场竞赛过程。感谢领导给我提供的机会!做为“菜鸟”界的一员,既然没有评价作品的能力，就说说自己没技术含量的感受吧。就我个人来说收获很多。通过各部门参赛小组的作品演示，不仅看到了平时接触不到的技术，也听到了完全陌生的专业术语。实话实说，由于个人知识库过于贫乏，此次竞赛内容听的也只能算是一知半解。虽然“菜”很丢人，但也正因如此，每次的观听都能让我增涨很多知识。除了实实在在的知识干货，还有各位大牛们解决问题的思维方式。不求记住多少，只要能吸收一点点，就够学习我实践很久了。除去这些方面，获得的最大收获就是认识了很多有趣的朋友，不得不说乐于助人绝对是中信员工贯彻最好的优良传统。我的很多进步都要归功于他们。借此马屁一把，感谢大家对我工作的帮助和支持，若有我能帮忙的，我也会尽力去做，大家一起进步。18号决赛了，参赛的各位加油哈！没有参加的也非常欢迎大家来现场体验一把。对初选情况感兴趣的看附件哦！灵光云叙述篇0906.docx",2016/9/6
52,一个工作快八年的老IT人士这几年沉浮总结的职场经验教训,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9241,一个工作快八年的老IT人士这几年沉浮总结的职场经验教训程序员的那点事微信号Coder1024功能介绍分享程序员生活点滴以及程序员各种吐槽。这里没有具体技术讲解，只有幽默、职场、规划、学习路线、学习方法总结。输入相关关键词可以获得相应的文章，输入m获取全部文章编号。来自：CSDN论坛作者：gooogleman以前我挺喜欢写博客，觉得把心中的想法表达出来非常畅快，并且还能和网上很多人沟通交流，现在我更喜欢把想法留在心中，博客很久没更新了，刚才闲来无事，看看职场话题版块发现很多人都挺迷茫的，所以我写一些个人的职场教训给大家分享一下，希望对我对大家都有用。1、工作的前三年，别那么在乎待遇，甚至在不影响生活的情况下，后面都可以一两年之内不在乎这些，关键是这几年咱要有过硬的本事，要不断学习。2、要加强自己做人的基本素养，对领导要尊敬，处理好同事之间的关系，即使自己的领导真的做人有问题，也没必要和他公开吵架，真的没必要，就重新找个公司，或者等机会取而代之就行了。3、在自己羽翼未丰的时候千万不要去兼职干别的，因为那点小钱会让我们失去理智，失去方向；如果自己觉得有必要出来自己干了，或者转型了，才可以采取这种方式——人生赚钱的方式很多，如果继续用这种高付出，低回报的方式去兼职，我觉得这个钱赚的太辛苦了。4、永远不要只知道工作，要懂得调节，懂得娱乐，不要让外人一看就是IT男5、当自己有很多负面情绪的时候，请不要到网上去散播，因为爱上网的人，通常也很多负面情绪，两个都郁闷的人走在一起，负面情绪会更加膨胀。正确的做法是在公司找你的领导表达一下你的状态，并让他来帮你，一个合格的领导听到你愿意把心底的事情告诉他，他会很开心的，并且他会更关注你，并且这样是和领导形成默契的很重要的方法，但是如果不把事情告诉领导，又在工作中把这些负面情绪散发出来，对团队形成不利，那领导对咱的印象是很坏的，甚至可以说是直接打入冷宫。多少年轻人会冲动的做出不理智的选择啊，领导是老虎，领导是坏人，我们要远离他们？！虽然拼实力，但是人的感情是绝对影响一个人的决定的。6、在一天公司，就要好好干一天，如果已经对公司诸多不满了，请默默离开。很多人喜欢有点事就骂公司，但是自己却一直不走，隔墙有耳，这种人我敢说不可能在公司混的好。把不满，把自己最阴暗的一面只展现给自己的好朋友，老婆，但是不能在公司展现出来，公司需要正能量才能发展。7、当工作了三五年后，一定要学会带团队，一个人的力量很有限，如果一个人能把一个集体管理的很好，那么这比一个高手要有价值的多。8、明白公司的核心是什么，尽量做公司核心的东西。9、找一个温柔贤淑的老婆，让自己做什么高风险的事情都会无后顾之忧。10、多在网络上结交朋友，朋友多，机会多。注：标题图片来自网络第9点很重要,2016/9/6
53,2016年成人高考招生工作进程表,居晨,http://180.168.156.212:2262/wecenter/?/article/9240,时间工作2016年8月31日—9月4日网上报名及填报“意向志愿”（8月31日9:00开始，9月4日24：00结束），考生在网上输入基本信息、填报志愿、签署考生诚信考试承诺书（三支一扶、退役士兵一并报名）9月9日—9月12日现场确认，考生校对网上输入的基本信息、数码照相、缴费，招生院校核验学历证书及相关证件。同时进行网上补报名。9月9日-11日8:30-16:30，9月12日8:30-13:00。（三支一扶、退役士兵一并确认）10月29、30日考生考试11月8日前专科生能力考试（部分报名参加能力考试的专科生参加）11月中下旬公布成绩、划定分数线，组织考生志愿确认12月底招生录取2017年1月中上旬新生报到（各教学点根据需要可调整时间）3月初新生上课,2016/8/3
54,蓝色球迷们可以出来了,马丰亮,http://180.168.156.212:2262/wecenter/?/article/9239,逝去的“蓝色”前日的上海，天空令人生疑地灰暗，空气充满着闷热，在这样一个令人压抑的午后，忧郁与紧张都显得那么不合时宜，我以为一切会持续着2006年的奇迹。天气忽晴忽雨，可生活依旧平静得令人窒息。夜晚的到来，我独自锁在房门，我穿着尤文队衣要为意大利拼尽全力，我没有再去酒吧，我不想让自己的呐喊汇入到众声喧哗中；也许，我只是不愿意当失利到来的时候，面对周围同情的眼神，甚至有些同情分明还带有一些嘲讽。信仰是自己的选择，当伤痛到来的时候，只有自己的心才是可以躲藏的地方，连身边最爱的人都帮不了你。“平民的意大利”冲入了八分之一决赛，相遇了德意志战车，但是中场的伤病只能带着替补承受着日耳曼民族的攻击，德国人不断地攻击，布冯的高接抵挡，那几十分钟的时间，我就像在地狱中翻滚，等待着奇迹的到来；但它迟迟不来，当德国人进球的时候，我平静的接受了；又过了段时间，当意大利获得点球的时候，看到布冯背对球门，那忧郁的眼神，我也关闭了视频，不敢看下去…..比赛进入了点球大战，但我看到38岁的布冯7次猜对方向但只扑出一粒点球，年迈的吉吉，青春已不在…我关闭了视频，把头埋进令我窒息的枕头，也许一开始便是充满希望的绝望…蓝色的夏天是忧郁的，上周的蓝色带走了西班牙，今天的白色带走了蓝色，我关闭了自己的手机，我不需要同情与安慰。信仰是自己选择的，伤痛也该自己承担，寂静与时间，是疗伤最好的疗伤药。现在想想，其实老了的不只是布冯，还有我，岁月给我们开了一个很大的玩笑，我只顾关注着布冯黑发中夹杂着白发的身影，却完全忘记了自己，德意之战，让我们感谢布冯，让我们更感谢“蓝色”，与我们共同成长，我的青春渐渐远去，如今我们都在为生活奔波，但是足球依然是我们最好的朋友。最后，布冯希望你能再坚持2年，40岁的你复制佐夫神迹捧起大力神杯的画面太美….哎.jpg布冯.jpg,2016/7/4
55,网速,刘咏梅,http://180.168.156.212:2262/wecenter/?/article/9238,虽然公司网站网速慢，我仍然愤怒的进来吐槽下，这OA打开的速度，进去可以出去抽根烟,2016/7/3
56,广而告之：我司已经构建了三朵云了，欢迎大家访问品鉴,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9237,食品追溯云： /aiot，管理员：宋杰,2016/6/17
57,第二期：“征答题，做答人”活动,张杰,http://180.168.156.212:2262/wecenter/?/article/9236,第二期问题：Q2：你们公司号称过了CMM5，怎么CMM3的标准都不适应？请各位答人给出你的回答！同时恭喜包士杰获得中信币20元！问题征集令继续征集中，期待你们的问题！！！中信“答人”秀规则1、每月月初各PMC成员和项目管理中心从“项目管理问题收集帖”中选择本月项目问题，问题一经采用，问题提出人将获得20中信币；2、发起本期“征答题，做答人”活动，公司全体成员均可在中信内网论坛里通过网络答题的方式参与此次活动，参与答题人每人将得到1个中信币/次。3、通过网络投票（点赞）的方式，每月月底综合网络票数、专家评分数决出本期“答”人，胜出者将得到200元的现金奖励。4、被选中答案者会优先成为年底优秀奖励人员。【投票/评分标准】1）答案需体现一定的专业度；2）言语中肯，能安抚客户，让客户满意，提高满意度；3）能很好地解决该项问题；,2016/6/12
58,《企业数字档案馆（室） 建设指南（征求意见稿）》公开征求意见,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9235,档办函〔2016〕130号各省、自治区、直辖市档案局，各计划单列市档案局，新疆生产建设兵团档案局，各中央企业档案部门：为推动企业数字档案馆（室）标准化、规范化建设，我局起草了《企业数字档案馆（室）建设指南（征求意见稿）》，现向你们征求意见。征求意见稿可在国家档案局网站上下载（网址： 国家档案局办公室2016年5月26日企业数字档案馆室建设指南（征求意见稿）.docx,2016/6/4
59,档办发〔2015〕4号 企业电子文件归档和电子档案管理指南,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9233,GB/T18894电子文件归档与电子档案管理规范修订版迟迟发不出来，这个企业的指南倒是先发了。档办发〔2015〕4号企业电子文件归档和电子档案管理指南.pdf,2016/6/4
60,服务器加域后出现重启或关机时间很长的问题处理,章俊1,http://180.168.156.212:2262/wecenter/?/article/9232,新安装的服务器系统wS2008R2都是正常重启的，但是加入本地的AD域后，出现重启或关机时需要等待很长时间（现场估算大概40分钟）。后来核查资料，找到问题原因，即当前AD域中的组策略启用了“关机：清除虚拟内存页面文件”，所以出现此种现象默认情况下此选项是禁用状态。位置：本地安全策略->本地策略->安全选项->“关机：清除虚拟内存页面文件”出现以上现象的时候，请恢复到默认的禁用状态。,2016/5/30
61,《中华人民共和国档案法》修订草案公开征求意见,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9234,国家档案局关于《中华人民共和国档案法》修订草案（送审稿）公开征求意见的公告作者：政策法规司来源：政策法规司2016年05月25日为进一步加强档案的形成、保障档案信息安全和利用，有效服务国家治理体系治理能力现代化，根据国务院立法工作安排，国家档案局组织开展了《中华人民共和国档案法》修订工作。经过深入调研、广泛征求意见、反复论证修改，形成了《中华人民共和国档案法》修订草案（送审稿）。为提高立法质量，现将全文公布，征求社会各界意见。公众可通过以下途径和方式提出反馈意见：1.电子邮箱：faguichu@saac.gov.cn2.通信地址：北京市西城区丰盛胡同21号国家档案局法规司法规督查处（邮编100032），并在信封上注明“《档案法》修订草案征求意见”字样。意见反馈截止时间为2016年6月30日。国家档案局2016年5月25日《中华人民共和国档案法》修订草案.docx《中华人民共和国档案法》修订说明.docx《中华人民共和国档案法》修订草案【胡绪汉提出部分修订建议】.docx《中华人民共和国档案法》修订草案-袁嘉新的修改建议.doc,2016/5/25
62,怀念以前的楼层座位图……,孙进,http://180.168.156.212:2262/wecenter/?/article/9231,今天回公司看到很多新面孔，而且部门位置调整也比较大，对于新员工或者长时间不回公司的来说，确实是个问题，建议恢复以前OA里隔三岔五发布的楼层座位图，固定一个位置，可以查询最新的各个办公场所的楼层座位图。,2016/5/20
63,国务院发布《国家创新驱动发展战略纲要》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9230,其中提到“文化创新”、“文化创意”“发展全产业链食品安全保障技术、质量安全控制技术和安全溯源技术，建设安全环境、清洁生产、生态储运全覆盖的食品安全技术体系”我们的文化事业和食安事业大有可为啊！国务院印发《国家创新驱动发展战略纲要》.docx,2016/5/20
64,关于预防邮箱、短信诈骗的紧急注意事项,张杰,http://180.168.156.212:2262/wecenter/?/article/9229,近期由于各类诈骗案件高发，一些不法之徒冒充公司人员（尤其管理人员）发送一些诈骗邮件，请各位领导、同事加强自身信息安全意识，不要轻信骗子的邮件或短信，以免造成不必要的损失。一、为了避免您的邮箱或个人信息被盗用或仿冒造成不必要的损失，请注意以下事项：1、公司邮箱以@cesgroup.com.cn结尾，如收到非公司域名结尾的邮件信息需要加强警惕。3、在进行邮箱升级、数据迁移、系统升级等操作时，都无需用户提供账号、密码及个人信息，凡收到此类邮件的，一律为诈骗邮件！请不要进行回复和点击邮件中的任何链接地址！可将此邮件的发件人加入黑名单，或者致电信息技术部进行举报。5、凡是收到让提供邮箱账号、密码、个人信息、公司通讯录及他人信息的邮件或短信，为了确保邮箱安全，请将强警惕或尽快修改密码！6、如果对邮箱有任何疑问，请联系信息技术部。二、为了有效的收集相关诈骗信息，请各位将收到的诈骗邮件、短信等信息反馈至此论坛跟帖中，以便于我们进行相应的跟踪及处理。,2016/5/19
65,“互联网+”现代农业三年行动实施方案,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9228,农业部等多部委联合发布“互联网+”现代农业三年行动实施方案。“互联网+”现代农业三年行动实施方案.docx,2016/5/17
66,“倾听用户心声，网罗大众需求”-信息发布平台V5.2需求征集贴,魏爱红,http://180.168.156.212:2262/wecenter/?/article/9227,信息发布平台V5.1已正式发布，为了更好的了解产品的复用情况，吸取产品改进意见，使信息发布平台产品升级工作显见成效，特发此帖。使用者吐槽、项目问题反馈、潜在用户咨询、专家引路，欢迎大家一起来！,2016/5/17
67,农业部关于推进“三品一标”持续健康发展的意见,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9226,其中提及追溯的内容：1、（三）发展目标：力争通过5年左右的推进，使“三品一标”生产规模进一步扩大，产品质量安全稳定在较高水平。“三品一标”获证产品数量年增幅保持在6%以上，产地环境监测面积达到占食用农产品生产总面积的40%，获证产品抽检合格率保持在98%以上，率先实现“三品一标”产品可追溯。2、切实将无公害农产品标识与产地准出和市场准入有机结合，凡加施获证无公害农产品防伪追溯标识的产品，推行等同性合格认定，实施顺畅快捷产地准出和市场准入。3、推动“三品一标”产品率先建立全程质量安全控制体系和实施追溯管理，全面开展“三品一标”产品质量追溯试点。农质发[2016]6号农业部关于推进“三品一标”持续健康发展的意见.docx,2016/5/13
68,国务院办公厅关于印发2016年食品安全重点工作安排的通知,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9225,全文主要有三处提到建立追溯体系：1、采取完善标准、制定行为规范、建立追溯体系、加强市场抽检等措施，实行严格的农业投入品使用管理制度（农业部）；2、督促和指导企业依法建立肉类、蔬菜、婴幼儿配方乳粉、白酒、食用植物油等重点产品追溯体系（工业和信息化部、农业部、商务部、质检总局、食品药品监管总局等负责）；3、推进重大信息化项目建设，加快国家食品安全监管信息化工程立项和平台建设，推进食用农产品质量安全追溯管理信息平台建设，统一标准，互联互通，尽快实现食品安全信息互联共享。（国家发展改革委、工业和信息化部、农业部、商务部、国家卫生计生委、工商总局、质检总局、食品药品监管总局、国家粮食局负责）国办发〔2016〕30号国务院办公厅关于印发2016年食品安全重点工作安排的通知.docx,2016/5/13
69,第一期：“征答题，做答人”活动,张杰,http://180.168.156.212:2262/wecenter/?/article/9224,第一期问题：Q1：你们公司怎么人员老是变动？请各位答人给出你的回答！同时恭喜冯叶先获得中信币20元！问题征集令继续征集中，期待你们的问题！！！中信“答人”秀规则1、每月月初各PMC成员和项目管理中心从“项目管理问题收集帖”中选择本月项目问题，问题一经采用，问题提出人将获得20中信币；2、发起本期“征答题，做答人”活动，公司全体成员均可在中信内网论坛里通过网络答题的方式参与此次活动，参与答题人每人将得到1个中信币/次。3、通过网络投票（点赞）的方式，每月月底综合网络票数、专家评分数决出本期“答”人，胜出者将得到200元的现金奖励。4、被选中答案者会优先成为年底优秀奖励人员。【投票/评分标准】1）答案需体现一定的专业度；2）言语中肯，能安抚客户，让客户满意，提高满意度；3）能很好地解决该项问题；,2016/5/11
70,笔记本电脑pc关机或重启出现黑屏没声音问题处理,章俊1,http://180.168.156.212:2262/wecenter/?/article/9223,笔记本电脑出现无法正常关机或重启的问题较多，原因也有很多种，今日碰到一情况，找出问题出在笔记本电池问题，供大家共享。拆卸电池后，笔记本使用外接电源系统正常关机，正常重启。,2016/5/3
71,钉钉和企业微信,朱俊1,http://180.168.156.212:2262/wecenter/?/article/9222,也许是因为钉钉发布的比较早认知度比较高，公司选择了它作为wotalk的替代品如果还有可能的话，希望公司能考虑一下腾讯的企业微信，虽然4月份才刚发布正式版，但有两款成熟产品RTX和微信做基础，相信企业微信不会让人失望反观频频做出各种反人类产品的阿里，令人实在没法看好这款钉钉最后不是不可以心疼一记wotalk，在大企业的漩涡中求生存不容易啊,2016/5/3
72,Google视觉资产指南-上,康廷,http://180.168.156.212:2262/wecenter/?/article/9221,【翻译】Google视觉资产指南-上原作者：GoogleDesign很难相信这篇指南的发表时间是在12年，所以说，优秀的设计总能经受时间的考验。转载自： ,2016/4/26
73,上海市检察院信息中心运维系统项目的部分问题,向俊,http://180.168.156.212:2262/wecenter/?/article/9220,Q1:你们项目上的人员不稳定，为什么经常更换？Q2:你们的系统为什么不能这么改？Q3：你们的开发人员为什么不能常驻现场？,2016/4/25
74,项目管理问题收集帖,张杰,http://180.168.156.212:2262/wecenter/?/article/9219,各位从事项目工作的同胞，你有什么平时老是回答不好的客户问出来的问题欢迎在此留言向我们求助！我们帮你问出来哦！一经采用，获赠20中信币。此贴为问题反馈帖，只作为问题反馈及吐槽的收集，不进行问题的讨论！,2016/4/22
75,档发[2016]4号 全国档案事业发展十三五规划纲要,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9218, 总体感觉新意不多，有几点值得关注：1、“到2020年，初步实现以信息化为核心的档案管理现代化”，首次把“信息化”作为核心；2、“加强司法、廉政建设、审计工作记录材料的归档管理”，这个工作和当前依法治国、反腐倡廉的大环境密切相关，可能会是我们档案软件推广的机会；3、“每年安排若干重大专题进行档案开发”，自从全年抗日战争胜利70周年档案专题展活动取得巨大成功之后，档案信息资源开发肯定是今后的重点，需要密切关注；4、“全国50%的县建成数字档案馆或启动数字档案馆建设项目”，提出了量化指标；5、“适时启动国家级电子（数字）档案馆系统项目建设”，如果这个项目启动，那肯定是一个上亿的大工程，不亚于美国的“ERA”；6、“在有条件的部门开展电子档案单套制（即电子设备生成的档案仅以电子方式保存）、单轨制（即不再生成纸质档案）管理试点”，正式提出“单套制”和“单轨制”，可惜还只是“在有条件的部门”；7、“启动中央档案馆3号库建设；新建中国第一历史档案馆、中国第二历史档案馆馆库；建设北京、吉林、河北、河南、上海、湖北、重庆、贵州、云南、西藏、甘肃、青海、新疆等省区市档案馆新馆；推进地市级综合档案馆馆库建设达标”，这么多新馆建设，我们的智能系统事业部有机会吗？档发[2016]4号全国档案事业发展十三五规划纲要.docx,2016/4/13
76,新员工，只从网站从客户的角度看公司产品，有点想法,吕锋,http://180.168.156.212:2262/wecenter/?/article/9217,"看到公司也有不少产品。看到门户网站向用户提供整体解决方案，这点非常赞赏。就是感觉解决方案页面介绍不够生动。还有一个我觉得是个较大问题：就是产品没有品牌，也没有看见商标。比如食品追溯系统可否注册一个""Foodway（R）2.0""(食品之道)（这里只是示例一下，具体产品功能模式我不了解）.品牌对一个产品影响太大了，没有品牌无论多么优秀的东西在用眼里也是一个山寨品。其他产品也同样应该注重品牌作为新员工，了解还不足，望多指教。",2016/4/12
77,如何把你的笔记本设置成wi-fi无线热点,吕锋,http://180.168.156.212:2262/wecenter/?/article/9216,适合经常出差的同事，当你为身边没有wi-fi信号而苦恼的时候，如果你身边有一个笔记本可以连接到互联网，那么可以把你的笔记本变成无线热点。具体步骤：以管理员模式打开命令行窗口（必须以管理员模式运行哦）。执行以下命令两行netshwlansethostednetworkmode=allowssid=无线热点名称key=你的无线热点密码netshwlanstarthostednetwork然后重启电脑（如果你够熟练也可以只重启一下网卡）现在拿起手机应该可以搜索到你刚刚设置的wi-fi热点了。,2016/4/8
78,最全的CSS浏览器兼容问题,车园园,http://180.168.156.212:2262/wecenter/?/article/9215,"CSS对浏览器的兼容性有时让人很头疼,或许当你了解当中的技巧跟原理,就会觉得也不是难事,从网上收集了IE7,6与Fireofx的兼容性处理方法并整理了一下.对于web2.0的过度,请尽量用xhtml格式写代码,而且DOCTYPE影响CSS处理,作为W3C的标准,一定要加DOCTYPE声名.CSS技巧1.div的垂直居中问题vertical-align:middle;将行距增加到和整个DIV一样高line-height:200px;然后插入文字，就垂直居中了。缺点是要控制内容不要换行2.margin加倍的问题设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上display:inline;例如：<#divid=”imfloat”>相应的css为#IamFloat{float:left;margin:5px;/*IE下理解为10px*/display:inline;/*IE下再理解为5px*/}3.浮动ie产生的双倍距离#box{float:left;width:100px;margin:000100px;//这种情况之下IE会产生200px的距离display:inline;//使浮动忽略}这里细说一下block与inline两个元素：block元素的特点是,总是在新行上开始,高度,宽度,行高,边距都可以控制(块元素);Inline元素的特点是,和其他元素在同一行上,不可控制(内嵌元素);#box{display:block;//可以为内嵌元素模拟为块元素display:inline;//实现同一行排列的效果diplay:table;4IE与宽度和高度的问题IE不认得min-这个定义，但实际上它把正常的width和height当作有min的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样：#box{width:80px;height:35px;}html>body#box{width:auto;height:auto;min-width:80px;min-height:35px;}5.页面的最小宽度min-width是个非常方便的CSS命令，它可以指定元素最小也不能小于某个宽度，这样就能保证排版一直正确。但IE不认得这个，而它实际上把width当做最小宽度来使。为了让这一命令在IE上也能用，可以把一个<div>放到<body>标签下，然后为div指定一个类,然后CSS这样设计：#container{min-width:600px;width:expression(document.body.clientWidth<600?""600px"":""auto"");}第一个min-width是正常的；但第2行的width使用了Javascript，这只有IE才认得，这也会让你的HTML文档不太正规。它实际上通过Javascript的判断来实现最小宽度。6.DIV浮动IE文本产生3象素的bug左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距.#box{float:left;width:800px;}#left{float:left;width:50%;}#right{width:50%;}*html#left{margin-right:-3px;//这句是关键}<divid=""box""><divid=""left""></div><divid=""right""></div></div>7.IE捉迷藏的问题当div应用复杂的时候每个栏中又有一些链接，DIV等这个时候容易发生捉迷藏的问题。有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。解决办法：对#layout使用line-height属性或者给#layout使用固定高和宽。页面结构尽量简单。8.float的div闭合;清除浮动;自适应高度;①例如：<#divid=”floatA”><#divid=”floatB”><#divid=”NOTfloatC”>这里的NOTfloatC并不希望继续平移，而是希望往下排。(其中floatA、floatB的属性已经设置为float:left;)这段代码在IE中毫无问题，问题出在FF。原因是NOTfloatC并非float标签，必须将float标签闭合。在<#divclass=”floatB”><#divclass=”NOTfloatC”>之间加上<#divclass=”clear”>这个div一定要注意位置，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系，否则会产生异常。并且将clear这种样式定义为为如下即可：.clear{clear:both;}②作为外部wrapper的div不要定死高度,为了让高度能自动适应，要在wrapper里面加上overflow:hidden;当包含float的box的时候，高度自动适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊！)用zoom:1;可以做到，这样就达到了兼容。例如某一个wrapper如下定义：.colwrapper{overflow:hidden;zoom:1;margin:5pxauto;}③对于排版,我们用得最多的css描述可能就是float:left.有的时候我们需要在n栏的floatdiv后面做一个统一的背景,譬如:<divid=”page”><divid=”left”></div><divid=”center”></div><divid=”right”></div></div>比如我们要将page的背景设置成蓝色,以达到所有三栏的背景颜色是蓝色的目的,但是我们会发现随着leftcenterright的向下拉长,而page居然保存高度不变,问题来了,原因在于page不是float属性,而我们的page由于要居中,不能设置成float,所以我们应该这样解决<divid=”page”><divid=”bg”style=”float:left;width:100%”><divid=”left”></div><divid=”center”></div><divid=”right”></div></div></div>再嵌入一个floatleft而宽度是100%的DIV解决之④万能float闭合(非常重要!)关于clearfloat的原理可参见[HowToClearFloatsWithoutStructuralMarkup],将以下代码加入GlobalCSS中,给需要闭合的div加上class=""clearfix""即可,屡试不爽./*ClearFix*/.clearfix:after{content:""."";display:block;height:0;clear:both;visibility:hidden;}.clearfix{display:inline-block;}/*HidefromIEMac*/.clearfix{display:block;}/*EndhidefromIEMac*//*endofclearfix*/或者这样设置：.hackbox{display:table;//将对象作为块元素级的表格显示}11.高度不适应高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用margin或paddign时。例：#box{background-color:#eee;}#boxp{margin-top:20px;margin-bottom:20px;text-align:center;}<divid=""box""><p>p对象中的内容</p></div>解决方法：在P对象上下各加2个空的div对象CSS代码：.1{height:0px;overflow:hidden;}或者为DIV加上border属性。12.IE6下为什么图片下有空隙产生解决这个BUG的方法也有很多,可以是改变html的排版,或者设置img为display:block或者设置vertical-align属性为vertical-align:top|bottom|middle|text-bottom都可以解决.13.如何对齐文本与文本输入框加上vertical-align:middle;<styletype=""text/css""><!--input{width:200px;height:30px;border:1pxsolidred;vertical-align:middle;}--></style>14.web标准中定义id与class有什么区别吗一.web标准中是不容许重复ID的,比如divid=""aa""不容许重复2次,而class定义的是类,理论上可以无限重复,这样需要多次引用的定义便可以使用他.二.属性的优先级问题ID的优先级要高于class,看上面的例子三.方便JS等客户端脚本,如果在页面中要对某个对象进行脚本操作,那么可以给他定义一个ID,否则只能利用遍历页面元素加上指定特定属性来找到它,这是相对浪费时间资源,远远不如一个ID来得简单.15.LI中内容超过长度后以省略号显示的方法此方法适用与IE与OP浏览器<styletype=""text/css""><!--li{width:200px;white-space:nowrap;text-overflow:ellipsis;-o-text-overflow:ellipsis;overflow:hidden;}--></style>16.为什么web标准中IE无法设置滚动条颜色了解决办法是将body换成html<!DOCTYPEhtmlPUBLIC""-//W3C//DTDXHTML1.0Strict//EN"""" /china/msdn/library/webservices/asp.net/ASPNETusStan.mspx?mfr=trueIE6,IE7,FFIE7.0出来了，对CSS的支持又有新问题。浏览器多了，网页兼容性更差了，疲于奔命的还是我们，为解决IE7.0的兼容问题，找来了下面这篇文章：现在我大部分都是用!important来hack，对于ie6和firefox测试可以正常显示，但是ie7对!important可以正确解释，会导致页面没按要求显示！下面是三个浏览器的兼容性收集.第一种，是CSSHACK的方法height:20px;/*ForFirefox*/*height:25px;/*ForIE7&IE6*/_height:20px;/*ForIE6*/注意顺序。这样也属于CSSHACK，不过没有上面这样简洁。#example{color:#333;}/*Moz*/*html#example{color:#666;}/*IE6*/*+html#example{color:#999;}/*IE7*/<!--其他浏览器--><linkrel=""stylesheet""type=""text/css""href=""css.css""/><!--[ifIE7]><!--适合于IE7--><linkrel=""stylesheet""type=""text/css""href=""ie7.css""/><![endif]--><!--[iflteIE6]><!--适合于IE6及一下--><linkrel=""stylesheet""type=""text/css""href=""ie.css""/><![endif]-->第三种，cssfilter的办法，以下为经典从国外网站翻译过来的。.新建一个css样式如下：#item{width:200px;height:200px;background:red;}新建一个div,并使用前面定义的css的样式：<divid=""item"">sometexthere</div>在body表现这里加入lang属性,中文为zh：<bodylang=""en"">现在对div元素再定义一个样式：*:lang(en)#item{background:green!important;}这样做是为了用!important覆盖原来的css样式,由于:lang选择器ie7.0并不支持,所以对这句话不会有任何作用,于是也达到了ie6.0下同样的效果,但是很不幸地的是,safari同样不支持此属性,所以需要加入以下css样式：#item:empty{background:green!important}:empty选择器为css3的规范,尽管safari并不支持此规范,但是还是会选择此元素,不管是否此元素存在,现在绿色会现在在除ie各版本以外的浏览器上。对IE6和FF的兼容可以考虑以前的!important个人比较喜欢用",2016/4/8
79,关于我司软件系统中的功能实现（数据库与程序篇）,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9214,"我司软件部门开发人员写数据库sql的能力已经远远超过了常人想象，这一点我是不得不服，绝对厉害，三大事业部群（食安除外），主流业务的查询，那试图和存储过程sql写的真让人叹为观止，为了实现业务功能，一条sql可以赶得上一篇500字作文的长度，有的可能还超过，特别让我汗颜的是如果让我写，我自己还真心写不出来。如果要按我接触的部门SQL能力排名的话，档案馆赶不上档案室的一半，档案室赶不上公司IT部门,IT赶不上监狱的1/5，大家可以对号想想，究竟有多复杂。之前检察院一直号称文书档案检索慢，今天去检察院，看了下系统数据，才12万的模糊查询，光数据库层就要24秒，遇到复杂检索档案利用界面查询需要20分钟，客户现场直接无法忍受。经过分析12万的数据来自某个视图，而这个视图是尝试将文书案卷表和一文一件表两张表的数据做一个联合查询，再提供给程序进行文书档案一体化查询。当时想都没想，直接createtableasselect*fromv_xxx，确认下查真表的速度，就这么点数据，从未怀疑过ORACLE的能力业务中果断使用真表替代视图，开启定时任务，每天晚上DROP掉真表再重新创建新表，保证数据最新即可。江山代有才人出,各领风骚数百年，我希望我们的程序员在面对业务，耍酷挑战自我的同时，尽可能的多考虑一些，而不是实现了某个功能，达到了某个效果就可以了",2016/4/7
80,如何查看Windows AD域控服务器FSMO角色,章俊1,http://180.168.156.212:2262/wecenter/?/article/9213,在任意一台Windows的DC域控服务器下：1.打开cmd窗口，并输入命令：C:\netdomqueryfsmo在输出的结果中可以查看FSMO角色在那一台域控服务器上。,2016/4/5
81,Windows平台下如何查看服务器系统是什么时间安装了以及已经启动了多长时间,章俊1,http://180.168.156.212:2262/wecenter/?/article/9212,在windows平台下，可以对服务器或pc的操作系统都可以查看，查看方式如下：1.打开CMD命令窗口，在命令窗口中输入：systeminfo在输出的结果中可以看到系统初始安装时间以及系统启动时间。,2016/4/5
82,城市轨道交通工程文件归档要求与档案分类规则（征求意见稿）,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9210,其中的分类方案、归档范围和保管期限表很有参考价值。《城市轨道交通工程文件归档要求与档案分类规则（征求意见稿）》.doc,2016/3/27
83,归档范围和档案保管期限表通过审核的央企名单，应该都是我们光典系统的潜在客户,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9209,管理类文件材料归档范围和档案保管期限表通过审核的企业名单（按批复时间先后排序）编号单位名称1中国兵器装备集团公司2中国华能集团公司3中国石油天然气集团公司4中国中信集团有限公司5中国长江三峡集团公司6中国光大（集团）总公司7中国铁道建筑总公司8中国工商银行股份有限公司9国家核电技术公司10中国林业集团公司11中国核工业集团公司12中国东方资产管理公司13中诚信托有限责任公司14中国航天科工集团公司15中粮集团有限公司16中国五矿集团公司17中国人寿保险（集团）公司18中国交通建设集团有限公司19中国兵器工业集团公司20中国航天科技集团公司21中国中化集团公司22中国再保险（集团）股份有限公司23中国电子科技集团公司24中国铁路工程总公司25中国广核集团有限公司26中国第一汽车集团公司27中国人民财产保险股份有限公司28中国银行股份有限公司29中国冶金地质总局30中国华电集团公司31中国化工集团公司32中国船舶工业集团公司33华侨城集团公司34中国商用飞机有限责任公司35国家开发银行股份有限公司36中国建筑材料集团有限公司37神华集团有限责任公司38中国西电集团公司39中国民航信息集团公司40交通银行股份有限公司41中国医药集团总公司42华润（集团）有限公司43中国工艺（集团）公司44中国铝业公司45中国化学工程集团公司46武汉邮电科学研究院47国家开发投资公司48中国信达资产管理股份有限公司49哈尔滨电气集团公司50宝钢集团有限公司51东风汽车公司52武汉钢铁（集团）公司53中国冶金科工集团有限公司54中国农业发展集团有限公司55中国邮政集团公司56中国东方电气集团有限公司57中国中煤能源集团有限公司58中国人寿保险股份有限公司59国家电网公司60中央国债登记结算有限责任公司,2016/3/27
84,redis的各系统安装,赵本,http://180.168.156.212:2262/wecenter/?/article/9208,最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在Lucene上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。入门每个人的学习方式都不一样，有的人喜欢亲自实践学习，有的喜欢观看教学视频，还有的喜欢通过阅读来学习。对于Redis，没有什么比亲自实践学习来得效果更好的了。Redis的安装非常简单。而且通过随之安装的一个简单的命令解析程序，就能处理我们想做的一切事情。让我们先花几分钟的时间把Redis安装到我们的机器上。Windows平台Redis并没有官方支持Windows平台，但还是可供选择。你不会想在这里配置实际的生产环境，不过在我过往的开发经历里并没有感到有什么限制。首先进入 /fi...ar.gztarxzfredis-2.4.6.tar.gzcdredis-2.4.6make（当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入brewinstallredis即可。）如果你是通过源文件来安装，二进制可执行文件会被放置在src目录里。通过运行cdsrc可跳转到src目录。运行和连接Redis如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击redis-server，在*nix/MacOSX平台则运行./redis-server.如果你仔细看了启动信息，你会看到一个警告，指没能找到redis.conf文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。然后，通过双击redis-cli（Windows平台）或者运行./redis-cli（*nix/MacOSX平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。可以在命令行界面键入info命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。如果在上面的启动步骤里遇到什么问题，我建议你到Redis的官方支持组里获取帮助。驱动Redis很快你就会发现，Redis的API就如一组定义明确的函数那般容易理解。Redis具有让人难以置信的简单性，其操作过程也同样如此。这意味着，无论你是使用命令行程序，或是使用你喜欢的语言来驱动，整体的感觉都不会相差多少。因此，相对于命令行程序，如果你更愿意通过一种编程语言去驱动Redis，你不会感觉到有任何适应的问题。如果真想如此，可以到Redis的客户端推荐页面下载适合的Redis载体。,2016/3/25
85,处理旧手机，99%的人都不知道的几招,张婷婷,http://180.168.156.212:2262/wecenter/?/article/9207,互联网技术日新月异，手机产品也不停更新迭代，相信很多小伙伴都和小编一样，肾3，肾4，肾5，肾6，马上又要肾7了，更新换代的旧手机怎么办？你的旧手机都去哪儿了？当互联网已经完全渗透到我们生活的方方面面的的时候，二手手机回收，自然也会想到通过网络搞定，于是，线上二手3C产品交易的平台如闲鱼也渐渐火了起来，甚至还有O2O回收平台如爱回收等也在不断瞄准这个日益庞大的市场。在闲鱼上，可以很方便的将自己的二手手机转手出去然而，当准备将不用的手机转手时，绝大部分的同学只是删掉了照片、支付软件、银行app等，就认为万事大吉了。Toosimple，sometimesna?ve!纳尼，删掉还不够吗？远远不够！想想不断被曝出的旧手机被人利用，损失钱财的案例吧，原来，问题就出在旧手机上！怎么办才能保证安全？第一点：删掉手机中的所有隐私信息，退出支付宝账户的登录，删除支付宝App和其他所有APP，并清空手机上所有信息含照片、通讯录、短信、备忘录、注销手机云账号等。是不是觉得很烦？好吧，其实就一句话！将手机恢复出厂设置和拔除手机SIM卡！然后更保险的方法是，用垃圾文件将手机硬盘填满，因为硬盘上的数据可以反复被覆盖，但数据恢复只能恢复最上层的信息，信息填得越满，恢复就越难。第二点：不要告诉别人密码！不要告诉别人密码！不要告诉别人密码！重要的信息说三遍，也不要提供任何可能猜到密码的信息。万一手机被盗又怎么办呢？还有空问这个问题，赶紧去挂失啊！第一步，首先联系通讯运营商，挂失SIM卡，并尽快补办手机卡；第二步，如手机有绑定支付宝账户或手机上装有支付宝APP，还要赶紧支付宝挂失。支付宝挂失有三种方式：拨打支付宝客服电话95188挂失；电脑挂失，电脑登录支付宝账户，进入“服务大厅－自助服务－安全服务－手机丢失”快速挂失；其他手机登录支付宝账户，进入“设置-安全设置-安全中心-快速挂失”；另外要注意的是：补办手机卡后，小伙伴们重新登录支付宝之时，记得修改登录密码和支付密码；如果手机号码无法找回，还必须及时更换支付宝账户的绑定手机并修改密码；可能还会有小伙伴问，“我的手机已经转卖、送人或者送修了，但我没有来得及在旧手机上退出支付宝账户登录，更别提删除支付宝App，该怎么办呢？”很简单：在新手机上登录支付宝账号，原手机的支付宝账户会自动退出，不过，亲，最好记得修改登录密码哦。支付软件密码应该怎么设置？第一点：涉及资金交易的网站要和其他网站的登录名、登录密码、密码保护问题有所区分。尤其不要拿姓名、生日、手机号码等极易被破解的信息来作为密码避免。这样是避免信息泄露后，不法分子拿着这些数据，去资金类网站尝试登录。有一种观点说，所有的密码都要不一样。这种观点过于极端，我们动不动就在几十个网站软件注册，如果每一个密码都不一样，记住这些密码也是一个重大挑战。有人说，密码文档存在电脑里不就好了，可是你想过电脑被人种木马的情形吗？还有人说，上传到网盘，想不起来就去查一下。的确，密码文档存网盘的安全性一定比存在自己电脑里强。如果想要更安全，可以增加一个登录时输入短信校验码的功能。但小编依然觉得，把所有密码放在一个文档里，相当于把所有鸡蛋放在一个篮子里。如果不小心被攻破了网盘密码，岂不是所有的重要信息都被人掌握了。第二点：有一个更安全的邮箱有些网站是仅通过邮箱验证就能找回密码的，那么，万一邮箱密码泄露，你在这些网站上的密码也可能被修改。所以遇到不重要的网站，小编一般就填一个接收垃圾邮件的邮箱。重要的银行账单、股票账户信息等都发到一个安全级别更高的邮箱，这个邮箱一般会设置异常登录提醒。第三点：安全大牛怎么设密码？用统一规则记住多个不同密码首先选取一个基本密码，然后根据服务的不同，在这个密码的基础上按照一定的规则叠加一些其他元素。举个例子：基本密码+网站名称的后两个字母+网站名称的前两个字母。比如说，基本密码是“7452”，那么要登录工商银行ICBC密码就是7452BCIC。为了更加安全，还可以在中间加上几个不为人知的字母，比如自己的乳名。第四点：万一被异常登录，马上修改密码当账号在异常设备登录，支付软件一般会给手机发送登录通知，或者踢出原设备。如果不是自己登录，那很可能密码被人知道了，这时候就要改密码啦！第五点：千万不要告诉别人密码！千万不要告诉别人密码！千万不要告诉别人密码！做到以上五点，小伙伴们就不用担心因为密码泄漏而导致钱包吃亏啦，小编也不枉到处搜罗资料，打字打成狗了！另外一个好消息是：随着科学技术的发展，未来，支付软件都将淘汰掉密码支付，国内一些先进的支付软件公司已经开始改用指纹、人脸、虹膜等生物识别技术，更安全更便捷了，小伙伴们不妨一试哦！文章出自： ,2016/3/25
86,关于java和redis的小程序和redis常用指令（见文末）,赵本,http://180.168.156.212:2262/wecenter/?/article/9206,"一、server端安装1、下载 /blog/794194ps:如果配置文件的版本和当前exe程序的版本不匹配，很容易由于参数不一致导致server端无法启动。4、通过指定的配置文件启动服务端5、客户端访问测试另起一个cmd窗口：二、基本功能测试1、程序基本结构2、主要类1）功能类packagecom.redis;importjava.util.ArrayList;importjava.util.Iterator;importjava.util.List;importjava.util.Set;importredis.clients.jedis.Jedis;importredis.clients.jedis.JedisPool;importredis.clients.jedis.JedisPoolConfig;importredis.clients.jedis.JedisShardInfo;importredis.clients.jedis.ShardedJedis;importredis.clients.jedis.ShardedJedisPool;importredis.clients.jedis.SortingParams;publicclassRedisClient{privateJedisjedis;//非切片额客户端连接privateJedisPooljedisPool;//非切片连接池privateShardedJedisshardedJedis;//切片额客户端连接privateShardedJedisPoolshardedJedisPool;//切片连接池publicRedisClient(){initialPool();initialShardedPool();shardedJedis=shardedJedisPool.getResource();jedis=jedisPool.getResource();}/***初始化非切片池*/privatevoidinitialPool(){//池基本配置JedisPoolConfigconfig=newJedisPoolConfig();config.setMaxActive(20);config.setMaxIdle(5);config.setMaxWait(1000l);config.setTestOnBorrow(false);jedisPool=newJedisPool(config,""127.0.0.1"",6379);}/***初始化切片池*/privatevoidinitialShardedPool(){//池基本配置JedisPoolConfigconfig=newJedisPoolConfig();config.setMaxActive(20);config.setMaxIdle(5);config.setMaxWait(1000l);config.setTestOnBorrow(false);//slave链接List<JedisShardInfo>shards=newArrayList<JedisShardInfo>();shards.add(newJedisShardInfo(""127.0.0.1"",6379,""master""));//构造池shardedJedisPool=newShardedJedisPool(config,shards);}publicvoidshow(){KeyOperate();StringOperate();ListOperate();SetOperate();SortedSetOperate();HashOperate();jedisPool.returnResource(jedis);shardedJedisPool.returnResource(shardedJedis);}privatevoidKeyOperate(){。。。}privatevoidStringOperate(){。。。}privatevoidListOperate(){。。。}privatevoidSetOperate(){。。。}privatevoidSortedSetOperate(){。。。}privatevoidHashOperate(){。。。}}2）测试类packagecom.redis;publicclassMain{publicstaticvoidmain(String[]args){//TODOAuto-generatedmethodstubnewRedisClient().show();}}3、各个功能函数1）key功能privatevoidKeyOperate(){System.out.println(""======================key=========================="");//清空数据System.out.println(""清空库中所有数据：""+jedis.flushDB());//判断key否存在System.out.println(""判断key999键是否存在：""+shardedJedis.exists(""key999""));System.out.println(""新增key001,value001键值对：""+shardedJedis.set(""key001"",""value001""));System.out.println(""判断key001是否存在：""+shardedJedis.exists(""key001""));//输出系统中所有的keySystem.out.println(""新增key002,value002键值对：""+shardedJedis.set(""key002"",""value002""));System.out.println(""系统中所有键如下："");Set<String>keys=jedis.keys(""*"");Iterator<String>it=keys.iterator();while(it.hasNext()){Stringkey=it.next();System.out.println(key);}//删除某个key,若key不存在，则忽略该命令。System.out.println(""系统中删除key002:""+jedis.del(""key002""));System.out.println(""判断key002是否存在：""+shardedJedis.exists(""key002""));//设置key001的过期时间System.out.println(""设置key001的过期时间为5秒:""+jedis.expire(""key001"",5));try{Thread.sleep(2000);}catch(InterruptedExceptione){}//查看某个key的剩余生存时间,单位【秒】.永久生存或者不存在的都返回-1System.out.println(""查看key001的剩余生存时间：""+jedis.ttl(""key001""));//移除某个key的生存时间System.out.println(""移除key001的生存时间：""+jedis.persist(""key001""));System.out.println(""查看key001的剩余生存时间：""+jedis.ttl(""key001""));//查看key所储存的值的类型System.out.println(""查看key所储存的值的类型：""+jedis.type(""key001""));/**一些其他方法：1、修改键名：jedis.rename(""key6"",""key0"");*2、将当前db的key移动到给定的db当中：jedis.move(""foo"",1)*/}运行结果：======================key==========================清空库中所有数据：OK判断key999键是否存在：false新增key001,value001键值对：OK判断key001是否存在：true新增key002,value002键值对：OK系统中所有键如下：key002key001系统中删除key002:1判断key002是否存在：false设置key001的过期时间为5秒:1查看key001的剩余生存时间：3移除key001的生存时间：1查看key001的剩余生存时间：-1查看key所储存的值的类型：string2）String功能privatevoidStringOperate(){System.out.println(""======================String_1=========================="");//清空数据System.out.println(""清空库中所有数据：""+jedis.flushDB());System.out.println(""=============增============="");jedis.set(""key001"",""value001"");jedis.set(""key002"",""value002"");jedis.set(""key003"",""value003"");System.out.println(""已新增的3个键值对如下："");System.out.println(jedis.get(""key001""));System.out.println(jedis.get(""key002""));System.out.println(jedis.get(""key003""));System.out.println(""=============删============="");System.out.println(""删除key003键值对：""+jedis.del(""key003""));System.out.println(""获取key003键对应的值：""+jedis.get(""key003""));System.out.println(""=============改============="");//1、直接覆盖原来的数据System.out.println(""直接覆盖key001原来的数据：""+jedis.set(""key001"",""value001-update""));System.out.println(""获取key001对应的新值：""+jedis.get(""key001""));//2、直接覆盖原来的数据System.out.println(""在key002原来值后面追加：""+jedis.append(""key002"",""+appendString""));System.out.println(""获取key002对应的新值""+jedis.get(""key002""));System.out.println(""=============增，删，查（多个）============="");/***mset,mget同时新增，修改，查询多个键值对*等价于：*jedis.set(""name"",""ssss"");*jedis.set(""jarorwar"",""xxxx"");*/System.out.println(""一次性新增key201,key202,key203,key204及其对应值：""+jedis.mset(""key201"",""value201"",""key202"",""value202"",""key203"",""value203"",""key204"",""value204""));System.out.println(""一次性获取key201,key202,key203,key204各自对应的值：""+jedis.mget(""key201"",""key202"",""key203"",""key204""));System.out.println(""一次性删除key201,key202：""+jedis.del(newString[]{""key201"",""key202""}));System.out.println(""一次性获取key201,key202,key203,key204各自对应的值：""+jedis.mget(""key201"",""key202"",""key203"",""key204""));System.out.println();//jedis具备的功能shardedJedis中也可直接使用，下面测试一些前面没用过的方法System.out.println(""======================String_2=========================="");//清空数据System.out.println(""清空库中所有数据：""+jedis.flushDB());System.out.println(""=============新增键值对时防止覆盖原先值============="");System.out.println(""原先key301不存在时，新增key301：""+shardedJedis.setnx(""key301"",""value301""));System.out.println(""原先key302不存在时，新增key302：""+shardedJedis.setnx(""key302"",""value302""));System.out.println(""当key302存在时，尝试新增key302：""+shardedJedis.setnx(""key302"",""value302_new""));System.out.println(""获取key301对应的值：""+shardedJedis.get(""key301""));System.out.println(""获取key302对应的值：""+shardedJedis.get(""key302""));System.out.println(""=============超过有效期键值对被删除============="");//设置key的有效期，并存储数据System.out.println(""新增key303，并指定过期时间为2秒""+shardedJedis.setex(""key303"",2,""key303-2second""));System.out.println(""获取key303对应的值：""+shardedJedis.get(""key303""));try{Thread.sleep(3000);}catch(InterruptedExceptione){}System.out.println(""3秒之后，获取key303对应的值：""+shardedJedis.get(""key303""));System.out.println(""=============获取原值，更新为新值一步完成============="");System.out.println(""key302原值：""+shardedJedis.getSet(""key302"",""value302-after-getset""));System.out.println(""key302新值：""+shardedJedis.get(""key302""));System.out.println(""=============获取子串============="");System.out.println(""获取key302对应值中的子串：""+shardedJedis.getrange(""key302"",5,7));}运行结果:======================String_1==========================清空库中所有数据：OK=============增=============已新增的3个键值对如下：value001value002value003=============删=============删除key003键值对：1获取key003键对应的值：null=============改=============直接覆盖key001原来的数据：OK获取key001对应的新值：value001-update在key002原来值后面追加：21获取key002对应的新值value002+appendString=============增，删，查（多个）=============一次性新增key201,key202,key203,key204及其对应值：OK一次性获取key201,key202,key203,key204各自对应的值：[value201,value202,value203,value204]一次性删除key201,key202：2一次性获取key201,key202,key203,key204各自对应的值：[null,null,value203,value204]======================String_2==========================清空库中所有数据：OK=============新增键值对时防止覆盖原先值=============原先key301不存在时，新增key301：1原先key302不存在时，新增key302：1当key302存在时，尝试新增key302：0获取key301对应的值：value301获取key302对应的值：value302=============超过有效期键值对被删除=============新增key303，并指定过期时间为2秒OK获取key303对应的值：key303-2second3秒之后，获取key303对应的值：null=============获取原值，更新为新值一步完成=============key302原值：value302key302新值：value302-after-getset=============获取子串=============获取key302对应值中的子串：3023）List功能privatevoidListOperate(){System.out.println(""======================list=========================="");//清空数据System.out.println(""清空库中所有数据：""+jedis.flushDB());System.out.println(""=============增============="");shardedJedis.lpush(""stringlists"",""vector"");shardedJedis.lpush(""stringlists"",""ArrayList"");shardedJedis.lpush(""stringlists"",""vector"");shardedJedis.lpush(""stringlists"",""vector"");shardedJedis.lpush(""stringlists"",""LinkedList"");shardedJedis.lpush(""stringlists"",""MapList"");shardedJedis.lpush(""stringlists"",""SerialList"");shardedJedis.lpush(""stringlists"",""HashList"");shardedJedis.lpush(""numberlists"",""3"");shardedJedis.lpush(""numberlists"",""1"");shardedJedis.lpush(""numberlists"",""5"");shardedJedis.lpush(""numberlists"",""2"");System.out.println(""所有元素-stringlists：""+shardedJedis.lrange(""stringlists"",0,-1));System.out.println(""所有元素-numberlists：""+shardedJedis.lrange(""numberlists"",0,-1));System.out.println(""=============删============="");//删除列表指定的值，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈System.out.println(""成功删除指定元素个数-stringlists：""+shardedJedis.lrem(""stringlists"",2,""vector""));System.out.println(""删除指定元素之后-stringlists：""+shardedJedis.lrange(""stringlists"",0,-1));//删除区间以外的数据System.out.println(""删除下标0-3区间之外的元素：""+shardedJedis.ltrim(""stringlists"",0,3));System.out.println(""删除指定区间之外元素后-stringlists：""+shardedJedis.lrange(""stringlists"",0,-1));//列表元素出栈System.out.println(""出栈元素：""+shardedJedis.lpop(""stringlists""));System.out.println(""元素出栈后-stringlists：""+shardedJedis.lrange(""stringlists"",0,-1));System.out.println(""=============改============="");//修改列表中指定下标的值shardedJedis.lset(""stringlists"",0,""hellolist!"");System.out.println(""下标为0的值修改后-stringlists：""+shardedJedis.lrange(""stringlists"",0,-1));System.out.println(""=============查============="");//数组长度System.out.println(""长度-stringlists：""+shardedJedis.llen(""stringlists""));System.out.println(""长度-numberlists：""+shardedJedis.llen(""numberlists""));//排序/**list中存字符串时必须指定参数为alpha，如果不使用SortingParams，而是直接使用sort(""list"")，*会出现""ERROneormorescorescan'tbeconvertedintodouble""*/SortingParamssortingParameters=newSortingParams();sortingParameters.alpha();sortingParameters.limit(0,3);System.out.println(""返回排序后的结果-stringlists：""+shardedJedis.sort(""stringlists"",sortingParameters));System.out.println(""返回排序后的结果-numberlists：""+shardedJedis.sort(""numberlists""));//子串：start为元素下标，end也为元素下标；-1代表倒数一个元素，-2代表倒数第二个元素System.out.println(""子串-第二个开始到结束：""+shardedJedis.lrange(""stringlists"",1,-1));//获取列表指定下标的值System.out.println(""获取下标为2的元素：""+shardedJedis.lindex(""stringlists"",2)+""\n"");}运行结果:======================list==========================清空库中所有数据：OK=============增=============所有元素-stringlists：[HashList,SerialList,MapList,LinkedList,vector,vector,ArrayList,vector]所有元素-numberlists：[2,5,1,3]=============删=============成功删除指定元素个数-stringlists：2删除指定元素之后-stringlists：[HashList,SerialList,MapList,LinkedList,ArrayList,vector]删除下标0-3区间之外的元素：OK删除指定区间之外元素后-stringlists：[HashList,SerialList,MapList,LinkedList]出栈元素：HashList元素出栈后-stringlists：[SerialList,MapList,LinkedList]=============改=============下标为0的值修改后-stringlists：[hellolist!,MapList,LinkedList]=============查=============长度-stringlists：3长度-numberlists：4返回排序后的结果-stringlists：[LinkedList,MapList,hellolist!]返回排序后的结果-numberlists：[1,2,3,5]子串-第二个开始到结束：[MapList,LinkedList]获取下标为2的元素：LinkedList4）Set功能privatevoidSetOperate(){System.out.println(""======================set=========================="");//清空数据System.out.println(""清空库中所有数据：""+jedis.flushDB());System.out.println(""=============增============="");System.out.println(""向sets集合中加入元素element001：""+jedis.sadd(""sets"",""element001""));System.out.println(""向sets集合中加入元素element002：""+jedis.sadd(""sets"",""element002""));System.out.println(""向sets集合中加入元素element003：""+jedis.sadd(""sets"",""element003""));System.out.println(""向sets集合中加入元素element004：""+jedis.sadd(""sets"",""element004""));System.out.println(""查看sets集合中的所有元素:""+jedis.smembers(""sets""));System.out.println();System.out.println(""=============删============="");System.out.println(""集合sets中删除元素element003：""+jedis.srem(""sets"",""element003""));System.out.println(""查看sets集合中的所有元素:""+jedis.smembers(""sets""));/*System.out.println(""sets集合中任意位置的元素出栈：""+jedis.spop(""sets""));//注：出栈元素位置居然不定？--无实际意义System.out.println(""查看sets集合中的所有元素:""+jedis.smembers(""sets""));*/System.out.println();System.out.println(""=============改============="");System.out.println();System.out.println(""=============查============="");System.out.println(""判断element001是否在集合sets中：""+jedis.sismember(""sets"",""element001""));System.out.println(""循环查询获取sets中的每个元素："");Set<String>set=jedis.smembers(""sets"");Iterator<String>it=set.iterator();while(it.hasNext()){Objectobj=it.next();System.out.println(obj);}System.out.println();System.out.println(""=============集合运算============="");System.out.println(""sets1中添加元素element001：""+jedis.sadd(""sets1"",""element001""));System.out.println(""sets1中添加元素element002：""+jedis.sadd(""sets1"",""element002""));System.out.println(""sets1中添加元素element003：""+jedis.sadd(""sets1"",""element003""));System.out.println(""sets1中添加元素element002：""+jedis.sadd(""sets2"",""element002""));System.out.println(""sets1中添加元素element003：""+jedis.sadd(""sets2"",""element003""));System.out.println(""sets1中添加元素element004：""+jedis.sadd(""sets2"",""element004""));System.out.println(""查看sets1集合中的所有元素:""+jedis.smembers(""sets1""));System.out.println(""查看sets2集合中的所有元素:""+jedis.smembers(""sets2""));System.out.println(""sets1和sets2交集：""+jedis.sinter(""sets1"",""sets2""));System.out.println(""sets1和sets2并集：""+jedis.sunion(""sets1"",""sets2""));System.out.println(""sets1和sets2差集：""+jedis.sdiff(""sets1"",""sets2""));//差集：set1中有，set2中没有的元素}运行结果:======================set==========================清空库中所有数据：OK=============增=============向sets集合中加入元素element001：1向sets集合中加入元素element002：1向sets集合中加入元素element003：1向sets集合中加入元素element004：1查看sets集合中的所有元素:[element001,element002,element003,element004]=============删=============集合sets中删除元素element003：1查看sets集合中的所有元素:[element001,element002,element004]=============改==========================查=============判断element001是否在集合sets中：true循环查询获取sets中的每个元素：element001element002element004=============集合运算=============sets1中添加元素element001：1sets1中添加元素element002：1sets1中添加元素element003：1sets1中添加元素element002：1sets1中添加元素element003：1sets1中添加元素element004：1查看sets1集合中的所有元素:[element001,element002,element003]查看sets2集合中的所有元素:[element002,element003,element004]sets1和sets2交集：[element002,element003]sets1和sets2并集：[element001,element002,element003,element004]sets1和sets2差集：[element001]5）SortedSet功能（有序集合）privatevoidSortedSetOperate(){System.out.println(""======================zset=========================="");//清空数据System.out.println(jedis.flushDB());System.out.println(""=============增============="");System.out.println(""zset中添加元素element001：""+shardedJedis.zadd(""zset"",7.0,""element001""));System.out.println(""zset中添加元素element002：""+shardedJedis.zadd(""zset"",8.0,""element002""));System.out.println(""zset中添加元素element003：""+shardedJedis.zadd(""zset"",2.0,""element003""));System.out.println(""zset中添加元素element004：""+shardedJedis.zadd(""zset"",3.0,""element004""));System.out.println(""zset集合中的所有元素：""+shardedJedis.zrange(""zset"",0,-1));//按照权重值排序System.out.println();System.out.println(""=============删============="");System.out.println(""zset中删除元素element002：""+shardedJedis.zrem(""zset"",""element002""));System.out.println(""zset集合中的所有元素：""+shardedJedis.zrange(""zset"",0,-1));System.out.println();System.out.println(""=============改============="");System.out.println();System.out.println(""=============查============="");System.out.println(""统计zset集合中的元素中个数：""+shardedJedis.zcard(""zset""));System.out.println(""统计zset集合中权重某个范围内（1.0——5.0），元素的个数：""+shardedJedis.zcount(""zset"",1.0,5.0));System.out.println(""查看zset集合中element004的权重：""+shardedJedis.zscore(""zset"",""element004""));System.out.println(""查看下标1到2范围内的元素值：""+shardedJedis.zrange(""zset"",1,2));}运行结果:======================zset==========================OK=============增=============zset中添加元素element001：1zset中添加元素element002：1zset中添加元素element003：1zset中添加元素element004：1zset集合中的所有元素：[element003,element004,element001,element002]=============删=============zset中删除元素element002：1zset集合中的所有元素：[element003,element004,element001]=============改==========================查=============统计zset集合中的元素中个数：3统计zset集合中权重某个范围内（1.0——5.0），元素的个数：2查看zset集合中element004的权重：3.0查看下标1到2范围内的元素值：[element004,element001]6）Hash功能privatevoidHashOperate(){System.out.println(""======================hash=========================="");//清空数据System.out.println(jedis.flushDB());System.out.println(""=============增============="");System.out.println(""hashs中添加key001和value001键值对：""+shardedJedis.hset(""hashs"",""key001"",""value001""));System.out.println(""hashs中添加key002和value002键值对：""+shardedJedis.hset(""hashs"",""key002"",""value002""));System.out.println(""hashs中添加key003和value003键值对：""+shardedJedis.hset(""hashs"",""key003"",""value003""));System.out.println(""新增key004和4的整型键值对：""+shardedJedis.hincrBy(""hashs"",""key004"",4l));System.out.println(""hashs中的所有值：""+shardedJedis.hvals(""hashs""));System.out.println();System.out.println(""=============删============="");System.out.println(""hashs中删除key002键值对：""+shardedJedis.hdel(""hashs"",""key002""));System.out.println(""hashs中的所有值：""+shardedJedis.hvals(""hashs""));System.out.println();System.out.println(""=============改============="");System.out.println(""key004整型键值的值增加100：""+shardedJedis.hincrBy(""hashs"",""key004"",100l));System.out.println(""hashs中的所有值：""+shardedJedis.hvals(""hashs""));System.out.println();System.out.println(""=============查============="");System.out.println(""判断key003是否存在：""+shardedJedis.hexists(""hashs"",""key003""));System.out.println(""获取key004对应的值：""+shardedJedis.hget(""hashs"",""key004""));System.out.println(""批量获取key001和key003对应的值：""+shardedJedis.hmget(""hashs"",""key001"",""key003""));System.out.println(""获取hashs中所有的key：""+shardedJedis.hkeys(""hashs""));System.out.println(""获取hashs中所有的value：""+shardedJedis.hvals(""hashs""));System.out.println();}运行结果:======================hash==========================OK=============增=============hashs中添加key001和value001键值对：1hashs中添加key002和value002键值对：1hashs中添加key003和value003键值对：1新增key004和4的整型键值对：4hashs中的所有值：[value001,value002,value003,4]=============删=============hashs中删除key002键值对：1hashs中的所有值：[value001,value003,4]=============改=============key004整型键值的值增加100：104hashs中的所有值：[value001,value003,104]=============查=============判断key003是否存在：true获取key004对应的值：104批量获取key001和key003对应的值：[value001,value003]获取hashs中所有的key：[key004,key003,key001]获取hashs中所有的value：[value001,value003,104]三、常用命令1）连接操作命令quit：关闭连接（connection）auth：简单密码认证helpcmd：查看cmd帮助，例如：helpquit2）持久化save：将数据同步保存到磁盘bgsave：将数据异步保存到磁盘lastsave：返回上次成功将数据保存到磁盘的Unix时戳shundown：将数据同步保存到磁盘，然后关闭服务3）远程服务控制info：提供服务器的信息和统计monitor：实时转储收到的请求slaveof：改变复制策略设置config：在运行时配置Redis服务器4）对value操作的命令exists(key)：确认一个key是否存在del(key)：删除一个keytype(key)：返回值的类型keys(pattern)：返回满足给定pattern的所有keyrandomkey：随机返回key空间的一个keyrename(oldname,newname)：重命名keydbsize：返回当前数据库中key的数目expire：设定一个key的活动时间（s）ttl：获得一个key的活动时间select(index)：按索引查询move(key,dbindex)：移动当前数据库中的key到dbindex数据库flushdb：删除当前选择数据库中的所有keyflushall：删除所有数据库中的所有key5）Stringset(key,value)：给数据库中名称为key的string赋予值valueget(key)：返回数据库中名称为key的string的valuegetset(key,value)：给名称为key的string赋予上一次的valuemget(key1,key2,…,keyN)：返回库中多个string的valuesetnx(key,value)：添加string，名称为key，值为valuesetex(key,time,value)：向库中添加string，设定过期时间timemset(keyN,valueN)：批量设置多个string的值msetnx(keyN,valueN)：如果所有名称为keyi的string都不存在incr(key)：名称为key的string增1操作incrby(key,integer)：名称为key的string增加integerdecr(key)：名称为key的string减1操作decrby(key,integer)：名称为key的string减少integerappend(key,value)：名称为key的string的值附加valuesubstr(key,start,end)：返回名称为key的string的value的子串6）Listrpush(key,value)：在名称为key的list尾添加一个值为value的元素lpush(key,value)：在名称为key的list头添加一个值为value的元素llen(key)：返回名称为key的list的长度lrange(key,start,end)：返回名称为key的list中start至end之间的元素ltrim(key,start,end)：截取名称为key的listlindex(key,index)：返回名称为key的list中index位置的元素lset(key,index,value)：给名称为key的list中index位置的元素赋值lrem(key,count,value)：删除count个key的list中值为value的元素lpop(key)：返回并删除名称为key的list中的首元素rpop(key)：返回并删除名称为key的list中的尾元素blpop(key1,key2,…keyN,timeout)：lpop命令的block版本。brpop(key1,key2,…keyN,timeout)：rpop的block版本。rpoplpush(srckey,dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部7）Setsadd(key,member)：向名称为key的set中添加元素membersrem(key,member)：删除名称为key的set中的元素memberspop(key)：随机返回并删除名称为key的set中一个元素smove(srckey,dstkey,member)：移到集合元素scard(key)：返回名称为key的set的基数sismember(key,member)：member是否是名称为key的set的元素sinter(key1,key2,…keyN)：求交集sinterstore(dstkey,(keys))：求交集并将交集保存到dstkey的集合sunion(key1,(keys))：求并集sunionstore(dstkey,(keys))：求并集并将并集保存到dstkey的集合sdiff(key1,(keys))：求差集sdiffstore(dstkey,(keys))：求差集并将差集保存到dstkey的集合smembers(key)：返回名称为key的set的所有元素srandmember(key)：随机返回名称为key的set的一个元素8）Hashhset(key,field,value)：向名称为key的hash中添加元素fieldhget(key,field)：返回名称为key的hash中field对应的valuehmget(key,(fields))：返回名称为key的hash中fieldi对应的valuehmset(key,(fields))：向名称为key的hash中添加元素fieldhincrby(key,field,integer)：将名称为key的hash中field的value增加integerhexists(key,field)：名称为key的hash中是否存在键为field的域hdel(key,field)：删除名称为key的hash中键为field的域hlen(key)：返回名称为key的hash中元素个数hkeys(key)：返回名称为key的hash中所有键hvals(key)：返回名称为key的hash中所有键对应的valuehgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value",2016/3/25
87,win7系统下 Cygwin 安装使用,赵本,http://180.168.156.212:2262/wecenter/?/article/9205,Cygwin是一个在windows平台上运行的unix模拟环境，是cygnussolutions公司开发的自由软件（该公司开发了很多好东西，著名的还有eCos，不过现已被Redhat收购）。它对于学习unix/linux操作环境，或者从unix到windows的应用程序移植，或者进行某些特殊的开发工作，尤其是使用gnu工具集在windows上进行嵌入式系统开发，非常有用。随着嵌入式系统开发在国内日渐流行，越来越多的开发者对cygwin产生了兴趣。Cygwin是一个用于Windows的类UNIXshell环境。它由两个组件组成：一个UNIXAPI库，它模拟UNIX操作系统提供的许多特性；以及Bashshell的改写版本和许多UNIX实用程序，它们提供大家熟悉的UNIX命令行界面。前一个组件是一个Windows动态链接库(DLL)。后一个组件是一组基于CygwinDLL的程序，其中许多是用未经修改的UNIX源代码编译的。它们合在一起提供大家熟悉的UNIX环境。官网下载地址： 安装Cygwin一、下载完成后，安装Cygwin_setup.exe，直接点击下一步出现安装模式，如下图所示：三种安装模式:1.InstallfromInternet，这种模式直接从Internet安装，适合网速较快的情况；2.downloadWithoutInstalling，这种模式只从网上下载Cygwin的组件包，但不安装；3.InstallfromLocalDirectory，这种模式与上面第二种模式对应，当你的Cygwin组件包已经下载到本地，则可以使用此模式从本地安装Cygwin。二、从上述三种模式中选择适合的安装模式，这里我们选择第一种安装模式，Cygwin组件下载完毕后会直接保存到本地，以便能够再次安装。选中后，点击“下一步”，如图所示：三、这一步选择Cygwin的安装目录，默认安装位置是c:cygwin，你自己也可以选择安装目录，然后点击“下一步”，如图所示：四、安装过程中从网上下载的Cygwin组件包的保存位置，是你上一步操作选择的目录，点击“下一步”，如图所示：1.DirectConnection指定Internet连接;2.如果你有代理服务器，选择“UseInternetExplorerProxySettings”;3.通过浏览器选项获得服务器名，选择使用代理，输入代理服务器的主机名和端口号。五、通过DirectConnection连接，选择“下一步”，如图所示：1.Cygwin默认情况下提供了多个下载镜像站点，因为这些站点是义务的镜像，单独一个下载点可能有风险，在其中选择一个下载站点即可（通常情况下它们是可用的，但有时可能因各种原因不可用）。通常情况下，建议选择离你比较近的那个站点。2.指定一个站点，例如输入 用户连接，点击“下一步”，如图所示:1.在此页面，你将选择要安装的包。默认情况下，Cygwin基本包将不会安装GCC，因此，你必须修改默认设置2.将鼠标移动Devel边的加号（+）上，然后点击它展开Devel类;后面紧跟三个参数分别为：Default（默认），Install（安装，全部），Uninstall（卸载，全部）。3.Devel的分支下有很多组件，其中我们必须安装的组件包含：Binutils，gcc，gcc-mingw，gdb，如图所示：binutils组件gcc组件gcc-mingw组件gdb组件选择完成之后，点击“下一步”，进入安装过程，此时等待安装结束，出现如图所示，点击“完成”。七、测试安装是否成功，如图：,2016/3/25
88,20 个 CSS 高级技巧汇总,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9204,"1.黑白图像这段代码会让你的彩色照片显示为黑白照片，是不是很酷？img.desaturate{filter:grayscale(100%);-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);}2.使用:not()在菜单上应用/取消应用边框先给每一个菜单项添加边框/*addborder*/.navli{border-right:1pxsolid#666;}……然后再除去最后一个元素……//removeborder/.navli:last-child{border-right:none;}……可以直接使用:not()伪类来应用元素：.navli:not(:last-child){border-right:1pxsolid#666;}这样代码就干净，易读，易于理解了。当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：..navli:first-child~li{border-left:1pxsolid#666;}3.页面顶部阴影下面这个简单的CSS3代码片段可以给网页加上漂亮的顶部阴影效果：body:before{content:"""";position:fixed;top:-10px;left:0;width:100%;height:10px;-webkit-box-shadow:0px0px10pxrgba(0,0,0,.8);-moz-box-shadow:0px0px10pxrgba(0,0,0,.8);box-shadow:0px0px10pxrgba(0,0,0,.8);z-index:100;}4.给body添加行高你不需要分别添加line-height到每个p,h标记等。只要添加到body即可：body{line-height:1;}这样文本元素就可以很容易地从body继承。5.所有一切都垂直居中要将所有元素垂直居中，太简单了：html,body{height:100%;margin:0;}body{-webkit-align-items:center;-ms-flex-align:center;align-items:center;display:-webkit-flex;display:flex;}看，是不是很简单。注意：在IE11中要小心flexbox。6.逗号分隔的列表让HTML列表项看上去像一个真正的，用逗号分隔的列表：ul>li:not(:last-child)::after{content:"","";}对最后一个列表项使用:not()伪类。7.使用负的nth-child选择项目在CSS中使用负的nth-child选择项目1到项目n。li{display:none;}/*selectitems1through3anddisplaythem*/li:nth-child(-n+3){display:block;}8.对图标使用SVG我们没有理由不对图标使用SVG：.logo{background:url(""logo.svg"");}SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。9.优化显示文本有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：html{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;}注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。10.对纯CSS滑块使用max-height使用max-height和溢出隐藏来实现只有CSS的滑块：.sliderul{max-height:0;overlow:hidden;}.slider:hoverul{max-height:1000px;transition:.3sease;}11.继承box-sizing让box-sizing继承html：html{box-sizing:border-box;}*,*:before,*:after{box-sizing:inherit;}这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。12.表格单元格等宽表格工作起来很麻烦，所以务必尽量使用table-layout:fixed来保持单元格的等宽：.calendar{table-layout:fixed;}13.用Flexbox摆脱外边距的各种hack当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：.list{display:flex;justify-content:space-between;}.list.person{flex-basis:23%;}现在，列表分隔符就会在均匀间隔的位置出现。14.使用属性选择器用于空链接当a元素没有文本值，但href属性有链接的时候显示链接：a[href^=""http""]:empty::before{content:attr(href);}相当方便。15.检测鼠标双击HTML：<divclass=""test3""><span><inputtype=""text""value=""""readonly=""true""/><ahref="" plexBlock{width:calc(100%-50%/3);padding:5pxcalc(3%-2px);margin-left:calc(10%+10px);}18.文本渐变文本渐变效果很流行，使用CSS3能够很简单就实现：h2[data-text]{position:relative;}h2[data-text]::after{content:attr(data-text);z-index:10;color:#e3e3e3;position:absolute;top:0;left:0;-webkit-mask-image:-webkit-gradient(linear,lefttop,leftbottom,from(rgba(0,0,0,0)),color-stop(50%,rgba(0,0,0,1)),to(rgba(0,0,0,0)));}19.禁用鼠标事件CSS3新增的pointer-events让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。.disabled{pointer-events:none;}20.模糊文本简单但很漂亮的文本模糊效果，简单又好看！.blur{color:transparent;text-shadow:005pxrgba(0,0,0,0.5);}",2016/3/16
89,初学struts，遇到struts.xml无法加载的问题以及解决,张婷婷,http://180.168.156.212:2262/wecenter/?/article/9211,刚学struts，运行的时候老是报这个错误：struts.xml无法加载。然后查看在Myeclipse的Console给的报错，发现下面几个错误，通过在网上搜索发现了这些错误的解决方法，供新手借鉴。（1）严重:DispatcherinitializationfailedUnabletoloadconfiguration.-file:/D:/javaEnvironment/apache-tomcat-7.0.67/webapps/strutsTest2/WEB-INF/classes/struts.xml:3:8问题缘由以及解决方法：关掉你的myeclipse，然后打开任务管理器--->进程，结束全部javaw.exe。javaw.exe有好几个，一个是myeclipse的，还有一个是java虚拟机的，最后一个就是tomcat进程的，当你程序运行出现线程时也会出现几个。应关掉属于tomact那个javaw.exe。让你关了myeclipse就是让不属于tomcat的进程结束，myeclipse关闭后还存在的就是tomcat的进程了。参考： ,2016/3/15
90,Windows系统查看端口被哪个进程占用,张婷婷,http://180.168.156.212:2262/wecenter/?/article/9203,"启动Tomcat时出现端口占用错误：严重:StandardServer.await:create[localhost:8005]:java.net.BindException:Addressalreadyinuse:J错误描述：严重:StandardServer.await:create[localhost:8005]:java.net.BindException:Addressalreadyinuse:JVM_Bind解决方法：找到占用8005端口的进程，然后杀掉它。一、在Windows下查看端口的占用情况在命令行窗口执行：netstat-aon|findstr""8005""TCP127.0.0.1:80050.0.0.0:0LISTENING17208005端口被进程号为1720的进程占用.二、查看指定进程号对应哪个进程：tasklist|findstr""1720""javaw.exe1720Console1264,304K可见，是javaw.exe占用了你的端口，杀掉即可。命令：taskkill-F-PID1720如果第二步查不到，可以在任务管理器中，进程---查看---选择列---pid（进程位标识符）打个勾就可以了看哪个进程是1720。按照以上的方法不行的话，找到Tomcat安装目录下conf/server.xml把8005改成不被占用的8006就可以了。",2016/3/14
91,国家档案局官网上有最全的档案政策法规，特别是行业标准pdf/doc文件,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9202, 可以下载标准全文。,2016/3/9
92,透视UAC级别设置 享受清净安全Win7系统,王四云,http://180.168.156.212:2262/wecenter/?/article/9201, /377/30900877.shtml,2016/3/8
93,一款简洁高效的在线原型图设计工具——摩客,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9200, /mockplus-windows/,2016/2/29
94,国家档案局办公室关于印发《档案信息系统安全保护基本要求》的通知,李刚,http://180.168.156.212:2262/wecenter/?/article/9199, ,2016/2/24
95,上海市2016年度全国计算机技术与软件专业技术资格（水平）考试考务工作安排,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/9198,请至官网查看 ,2016/2/24
96,jQuery 1.12.1 和 2.2.1 发布,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9196,jQuery今天发布了两个新版本，分别是1.12.1和2.2.1。下载地址： 相关链接jQuery的详细介绍： /download/,2016/2/23
97,档案规范知识，在论坛上综合技术下面有档案知识专区栏目,黄贇,http://180.168.156.212:2262/wecenter/?/article/9195,大家有兴趣学习的可以去多看看。,2016/2/3
98,国家档案局最新发布了9项档案业务标准征求意见稿,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9194,其中有三项数字化加工方面的标准应该比较有参考价值：《档案抢救与修复相关规范第1部分：纸质档案破损等级的划分》《档案抢救与修复相关规范第2部分：纸质档案保存状况的调查方法》《档案抢救与修复相关规范第3部分：档案抢救修复技术质量要求》档案业务标准（征求意见稿）.zip,2016/2/2
99,新人报道，请多多关照,孙艳,http://180.168.156.212:2262/wecenter/?/article/9193,大家好！我是江北生产部的孙艳，希望能在这里认识到更多的新同事和新朋友，学习到更多知识，谢谢！,2016/2/2
100,数字化加工软件和工具相关,王会玲,http://180.168.156.212:2262/wecenter/?/article/9192,数字化加工软件和工具相关都在360网盘中，会定期更新，相关技术和实施人员需要可以咨询我这边。有好的建议和成熟的思路也欢迎大家踊跃提出，我们共同进步！,2016/2/2
101,本想进来学习下，学习到了什么叫空城计。。。。,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9191,如题,2016/2/1
102,笑脸样式音乐播放器，喜迎新年！开心一下~,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9197,它具有播放器的大部分功能，并以HTML5和JavaScript实现。这些HTML5播放器有着非常漂亮的外观，很多你都无需自己重新定义样式，引用相关JS即可，源代码大家都可以下载。HTML5笑脸样式的音乐播放器一款非常有爱的HTML5音乐播放器，它的外观酷似一张笑脸，其实笑脸的样式也是通过对播放器的各项按钮进行布局而产生的。同时这款播放器的功能也是比较完整的，播放、暂停、音量控制、播放进度等。今天要来分享一款非常有爱的HTML5音乐播放器，它的外观酷似一张笑脸，其实笑脸的样式也是通过对播放器的各项按钮进行布局而产生的。同时这款播放器的功能也是比较完整的，播放、暂停、音量控制、播放进度等。演示地址： ,2016/1/29
103,Colorfavs：优秀在线配色工具,朱鹏,http://180.168.156.212:2262/wecenter/?/article/9190,Colorfavs：主要用于上传图像并获取图像颜色，功能和Pictaculous、Colorhunter配色工具类似，它的体验还是不错的，比如界面设计简洁，可以浏览优秀颜色搭配、收藏配色方案功能、拖拽上传图像抓取颜色配色等等，都是不错的功能。上传图像获取配色方案Colorfavs工具界面简洁，不需要教学就知道怎么用啦，如果要上传图像，直接拖动到窗口Upload区域不能上传，很方便！众多漂亮配色方案汇聚众多的漂亮配色方案，看到喜欢的可以点击「AddtoCollection」收藏它。除了以上，还有很多细节的小功能；大家可以去官网看看。官方网站： /,2016/1/25
104,我们要关注国家新标准出台，因为与我们有关,朱鹏,http://180.168.156.212:2262/wecenter/?/article/9189,传达信息：昨日上午就国家最新标准去国家档案局，有幸与档案馆室司机关指导处丁处长座谈，他说，1.近期出台了DA/T22-2015《归档文件整理细则》、财政部、国家档案局令79号《会计档案管理办法》。2.《数字档案室建设指南》是数字化工作标准必须执行的。3.由此考虑我们加工也要向规范靠拢，例如，页码、题名、档号编制...........是否要纠正呢？仅参考。郭春荣,2016/1/20
105,喜讯！-江南区,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9188,江南区再传喜讯！继中标无锡市档案局项目（1507万人民币）之后，又拿下一个大项目，南京社保中心退休人员档案（836万人民币）！撒花、欢呼！,2016/1/18
106,数字化第一帖？,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9187,大家好，我是金档江南区朱鹏，联系号码18012977456（微信号、QQ号、邮箱.163.com）都可以找到我。江南区具有一批敢闯、敢拼的年轻小伙子、小姑娘们，大家热爱工作，具有相对丰富的数字化加工及管理经验，欢迎大家交流、学习，相互进步。另：美丽、富饶的江南区欢迎大家前来，共创前程、事业！,2016/1/18
107,桌面版 Android 系统来了,张二伟,http://180.168.156.212:2262/wecenter/?/article/9185,本文转载自: p?articleId=7443240&display=all一直使用Windows系统，大家是不是都已经面对它的桌面有点厌倦了呢？最近几位谷歌的工程师打造的RemixOS可能会有耳目一新的感觉。RemixOSforPC基于Android-x86项目，由安卓5.1Lollipop深度定制而来，不但兼容所有安卓应用和游戏，还针对桌面应用环境增加了各种使用功能。本次放出的是预览版的内容，版本号为2016011201，体积约692.15MB，主要面向开发者和尝鲜者。需要注意的是，安装需要通过U盘，而且必须支持USB3.0接口，而且写入速度不低于20MB/s，容量不低于8GB。RemixOS官方下载地址。安装包里自带了U盘启动盘制作工具RemixOSUSBTool，根据向导制作即可。,2016/1/18
108,学习新东西的唯一方法,王国栋,http://180.168.156.212:2262/wecenter/?/article/9184,作者:译/Jodoo来源:简书英文原文：TheOnlyTechniqueToLearnSomethingNew有人曾从我工作的一家公司盗取了9千万美元。我不太懂得如何观人识人。这家公司最终关门了。有一些事情我就是学不会。我很容易相信一个人。因此，无论我如何尝试，判断一个人对我来说，简直太难了。所以，我寻找擅长做这件事的人，我让他们给我提供帮助。Learn不要强迫自己学习那些你不想或者不属于你天赋所及的事情。天赋的作用到底有多大？非常小。但你需要从它开始起步。天赋是技能的种子。你如何得知你在某个方面具有天赋？当你10岁时，如果你热爱它，如果你梦到过它，如果你喜欢阅读这方面的内容。请继续阅读以下内容，你会发现你的天赋到底在哪里。当我说：每一个人在许多方面都具有天赋。请相信我。在过去的20多年里，我一直在试着学习一些东西，而且我希望把它们学好。写作、编程、商业技巧（领导力，销售，协商和决策制定等等），戏剧，游戏。所以，我专门研究出了一项由10个步骤组成的学习方法。热爱你学习的东西如果你不能从“热爱”出发，那么那些热爱它们的人将会战胜那些仅仅“喜欢”或者“讨厌”它们的人。这是一条放之四海而皆准的规则。第一个从西伯利亚出发直至阿拉斯加穿越北极的人，即使零下60多度，他依旧热爱他所做的事情。其他人可能宁愿呆在东非的大草原上。在我第一次写下“HelloWorld”计算机程序时，我就梦到了计算机。我凌晨4点起床，返回“计算机实验室”，写出了一个更复杂点儿的程序。当我第一天开始写作时，我写了一整天。我无法停下来。而且，在那时，我只想和形形色色的写作者们谈话和交流。当我只有10岁时，我写了一个有关我五年级同学的专栏。我每天都阅读JudyBlume的书。我几乎什么都读，我太喜欢写作了。我的绝大多数朋友都觉得我很无趣，所以，我很快陷入了一种孤独境地。当然，写作的时候例外。阅读与之相关内容BobbyFischer原本不擅长国际象棋。他有这方面的天赋，但很多人不这么认为。因此，在他大约12-13岁时，他消失了一年时间。当他在13岁时，他再次出现，而且突然之间，他成了美国最好的国际象棋手，赢得了美国象棋冠军赛。他成为当时世界上最年轻的国际象棋大师。他如何做到的呢？其实，在这一整年里，他几乎没有真正地下过一盘象棋。相反，他只做了两件事：a)他把上个世纪所有的象棋赛棋局研究了一遍。当他返回时，他对所有的开局模式都非常熟悉，而且他把这些开局模式做了必要的改进。没人知道怎样才能战胜这些改进模式。事实上，在1972年举办的世界冠军赛的决赛中，他和Spassky对垒，Fischer就是凭借其1800年代的武器装备，最终赢得了世界冠军。Spassky必须赢得比赛以保持其冠军称号。Fischer必须获胜比赛才能摘得冠军头衔。Spassky采用了一个非常现代的极具进攻态势的开局（“TheSicilian”），但是在随后的13步之后，所有的评论员开始窃窃私语。Fischer故意将开局做成了一种老式风格的“TheScotchGame”模式。自此，Spassky始终没能再有胜出的机会。b)Fischer通过阅读俄罗斯象棋杂志学习和了解了有关俄罗斯棋手的信息。那个时候，世界象棋排名前20都是俄罗斯人。美国人根本没有机会。正当所有美国棋手研究各种俄罗斯人已经熟知的各类开局风格时，Fischer却在研究俄罗斯人的具体棋法。结果是，当Fischer赢得全美冠军时，他成为了第一位全胜棋手，甚至没有一盘和局。研究历史，研究既往最佳棋手，是成为最佳棋手的关键。即使开始时你只是有点儿天赋而已。尝试，但不要太艰难如果你想成为一名作家，一位商界精英，或者一名程序员，你必须写很多东西，创办很多企业，编写很多程序。失败或错误时有发生。这就是为什么在开始的时候，数量比质量更重要。我们的学习曲线不是构建在你业已取得的成就之上，而是构筑在数量之上。如果你看到一个东西1000次，你将会比那些只看10次的人更有见识。不要忘记这条重要规则：快乐的秘密不在于“成就卓越”，而在于“不断成长”。如果你仅仅“尝试”你能力范围内的事情，成长将会停止，对此，你不会感到快乐和幸福。找到一位老师（外加一个10倍速规则）如果我尝试自学西班牙语，我会迷失方向。但当我走出门，结识一些阿根廷人，我会学到更多。在国际象棋，写作，编程，商业等方面，我总能找到比我更加出色的人，为此，我会每周安排一定时间向他们请教一些问题，让他们给我布置一些作业，帮助我发现错误并且告知我错误的具体细节。对于任何你热爱的事情，找到一位老师，就能帮助你以10倍速的效率前进。事实上，我放在这个列表中的每一件事情，都可以让你的学习以10倍的速度前进。因此，如果你在学习中应用了这份列表中每一项方法的话，你的学习效率将是其他人的10的10次方。这就是让你在某个方面取得杰出成就的基本路径。学习历史，学习现在如果你想要成为一名优秀的程序员，不要仅仅满足于编写一个应用程序，你应该学习机器语言。学习1和0，学习计算机的历史，学习如何设计一个操作系统，学习各种编程语言，Fortran，Cobol，Pascal，Lisp，C，C++直至现代语言，比如，Python等。如果你想要提高自己的写作技能，去读自1800年起的优秀的文章。阅读海明威和弗吉尼亚·伍尔夫，甚至“垮掉一代”（BeatGeneration）的文学著作，阅读那些经得起时间考验的作品。它们都历经了时间的考验。经过与其他几百万本书的比较，它们就是这个世界上最好的文学作品。然后，你需要研习当代对这些书籍的评论和批评。这样做的重要性就如同阅读它们一样重要。如果你希望学习商业，阅读洛克·菲勒和卡内基的传记，了解阿姆斯特丹成立的第一家交易所，90年代的垃圾债券泡沫，金融危机，每一次经济衰退。每一次经济衰退都是再一次经济繁荣的发源地。阅读彼得·蒂尔撰写的“从零到一”这本书。在CNBC电视网上观看“TheProfit”专栏节目。阅读苹果公司创始人史蒂夫·乔布斯的传记。阅读《权力的终结》了解柯达如何衰落。不要阅读那些自助型商业书籍。它们没有什么价值。你己经进入一个广阔的领域-创新领域-现代社会创建的一个领域。不要读去年刚刚出版的平庸作品。再进一步，你可以阅读一些有关通过创新如何将世界变成今天这个形态的著作。阅读亨利·福特如何从创办三家汽车公司起家，最终怎样找到正确发展之路，而且你还需要知道为什么“三”对于亨利·福特而言，是一个重要的数字。阅读了解为什么雷·克拉克的技巧成就了世界上最大的特许加盟连锁餐饮企业-麦当劳。阅读可口可乐如何通过不生产任何东西，却造就了世界上最大的饮料公司。把你从这些阅读中收获的东西记录下来。先易后难TonyRobbins曾经向我提及他的第一次教学工作经历，当时，他对这份工作甚至有点害怕。他必须教会一组海军陆战队员提高他们的射击准确度。“我这一辈子都没打过枪，”他说。他之前在一些专业人士那里学了一些东西，然而不久之后，他就发现了一个技巧，结果使得受训陆战队员的射击成绩达到了前所未有的水平。他只是把射击目标拉近了。他将靶子放在距离仅有5英尺的地方。他们全都命中了靶心。然后，他再将其后移一点，直至标准距离。他们全都击中靶心。理查德·布兰森在他开办航空公司之前，从创办一本杂志起步。比尔盖茨在整个团队都从事Windows开发之前，他自己编写第一个Basic语言和编译器。斯蒂芬妮·迈耶（是的，我包括了她）撰写了《暮光之城》，在此之前，她写过一本名叫《五十级灰度》的书。在早期，海明威从没有梦想成为一位小说家。因此，他只是写了一些小故事。程序员在着手设计第一个搜索引擎之前，编写“HelloWorld”程序。许多国际象棋大师在你开始学习象棋时，会推荐你先学习象棋残局（只有几枚棋子）。这样做会给予你信心，会给予你微妙的提示，会给予你有关成长和提高的强烈的感受。回顾你学过的东西有一天，我把我几乎所有的东西都扔了。所有的东西。我扔了我所有的书（捐献了）。我扔了我所有的衣服。我扔了那些旧电脑。我扔掉了我从来不用的盘子。我扔掉了我认为我不会有机会穿着的衬衣。我扔了我所有的家具，纸张及其它东西。我想来个大扫除。我就这么做了。我发现了一本我写于1991年的小说。24年之前。真是可怕呀。24年来，我第一次重读了这本小说。我知道了当时出错的地方（人物不相关。故事刻画太明显。故事的高潮都发生在同一个地点）。有人告诉我一个关于AmySchumer（我最喜爱的喜剧演员之一）的故事。她把自己所有的表演都录了下来。然后她返回家中，仔细研究她自己的表演，一秒接一秒。“我当时应该在这个动作上停留四分之一秒。”她希望成为一名最好的喜剧演员。她研究了自己的每一次表演。我下棋的时候，如果输掉一局，我会把这个棋局保存在计算机中。事后，我会查看我下过的每一步棋和计算机提示。我会思考在我下了步臭棋时，我当时都在想些什么等诸如此类的事情。我最近投资的一个项目失败了。对我来说，我的感受糟糕极了。但不管怎样，我必须要研究出我到底错在了那里。我在什么地方出的错误。在各个层面上，我都将其进行必要的反思，并且在最后把它们记录下来。如果你无法沉迷于自己的错误，这可能表明你对这个领域还不够热爱。你不应该问自己这样的问题“我擅长做什么？”相反，你应该问自己：“我什么地方做得不对，我应该如何改进？”在你持续不断地询问自己一个更好的问题过程中，你将会变得比那些只问自己糟糕问题的人更为优秀。例子：我讨厌看到自己在电视里的表现。所以我无法在表演方面做得更好。你就是你最要好的5个朋友的平均数观察一下每一个文化，艺术以及商业场景。很少有人能够作为个体表现突出，他们往往作为一个群体而表现突出。垮掉一代（文学）：杰克·克鲁亚克，艾伦·金斯堡，威廉·博罗斯以及其他一些人。技术与编程：史蒂夫·乔布斯，比尔·盖茨，泰德莱·昂西斯，保罗·艾伦，斯蒂夫·沃兹尼亚克等其它佳酿俱乐部成员。50年代艺坛：贾斯珀·约翰斯，德·库宁，Pollack等所有当时身处纽约芝麻街的那些人。YouTube，LinkedIn，Tesla，Palantir等所有这些被称为“PayPal帮”的成员。所有这些人都不是独自存在的。人类是一种以部落为单位的群居动物。我们需要和群体一起工作才能获得更大的提高。找到这些最好的群体，尽量花费大量的时间和他们在一起，你就会变得和他们一样优秀。你们每一个人彼此相互挑战，相互竞争，喜爱和欣赏彼此的工作成果，甚至彼此羡慕，最终，你们都将相互超越。多多益善坚持不懈与偶尔为之相比，坚持不懈更为重要。我过去有一位朋友，一直想在绘画上有所提高。但是，她认为她应该去巴黎，因为那里的气氛更适合。她的巴黎之旅一直没能成行。她目前坐在一个小隔间里，伴着荧光灯填写着各类报表，还有就是一些无聊的文书工作。写作每一天，社交每一天，娱乐每一天，健康生活每一天。请按照你所做事情的数量来衡量你的生活。找到你自己的魔鬼计划学生最终实现超越成为一名大师。我曾为之工作的第一位对冲基金经理现在非常恨我。我开创自己的基金时，他的基金正要被淘汰出局。我的魔鬼计划最终来看比他的更有效。然而，自此之后，我会发现自己的声音。而且，当你用这种声音说话，世界就会呈现出一种新气象。你的老师和朋友们可能并不希望听到这种声音。但是，如果你能够继续让喜欢和尊重你的人围绕在你周围，那么，他们会继续鼓励你发出那样的声音。有句话是这样说的，“therearenonewideas.”Butthereare。如果你能融合已有的思想或想法，你就是那只美丽的蝴蝶。,2016/1/15
109,李明华在全国档案工作暨表彰先进会议上的讲话,容琼,http://180.168.156.212:2262/wecenter/?/article/9183,对十二五档案工作进行了回顾和总结，对十三五档案工作进行了规划和部署。李明华在全国档案工作暨表彰先进会议上的讲话.mht,2016/1/14
110,拟真 vs. 扁平，我选择Material Design,戎海龙,http://180.168.156.212:2262/wecenter/?/article/9186,设计语言，期望通过模拟现实世界的物体，给用户身临其境的感觉。自metro和ios7开始的扁平化设计语言则相反，它着意去掉冗余的装饰效果（比如透视、纹理、渐变等等能做出3D效果的元素），让信息本身重新作为核心被凸显出来。从下面的对比图中，我们可以体会到两种设计语言的差异>MaterialDesign如果说拟真代表设计语言的一个极端，而扁平代表设计语言的另一个极端，那么则居于两者之间更偏右的位置：在MaterialDesign中，屏幕里看上去平整的一个App界面，事实上不同控件之间都拥有着层级关系。不同控件之间的层级关系会使用阴影作为表示，而阴影的深浅，代表的正是这个控件在Z轴的高度：>,2016/1/13
111,ionic 1.2.4 发布，移动应用框架,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9182,下载： /driftyco/ionic/releases,2016/1/13
112,国家食药监总局令20号《食用农产品市场销售质量安全监督管理办法》,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9181,追溯、检测、三品一标、信用体系等等基本都在上面了，请追溯事业群的各位同仁仔细研读。国家食药监总局令20号《食用农产品市场销售质量安全监督管理办法》.mht,2016/1/12
113,Tomcat、TongWeb5.0、TongWeb6.0部署solr,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9180,"将solr,solr-4.7.2复制到某一路径下，比如F盘根目录。1、tomcat中进行配置，配置如下：<ContextdocBase=""F:/solr""reloadable=""true""><Environmentname=""solr/home""type=""java.lang.String""value=""F:/solr-4.7.2/example/solr""override=""true""/></Context>将tomcat启动，启动solr服务器，就可以进行索引创建及查询了。2、东方通TongWeb5.0中进行配置。配置如下：a、东方通安装目录下**\TongWeb5.0\config\twns.xml的<deployments></deployments>标签中间添加<web-appcontext-root=""solr""name=""solr""source-path=""F:\solr""/>b、solr主目录配置：F:\solr\WEB-INF\web.xml中加入<env-entry><env-entry-name>solr/home</env-entry-name><env-entry-value>F:\solr-4.7.2\example\solr</env-entry-value><env-entry-type>java.lang.String</env-entry-type></env-entry>3、东方通TongWeb6.0中进行配置，配置如下：a、把solr1\solr-4.7.2\dist\solr-4.7.2.war包复制到TongWeb6.0\autodeploy目录下b、在TongWeb6.0\bin\tongweb.xml文件里添加：<web-appname=""solr-4.7.2""original-location=""D:\TongWeb6.0\autodeploy\solr-4.7.2.war""location=""${tongweb.app}\solr-4.7.2""context-root=""/solr-4.7.2""vs-names=""server""is-directory=""false""enabled=""true""description=""autodeploy---solr-4.7.2.war""deploy-order=""100""object-type=""user""jsp-compile=""false""dtd-validate=""false""is-autodeploy=""true""version=""""retire-state=""none""retire-strategy=""nature""retire-timeout=""0""version-serial-number=""1""/>指定war位置和系统访问路径。c、将solr1\solr-4.7.2\example\目录下的solr文件夹复制到TongWeb6.0\bin下d、点击TongWeb6.0\bin\startserver.bat运行TongWeb，在命令框中会出现缺少class的错误。这时候操作下一步。e、将solr1\solr-4.7.2\dist文件下的有关solr的jar包复制到TongWeb6.0\lib目录",2016/1/11
114,MyEclipse10.1破解工具及方法图解,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/9179,MyEclipse10.1破解工具下载 plusgin目录Tools---saveProperties再次点击Active按钮将会生成新的ACTIVATION_KEY。6、打开MyEclipse，MyEclipse->SubscriptionInformation，再次把上面生成的LICENSEE复制到Subscripter中，LICENSE_KEY复制到Subscriptioncode中。点击ActivateNow按钮，选择Ialreadyhaveanactivationcode。点Next，把破解界面的ACTIVATION_KEY复制到弹出的窗口中7、点next，破解成功,2016/1/11
115,jQuery如何阻止事件冒泡,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9178,"jQuery如何阻止事件冒泡:事件冒泡现象有时候能够起到很大的作用，有时候也会干扰操作。阻止事件冒泡可以有两种方式，列举如下:解决方案一:$(""#thediv"").mousedown(function(event){event.stopPropagation();//其他代码});解决方案二:$(""#thediv"").mousedown(function(event){returnfalse;//其他代码});原文地址是: /jquery/",2016/1/8
116,关于响应式布局,张二伟,http://180.168.156.212:2262/wecenter/?/article/9177,来源:Heyuchan先梳理下网页设计中整体页面排版布局，常见的主要有如下几种类型：布局类型布局实现采用何种方式实现布局设计，也有不同的方式，这里基于页面的实现单位而言，分为四种类型：固定布局、可切换的固定布局、弹性布局、混合布局。固定布局：以像素作为页面的基本单位，不管设备屏幕及浏览器宽度，只设计一套尺寸；可切换的固定布局：同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过设别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局；弹性布局：以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；混合布局：同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；只是混合像素、和百分比两种单位作为页面单位。可切换的固定布局、弹性布局、混合布局都是目前可被采用的响应式布局方式：其中可切换的固定布局的实现成本最低，但拓展性比较差；而弹性布局与混合布局效果具响应性，都是比较理想的响应式布局实现方式。只是对于不同类型的页面排版布局实现响应式设计，需要采用不用的实现方式。通栏、等分结构的适合采用弹性布局方式、而对于非等分的多栏结构往往需要采用混合布局的实现方式。布局响应对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，有两种方式：桌面优先（从桌面端开始向下设计）；移动优先（从移动端向上设计）；无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点），我们通过JS获取设备的屏幕宽度，来改变网页的布局，这一过程我们可以称之为布局响应屏幕。常见的主要有如下几种方式：布局不变，即页面中整体模块布局不发生变化，主要有：模块中内容：挤压－拉伸；模块中内容：换行－平铺；模块中内容：删减－增加；布局改变，即页面中的整体模块布局发生变化，主要有：模块位置变换；模块展示方式改变：隐藏－展开；模块数量改变：删减－增加；很多时候，单一方式的布局响应无法满足理想效果，需要结合多种组合方式，但原则上尽可能时保持简单轻巧，而且同一断点内（发生布局改变的临界点称之为断点）保持统一逻辑。否则页面实现得太过复杂，也会影响整体体验和页面性能。,2016/1/5
117,云平台,陈蒙,http://180.168.156.212:2262/wecenter/?/article/9176,不久前去参加了亚马逊的年度技术峰会，一天赶场下来感觉就一句废话：牛逼到你无法想象！峰会涉及的主题很多，我主要参加的是关于云部署的内容，对于一些很火爆的讲座我也去凑了凑热闹，但毕竟是讲座，只能知道云服务能干什么，但怎么干还得实践。因为公司的产品要部署的云服务上，自己摸索无果后在同事的帮助下才对云部署有了一些大致概念。关于部署，亚马逊能提供从网络搭建到应用安装的一套解决方案。刚好公司正打算建设云平台，暂不清楚公司在该平台上的规划，但据了解至少在部署方面要达到像亚马逊一样能提供虚拟机的申请和使用的功能，于是产生了一些疑问，公司打算用什么技术解决生成一台虚拟机和管理这些虚拟机的问题。经常看到大型电商在介绍自己公司技术架构时会提到一个词DOCKER，而上次参加峰会时也听了一个关于这项技术的火爆专场，就是灵雀云CEO介绍DOCKER，这位BOSS看上去像卖猪肉的，但是讲起技术来不仅语速飞快，而且思路清晰，我在现场虽然没能明白讲的内容，但还是坚持听完了。DOCKER是什么？DOCKER是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目，自开源后受到广泛的关注和讨论，最重要的是该项目的目标是实现轻量级的操作系统虚拟化解决方案。亚马逊CTO的介绍产品时也将该项技术列入了运行容器最佳部署中的重要一环，我饶有兴趣在网上搜索了该技术的一些资料，发现此君跟传统虚拟技术相比确有很多优势，不仅高效而且快速。再回到公司云平台建设的问题，如何生成及管理虚拟机？DOCKER可以完成该项任务，具体操作就是通过DOCKER将一个打包好的镜像启动，启动后的进程称之为容器，该容器有ID、NAME、STATUS，进入容器后可以完成网络搭建和应用安装。不知公司云平台搭建的思路是？,2016/1/3
118,上海市2016年度全国专业技术人员职称外语等级统一考试考务工作安排,娄会兵,http://180.168.156.212:2262/wecenter/?/article/9175,由于官网技术问题无法下载文档，请至官网查看中级请报理工B高级请报理工A ,2015/12/31
119,农业部关于推进农业农村大数据发展的实施意见,肖顺亲,http://180.168.156.212:2262/wecenter/?/article/9174,（十六）实现农产品质量安全全程追溯。加快建设国家农产品质量安全追溯管理信息平台，建立健全制度规范和技术标准，加强与相关部门的数据对接，实现生产、收购、贮藏、运输等环节的追溯管理，建立质量追溯、执法监管、检验检测等数据共享机制，推进数据实现自动化采集、网络化传输、标准化处理和可视化运用，实现追溯信息可查询、来源可追溯、去向可跟踪、责任可追究。推进实现农药、兽药、饲料和饲料添加剂、肥料等重要生产资料信息可追溯，为农产品监管机构、检验检测认证机构、生产经营主体和社会公众提供全程信息服务。（十七）实现农作物种业全产业链信息查询可追溯。建立农作物种业大数据信息系统，整合部、省、市、县种业科研、品种管理、种子生产经营、市场供需各环节信息数据，实现新品种保护、品种审定、品种登记、引种备案、种子生产经营许可备案网上申请，种子供求、市场价格、市场监管等信息公开和查询，统一市场种子标签规范，实现从品种选育到种子零售的全程可追溯，为农民选购放心种和农业部门依法治种提供信息服务。农业部关于推进农业农村大数据发展的实施意见.mht,2015/12/31
120,偏执却管用的 10 条 Java 编程技巧,戴鑫宇,http://180.168.156.212:2262/wecenter/?/article/9173,"1.把字符串常量放在前面通过把字符串常量放在比较函数equals()比较项的左侧来防止偶然的NullPointerException从来都不是一个坏主意，就像这样：//Badif(variable.equals(""literal"")){...}//Goodif(""literal"".equals(variable)){...}这是毫无疑问的，把一种表达式转换成另一种更好的表达式，并不会失去什么。只要我们的Options是真实存在的（Java8中Optional是对可以为空的对象进行的封装），不是吗？讨论一下…2.不要相信早期的JDKAPIsJava刚出现的时候，编程一定是件很痛苦的事。那时的API仍然不够成熟，你可能曾经遇到过这样一段代码：String[]files=file.list();//Watchoutif(files!=null){for(inti=0;i<files.length;i++){...}}看起来很奇怪对吗？如果抽象路径名表示的不是一个目录，那么这个方法返回null。否则返回一个字符串数组，其中每个字符串表示当前目录下的一个文件或目录。是的，最好再加上判空检查，以确保正确：if(file.isDirectory()){String[]files=file.list();//Watchoutif(files!=null){for(inti=0;i<files.length;i++){...}}}糟糕！前者违反了Java编码中10个微妙的最佳实践的规则＃5和＃6。因此一定要记得判null检查！3.不要相信“-1”我知道这很偏执，Javadoc中关于String.indexOf()的早期描述是这样的…字符在字符序列中第一次出现的位置将作为结果[被返回]，如果字符不存在则返回-1。所以，-1就可以理所当然被拿来用，对吗？我说不对，看看这个：谁知道呢。也许在某个特定场合下他们将会需要另一种编码值，如果不区分大小写的话，otherString就会被包含进去…此时或许可以返回-2呢？谁知道呢。毕竟，我们有非常多关于NULL——价值亿万美金的错误的讨论。为什么不开始讨论-1呢，某种意义上来说-1是null在int类型下的另一种形式。4.避免意外的赋值是的。即使最优秀的程序员也可能犯这种错误（当然，不包括我。看#7）。（假设这是JavaScript，我们暂且偏执地认为是这种语言）//Ooopsif(variable=5){...}//Better(becausecausesanerror)if(5=variable){...}//Intent(remember.ParanoidJavaScript:===)if(5===variable){...}再说一遍。如果你的表达式中有常量，将它放在等式左边。这样当你打算再添加一个=时，不容易出错。5.检查null和长度不管什么时候你有一个集合、数组或者其他的，确保它存在并且不为空。//Badif(array.length>0){...}//Goodif(array!=null&&array.length>0){...}你不知道这些数组来自哪儿，也许是早期的JDKAPI呢？6.所有的方法都用final声明你可以告诉我任何你想要的开闭原则，不过那都是胡说八道。我不相信你（可以正确继承我的类），也不相信我自己（不会意外地继承我的类）。因此除了接口（专门用于继承）都应该是严格的final。可以查看我们的Java编码中10个微妙的最佳实践中的#9。//Badpublicvoidboom(){...}//Good.Don'ttouch.publicfinalvoiddontTouch(){...}是的，写成final。如果这样做对你来说没有意义，你也可以通过修改或重写字节码来改变类和方法，或者发送功能请求。我敢肯定重写类/方法并不是一个好主意。7.所有的变量和参数都用final声明就像我说的。我不相信自己不会无意间重写了某个值。这么说来，我的确一点都不相信自己。//Badvoidinput(StringimportantMessage){Stringanswer=""..."";answer=importantMessage=""LOLaccident"";}//Goodfinalvoidinput(finalStringimportantMessage){finalStringanswer=""..."";}8.重载的时候不要相信泛型是的，这是会发生的。你觉得你写了一个超好的API，它真的是既酷炫又直观；接着就出现了一群用户，他们只是把一切类型生搬硬套进Object中直到那该死的编译器停止工作，然后他们突然链接到了错误的方法，认为这一切都是你的错（事情总是这样）。思考一下这个：//Bad<T>voidbad(Tvalue){bad(Collections.singletonList(value));}<T>voidbad(List<T>values){...}//Goodfinal<T>voidgood(finalTvalue){if(valueinstanceofList)good((List<?>)value);elsegood(Collections.singletonList(value));}final<T>voidgood(finalList<T>values){...}因为，你知道的…你的用户们，他们就像这样//Thislibrarysucks@SuppressWarnings(""all"")Objectt=(Object)(List)Arrays.asList(""abc"");bad(t);相信我，我看过的多了，还有这样的所以说偏执是有好处的。9.总是在switch语句里加上defaultSwitch…作为最滑稽的表达式之一，我不知道是该心存敬畏还是默默哭泣。不管怎样，我们既然无法摆脱switch，在必要的时候我们最好能够正确使用它，例如：//Badswitch(value){case1:foo();break;case2:bar();break;}//Goodswitch(value){case1:foo();break;case2:bar();break;default:thrownewThreadDeath(""That'llteachthem"");}因为在当value=3被引入到软件中的时候，default就能发挥作用，使其正常运行！别和我提enum类型，因为这对enums也一样适用。10.用大括号隔开switch的每一个case块事实上，switch是最坑爹的语句，任何喝醉了或是赌输了的人都可以在某种语言中使用它。看看下面这个例子：//Bad,doesn'tcompileswitch(value){case1:intj=1;break;case2:intj=2;break;}//Goodswitch(value){case1:{finalintj=1;break;}case2:{finalintj=2;break;}//Remember:default:thrownewThreadDeath(""That'llteachthem"");在switch语句中，为所有的case都只定义了一个作用域。事实上，这些case不是真正意义上的语句，他们更像是标签，而switch就是指向这些标签的goto语句。事实上，你甚至可以把case语句和惊人的FORTRAN77项声明类比，对于FORTRAN，它的神秘已经超越了它的功能。这意味着变量finalintj可以被任何case访问，不论我们是否有break。看起来并不是很直观。我们可以通过添加简单的花括号为每一个case创建一个新的嵌套的作用域，当然不要忘了在每个case的语句块最后加break。原文: ",2015/12/30
121,没想到大数据概念流行之后，现在BI市场已经是Tableau、Qlik的天下,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9172,分析零距离数据可视化产品选型指南 这种基于Javascript的数据可视化工具更适合在互联网上互动的展示数据。除此之外，笔者还将盘点如下五款商业化的数据可视化工具，它们的共同特点是技术门槛低、便捷易用，并且支持多种数据源，能够帮助企业更直观的获得数据中的价值。1.TableauDesktopTableauDesktop是Tableau公司开发的桌面系统中最简单的商业智能工具软件，Tableau没有强迫用户编写自定义代码，新的控制台也可完全自定义配置。在控制台上，不仅能够监测信息，而且还提供完整的分析能力。Tableau控制台灵活，具有高度的动态性。如上图所示，Tableau将数据运算与美观的图表完美地嫁接在一起。程序通过拖放将所有的数据展示到数字“画布”上，转眼间就能创建好各种图表。这一软件的理念是，界面上的数据越容易操控，公司对自己在所在业务领域里的所作所为到底是正确还是错误，就能了解得越透彻。TableauDesktop数据来源有多种方式，能同时支持Excel、支持各种数据库类型，同时能以web模式发布至网络中，以供别人访问。也支持团队协作，由多个人同时完成一件任务。如上图所示，TableauDesktop有多种展现形式，操作人员能操作人员能够自定义图表类型，并以多种图形的方式进行展现，同时根据图形的不同，针对不同的展示图形有不同的提示。当用户从TableauDesktop完成图形的绘制后，数据会从数据库中进行自动更新，从而对展示的数据进行自动同步，同时TableauDesktop中集成了趋势分析，能对数据未来的走向进行一定的趋势分析，同时TableauDesktop也与地理信息等进行了较好集成。在TableauDesktop使用中发现，使用该软件操作反应较慢，由于该软件将数据全部加载至内存，因此对计算机的内存等使用要求较高。同时TableauDesktop的趋势分析模块中，用户无法根据自己的需求选择算法，用户从而无法根据自己的商业特性对未来进行一个预测。2.QlikView下图是QlikView的界面截图，QlikView是一个完整的商业分析软件，使开发者和分析者能够构建和部署强大的分析应用。QlikView应用使各种各样的终端用户以一个高度可视化，功能强大和创造性的方式，互动分析重要业务信息。QlikView把商业分析需要的三个因素放在一个独立软件包里。QlikView的客户能得到：一个具有完全集成的ETL工具的向导驱动的应用开发环境、一个考虑到无限钻取的强大AQL分析引擎和一个高度直觉化的、使用简单的用户界面。QlikView让开发者能从多种数据库里提取和清洗数据，建立强大、高效的应用，而且使它们能被Power用户、移动用户和每天的终端用户修改后使用。QlikView获得专利的AQL构架利用了计算机和网络设备的提高，例如价格便宜，速度快的内存。当提供灵活、强大的分析能力时，AQL构架改变了需要OLAP立方体的需求，也不一定要使用数据库。QlikView是一个可升级的解决方案，完全利用了基础硬件平台，来用上亿的数据记录进行业务分析。QlikView由以下组成：开发工具(QlikViewLocalClient);服务器组件(QlikViewServer);发布组件(QlikViewPublisher);其他应用接口(SAP\Salesforce\Informatica)。服务器支持多种方式发布如AJAX客户端、ActiveX客户端。还可以与其他CS/BS系统进行集成。上图是使用QlikView工具进行数据可视化的第一步，用户可以选择想使用的图表类型来进行建模，用上图可以看出，QlikView的图表类型较TableauDesktop较少。QlikView数据支持的格式与TableauDesktop一样，支持多种数据来源，所不同的是，QlikView通过导入数据后生成qvw来对数据进行展示，因为采用了自有的qvw格式，因此在使用QlikView过程中发现，该工具使用起来展示速度较TableauView迅速。3.MicrosoftExcelExcel一直为用户使用来进行数据可视化展示的软件之一，通过Excel内在集成的图表来对选定的数据源进行可视化展示。同时，Excel支持3D的可视化展示，微软发布了一款叫做GeoFlow的插件，它是结合Excel和Bing地图所开发出来的3D数据可视化工具。这个工具可以以加载项的形式运行，目前支持Excel2013和Office365ProPlus。上图为Excel3D可视化的截图，GeoFlow的概念最早于2011年6月被提出，微软也曾在2012年11月的SharePoint大会上推出过GeoFlow。GeoFlow可以帮助用户创建和浏览时间敏感型数据并与之交互，而这些数据也可以应用到数字地图上。同时，用户也可以使用GeoFlow将数据转换为3D图像的形式与他人分享。按照微软的说法，我们可以把GeoFlow理解为WorldWideTelescope项目的更新版。它可以帮助信息工作者通过详细的3D数据图来搜寻和分享全新的数据视角。据介绍，GeoFlow目前支持的数据行规模最高可达100万行，并可以直接通过Bing地图引擎生成可视化3D地图。数据可以通过三维垂直或二维贴片的方式呈现，并且同时支持ExeclDataModel和PowerPivot两种模型，还可实现对BingMaps的区域可视化。目前，GeoFlow支持包括立柱型、二维斑块以及“气泡图”在内的多种可视化类型。来自微软研究院的CurtisWong指出，他们是在构建一个巨大的“虚拟望远镜”，若想达到这个目的则先要构建一个“可视化宇宙”的引擎。他还表示GeoFlow将为全球公司带来动态、交互式的数据可视化功能。微软在Excel的官方博客中解释了GeoFlow的工作方式。以德州达拉斯居民家庭能源使用数据为例，GeoFlow先将这些用户的位置在地图上标记出来，而Excel则会将这些家庭的房屋面积和市价用三维图像显示出来。随着时间的变化，这个“地图”也会实时改变。用户若想将数据分享给他人，只需在GeoFlow中截取“画面”，然后创建一个“场景导游”最后导出就可以了。目前GeoFlow只支持OfficeProfessionalPlus2013和Office365ProPlus。4.SAS可视化分析作为SAS高性能分析方案家族中最新一款产品，SAS可视化分析拥有内存分析的卓越速度、自助服务功能和高度可视化的界面可为企业提供快速、简单而经济有效的商业洞察，并进行更好的商业决策。SAS可视化分析(VA)具有强大的数据探索和显示能力，它不是一个简单的商业智能产品，而是一个将商业智能和分析能力充分结合，并且快速、易用的产品。我们正处于各项技术涌现急需整合的时期，SAS可视化分析适用范畴广，无论是小型工作组、中小型公司还是超大型企业均可从使用中受益。SAS可视化分析的扩展性让各企业可以实现量身定制的数据可视化，或者按照实际需求逐步增加分析功能。其自助服务功能让非数据专家也可以轻松、有效地理解和分析大数据，在自己的数据中找到对业务问题的答案。用户可以在任何地点通过iPad等移动终端或者网页，生成交互式报表或从移动仪表盘中获取最更新的数据信息，由此更快速更好地做出决策。同时可将企业内部IT部门从不断增加的数据集、临时分析和一次性报表请求中解放出来，把更多精力用于其他项目，更为高效。SAS可视化分析的高性能内存分析架构能够快速的完成不同规模的数据分析，让用户能够快速检查所有数据，消除了传统的由IT生成报告的等待时间，几分钟或几秒时间内可以在数十亿行数据中执行分析计算，和呈现可视结果。SASVA6.1的优势在于以下七个方面：完整的，随时可交付的系统;大数据的价值体现;高性能分析;移动应用;开箱即用;拥抱开源技术;无须开发，基于配置的操作。SAS可视化分析的设计初衷是为解决大数据分析问题，可以低成本地利用行业标准刀片式服务器的扩展性，以及适用于EMCGreenplum和Teradata的数据库系统。目前其根据数据量大小，可应用于不同部门。除了支持各部门硬件平台之外，SAS可视化分析还可添加图形显示选项和特色分析功能，包括预测、多元回归模型选项，多重视觉互动，动态过滤，新可视化方法和更多其它功能。5.IBMSPSSSPSS是世界上最早采用图形菜单驱动界面的统计软件，它最突出的特点就是操作界面极为友好，输出结果美观漂亮。它将几乎所有的功能都以统一、规范的界面展现出来，使用Windows的窗口方式展示各种管理和分析数据方法的功能，对话框展示出各种功能选择项。用户只要掌握一定的Windows操作技能，粗通统计分析原理，就可以使用该软件为特定的科研工作服务。SPSS采用类似Excel表格的方式输入与管理数据，数据接口较为通用，能方便的从其他数据库中读入数据。其统计过程包括了常用的、较为成熟的统计过程，完全可以满足非统计专业人士的工作需要。输出结果十分美观，存储时则是专用的SPO格式，可以转存为HTML格式和文本格式。对于熟悉老版本编程运行方式的用户，SPSS还特别设计了语法生成窗口，用户只需在菜单中选好各个选项，然后按“粘贴”按钮就可以自动生成标准的SPSS程序。极大的方便了中、高级用户。SPSSforWindows是一个组合式软件包，它集数据录入、整理、分析功能于一身。用户可以根据实际需要和计算机的功能选择模块，以降低对系统硬盘容量的要求，有利于该软件的推广应用。SPSS的基本功能包括数据管理、统计分析、图表分析、输出管理等等。SPSS统计分析过程包括描述性统计、均值比较、一般线性模型、相关分析、回归分析、对数线性模型、聚类分析、数据简化、生存分析、时间序列分析、多重响应等几大类，每类中又分好几个统计过程，比如回归分析中又分线性回归分析、曲线估计、Logistic回归、Probit回归、加权估计、两阶段最小二乘法、非线性回归等多个统计过程，而且每个过程中又允许用户选择不同的方法及参数。SPSS也有专门的绘图系统，可以根据数据绘制各种图形。最新的21.0版采用DAA(DistributedAnalysisArchitecture，分布式分析系统)，全面适应互联网，支持动态收集、分析数据和HTML格式报告。SPSS输出结果虽然漂亮，但是很难与一般办公软件如Office或是WPS2000直接兼容，如不能用Excel等常用表格处理软件直接打开，只能采用拷贝、粘贴的方式加以交互。在撰写调查报告时往往要用电子表格软件及专业制图软件来重新绘制相关图表，这已经遭到诸多统计学人士的批评;而且SPSS作为三大综合性统计软件之一，其统计分析功能与另外两个软件即SAS和BMDP相比仍有一定欠缺。虽然如此，SPSSforWindows由于其操作简单，已经在我国的社会科学、自然科学的各个领域发挥了巨大作用。该软件还可以应用于经济学、数学、统计学、物流管理、生物学、心理学、地理学、医疗卫生、体育、农业、林业、商业等各个领域。6.小结根据对以上五个产品的使用及功能，总结如下：·从产品的使用功能来看：TableauDesktop产品应用最丰富，能通过简便的拖拽来实现数据可视化，且能支持GIS地理信息、多数据来源等功能。·专业性：SPSS能通过各种算法及软件包来对业务数据进行很好的预判展示，能与其他算法进行良好的集成，其产品的BI程度最高。·支持web及产品协作：SAS分布式存储以及多用户检索功能来搜索共享文件，通过共享的文件，不同用户能协同完成一个共同的任务。其余产品均支持进行web模式的发布;·简便性及3D特性：Excel本身即为良好的数据可视化展示软件，同时通过3D展示更能有效的将数据展示给用户。·性能：Qlikviw通过AQL构架提供灵活、强大的分析能力时，AQL构架改变了需要OLAP立方体的需求。通过将用户数据转换成自己的格式，从而拥有快速，灵活的分析性能。三、数据可视化主流产品对比表1.企业实施条件企业实施条件TableauQlikView微软/Pivotstream评论普及速度快稍慢稍慢可扩展性好仅限RAM优秀Tableau:虚拟RAM企业适用性适合能够采用云方案的小型企业。就本身来说，TableauDesktop成本并不高。适合注重性价比、需要更多许可权限的中型企业。对于微型团队而言不太适用或者性价比不高。由于提供大量产品选项，仅由一、两位成员组成的微型团队无法获得理想的性价比效果。适合中小型企业。就成熟程度而言QlikView更具优势，不过微软目前已经制定出更为明确的发展规划。Tableau已经被不少大型企业所接纳，其客户名单就是最好的证明。长期可用性增长速度最快上市企业可靠由于Excel已经广泛应用于企业领域，因此不存在采纳及实施问题。是否提供在线帮助服务Tableau论坛QlikViewLinkedIn小组微软在线社区Tableau与微软提供出色的免费在线帮助服务。QlikView拥有自己的论坛，大家可以登录并获取帮助。Tableau提供的免费培训视频质量堪称卓越、令人赞叹。是否提供付费培训服务是是是根据具体课程的不同，收费额度也有所区别。大数据支持能力高于平均水平处于平均水平是，提供指向HDInsight的ODBC连接三者都已经将大数据支持能力纳入路线图当中。Tableau提供大量方式帮助用户与各种数据源相对接。不过由于无法与PDW顺利连接，因此微软在PDW的支持能力上更胜一筹。目前还不清楚QlikView是否支持PDW。合作阵营处于平均水平QlikView:超过一千家合作伙伴规模较小。主要由微软自身直接提供方案。由于PivotStream还是一家非常年轻的企业，因此其合作阵营也相对薄弱。大部分方案都由公司自身提供，而非来自合作伙伴。2.可视化条件可视化条件TableauQlikView微软/Pivotstream评论美观程度好一般一般Tableau所提供的数据可视化效果非常出众，能够快速抓住用户的眼球——这也是我见过的最完美的设计效果。美观程度可以说是Tableau的王牌技能。数据交互优秀优秀优秀Tableau的交互性已经得到显著改进，完成能够满足大部分用户的实际需求。QlikView对脚本化的要求可能会让一部分用户望而却步。微软提供的一系列报告工具需要深入调整方能奏效，但微软此前已经成功解决过多种类似问题——我坚信未来用户将能够更便利地让PerformancePoint与PowerView实现通信。正所谓不积跬步无以至千里，目前的问题应该只是微软迅速交付大量报告解决方案所带来的暂时性副作用。可视化深入程度优秀优秀很好我更希望在PowerView当中体验深入探寻的感受，毕竟Excel已经用简洁的功能解决了这个问题。离线查看FreeTableauReaderPersonalEdition下载Excel电子表格Tableau与Pivotstream都针对离线查看需求提供Excel文档下载功能。分析师桌面系统工具TableauProQlikViewDesktopExcel对于大多数企业用户来说，Excel无疑最为他们所熟悉。仪表板支持效果好优秀优秀QlikView与Tableau都提供仪表板处理方法。Tableau默认采用KPI，但在使用便利性方面表现良好。QlikView似乎在金融业务部门当中人气较高，与相关工作的契合度也较好。Web客户端很好很好很好三者在这方面没什么区别。不过微软提供Excel服务，我们都知道企业用户最喜欢Excel了！移动客户端优秀优秀好Tableau与QlikView在这方面暂时领先于微软，但面向Office365推出的PowerBI显然正在迎头赶上、Preview也颇具吸引力。可视化控制很好很好很好3.技术条件技术条件TableauQlikView微软/Pivotstream评论数据整合效果优秀很好很好Tableau能够轻松与GoogleAnalytics进行整合从而执行进一步分析，但这一特性在商务智能策略的早期阶段并不属于必要条件。大家可以通过DataRoket为QlikView提供额外的整合通道。开发TableauProQlikViewDeveloperSQLServerBusinessIntelligence或者Excel技能QlikView拥有脚本化特性，企业用户需要有针对性地进行学习，而这很可能带来额外的培训成本。如果企业用户已经拥有很强的SQLServerBI开发技能，则应该可以直接上手。64位内存内数据库好优秀优秀SQLServer可以与其它系统“沟通”并能够轻松向QlikView或者以其它格式实现数据输出。这种交付机制并不涉及互换，也就是说一旦数据进入QlikView、就将继续存在于QlikView当中。映射支持优秀处于平均水平优秀TableauhasMapping、Excel2013以及3DPowerMap都包括这项功能，而这也是未来实现分析处理的重要前提。本地数据文件（包括文本及电子表格等）是是是关系型数据库（包括SQLServer以及Oracle等）是是是OLAPcubes(包括SSAS及Essbase等)是否否在线数据源是是是微软的全新PowerQuery允许大家进行在线搜索，并将数据直接导入Excel。多源访问是是是多表访问是是是提取数据存储可选（专有）专有数据仍存在于原始位置最大容量无限数十亿行内存内引擎DesktoporServerDesktoporServerTableau能够读取SSAS与PowerPivotCube，但效果并不理想。Tableau与QlikView倾向于把数据纳入自有数据模型之内；微软则保证数据仍处于原始位置，这样更易于微软及其它厂商的产品对其进行访问。模型与分析BelowAverageBelowAverageDatamining以及其它功能微软在这一项目中取得了优胜，其提供一系列模型化与分析工具，包括Tabular模型以及SSAS等。再次强调，企业用户对这些工具往往比较熟悉，因此只需利用现有内部技能储备即可上手。数据挖掘有限有限是所谓“数据挖掘”，我所指的是能够切实避免抖动与自举现象的神经网络创建流程。这并不属于假设场景，而是数据科学。多维很好有限优秀微软在多维模型化处理方面胜出。xVelocity支持能力好无优秀微软堪称xVelocity支持方面的先行者。PowerPivot支持能力好无优秀微软堪称xVelocity支持方面的先行者。API优秀是，QlikView社区网站提供说明文档。优秀微软采取软件开放策略，并允许用户自由使用API。四、总结总的来说，在数据可视化的分类中，免费的开源产品一般使用起来没有限制，但应用门槛高、学习成本高，适合有一定技术实力的企业;免费的商业化产品一般是数据可视化厂商提供的免费版本，功能和应用上会有一些限制，适合数据量不大、对分析要求不高的中小企业;而收费的商业化产品往往需要大量资金支持，但部署和应用简便、服务有保障，尤其适合有资金实力雄厚的企业。当然，数据可视化产品的选择还需要每个企业根据自己的情况“具体问题具体分析”，找出适合自己的解决方案。企业在选择和部署商业智能和分析平台的软件时，不妨考虑一下数据可视化产品，让数据与业务人员之间、数据价值和企业之间真正实现“零距离”。,2015/12/29
122,所有文件后缀名所代表文件的类型,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9171,"ASP：动态网页文件，我们上网访问的网站有很多都是使用的这个格式。AVI：MicrosoftAudioVideoInterleave，一种宽泛的视频文件格式，可以使用多种编码格式，使用暴风影音之类的影音播放程序通常是能够自动识别进行播的。BAK：备份文件，通常是被文件清理软件所清除的对象。BAT：DOS系统下的批处理文件，可以批量执行多个命令，被Windows系统继承了下来。BIN：二进制文件，任何程序都可能会使用BIN作为自己数据文件的扩展名，不具备唯一性。BMP：位图文件，使用几乎任何看图软件都可以打开。CAB：Microsoft压缩档案文件，通常都是作为软件的安装数据包存在的。CFG：配置文件，通常只能被其所属的软件读取。CGI：公共网管接口脚本文件，和ASP一样，也是一种网页程序文件。CHK：由Windows磁盘整理或碎片整理程序保存的碎片文件，对普通用户没什么意义，可以删除掉。CHM：编译过的HTML文件，通常作为帮助文件。CMD：Windows系统下的命令文件，功能和BAT相同COM：命令文件，通常都是DOS下的命令程序。DAT：数据文件，与BIN文件类似，这也是一个非唯一的格式，任何程序都有可能用它做为自己专属数据文件的扩展名。因为VCD光盘上的视频文件使用的就是DAT作为扩展名，所以很多视频播放软件都会与DAT文件进行关联。DBF：数据库文件，可以被很多数据库软件打开并编辑。DLL：动态链接库文件，是作为系统或程序的一部分而存在的，不能直接执行或被编辑。DOC：Word文件的扩展名。DOT：Word模板文件的扩展名。DRV：设备驱动程序文件。EML：OutlookExpress的邮件文件。EXE：可执行文件，也就是程序文件。Windows中所有的程序文件都是EXE格式的。FON：字体文件，Windows的所有字体文件都存放在Windows目录中的Fonts目录下，要安装新字体，只要把字体文件复制到Fonts目录下即可。GIF：动画图片文件。HLP：Windows帮助文件。HTM/HTML：超文本文件，就是最普通的网页文件。ICO：Windows图标文件。IMG：磁盘镜像文件，通常是软盘的镜像，现在已经比较少用到了。INF：信息文件，通常都是软件活硬件的安装信息。INI：初始化文件，通常存放的是一些程序的配置信息。ISO：光盘镜像文件。JAR：Java程序文件，手机上的Java程序通常都是以JAR为扩展名的。JPG：JPEG格式的图片文件，应该是现在大家最常见到的图片格式了。LOG：日志文件，对普通用户来说用处不大。LOG文件通常都是纯文本格式，可以使用系统自带的记事本打开。MID：MIDI格式的声音文件，用大多数媒体播放软件都能播放。MOV：苹果公司的QuickTime视频文件。MP3：这个不用说相信大家也都认得的了，现今最流行的音频格式文件。MPG：MPEG格式的视频文件，实际上VCD使用的DAT文件就是MPEG格式。MSG：邮件消息。MSI：Windows程序安装文件。OCX：对象链接与嵌入定制空间，与DLL文件类似，也是程序运行所需的文件，不可运行，不可修改。OCX被称为控件，一般是在IE浏览器中调用，它其实就是一个可执行文件，有些OCX文件自带图标，如果后缀改为EXE的话就可以直接运行。PDF：Adobe公司的Acrobat格式文档，不能修改。很多产品说明书都是以PDF格式发布的。PHP：和上面的APS、CGI一样，也是一种网络程序文件。PPT：Powerpoint的幻灯片文件。RAR：现在网络上很流行的压缩文件格式，使用WinRAR来进行压缩或解压缩操作。REG：Windows注册表文件。RM/RMVB：Real公司的视频文件格式，使用RealPlayer或暴风影音等通用媒体播放器进行播放。SWF：Flash文件，只要你的电脑上安装了AdobeFlash插件，就可以使用IE打开SWF文件。SYS：系统文件，类似于上面介绍的DLL和OCX的文件。TIF：标签格式图像，接收传真后保存的文件就是TIF格式。TTF：Truetype字体文件。TXT：纯文本格式文件，可以使用任何文本编辑软件打开。WAV：波形文件，原始无损的声音格式文件。RTF：Windows自带写字板的格式，安装Word后，则会被关联到Word。XLS：Excel的文件格式。XLT：Excel的模板文件。ZIP：最为流行的压缩文件格式，WindowsXP以后的Windows系统都已经内置了ZIP压缩和解压功能。信息来源:(www.cxzzl.cn).ACA：Microsoft的代理使用的角色文档.acf：系统管理配置.acm：音频压缩管理驱动程序,为Windows系统提供各种声音格式的编码和解码功能.aif：声音文件，支持压缩，可以使用WindowsMediaPlayer和QuickTimePlayer播放.AIF：音频文件，使用WindowsMediaPlayer播放.AIFC：音频文件，使用WindowsMediaPlayer播放.AIFF：音频文件，使用WindowsMediaPlayer播放.ani：动画光标文件扩展名，例如动画沙漏。.ans：ASCII字符图形动画文件.arc：一种较早的压缩文件，可以使用WinZip,WinRAR,PKARC等软件打开.arj：压缩文件。可以使用WinZip,WinRAR,PKARC等软件打开.asf：微软的媒体播放器支持的视频流，可以使用WindowsMediaPlayer播放.asp：微软的视频流文件，可以使用WindowsMediaPlayer打开.asp：微软提出的ActiveServerPage,是服务器端脚本，常用于大型网站开发，支持数据库连接，类似PHP。可以使用VisualInterDev编写，是目前的大热门.asx：WindowsMedia媒体文件的快捷方式.au：是Internet中常用的声音文件格式，多由Sun工作站创建，可使用软件WaveformHoldandModify播放。NetscapeNavigator中的LiveAudio也可以播放.au文件.avi：一种使用MicrosoftRIFF规范的Windows多媒体文件格式，用于存储声音和移动的图片.bak：备份文件，一般是被自动或是通过命令创建的辅助文件，它包含某个文件的最近一个版本，并且具有于该文件相同的文件名.basBasic：语言源程序文件，可编译成可执行文件,目前使用Basic开发系统的是VisualBasic.bat：批处理文件，在MS-DOS中，.bat文件是可执行文件，有一系列命令构成，其中可以包含对其他程序的调用.bbs：电子告示板系统文章信息文件.bfc：Windows的公文包文件.bin：二进制文件，其用途依系统或应用而定.bmp：Bitmap位图文件，这是微软公司开发Paint的自身格式，可以被多种Windows和WindowsNT平台及许多应用程序支持，支持32位颜色，用于为Windows界面创建图标的资源文件格式。.c：C语言源程序文件，在C语言编译程序下编译使用.cab：Microsoft制订的压缩包格式，常用于软件的安装程序，使用Windows自带的实用程序，Extract.exe可以对其解压缩，WinZip,WinRAR等都支持这种格式.cal：Windows中的日历文件.cdf：InternetExplorer的频道文件.cdr：CorelDraw中的一种图形文件格式，它是所有CorelDraw应用程序中均能够使用的一种图形图像文件格式.cdx：索引文件，存在于Dbase,Foxbase,Foxpro系统软件环境下.cfg：配置文件，系统或应用软件用于进行配置自己功能，特性的文件.chm：编译过后的HTML文件，常用于制作帮助文件和电子文档.clp：在Windows下剪贴板中的文件格式.cmd：用于WindowsNT/2000的批处理文件，其实与BAT文件功能相同，只是为了与DOS/Windows9x下的BAT有所区别.cmf：声卡标准的音乐文件，FM合成器等可以回放.cnf：NetMeetting会议连接文件.cnt：联机帮助文件目录索引文件，通常和同名的.hlp文件一起保存.col：由AutodeskAnimator,AutodeskAnimatorPor等程序创建的一种调色板文件格式，其中存储的是调色板中各种项目的RGB值.com：DOS可执行命令文件，一般小于64KB.cpl：控制面板扩展文件，Windows操作系统使用.cpp：C++语言源程序，非常强大的语言，在各种平台中都有相应的开发系统.crd：Windows中的卡片文件.crt：用于安全方面的证书认证文件.cur：Windows下的光标资源文件格式，可用光标编辑软件编辑.css：Text/css文件.dat：数据文件，在应用程序中使用.dat：VCD中的图象声音文件，VCD播放软件可调用，或是通过VCD机播放.dbf：数据库文件，Foxbase,Dbase,VisualFoxPro,等数据库处理系统所产生的数据库文件.dcx：传真浏览文档文件.ddi：映象文件，DUP,HD,IMG等工具可展开.dev：设备驱动程序.dib：设备无关位图文件，这是一种文件格式，其目的是为了保证用某个应用程序创建的位图图形可以被其它应用程序装载或显示一样.dir：目录文件.dll：Windows动态连接库，几乎无处不在，但有时由于不同版本DLL冲突会造成败各种各样的问踢.doc：是目前市场占有率最高的办公室软件MicrosoftOffice中的字处理软件Word创建的文档.dos：Windows保留的MS-DOS的某些系统文件.dot：MicrosoftWord的文档模板文件，通过模板可以简化一些常用格式文档的创建工作,而且可以内嵌VBA程序来实现某些自动化功能.drv：设备驱动程序文件，用在各种系统中.dwg：AutoCAD的图纸文件，也是许多绘图软件都支持的格式，常用于共享数据.dxb：AutoCAD创建的一中图形文件格式.dxf：图形交换格式，一种计算机辅助设计的文件格式，最初开发用来与AutoCAD一起使用，以便于图形文件在应用程序之间的传递,它以ASCII方式储存图形，在表现图形的大小方面十分精确.der：Certiticate文件.dic：Txt文件.emf：由Microsoft公司开发的Windows32位扩展图元文件格式，其总体设计目标是要彌补在MicrosoftWindows3.1(Win16)中用的*.wmf文件格式的不足,使得图元文件更加易于使用.eps：用PostScript语言描述的一种图形文件格式，以文本文件保存，在PostScript图形打印机上能打印出高品质的图形图象，最高能表示32位图形图象.err：编译错误文件，存在于Dbase,Foxbase,Foxpro系列软件环境下.exe：可执行文件，虽然后缀名相同，但具有不同的格式和版本.exp：3DS使用的显示卡驱动程序.exc：Txt文件.flc：AutodeskAnimator和Animatorpro的动画文件，支持256色，最大的图象象索是64000*64000,支持压缩，广泛用于动画图形中的动画序列，计算机辅助设计和计算机游戏应用程序.fnd：保存的搜索结果.fon：点阵字库文件.for：Fortran语言程序.fot：指向字体的快捷键.fp：配置文件，存在于Dbase,Foxbase,Foxpro系列软件的环境下.fpt：备注字段文件，存在于Dbase,Foxbase,Foxpro系列软件的环境下.frt：报表文件,存在于Dbase,Foxbase,Foxpro系列软件的环境下.frx：报表文件,存在于Dbase,Foxbase,Foxpro系列软件的环境下.fxp：编译后的程序，存在于Dbase,Foxbase,Foxpro系列软件的环境下.gif：在各种平台的各种图形处理软件上均能够处理的，经过压缩的一种图形文件格式.grh：方正公司的图象排版文件.grp：Windows下的程序管理器产生的组窗口文件.goc：Gocserve.gra：MSGraph.Chart.5.h：C语言源程序头文件.hlp：Windows应用程序帮助文件.hqx：Macintosh中使用BinHex将二进制文件编码为7位的文本文件，大多数Macintosh文件皆以.hqx出现(.bin极少使用)，在Macintosh中,可使用StuffItExpander对.hqx解码，在Windows中可使用BinHex13解码.ht：超级终端.htm：保存超文本描述语言的文本文件，用于描述各种各样的网页，使用各种浏览器打开.html：同.htm文件.icm：图象配色描述文件.ico：Windows中的图标文件，可以包含同一个图标的多种格式，使用图标编辑软件创建.idf：MIDI乐器定义.idx：索引文件，存在于Dbase,Foxbase,Foxpro系列软件的环境下.iff：文件交换格式文件，这种文件格式多用于Amiga平台,在这种平台上它几乎可以存储各种类型的数据，在其它平台上，IFF文件格式多用于存储图象和声音文件.image：MAcintosh磁盘映象文件，常见于萍果机的FTP网点，在Macintosh中由ShrinkWrap处理.ime：Windows下的输入法文件.img：磁盘映象文件，用HD-COPY,WinImage等工具打开后可以恢复到一张磁盘上.inc：汇编语言包含文件，类似C/C++中的.H文件.inf：Windows下的软件安装信息，Windows的标准安装程序根据此文件内的安装信息对软件，驱动程序等进行安装.ini：Windows中的初始化信息文件,已经用的不多了，新的应用程序将设置保存在系统的注册表中.jar：一种压缩文件，ARJ的新版本，不过不太流行，可以使用WinJar,Winrar等打开.jpeg：一种图片压缩文件,同.jpg.jpg：静态图象专家组制订的静态图象压缩标准，具有很高的压缩比，使用非常广泛，可使用PhotoShop等图象处理软件创建.lnk：快捷方式，这个文件指向另一个文件，开始菜单的程序文件夹下每条项目都是一个LNK文件.log：日志文件,通常用来记录一些事件之类.lzh：一种古老的压缩文件，可以使用WinRAR打开.mac：Macintosh中使用的一中灰度图形文件格式，在MacintoshPaintbrush中使用，其分辨率只能是720*567.mag：图形文件格式.mdb：MicrosoftAccess使用的数据库格式，是非常流行的桌面数据库.men：内存应用文件,存在于Dbase,Foxbase,Foxpro系列软件的环境下.mid：音频压缩文件，曾经非常流行，不过在现在的软件中用的很少了rle：一种压缩过的位图文件格式，RLE压缩方案是一种极其成熟的压缩方案，特点是无损失压缩，既节省了磁盘空间又不损失任何图像数据，但在打开这种压缩文件时，要花费更多时间，此外，一些兼容性不太好的应用程序可能会搭不开.rm：Windows下的RealPlayer所支持的视频压缩文件，网上非常流行的流式视频文件，很多实时视频新闻等都是采用这种格式的，不过，最新的WindowsMediaVideoV8已经对其发起了强大的攻势.rmi：MIDI音序文件.rtf：丰富文本格式文件，以纯文本描述内容，能够保存各种格式信息，可以用写字版，Word等创建.sav：存档文件.scp：用于Windows系统中Internet拨号用户，自动拨号登录用的脚本文件，可避免手动登录时繁琐的键盘输入.scr：屏障保护文件.sct：屏幕文件.scx：屏幕文件.set：Microsoft备份集文件，用于保存要备份的内容，设置等信息.shb：指向一个文档的快捷方式.snd：Mac声音文件,Apple计算机公司开发的声音文件格式，被Macintosh平台和多种Macintosh应用程序所支持，支持某些压缩.sql：查询文件，在Dbase,Foxbase,Foxpro系列软件的环境下使用.svg：SVG可以算是目前最火热的图像文件格式了，它是基于XML由WorldWideWebConsortium联盟开发的，SVG是可缩放的矢量图形.svx：Amiga声音文件，Commodore所开发的声音文件格式，被Amiga平台和应用程序所支持，不支持压缩.swf：flash是Micromedia公司的产品，严格说它是一种动画编辑软件，实际上它是制作出一种后缀名为.swf的动画，这种格式的动画能用比较小的体积来表现丰富的多媒体形式，并且还可以与HTML文件达到一种""水乳交融""的境界.swg：虚拟内存交换文件，由操作系统使用.sys：系统文件，驱动程序等，在不同的操作系统中有不同的定义",2015/12/29
123,吐槽关于OA更新的通知,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9170,当收到“通知：OA服务器需数据更新，将停止5分钟。5分钟后即可正常使用，给大家带来的不便表示歉意！”的时候，这时候你就不要再尝试保存数据了，因为这个时候OA服务器已经重启了，你的信息也将丢失了，需要做的事情就是，你什么也不要动，再打开一个浏览器标签页，尝试访问OA，如果可以访问了就登陆进去，然后切换到之前没有保存的页面，再继续做保存事情，因为这个时候新的回话已经创建，页面也就起死回生了拜托，下次能不能通知的时候说：“服务器将于5分钟后（10:20）进行重启，并将停止片刻”，也好让大家有个反应时间，不至于抓瞎吧！,2015/12/28
124,江苏某项目集群负载的前世今生，不可小看的COOKIE,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9169,"江苏某项目集群负载的前世今生1、为了实现集群2、避开多节点SESSION会话同步的瓶颈系统使用了无会话（NOsession）状态，全系统基本废弃了利用SESSION存储业务会话信息，只使用了主域下的COOKIE（一份含有有效期的加密令牌）,理论上可以实现无限节点集群受限于于会话和令牌的有效期，系统将COOKIE设置为浏览器会话级，只要浏览器不关闭，COOKIE及有效，则系统需要做到：A、只要用户登录成功了，再次在浏览器其他TAB标签页中访问系统，需要免登陆直接跳转到登陆成功页，避免造成用户混淆登陆B、用户退出成功后，在浏览器中需要彻底删除当前COOKIE,否则将导致系统无法退出，因为上述A逻辑将生效为了实现跨系统访问，需要将COOKIE设置为主域路径下，在删除COOKIE的同时当然也要注意如下：1、为了保证COOKIE的安全，系统在读取COOKIE时,类似domain、path是无法获取的，千万不要尝试去获取他们并去判断它们的取值情况，所以使之失效赋值PATH、maxAge,是一个都不能少的，而且一定要避开类似cookie.setPath(cookie.getPath())习惯写法2、即使后台已经让其失效，还是需要再次通过response出去，让Client也知道，这样全世界就都知道你退出去了",2015/12/28
125,做出优秀的扁平化设计风格 PPT 或 Keynote 幻灯片演示文稿,赵本,http://180.168.156.212:2262/wecenter/?/article/9167,ppt扁平化设计排版，自觉实用，可以去看看~网址： /question/21274267,2015/12/25
126,如何快速测评一台电脑的性能,赵本,http://180.168.156.212:2262/wecenter/?/article/9166,其实，最简单的测试方法就是让电脑运行一下我们常用的软件来检查电脑有没有什么问题，简单的判断一下电脑性能是否满足要求。一般来说，测试可以分成几类：游戏测试、播放电影测试、图片处理测试、拷贝文件测试、压缩测试、网络性能测试。这些测试基本上包括了对电脑性能的整体测试。游戏性能测试。买电脑的朋友很少有不玩游戏的，而且游戏可以说是对电脑性能的综合测试，包含了对CPU、内存、显卡、主板、显示器、光驱、键盘鼠标、声卡、音箱等的测试。所以，电脑首先应该进行的就是游戏测试。我们可以选择几款常见的游戏来测试爱机。例如：极品飞车、古墓丽影、QUAKE、CS、虚幻竞技场、魔兽争霸。不一定要把这些游戏都试用一下，可以选择其中的几款来测试电脑性能。电脑配置高一些的朋友可以选择高一些的游戏版本来测试，配置低一些的朋友可以选择版本低一些的游戏来测试。测试主要应该注意游戏安装速度、游戏运行速度、游戏画质、游戏流畅程度、游戏音质等几方面。可以更改显示器设置、显卡设置、BIOS设置、系统设置、游戏设置来感受不同设置下电脑的不同表现。例如改变显示器的亮度、对比度，改变游戏的分辨率，改变显卡的频率，改变内存的延时，改变CPU频率，改变系统硬件加速比例，改变系统缓存设置等等。大家要注意的是在测试以前最好把所有的补丁程序安装齐全，改变设置测试完成以后要把设置改回来(或者改到最佳状态)。有条件的朋友可以和配置相近的电脑对比一下，相信能感受出自己爱机的性能。接下来可以考虑播放一段电影来测试自己的电脑。建议选择常用的播放器和比较熟悉的电影这样可能不用和其他电脑对比就能看出自己爱机的“优势”。这时候应该注意的是播放有没有异常、画面的鲜艳程度、调整显示器亮度后的画面变化情况、电影画面的清晰程度等等。再下来可以考虑测试一下电脑的图片处理能力。笔者推荐用常用的图形处理软件来测试，例如PHOTOSHOP、FIREWORKS、AUTOCAD、3DMAX等等。可以试着打开多个图片文件、更改图片或者编辑图片来测试电脑图片处理速度、观察画质。拷贝文件测试比较简单，应该尽量选择大一些的文件拷贝，大家可以选择拷贝VCD或者DVD。压缩测试可以选择我们常用的WINZIP或者WINRAR来压缩大一些的文件。也可以通过压缩CD、VCD来测试电脑，选择我们常用的超级解霸软件来测试。以上测试重点查看速度。网络性能测试相对来说简单一些，主要检查网络是否能正常连接、连接速度是否正常。除了上面几方面以外，大家也可以运行一些常用的测试软件来看看电脑得分。例如3DMARK2001SE、3DMARK03、PCMARK04等。然后可以和网上的参考得分来比较得到出对电脑的评价。,2015/12/24
127,雷军的“成人玩具”----平衡车,管俊,http://180.168.156.212:2262/wecenter/?/article/9165,据澎湃新闻了解，融资纳恩博，小米是最大的机构类股东。纳恩博由此成为小米生态链企业之一，将与小米结合打通智能研发模块。而小米也在智能手机外，进一步拓展生态体系。“我10年前就开始玩了，很喜欢，2008年还写过一篇博客文章。后来，我们十分关注这个市场。我关心的是它可以耍酷，是非常好玩的成年人玩具，是不是短途交通不关心。”雷军笑说。在雷军出场前，纳恩博首席执行官高禄峰一直在鼓吹平衡车作为一种“创新短途交通工具”的市场。其称，该市场价值可以达到千亿美元以上。纳恩博集平衡电动车研发、设计、生产、销售与服务于一体，产品在全球50多个国家销售，且大部分销量来自海外。高禄峰拒绝透露如今的估值。安全性一直是平衡车无法回避的一个问题。甚至赛格威的62岁老板骑着自家的平衡车掉落悬崖而身亡。如今，北京、上海等城市都明令禁止平衡车上路。“代步工具符合大势发展，中国应该制定相关标准，来鉴定产品的安全性。”高禄峰告诉澎湃新闻。不像其他小米生态链企业，纳恩博并没有走“低价销售、服务赚钱”的模式。纳恩博的产品价格比较高，单轮平衡车2000元左右，两轮的要上万，收购后的赛格威产品价格更高。对于未来与小米合作的细节，比如要不要共同推出产品、定价如何，高禄峰均表示“不知道”。全资现金收购平衡车鼻祖赛格威当日发布会，雷军、红杉资本中国基金创始及执行合伙人沈南鹏、顺为资本合伙人程天、华山资本主管合伙人杨镭等中国顶尖的投资人全部到齐。大佬齐聚一堂，宣布了一件更重要的事：纳恩博宣布全资现金收购全球自平衡车开创者赛格威。4月1日，双方签署《股权购买协议》。赛格威发明了世界上第一台智能自动平衡的交通工具，并于2001年问世，2008年借助北京奥运会的契机进入中国市场。赛格威有100名左右员工。收购后，纳恩博获得赛格威旗下三大产品系列的所有权、400多项核心专利，以及全球100多个国家的经销商网络和供应商体系。两个品牌均保留，未来双方将在品牌营销和研发技术上强强联手。高禄峰说，收购价格是保密的。不过他透露，赛格威融资超过4亿美元，盈利情况良好。“我们最早是在2014年2月邮件往来，进行了宽泛的交流。2014年10月进入日程开始收购谈判过程。”高禄峰对澎湃新闻记者表示，“这是痛苦而漫长的过程，我们往返美国很多次，电话会议不计其数，要知道中美时间相差12小时。另外，中美对于收购的法规也不一样。我们在品牌价值的理解是谈判中最大的分歧。”中国科技公司逆袭“中国科技公司走向全球有两种方式：一是自主研发，目前中国软硬件工程师已经具备了很好的竞争力，最近几年有长足的进步；二是通过收购、兼并海外公司，获得知识产权和成熟的市场渠道，这是全新的课题，非常需要勇气。当然，收购只是第一步，整合后能不能做到1+1>2才是关键。”沈南鹏说。雷军说，当纳恩博团队跟股东说想收购赛格威时，“我一秒钟都没有想，我就觉得这件事值得干，这是中国自信！”中国的科技企业正在吸引全球目光。当天发布会上，又出现不少外媒记者。雷军自己的小米自身也是中国成长飞速的科技企业，其手机出货量在全球仅次于三星、苹果，估值450亿美元。在无人机领域，全球规模最大的公司已经来自中国。4月15日，福布斯文章称，深圳大疆创新公司展开新一轮融资，融资规模可能达到数亿美元，估值达到100亿美元。前阵子，美国著名科技媒体人、前华尔街日报记者莫博士（WaltMossberg）来访中国，对中国科技行业的印象大为改观。“在来中国之前，我对中国科技行业的印象还停留在像富士康这样的代工厂，但现在觉得，中国科技行业越来越多的品牌，将通过价格、产品品质，在未来的国际市场占有一席之地。”莫博士记录道,2015/12/24
128,兼容各个操作系统的打开默认浏览器的方法,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9168,"privatestaticvoidopenUrl(Stringurl)throwsException{//获取操作系统的名字StringosName=System.getProperty(""os.name"","""");if(osName.startsWith(""MacOS"")){//苹果的打开方式ClassfileMgr=Class.forName(""com.apple.eio.FileManager"");MethodopenURL=fileMgr.getDeclaredMethod(""openURL"",newClass[]{String.class});openURL.invoke(null,newObject[]{url});}elseif(osName.startsWith(""Windows"")){//windows的打开方式。Runtime.getRuntime().exec(""rundll32url.dll,FileProtocolHandler""+url);}else{//UnixorLinux的打开方式String[]browsers={""firefox"",""opera"",""konqueror"",""epiphany"",""mozilla"",""netscape""};Stringbrowser=null;for(intcount=0;count<browsers.length&&browser==null;count++)//执行代码，在brower有值后跳出，//这里是如果进程创建成功了，==0是表示正常结束。if(Runtime.getRuntime().exec(newString[]{""which"",browsers[count]}).waitFor()==0)browser=browsers[count];if(browser==null)thrownewException(""Couldnotfindwebbrowser"");else//这个值在上面已经成功的得到了一个进程。Runtime.getRuntime().exec(newString[]{browser,url});}}",2015/12/23
129,Linux 开机漏洞,娄会兵,http://180.168.156.212:2262/wecenter/?/article/9164,Linux开机管理程序Grub2出现一项认证旁路(AuthenticationBypass)零时攻击漏洞，黑客只要按28次后退键就可以入侵任何Linux操作系统。新浪科技讯12月21日下午消息，据台媒报道，Linux开机管理程序Grub2出现一项认证旁路(AuthenticationBypass)零时攻击漏洞，黑客只要按28次后退键(Backspace)就可以入侵任何一款Linux操作系统。GRUB(GrandUnifiedBootloader)2是大部分Linux操作系统的开机管理程序，密码防护的重要一环。瓦伦西亚科技大学网络安全小组研究人员HectorMarco与IsmaelRipoll在Grub2中，发现存在一项整数下溢(integerunderflow)漏洞，编号CVE-2015-8370。通过该漏洞成功入侵的黑客可进入GRUB的RescueShell，进而提升权限、复制磁盘信息、安装RootKit、或是摧毁包括GRUB在内的任何资料，即使磁盘加密也可能遭到覆写，导致系统无法工作。研究人员发现该漏洞的攻击方法相当简单：只需在GRUB要求输入用户名时，连续按28次倒退键，就可进入RescueShell。IT管理员只需按照此方法操作，若看到系统重启，或是进入救援模式，即可判断自己系统有此漏洞。事实上，从2009年12月发行的1.98版到2015年12月的2.02版，GRUB2都存在这项漏洞，不过攻击者需要直接接触到机器才能进行攻击。包括Redhat、Ubuntu及Debian在内的Linux系统提供商已迅速修补这项漏洞，Marco与Ripoll也提供了紧急修补程序供下载安装。(张淇),2015/12/23
130,shell [ ]条件测试用法,陈玲,http://180.168.156.212:2262/wecenter/?/article/9163,"[]表示条件测试,中间必须有空格EXPRESSION1-aEXPRESSION2bothEXPRESSION1andEXPRESSION2aretrueEXPRESSION1-oEXPRESSION2eitherEXPRESSION1orEXPRESSION2istrue-nSTRINGthelengthofSTRINGisnonzeroSTRINGequivalentto-nSTRING-zSTRINGthelengthofSTRINGiszero-bFILEFILEexistsandisblockspecial-cFILEFILEexistsandischaracterspecial-dFILEFILEexistsandisadirectory-eFILEFILEexists-fFILEFILEexistsandisaregularfile-gFILEFILEexistsandisset-group-ID-GFILEFILEexistsandisownedbytheeffectivegroupID-hFILEFILEexistsandisasymboliclink(sameas-L)-kFILEFILEexistsandhasitsstickybitset-LFILEFILEexistsandisasymboliclink(sameas-h)-OFILEFILEexistsandisownedbytheeffectiveuserID-pFILEFILEexistsandisanamedpipe-rFILEFILEexistsandreadpermissionisgranted-sFILEFILEexistsandhasasizegreaterthanzero-SFILEFILEexistsandisasocketFILE1isolderthanFILE2-bFILEFILEexistsandisblockspecial-cFILEFILEexistsandischaracterspecial-dFILEFILEexistsandisadirectory-eFILEFILEexists-fFILEFILEexistsandisaregularfile-gFILEFILEexistsandisset-group-ID-GFILEFILEexistsandisownedbytheeffectivegroupID-hFILEFILEexistsandisasymboliclink(sameas-L)-kFILEFILEexistsandhasitsstickybitset-LFILEFILEexistsandisasymboliclink(sameas-h)-OFILEFILEexistsandisownedbytheeffectiveuserID-pFILEFILEexistsandisanamedpipe-rFILEFILEexistsandreadpermissionisgranted-sFILEFILEexistsandhasasizegreaterthanzeroe.g[-f“file”]判断此file是否存在1、编辑文件if#！/bin/bash[-f/etc/shadow]&&ehco""thispcuseshadowpasswd""#/etc/shadow为用户名和密码储存文件，每个linux系统都必须存在2、赋予if文件可执行权限chmoda+xif3、执行if脚本，sourceif，输出一定为：thispcuseshadowpasswd",2015/12/22
131,优秀的 JS 前端框架、库、工具及其使用时机,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9162,"源自：开源中国AngularJSAngular是一款流行的企业级框架，很多程序员都用它来构建和维护复杂的网页应用。Angular拥有巨大的人气，使用它的公司跟Domino的Pizza种类一样多，如Ryanair,iTunesConnect,PayPalCheckout,Google。Angular是一个由Google支持的开源框架。Angular称自己为构建复杂网页应用而对HTML的扩展。如果你也对TypeScript很熟悉，那么可以看看怎样写Angular2.Angular采用MVC架构。它提供了Model层和View层之间双重数据绑定。这种数据绑定方式的好处是不管哪边数据改变，都会自动的更新两边的数据。这有助于你构建可服用的View组件。它还提供了一个前后端服务易于交互的服务框架。最重要的是，它是简单的JavaScript。什么时候使用AngularJS?当你构建一个复杂的网页前端应用并需要一个单独的模块框架去处理一切时。GitHub: 当前版本:2.1.0官方网站:emberjs.comzicode翻译于1周前0人顶顶翻译的不错哦!JQueryJQuery这个库就不用多做介绍了。它独立承担了让跨浏览器网站成为现实的重任，是它使得整个web成为今天这个样子。Web标准的制定以及浏览器厂家对标准的接受方面，jQuery功不可没。jQuery基金会的目标是""通过开源软件的开发和支持，以及社区的协作，增进开放的网络，让每个人都能访问""JQuery是世界上应用最广的JavaScript库，没有应用可以离开它，除非你对开发效率不感兴趣。它使得DOM遍历、事件处理、动画和AJAX在所有浏览器上都变得如此的简单易用。何时使用jQuery?任何时候，除非你打算使用更轻量级的版本，例如Zepto。GitHub: ",2015/12/21
132,关于保存档案检索关键字的遐想,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9161,内容摘入“杨仕强、董海-同音同义拓展检索介绍”“曾经微软花了很多时间让很多高级工程师来对中文的分词算法进行研究，不管再怎么优化的算法，始终对中文的分词还是不够准确。可google公司，通过不断累积的用户检索词库，通过累积的数据量来进行分析，做简单的分词定义，就足够甩微软多个高级工程师多年的分词算法几条街。所以我觉得我们公司现在有档案检索方面的优势，建议我们公司可以对档案方面的检索词库进行收集，做自己的词库，可在平时用户检索和操作过程中对检索词进行收集，并记录到相应词库当中。使词库越来越完善和准确。也是大数据的一种用途。”,2015/12/18
133,帅气的无缝纹理背景资源站,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9160,图鱼！纹理宝库！这个网站的素材会不断的更新，都是由许多非常有才华的设计师设计的，你可以自由免费的下载他们。没有广告，下载方便快捷。还是比较实用的~ ,2015/12/17
134,Flash Professional更名为Adobe Animate CC,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9159,"Adobe官方宣布其Flash动画制作软件FlashProfessionalCC将于2016年起，正式更名为“AdobeAnimateCC”。如今由于大量HTML5内容都是由FlashProfessional制作完成，FlashProfessional早已不再局限于制作和发布Flash内容(swf,air),而已经俨然成为了HTML5内容（动画、广告）制作的标准工具。鉴于此，Adobe更名FlashProfessional为AdobeAnimate。官方说明： /flashpro/welcome-adobe-animate-cc-a-new-era-for-flash-professional/",2015/12/16
135,有哪些鲜为人知却非常有意思、好用的 Chrome 扩展？,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9158,"来源：知乎一、Chrome扩展：coplay-ChromeWebStoreFirefox附加组件： /cf04efd58581a7b3c4b5acd170634395_r.jpg""&gt;以上",2015/12/16
136,财政部、国家档案局联合发布《会计档案管理办法》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9157, 会计档案管理办法附件：会计档案保管期限表.docx会计档案管理办法.mht,2015/12/15
137,《你刚才在淘宝上买了一件东西》,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9156,你发现快要过年了，于是想给你的女朋友买一件毛衣，你打开了 /blog/254459622/799372165,2015/12/15
138,虚拟现实有多火热？,孟帅,http://180.168.156.212:2262/wecenter/?/article/9155,"虚拟现实技术使得人们可以探索人工构建的世界，我们只要戴上虚拟现实设备，足不出户就能走遍全世界。但是，计算机处理能力和内存方面的限制让虚拟现实设备的使用体验并没有想象中那么美好。从目前来看，不少科技大品牌都会在2016年推出自家的虚拟现实设备，今天，我们就来说一说值得考虑的几款虚拟现实设备。 /upload/ar...tn.png)no-repeat;"">0FreeflyVR同样是基于智能手机平台的虚拟现实头戴显示器，独特的“翼式”设计能将手机牢牢固定在镜头前，并且兼容Android、iOS以及Windows等3个移动平台的智能设备。这款设备内置陀螺仪、加速度计和数字罗盘，兼容谷歌纸板眼镜的应用，虽然造型有点奇特，但是舒适的佩戴体验和丰富的应用资源还是非常值得考虑的",2015/12/14
139,Ruby语言学习系列--基本的ruby语法,赵本,http://180.168.156.212:2262/wecenter/?/article/9154,"1.基本的ruby语法1.1变量、常量和类型1)定义变量变量类型描述示例局部变量（或伪变量）以小写字母或下划线卡头var_var全局变量以$开头$var类变量类中定义，以@@开头@@var实例变量对象中定义，以@开头@var常量以大写字母开头Var2)变量内插在双引号内使用“#{变量名}”内插变量a=2b=3puts""#{a}+#{b}=#{a+b}""#输入结果为：2+3=51.2注释1）单行注释：以#开头，如：#注释内容2）多行注释：在=begin和=end之间定义，如：=begin注释内容=end1.3循环和分支1.3.1条件语句If形式unless形式a=1ify==3a=1unlessy!=3x=ifa>0thenbelsecendx=unlessa<=0thenaelsebendifx<5thena=1elsea=2endunlessx<5thena=2elsea=1end1.3.2循环结构#while循环i=0whilei<list.sizedoprint“#list[i]”I+=1end#until循环i=0untili==list.sizedoprint“#list[i]”i+=1end#for循环forxinlisydoprint“#{x}”end#each循环list.eachdo|x|print“#{x}”end#loop循环i=0n=list.size-1loopdoprint“#{list[i]}”i+=1breakidi>nend#times循环n=list.sizen.timesdo|i|print“#{list[i]}”end#upto循环n=list.size–10.upto(n)do|i|print“#{list[i]}”end#each_index循环list.each_indexdo|x|print“#{list[x]}”end1.3.3异常beginx=Math.sqrt(y/z)rescueArgumentError#匹配错误类型puts""Errortakingsquareroot""rescueZeroDivisionError#匹配错误类型puts""Attempteddivisionbyzero""elseputs""OtherError""ensure#这部分代码在最后一定会执行end1.3.4类classHello#类名必须以大写字母开头@@myname=""John""#类变量definitialize(name,phone)@name,@phone=name,phone#定义实例变量enddefhello#定义类方法puts""#{@name}的电话是#{@phone}""endendf=Hello.new(""Tom"",""13100000000"")#创建类对象f.hello#调用类方法，结果为：Tom的电话是131000000001.3.5模块方法说明include‘watir’将模块的功能添加到当前空间中，不加载已加载的文件extend‘watir’将模块的函数添加到对象中load‘watir’读取文件，并将其插入到源文件的当前位置，以便从这个位置开始就可以使用其定义1.3.6case语句casexwhen1..10#匹配数字puts""Firstbranch""whenfoobar()#批量方法返回的值puts""Secondbranch""when/^hel.*/#匹配正则表达式puts""Thirdbranch""elseputs""Lastbranch""endRuby语言学习系列--String类函数函数名称说明示例*将字符串拷贝N次“ha”*4>>“hahahaha”+<<concat连接字符串“yes”+“no”>>“yesno”""yes""<<""no"">>“yesno”""yes"".concat(""no"")<=>比较字符串，返回值如下：大于：-1等于：0小于：1""Ab""<=>""ab"">>-1""ab""<=>""ab"">>0""ab""<=>""Ab"">>1==或===判断两个对象是否相等""1""==""1"">>true""1""==1>>flase=~匹配正则表达式""abc123abc""=~/""d/>>3[]或slice返回字符串的某一范围内的值“abc”[0,2]>>“ab”""hello""[/llo/]>>“llo”“abc”slice[0,2]>>“ab”[]=替换字符串的某一范围内的值a=“helloword”a[1,2]=“OO”putsa>>”hOOloword”capitalizecapitalize!把字符串的首字母大写，其他字母小写""hi,Ruby"".capitalize>>“Hi,ruby”chompchomp!删除字符串后的空白字符""string""r""n"".chomp>>”string”chop删除最后一个字符""string"".chop>>“strin”count返回该字符串中含的字符个数a=""helloworld""a.count""lo"">>5(l出现3次，o出现2次)deletedelete!删除字符""hello"".delete""l"",""lo""?""heo""""hello"".delete""lo""?""he""downcasedowncase！将大写字母改写为小写""hEllO"".downcase?""hello""upcaseupcase！将小写字母改写为大写""hEllO"".upcase?""HELLO""swapcaseswapcase!将所有的大写字母改为小写字母，小写字母改为大写字母。""Hello"".swapcase?""hELLO""each对字符串中的各行进行迭代操作""Hi""nRuby"".each{|s|putss}each_byte对字符串中的各个字节进行迭代操作""Hi""nRuby"".each_byte{|s|putss}each_line对字符串中的每一行进行迭代操作""Hi""nRuby"".each_line{|s|putss}empty?判断字符串是否为空""hello"".empty??false"""".empty??truegsubgsub！以replace来替换字符串中所有与pattern相匹配的部分""hello"".gsub(/[aeiou]/,'*')?""h*ll*""hash返回字符串的哈希值""h"".hash>>107include?若字符串中包含substr子字符串的话,就返回真""hello"".include?""lo""?true""hello"".include?""ol""?falseindex按照从左到右的顺序搜索子字符串,并返回搜索到的子字符串的左侧位置.若没有搜索到则返回nil""hello"".index('lo')?3""hello"".index('a')?nillength返回字符串的字节数""hello"".length>>5replace替换字符串的内容s=""hello""?""hello""s.replace""world""?""world""sub或sub!用replace来替换首次匹配pattern的部分。""hello"".sub(/[aeiou]/,'*')?""h*llo""reversereverse!对字符串进行反转""stressed"".reverse?""desserts""scan使用正则表达式re反复对self进行匹配操作,并以数组的形式返回匹配成功的子字符串a=""cruelworld""a.scan(/""w+/)?[""cruel"",""world""]a.scan(/.../)?[""cru"",""el"",""wor""]split使用sep指定的pattern来分割字符串,并将分割结果存入数组""mellowyellow"".split(""ello"")?[""m"",""wy"",""w""]squeezesqueeze!压缩由str所含字符构成的重复字符串""yellowmoon"".squeeze?""yelowmon""""nowisthe"".squeeze("""")?""nowisthe""stripstrip!删除头部和尾部的所有空白字符。空白字符是指""""t""r""n""f""v""。""hello"".strip?""hello""""""tgoodbye""r""n"".strip?""goodbye""tr或tr!若字符串中包含search字符串中的字符时，就将其替换为replace字符串中相应的字符hello"".tr('aeiou','*')?""h*ll*""""hello"".tr('^aeiou','*')?""*e**o""tr_s或tr_s！若字符串中包含search字符串中的字符时，就将其替换为replace字符串中相应的字符。同时，若替换部分中出现重复字符串时，就将其压缩为1个字符""hello"".tr_s('l','r')?""hero""""hello"".tr_s('el','*')?""h*o""""hello"".tr_s('el','hx')?""hhxo""upto在从self到max的范围内，依次取出下一个字符串”后将其传给块，进行迭代操作""a1"".upto(""a3""){|s|putss}?a1""na2""na3to_f将字符串转为浮点数""45.67degrees"".to_f?45.67to_i将字符串转为整数""99redballoons"".to_i?99to_s将字符串转为字符串ruby学习系列--Hash类函数函数名称说明示例==判断两个Hash是否相等h1={""a""=>1,""c""=>2}h2={""a""=>1,""c""=>2,7=>35}h1==h2?false[]返回指定键值对应的对象h={""a""=>100,""b""=>200}h[""a""]?100h[""c""]?nil[]=向Hash添加记录h={""a""=>100,""b""=>200}h[""a""]=9h[""c""]=4h?{""a""=>9,""b""=>200,""c""=>4}clear清空哈希表的内容.返回self.h={""a""=>100,""b""=>200}h.clear?{}default返回哈希表的默认值h={""a""=>100,""b""=>200}h.default=""Gofish""h[""a""]?100h[""z""]?""Gofish""delete从词典中删除和键值相符的记录h={""a""=>100,""b""=>200}h.delete(""a"")?100h.delete(""z"")?nilh.delete(""z""){|el|""#{el}notfound""}?""znotfound""delete_if通过过程块来删除特定键值的记录h={""a""=>100,""b""=>200}h.delete_if{|key,value|key>=""b""}?{""a""=>100}eachHash表的迭代操作，对表的每一个词对进行迭代操作h={""a""=>100}h.each{|key,value|printkey,""is"",value,""""n""}?ais100each_key对表的每一个键对进行迭代操作h={""a""=>100,""b""=>200}h.each_key{|key|printkey}?abeach_value针对value进行迭代操作h={""a""=>100,""b""=>200}h.each_value{|value|printvalue}?100200empty?判断哈希表是否为空，空则返回true{}.empty??truefetch如果能找到键值为key的hash值，则返回Hash值；如果找不到，则返回默认值或指定值；如果默认值和指定值都找不到，抛异常h={""a""=>100,""b""=>200}h.fetch(""a"")?100h.fetch(""z"",""gofish"")?""gofish""h.fetch(""k"")?in`fetch':keynotfound(IndexError)has_key?判断是否存在相符的key值h={""a""=>100,""b""=>200}h.has_key?(""a"")?trueh.has_key?(""z"")?falsekey？h.key?(""z"")?falseinclude?h.include?(""b"")?truehas_value?判断是否存在相符的value值h={""a""=>100,""b""=>200}h.has_value?(100)?trueh.has_value?(999)?falsevalue?h.value?(100)?trueh.value?(999)?falseindex返回给定值的键值，未找到返nilh={""a""=>100,""b""=>200}h.index(200)?""b""h.index(999)?nilindexes返回一系列给定的键值对应值组成的数组h={""a""=>100,""b""=>200,""c""=>300}h.indexes(""a"",""c"")?[100,300]h.indexes(""a"",""z"")?[100,nil]indicesh.indexes(""a"",""c"")?[100,300]h.indexes(""a"",""z"")?[100,nil]invert将元素值和索引互换,返回变换后的哈希表.注意:若原哈希表中若干不同的索引对应相同的元素值时,其变换结果将无法预测.h={""n""=>100,""m""=>100,""y""=>300}h.invert?{300=>""y"",100=>""n""}keys返回一个包含所有key的数组.h={""a""=>100,""b""=>200}h.keys?[""a"",""b""]values返回一个包含所有vakue的数组.h={""a""=>100,""b""=>200,""c""=>300}h.values?[100,200,300]length返回词典中元素的个数h={""d""=>100,""a""=>200,""v""=>300}h.length?3h.size?3sizerehash重新计算索引对应的哈希表值。当与索引对应的哈希表值发生变化时，若不使用该方法来重新计算的话，将无法取出与索引对应的哈希表值。a=[""a"",""b""]c=[""c"",""d""]h={a=>100,c=>300}a[0]=""z""h.rehash?{[""z"",""b""]=>100,[""c"",""d""]=>300}h[a]?100replace以另外一张Hash表的内容来替换当前Hash表的内容h={""a""=>100,""b""=>200}h.replace({""c""=>300,""d""=>400})?{""c""=>300,""d""=>400}shift删除一个哈希表元素后再以[key,value]数组的形式将其返回h={1=>""a"",2=>""b"",3=>""c""}h.shift?[1,""a""]h?{2=>""b"",3=>""c""}sort对Hash进行排序按键值从小到大排序h={""b""=>30,""a""=>20,""c""=>10}h.sort?[[""a"",20],[""b"",30],[""c"",10]]h.sort{|a,b|a[1]<=>b[1]}?[[""c"",10],[""a"",20],[""b"",30]]to_a把Hash表转换为数组数组按Hash表的键值从小到大排序h={""c""=>300,""a""=>100,""d""=>400}?[[""a"",100],[""c"",300],[""d"",400]]to_s把Hash表转换为字符串h={""c""=>300,""a""=>100,""d""=>400}h.to_s?""a100c300d400""update用一张Hash表去更新另外张Hash表h1={""a""=>100,""b""=>200}h2={""b""=>254,""c""=>300}h1.update(h2)?{""a""=>100,""b""=>254,""c""=>300}Ruby语言学习系列--Array类函数函数名称说明示例&数组与，返回两数组的交集[1,2]&[2,3]?[2]*复制数组n次[1,2]*2?[1,2,1,2]+返回两数组的并集，但不排除重复元素[1,2]+[2,3]?[1,2,2,3]<<追加元素，但不排除重复元素[1,2]<<[2,3]?[1,2,2,3]|追加元素，但排除重复元素1,2]|[2,3]?[1,2,3]-返回第一个数组与第二个数组不同的元素[1,2]-[2,3]?[1]<=>比较数组[1,2]<=>[2,3]?flase==比较数组，若所有元素均相等时返回真[1,2]==[2,1]?flaseassoc从数组的每个元素中寻找指定对象[[1,2],[3,4]].assoc(2)?[1,2]at找到数组的第N个元素负数表示逆向查找[""a"",""b"",""c"",""d"",""e""].at(0)?""a""[""a"",""b"",""c"",""d"",""e""].at(-1)?""e""clear删除数组中的所有元素[""a"",""b"",""c"",""d"",""e""].clearcollectcollect！用一个过程块对数组的每个元素进行处理[""a"",""b"",""c"",""d""].collect{|x|x+""!""}?[""a!"",""b!"",""c!"",""d!""]compactcompact!删除值为nil的元素后生成新数组并返回它[""a"",nil,""b"",nil,""c"",nil].compact?[""a"",""b"",""c""]delete删除元素，如果元素重复，全部删除a=[""a"",""b"",""b"",""b"",""c""]a.delete(""b"")putsa?[""a"",""c""]delete_at删除pos所指位置的元素并返回它。若pos超出数组范围则返回nila=%w(antbatcatdog)a.delete_at(2)?""cat""a?[""ant"",""bat"",""dog""]a.delete_at(99)?nildelete_if根据条件删除a=[""a"",""b"",""c""]a.delete_if{|x|x>=""b""}?[""a""]each对数组的每个元素按值进行迭代操作a=[""a"",""b"",""c""]a.each{|x|printx,""--""}?""a--b--c--""each_index对数组的每个元素按索引进行迭代操作a=[""a"",""b"",""c""]a.each_index{|x|printx,""--""}?""0--1--2--""empty?判断数组是否为空，为空则返回真[].empty??trueeql！比较两数组是否相等[""a"",""b"",""c""].eql?([""a"",""b"",""c""])?truefill填充数组[""a"",""b"",""c"",""d""].fill(""x"")?[""x"",""x"",""x"",""x""][""a"",""b"",""c"",""d""].fill(""z"",2,2)?[""x"",""x"",""z"",""z""]first返回数组的首元素。若没有首元素则返回nil[""q"",""r"",""s"",""t""].first?""q""last返回数组末尾的元素。若数组为空时，返回nil[""w"",""x"",""y"",""z""].last?""z""include?判断数组中是否包含元素a=[""a"",""b"",""c""]a.include?(""b"")?truea.include?(""z"")?falseindex返回数组中第一个==val的元素的位置a=[""a"",""b"",""c""]a.index(""b"")?1a.index(""z"")?nilindexes以数组形式返回其索引值与各参数值相等的元素a=[""a"",""b"",""c"",""d"",""e"",""f"",""g""]a.indexes(0,2,4)?[""a"",""c"",""e""]a.indexes(2,4,12)?[""c"",""e"",nil]insert在索引为nth的元素前面插入第2参数以后的值ary=%w(foobarbaz)ary.insert2,'a','b'pary?[""foo"",""bar"",""a"",""b"",""baz""]join将数组元素按一定的分隔符连接起来[""a"",""b"",""c""].join?""abc""[""a"",""b"",""c""].join(""-"")?""a-b-c""lengthsize返回数组长度。若数组为空则返回0[1,2,3].length?3[1,2,3].size?3nitems返回非nil元素的个数[1,nil,3,nil,5].nitems?3pop删除末尾元素并返回它。若数组为空则返回nila=[""a"",""m"",""z""]a.pop?""z""pa?[""a"",""m""]push添加新元素[""a"",""b""].push(['1','2'])?[""a"",""b"",[""1"",""2""]]rassoc遍历数组每个元素（元素必须是数组），匹配索引为1的值是否与查找的字符相等，返回第一个相等的元素a=[[15,1],[25,2],[35,2]]pa.rassoc(2)?[25,2]replace替换数组元素a=[""a"",""b""]a.replace([""x"",""y"",""z""])pa?[""x"",""y"",""z""]reversereverse！将所有元素以逆序重新排列生成新数组并返回它[""a"",""b"",""c""].reverse?[""c"",""b"",""a""]rindex返回最后一个值相等的元素的索引值a=[""a"",""b"",""b"",""b"",""c""]a.rindex(""b"")?3shift删除数组的首元素并返回它。剩余元素依次提前。若数组为空返回nil。args=[""-m"",""-q"",""filename""]args.shift?""-m""args?[""-q"",""filename""]sortsort!从小到大排序a=[""d"",""a"",""e"",""c"",""b""]a.sort?[""a"",""b"",""c"",""d"",""e""]uniquniq！删除数组中的重复元素后生成新数组并返回它a=[""a"",""a"",""b"",""b"",""c""]a.uniq?[""a"",""b"",""c""]unshift在数组第一个元素前添加元素a=[""b"",""c"",""d""]a.unshift(""a"")?[""a"",""b"",""c"",""d""]to_s将数组的所有元素连接成字符串[""a"",""e"",""i"",""o""].to_s?""aeio""Ruby语言学习系列--Numeric类函数函数名称说明示例chr返回数字的ACSII码65.chr>>“A”downto接收一个block,从大到小循环执行5.downto(2){|i|putsi}>>5432upto接收一个block,从小到大循环执行2.upto(5){|i|putsi}>>2345next或succ返回下一个数1.next>>21.succ>>2step以固定步长循环执行1.step(10,2){|i|putsi}>>12357times循环执行n次5.times{|i|putsi}>>12345Ruby语言学习系列--Float类函数函数名称说明示例ceil返回比float大的最小整数(2.98).ceil>>3floor返回比float小的最大整数(2.98).floor>>2round四舍五入到一个整数(2.98).round>>3to_i返回float截掉小数点后的整数(2.98).to_i>>2",2015/12/14
140,ruby on Rails使用教程,赵本,http://180.168.156.212:2262/wecenter/?/article/9153,"1前提条件本文针对想从零开始开发Rails程序的初学者，不需要预先具备任何的Rails使用经验。不过，为了能顺利阅读，还是需要事先安装好一些软件： .erb文件的“Hello,Rails!”，说明新定义的路由把根目录交给WelcomeController的index动作处理了，而且也正确的渲染了视图。 welcome#index",2015/12/14
141,intellij idea简单实用教程,赵本,http://180.168.156.212:2262/wecenter/?/article/9152,".创建项目intellij里面file-->createproject是会创建一个的workspace的，比如我创建了一个ijtest,里面可以添加modules，这个modules才是正真的项目，创建项目的时候可以选择是新建一个项目还是从其他地方导入项目，其他地方可以是eclipse的工作区。3.添加框架，编辑class输出目录如上图，点击项目右键-->Openmodulesettings-->modules--->点项目选择usemodulecompileoutputpath用intellij启动main函数的时候可以在EditConfigurations里面选择main函数指定classes的读取路径4.添加tomcat，集成tomcat，部署项目到tomcat启动tomcat6就可以看到你的项目已经部署上去了5.intellij的快捷键ctrl+shift+space(new后面自动提示)ctrl+shift+/(注释)itar后面tab(for循环)it后面ctrl+j(很多智能代码生成)Alt+Insert(自动生成构造函数，get,set方法)ctrl+alt+t(自动生成try,catch)alt+enter(创建测试类和子类)ctrl+shift+backspace(最后编辑的地方)ctrl+e(查看所有文件)ctrl+shift+v(粘贴)alt+shift+c(最近变更历史)ctrl+shift+enter(智能完善代码如if())ctrl+shift+i(快速查看实现)ctrl+shift+up/down(移动行、合并选中行)",2015/12/14
142,Web 前沿——HTML5 Form Data 对象的使用,吴晓明,http://180.168.156.212:2262/wecenter/?/article/9151,"1.创建一个FormData对象你可以先创建一个空的FormData对象,然后使用append()方法向该对象里添加字段，如下：varoMyForm=newFormData();oMyForm.append(""username"",""Groucho"");oMyForm.append(""accountnum"",123456);//数字123456被立即转换成字符串""123456""//fileInputElement中已经包含了用户所选择的文件oMyForm.append(""userfile"",fileInputElement.files[0]);varoFileBody=""<aid=""a""><bid=""b"">hey!</b></a>"";//Blob对象包含的文件内容varoBlob=newBlob([oFileBody],{type:""text/xml""});oMyForm.append(""webmasterfile"",oBlob);varoReq=newXMLHttpRequest();oReq.open(""POST"","" /submitform.php"");oReq.send(oMyForm);注：字段""userfile""和""webmasterfile""的值都包含了一个文件。通过FormData.append()方法赋给字段""accountnum""的数字被自动转换为字符（字段的值可以是一个Blob对象，File对象或者字符串，剩下其他类型的值都会被自动转换成字符串）。在该例子中，我们创建了一个名为oMyForm的FormData对象，该对象中包含了名为""username""，""accountnum""，""userfile""以及""webmasterfile""的字段名，然后使用XMLHttpRequest的send()方法把这些数据发送了出去。""webmasterfile""字段的值不是一个字符串,还是一个Blob对象。2.使用HTML表单来初始化一个FormData对象可以用一个已有的form元素来初始化FormData对象，只需要把这个form元素作为参数传入FormData构造函数即可：varnewFormData=newFormData(someFormElement);例如：varformElement=document.getElementById(""myFormElement"");varoReq=newXMLHttpRequest();oReq.open(""POST"",""submitform.php"");oReq.send(newFormData(formElement));你还可以在已有表单数据的基础上，继续添加新的键值对，如下：varformElement=document.getElementById(""myFormElement"");formData=newFormData(formElement);formData.append(""serialnumber"",serialNumber++);oReq.send(formData);3.使用FormData对象发送文件你还可以使用FormData来发送二进制文件.首先在HTML中要有一个包含了文件输入框的form元素：<formenctype=""multipart/form-data""method=""post""name=""fileinfo""><label>Youremailaddress:</label><inputtype=""email""autocomplete=""on""autofocusname=""userid""placeholder=""email""requiredsize=""32""maxlength=""64""/><br/><label>Customfilelabel:</label><inputtype=""text""name=""filelabel""size=""12""maxlength=""32""/><br/><label>Filetostash:</label><inputtype=""file""name=""file""required/></form><divid=""output""></div><ahref=""javascript:sendForm()"">Stashthefile!</a>然后你就可以使用下面的代码来异步的上传用户所选择的文件：functionsendForm(){varoOutput=document.getElementById(""output"");varoData=newFormData(document.forms.namedItem(""fileinfo""));oData.append(""CustomField"",""Thisissomeextradata"");varoReq=newXMLHttpRequest();oReq.open(""POST"",""stash.php"",true);oReq.onload=function(oEvent){if(oReq.status==200){oOutput.innerHTML=""Uploaded!"";}else{oOutput.innerHTML=""Error""+oReq.status+""occurreduploadingyourfile.<br\/>"";}};oReq.send(oData);}4.你还可以使用jQuery来发送FormData，但必须要正确的设置相关选项：varfd=newFormData(document.getElementById(""fileinfo""));fd.append(""CustomField"",""Thisissomeextradata"");$.ajax({url:""stash.php"",type:""POST"",data:fd,processData:false,//告诉jQuery不要去处理发送的数据contentType:false//告诉jQuery不要去设置Content-Type请求头});",2015/12/10
143,人民币被纳入特别取款权（SDR）货币篮子，就成为世界货币了吗？,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9150,链接： /question/...97628来源：知乎问题1.什么是特别提款权？特别提款权是基金组织于1969年创造的一种用于补充成员国官方储备的国际储备资产。特别提款权的价值目前根据由四种主要货币（美元、欧元、日元和英镑）组成的货币篮子确定。2016年10月1日新货币篮子生效后，篮子将扩大，中国的人民币将作为第五种货币加入篮子。基金组织通常根据每个成员国在基金组织的份额，将特别提款权分配给成员国。到目前为止，总共分配了2041亿特别提款权，最近一次分配是在2009年，分配额为1826亿特别提款权。特别提款权不是货币，也不是对基金组织的债权，而是对基金组织成员国的可自由使用货币的潜在求偿权。特别提款权的持有方可以通过两种方式以其持有的特别提款权换取这些货币：一是通过成员国之间的自愿交换安排；二是基金组织指定对外状况强健的成员国从对外状况薄弱的成员国购买特别提款权。除了作为补充性储备资产外，特别提款权还是基金组织和其他一些国际组织的记账单位。特别提款权也被用于基金组织与成员国的融资安排。问题2.如何定义一种“可自由使用”的货币？根据《基金组织协定》，如果基金组织认定一个成员国的货币事实上广泛用于国际交易支付，并且在主要外汇市场上广泛交易，那么该货币被定义为“可自由使用”货币。可自由使用货币的概念关注货币的实际国际使用和交易，不能等同于某种货币是否自由浮动或完全可兑换。一种货币可以被广泛使用和广泛交易，即使其受到一些资本账户的限制（过去，英镑和日元被认定为可自由使用货币时，仍存在一些资本账户管制）。另一方面，某种完全可兑换的货币未必被广泛使用和广泛交易。可自由使用的概念在基金组织的资金操作中起着核心作用。具体而言，接受基金组织资金援助的成员国有权得到以可自由使用货币提供的这种援助。的确，基金组织的贷款业务实际上是通过可自由使用货币或特别提款权来进行的。在使用特别提款权的情况下，借款国有权将特别提款权兑换成可自由使用货币。在资金操作中，可自由使用的概念旨在确保成员国能够直接或间接地（不受损失地兑换成另一种货币）利用从基金组织获得的货币来满足国际收支融资需求。传统意义的世界货币依然只有美元，不要说人民币，更老牌的英镑、日元和欧元都只是美元的补充。美元在国际贸易中的地位仍然是无法替代的，金融市场上自然不用说，还有个具有代表性的是黑市交易，其他货币都只能在发行国周边很小的范围内通用，美元则广为接受。诚然，美元的地位日益衰落，但这并不意味着人民币会替代它成为世界货币。因为布雷顿森林体系的崩溃揭示了以单一国家货币作为世界货币的内在矛盾：特里芬难题。简言之：世界货币必须币值稳定，很容易理解，煎饼果子今天一元明天两元后天八角谁也受不了（嗯，八角你们是高兴，卖家不干了），这也是为什么布雷顿森林体系要求美元与黄金挂钩，于是就要求美国的国际收支长期顺差；另一方面，作为世界货币必须供给充足且大量以离岸货币形式存在，也就是说美国要长期逆差，这正是现实中发生的状况。一个国家的国际收支显然不可能既逆差又顺差，所以布雷顿森林体系无可避免地崩溃了。西欧国家和日本纷纷提出用美元兑换黄金的要求，美国锁上金库满地打滚大喊“不玩了”。任何货币想取代美元都将面临这个问题，人民币也不例外。未来的“世界货币”只能是以某种货币篮子甚至更广泛的资产组合为基准的，SDR就是这样一种试验性安排。然而鉴于货币发行权对于各国金融体系的重要性，类似SDR的工具在相当长的时期内只能作为外汇储备而不可能被直接用于国际交易甚至国内交易，最好的局面也就是成为一种被政府及金融机构广泛接受的中间货币而存在于国际交易中。欧元区债务危机就是贸然统一货币的前车之鉴，如果南欧诸国自己发行货币，虽然主权债评级一样会下滑，但至少能把债务还清，而使用欧元却有无法如期还债的风险。这还只是在欧元区的范围内，世界货币面临的局面显然要复杂得多。最后需要强调的是，人民币成为SDR篮子货币不是国际化的开端，而是国际化的阶段性成果，政治因素是肯定存在的，权重就是政治博弈的结果，但是就进入SDR货币篮子这件事而言，人民币受国际市场的欢迎才是根本原因。正如IMF所言：是人民币在国际市场上的表现达到了既定标准。在人民币国际化这个问题上不要本末倒置，货币是为经济服务的，其国际地位和经济发展水平相辅相成，揠苗助长只会带来不必要的风险。,2015/12/8
144,图灵奖得主：思考比编码重要,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9149,兰伯特现任美国微软研究院首席研究员，也是2013年有着“计算机界诺贝尔奖”之称的图灵奖获得者。此次他经北京大学“大学堂”顶尖学者讲学计划的邀请，与该校师生开展了交流，而此次交流的核心则是：思考，比写代码更加重要。编码也须锻炼“肌肉”如何才能写出更优质的程序呢？这是记者和很多现场学生关心的一个话题。“工程师在砌砖建房之前会画一张建筑蓝图；但程序员和软件工程师往往不会这样做。这是不是房屋很难倒塌而编程经常出问题的原因呢？”报告结束后，在接受《中国科学报》记者采访时，兰伯特对比说，很多程序员在开始编写程序之前，往往不愿意勾勒哪怕是一个最简易的程序轮廓。蓝图可以帮助工程师保证计划发挥作用。“‘发挥作用’不只意味着让大楼不倒塌，还意味着为所需要的目的服务，比如让建筑师和客户在施工之前了解他们打算建造什么样的工程。”兰伯特如是说，“蓝图可以帮助我们考虑清楚，我们在编写什么。”为编写软件所描绘的蓝图就是规范（spec）。然而，“计划赶不上变化，就像没有哪一场战争真正能够按计划进行一样，你做出的规范也有可能发生程式错误。”兰伯特说。比如，或者是必要条件发生了改变，或者是出现了错误，可能在你写完程序之前，就需要改变原来的规范。事实上，在真实世界中，代码可以修补，而规范也可以更新，这些都很普遍。那么，如果修补和更新不可避免，那么为什么要描绘这张蓝图呢？对此，兰伯特表示原因有二：其一，无论是谁在修补代码，都会由衷感谢规范中的每个词、每个公式的作者；其二，代码每修复一次，就会“变丑一点，更难理解一点，也更难维护”。“因此，如果不从思考规范开始，那么程序员所写的代码的每个片段就都是补丁。这样就会让一开始编写的程序变得丑陋、难以理解和维持下去。”兰伯特说。“为什么编码难？因为编码需要思考，思考存在难度，而很多人往往低估了思考的难度。”他说，“正如漫画家迪克·金敦（DickGuindon）所说的那样，‘写作是让你知道你的思想有多么混乱的根本方法。’”“思考不能保证你不犯错误，但是不思考通常一定会犯错误。”没有什么简单的方法可以保证一个人能够写出好的spec，兰伯特说。“编码就像跑步，你跑得越少，跑得也就越慢。所以必须经常反复锻炼你的编码‘肌肉’，而不是像很多人那样找借口不锻炼。”,2015/12/7
145,中国食品安全典型十大案例(2015)发布,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9146,"中国食品安全典型十大案例(2015)发布来源：法制日报蒋安杰更新时间：2015年12月02日【字体：大中小】11月24日,由中国人民大学食品安全治理协同创新中心、中国法律评论、知识产权出版社共同主办的中国食品安全典型案例发布暨学术研讨会在中国人民大学举行,研讨会邀请了学术界、政府监管部门、法律实务界和食品行业的代表,法律、公管、农业、食品科学、环境学等多学科的专家参与。法律出版社总编辑助理张雪纯,知识产权出版社副社长李程,食品安全治理协同创新中心常务副主任、中国人民大学法学院院长韩大元在会上发言。会议由中国人民大学法学院副院长杜焕芳主持。食品安全是重大的民生问题,习近平总书记指出“能不能在食品安全上给老百姓一个满意的交代,是对我们执政能力的重大考验”;党的十八届四中全会提出全面推进依法治国的宏伟蓝图,推进食品安全法治化,提升食品安全治理水平也是其中一项重要的任务;党的十八届五中全会公报提出“推进健康中国建设,实施食品安全战略”。在国家治理体系现代化进程中,保障国民健康素质,确保舌尖上的安全,为民众生活提供安全是政府的基本义务。韩大元在发言中提到,食品安全治理体系建设是一个系统化、长期化的过程。2013年,中国人民大学与清华大学、华南理工大学、国家食品药品监督管理总局、国家食品安全风险评估中心等单位共同建立食品安全治理协同创新中心。协同创新中心以健全食品安全治理体系、提升食品安全治理能力、推进食品安全法治保障、培育传承食品安全文化为使命,坚持问题导向,动员社会各界积极参与,努力构建食品安全社会共治的格局。据悉,此次发布为首次。会议发布了《中国食品安全典型十大案例(2015)》。",2015/12/3
146,"怎么去掉让人极其不爽的“如果您的浏览器不支持跳转,请点击这里.”",杨安荣,http://180.168.156.212:2262/wecenter/?/article/9148,"爱存档网站（ /，即档案云）是我司战略规划的“两朵云”之一（还有一个是追溯云 ），但只要一访问这个网址，就会出来：如果您的浏览器不支持跳转,请点击这里.据公司某位技术大虾说这是该网站技术牛叉的标志之一，因为要实现网站支持各种可能的浏览器以及各种终端屏幕大小自适应，只能用枚举法进行设置（有兴趣研究的童鞋可以直接查看该网页的源码），这就会导致一旦碰到没有穷举到的终端+浏览器组合，就会出来令人讨厌的“如果您的浏览器不支持跳转,请点击这里.”是不是这样？我想比我们先进的网站多了去了，别人为什么不是酱紫的？",2015/12/3
147,国家档案局11号令：《城市社区档案工作规定》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9145, 这个规定貌似离我们有点远，但最后面的归档范围和保管期限表有一定的参考价值。国家档案局11号令《城市社区档案工作规定》.mht,2015/12/3
148,关于IE兼容性视图和产品IE兼容性问题处理经验,管俊,http://180.168.156.212:2262/wecenter/?/article/9144,"IE浏览器是前端开发人员的恶梦，除了和流行的webkit内核（Chrome,Safari等）、Gecko内核（Firefox）不兼容外，自身历史版本也存在相互不兼容（尤其IE8与IE9）的情况。本文针对IE浏览器的兼容视图以及IE版本判别的前端处理分享一些经验。1、IE兼容性视图“IE兼容性视图”是自IE8以后版本提供的一个切换文档渲染内核的用户级功能，方便用户在新版IE浏览器访问老版页面时可能出现渲染问题的一种快速切换。同样IE8及以后版本同样提供了针对技术人员和开发人员的切换渲染内核版本功能，可以通过“开发人员工具”来选择“文本模式”。当用户选择兼容性视图，如果页面上没有强制使用文档模式版本的设定（见第二节），浏览器会选择降一个版本的模式来渲染。比如IE11浏览器，兼容视图会采用IE10文档模式渲染。而开发人员工具则可以有更多选择。值得注意的是，虽然开发人员工具中可选的文档模式版本和IE浏览器的版本对应，但有时候实际渲染效果可能与对应版本的浏览器渲染效果不尽相同。2、X-UA-Compatible<metahttp-equiv=""X-UA-Compatible""content=""IE=7;IE=9""/>此标签是自IE8及以上版本支持的IE浏览器专属标签。如果在页面中的<head>标签内设置，页面会通知浏览器强制按content中设置的优先级来选择对应的文档模式渲染本页面。这个时候用户无论是否设置了兼容视图模式，浏览器都会按照标签中的设置的文档模式来渲染（开发者工具中则不受影响）。content中的内容可以是多条记录，也可以是单条记录。多条记录采用分号分隔，注意前后顺序，浏览器会根据当前版本和优先级尝试。比如开头例子中，“IE=7;IE=9”，实际情况如果用户安装了IE7或IE8，则文档采用IE7文档模式渲染。如果IE版本是9或以上，则采用IE9文档模式。单条记录，则不管是何版本浏览器会按设置尝试使用指定的文档模式渲染，比如“IE=6”在IE8和以上版本（此标签IE6、IE7不支持）均采用IE6的文档模式渲染。content中可以指定除对应版本号的文档模式，还有两种记录需要说明，一是IE=EDGE，所谓“边缘版本”即浏览器支持的默认的、最新的渲染内核，比如IE10，IE=EDGE即是相当于10文档模式；二则是Chrome=1，此标签用于早期IE绝对占优市场时，Google为让用户能在IE上使用webkit内核而开发的IE插件，Chrome=1能让装有Chrome插件的IE自动切换到webkit内核渲染。后期，此插件已经不做更新，也就是说标签包含Chrome=1没有任何意义，而且它对国产双核浏览器也不起任何作用。这个标签在实际生产环境中还是相当有用的。系统在部署时客户使用当时的IE浏览器能正常使用，前面提过用户级的兼容模式只是降低一个版本的文档模式，但随着IE浏览器不停升级，有可能会出现兼容性的问题。这时通过此标签强制IE浏览器采用部署时客户的IE版本对应的文档模式渲染，可以比较简单地解决问题。3、条件注释X-UA-Compatible可以作为产品部署后解决兼容性的一个方案。但在产品研发过程中，可能需要使用HTML5特性但需要兼容各种内核浏览器，稳妥的方式是在代码中通过判断浏览器是否支持需要的特性，比如判断方法是否Undefined或使用modernizr.js等特征检测工具检测。但如果是样式文件需要根据不同IE版本调用对应兼容的样式文件或内容，则可以采用<!--[ifIE]>Content<![endif]-->IE独有的标签更为方便。具体使用方式可以参考下面例子：<pclass=""accent""><!--[ifIE]>此浏览器是IE浏览器<br/><![endif]--><!--[ifIE6]>此浏览器是IE6版本<br/><![endif]--><!--[ifIE7]>此浏览器是IE7版本<br/><![endif]--><!--[ifIE8]>此浏览器是IE8版本<br/><![endif]--><!--[ifIE9]>此浏览器是IE9版本<br/><![endif]--><!--[ifgteIE8]>此浏览器版本高于或等于IE8<br/><![endif]--><!--[ifltIE9]>此浏览器版本低于IE9<br/><![endif]--><!--[iflteIE7]>此浏览器版本低于或等于IE7<br/><![endif]--><!--[ifgtIE6]>此浏览器版本大于IE6<br/><![endif]--><!--[if!IE]>-->此浏览器不是IE浏览器或版本大于IE9<br/><!--<![endif]--></p>在“开发者工具”中设置文档模式，条件注释同样会相应。注意最后一条，!IE是无法判断非IE浏览器内核的，因为条件注释也只支持IE5~IE9，IE10及以上已经取消此标签。实际应用中，可以1、当我们需要提示用户系统不支持IE8以下的浏览器，在条件注释<!--[ifltIE8]>#htmlforupgradefromie6、7#<![endif]-->。这样就可以非常高效快捷准确的提示浏览器升级信息。很多人使用代码判断Agent信息来判断浏览器版本，但针对IE来说，如果兼容模式，最后生成的结果是不准确的，不建议使用。2、根据不同IE版本使用不同的css样式文件，这样就不用去费劲去寻找能够兼容所有浏览器的trick。以上是个人对于前端开发的经验之谈，如果大家认为有误或不足的地方欢迎斧正和补充。",2015/11/24
149,人脸识别有突破，“看脸行事”的时代离我们还有多远,杨木春,http://180.168.156.212:2262/wecenter/?/article/9143,人脸识别技术还是值得我们向往。“看脸行事”的时代离我们还有多远？这个很值得期待。人脸识别有突破，“看脸行事”的时代离我们还有多远我们都爱说“看脸行事”，也许未来不久，真正的“看脸行事”时代就要来了。最近，FacebookMessenger应用新增了一项人工智能功能，可以从上传到该服务的照片中识别出用户的好友。而微软的技术更进一步，日前它对外公布了一个新技术，可以通过照片识别脸部表情。而根据这一技术，用户上传一张自己的照片后，微软将会自动分析出照片中每个人的脸部表情，并给出“吃惊”、“忧伤”等分析结果。这两种成果，可以称之为我们早就有了的人脸识别技术，亦属于人工智能的发展。在我看来，这两种成果，对未来的意义难以预测，它可能会突破目前我们在人脸识别领域单纯的用于考勤、登记等领域较为“死板”的目的范围，而向更为广泛的领域发展。其实，人脸识别技术的应用已经有些年头。大概是2008年还是2009年左右吧，笔者应邀到汉王科技参观时，就见识过汉王的人脸识别考勤系统。而多年过去，国内人脸识别技术的应用范围越来越广泛，利用这项技术的企业也越来越多。不过，观察这项技术的应用领域，依然是传统的考勤、门禁、人员管理等领域，而在安防、支付等领域的应用目前正在探索之中。我们对人脸识别技术的向往，大多是从方便角度考虑。比如不用带那么多的繁琐证件，就可以办很多事情，省时省力。但是，依托人脸识别技术开发的无需银行卡“刷脸”取钱功能，目前还存在争议。而赵薇老公被司机人脸识别冒充案，更是让我们对人脸识别在支付等事关经济利益方面的安全隐患感到担忧。而Facebook和微软的新技术，尤其是微软的技术，可能会对以上的担忧和麻烦产生一定的积极作用，使人脸识别技术的应用更为成熟和安全。通过查阅一些资料、看一些企业的业务介绍，我们可以了解到目前一些人脸识别技术的应用原理和过程是这样的：“人脸图像采集及检测、人脸图像预处理、人脸图像特征提取以及匹配与识别。”而在某企业的介绍中，我看到这样的解释：“人脸识别业务接口开放性极强，用户仅需通过一个简单的Json字符串发送到服务平台，即可返回人脸模型信息，由此解决了传统意义上使用人脸比对技术的各种复杂问题。”但不管怎么样，赵薇老公被冒充的案件说明，目前的一些人脸识别技术应用，还过于“呆板”，容易被假冒。因为对于一些容貌相似的脸，或者经过化妆后容貌相似的脸，主要针对某些特征的人脸识别技术，可能还无法识别。如果单纯依靠特征，把黑人误认为大猩猩的笑话也会不断上演。不过，微软会自动分析出照片中每个人的脸部表情，并给出“吃惊”、“忧伤”等分析结果，这说明微软的人脸识别技术更加精准和深入了。能分辨出表情，意味着能够分辨出人脸更加细微的特征，从而能更精准的记住一个人。谁想要假冒，怕是很难了。“吃惊”、“忧伤”等表情，应该不是止境，将来的分析可能会更加清晰。而未来的人工智能系统，根据主人的表情进行分辨，可能会更加明确的为主人提供服务。比如说，当主人有口渴的表情时，人工智能机器人会端过饮料。想上去，这是不是会很美妙呢？目前，微软已经针对这款表情识别工具发布了应用编程接口，使得开发者可以轻松设计识别情绪和年龄的应用。当然，随着分析的不断深入和细化，人脸识别技术所触及的人类隐私可能会越来越多，这就要涉及到法律问题了。虽然如此，但人脸识别技术还是值得我们向往。“看脸行事”的时代离我们还有多远？这个很值得期待。,2015/11/13
150,爱奇艺传出合并：视频网站各建封闭围城背后的焦虑,管俊,http://180.168.156.212:2262/wecenter/?/article/9142,资本寒冬下的抱团取暖，以维持现有模式打造更大的封闭帝国为基础进行合并解决不了本质问题，它反映出视频网站在面临集体亏损下的集体焦虑。文/王新喜早在今年7月，圈内就传出了优酷土豆正在和爱奇艺进行收购洽谈的消息，当时这一消息被爱奇艺CEO龚宇否认。在优酷土豆卖身阿里之后，日前关于爱奇艺将与某视频巨头合并的消息再次出现并继续发酵。据某业内人士于11月10日爆料称，爱奇艺和××合并消息敲定了，不过三天内都是双十一上不了头条，也许，人家故意选在这个时候降低关注度了。“不过目前这一消息并未得到爱奇艺方面确认。基于爱奇艺的合并对象，笔者通过相关渠道获取到某资深人士的看法，该资深人士认为，爱奇艺合并对象应该是搜狐。原因有三：1，张朝阳一直不想放弃视频，客户端，视频、搜狗算张朝阳手里的三张牌，视频这张牌，他会想办法打好。交远攻近已成行业景象。2.龚宇原来是张朝阳的部下，爱奇艺创始人团队多搜狐旧人；3.视频需要增加营收，搜狐有很强的广告销售能力，可以互补。不过，目前搜狐方面已经否认了这一说法。合并背后是止损爱奇艺独家自制剧与独播战略推动视频行业走向封闭性合并传闻的背后，是爱奇艺面临着诸多盈利困境与亏损难题，过去一年，爱奇艺的发展势头强劲，拿下《来自星星的你》和《爱情公寓4》等热播剧的独播权，高价拿下湖南卫视《《天天向上》、《快乐大本营》、《百变大咖秀》等湖南卫视6档年播综艺以及《爸爸去哪儿》第二季的独播版权。并发布盒子、电视等系列硬件产品，成立工作室和影业公司，一系列举措形成闪电战的攻势，让优土与腾讯乐视等对手们感受到了巨大压力。视频网站讲究流量导向法则，包括爱奇艺在内的多家视频网站早已开始大举投资独家自制剧以及和影视公司签署排他性的独家版权协议，但这同样无法解决视频行业普遍面临的亏损难题，比如爱奇艺《盗墓笔记》每集投入高达500万元，这样天价的电视剧制作成本又成为版权开支的另一大重头戏。爱奇艺龚宇表示：“包括爱奇艺在内的视频网站过去几年内花钱最多，干的最大的一件事情就是买内容，爱奇艺花了很多钱买电视台的优秀综艺节目，并且独播这些优秀的综艺节目。”但遗憾的是，自制剧的投入是全行业的共有模式。比如优酷的《万万没想到》、搜狐的《屌丝男士》到腾讯自制剧《侦探狄仁杰》，对于爱奇艺来说，换不来竞争优势。这在依赖广告收入模式未变的情况下，内容高投入下带来的则是持续亏损。而据消息称，2014年爱奇艺全年亏损了10-15亿元。因此，爱奇艺合并传闻若成真，目的在于赢得资本市场认可该模式，但为达成压制对手的目的，各视频网站之间互相内容封锁的态势将愈加明显。独家自制剧与独播战略并不是一种健康的发展模式，它推动视频行业走向封闭性。有海外评论人士指出：“在中国的视频行业盛行视频内容捆绑网站平台，‘自封诸侯’已成为普遍现象。”虽然短时期内，倚内容自重能获取一定的用户与流量，但用户若总是从不同的平台不断跳转去寻求独家内容，无力把控对影视内容分享的自由度，该评论人士一针见血指出：“内容封闭的结果是网民对其收费视频也失去兴趣，会很快取消业务。市场只有通过互相开放，才能够变得更大，如果限制其他平台的用户观看，只会作茧自缚。”成也封闭败也封闭：优土之后，爱奇艺合并传闻背后是互联网创业风骨的丧失随着BAT全力扑向视频领域，爱奇艺的当务之急显然是扩大规模并巩固市场地位，快速上市和盈利，开放分享的精神已经不是爱奇艺一家所能考虑的事儿。从行业来看，成也封闭，败也封闭。因为通过版权费用与自制剧来吸引用户流量，但变现能力依然没跟上，视频行业多年未盈利的现状也大致源于此。回过头去看，视频网站发展伊始并不是封闭的独家内容购买与自制模式，因为Youtube并非一开始就那么火爆，而是在借鉴了Flickr的设计理念和分享模式之后方才迎来爆发。某业界人士指出：“国内搞独家自制以封锁获取市场，这种竞争模式事实上是一种倒退，只不过是将电视搬到了电脑上。”他表示，如今在各城市地铁、公交或者公共场所，人们对于视频网站使用习惯不是沿途拍摄一段趣闻轶事或将事关社会文明的事儿随手拍摄上传视频网站，来展现自我风格或者传播个人与社会价值，而是低头看剧，这不利于改善国民自我表达与自我展现的精神状态，也不是移动互联网发展的题中应有之义。而从整个行业来看，视频网站各倚内容自重，通过合并建封闭生态与帝国，导致竞争模式将进一步陷入购买版权内容或者自制内容不断烧钱但无法盈利的恶性循环，它也自然将用户导向了以看剧为主流的使用模式，而不是一种去中心化的分享模式。所以，视频网站如今的竞争现状已经和当初构建开放分享的平台初衷背离，我们看到，虽然国内视频网站的市值或估值普遍偏低，但Youtube目前的估值已经超800亿美金，接近谷歌市值的5分之一，而Youtube被资本市场认可源于其一直都将UCG个人分享作为主流模式，而开放是谷歌甚至美国互联网文化的基因或者说是基本特征，而Youtube的开放性与分享特质跟注重交流沟通的社交文化是相契合的。在国内，优酷土豆在创立之初，也都打着与Youtube同样的旗号，即以UCG分享为主。土豆网曾经提炼出的”每个人是生活的导演。“引发了业内诸多共鸣，事实上当时也为视频行业发展指明了方向。因为UCG为主流的模式更有想象空间，比如采用竞价排名或CPS的形式给商家提供短视频广告，与上传视频的用户进行广告费的分成，从而强化UGC的内容，引导用户自主分享的开放式的视频平台模式，进而打造一种良性循环。在Youtube上，众多年入百万的个人账户在不断产生，这些账户背后都是活跃粉丝，这推动用户UCG内容源源不断生产并被分享的同时，也恰恰契合了移动互联网与4G网络普及的现状与红利。但国内的视频网站却走了另一条路，视频网站集体迎合用户对于看剧、看选秀与娱乐节目等基本的娱乐需求并将其打造成主流。这种趋势要追根朔源到2008年，当时优酷、土豆、在内的多家视频网站因盗播被提起上千起版权侵权诉讼。这个时候各视频网站都意识到了版权问题，依靠买断版权或独家自制剧封锁获取市场，就成了一种商业下的必然选择，但这进一步导致版权带宽成本压力大增，全行业都在亏损。现在的优酷土豆自然也学不成Youtube，开始倾向于以专业内容为主的视频网站，近年来也曾借鉴Netflix等创新公司的模式，不过其效果始终平平。以维持现有模式为基础进行合并：视频网站集体亏损下的焦虑一直以来，爱奇艺的亏损都被认为是百度财务数据不好的直接原因，而据消息称：“百度的内容成本2014年同比增长125.4%，由8.3亿元增加到19亿元（约合3.02亿美元），而增长的主要原因是爱奇艺。”爱奇艺的亏损加深了其赴美上市的困境。此前来自投行、视频业以及审计领域的多个不同消息源透露，爱奇艺因财务问题已被迫推迟上市进度，但真实情况是爱奇艺清理财务问题仍需至少10个月的时间，这意味着爱奇艺在明年3月之前上市无望。此前互联网的那点事也透露：”虽然龚宇曾多次去美国见投行，但当前经济形势下没有投行愿意承接风险如此之大的IPO。“爱奇艺的赴美上市计划被搁浅也间接说明了它的模式不被资本市场认可。爱奇艺目前转而将上市地转向国内。据相关信息显示，上海已选定爱奇艺等企业作为上交所战略新兴板首批挂牌企业。而接下来，留给爱奇艺的是阿里收购优土之后，视频行业愈发混乱、难以预料的竞争局面，爱奇艺若拿不出新的资本故事将面临着很多的变数。传言百度对待爱奇艺也是一种甩包袱的姿态。致力于连接人与服务的百度表示未来将向O2O砸200亿，因此需要进一步理清自身的战略布局思路，进而在资金减亏、拉升股价、业务布局中保持平衡，爱奇艺与腾讯视频、搜狐几家将如何展开资本整合局，或将在不久后揭开谜底。爱奇艺未来若走向合并是否能止损尚是未知数，但资本的力量或可将推动爱奇艺将买版权打造自制剧的烧钱模式延续，这将导致几大封闭视频阵营更为持久而僵持的对峙状态，有业内人士指出：“当下视频网站的竞争模式已退回到传统电视台竞争模式。”在某种程度上，这意味着在压力下，它们集体丢掉了互联网创业风骨与精神。无论如何，考虑到盈利能力、行业环境、财务审计等多个因素制约，在移动端全方位突出UGC内容的优势，利用UGC内容超短时长以及易于传播分享的特性来实现用户虚拟资产的沉淀，向生态化的开放分享平台进化从而获取更大的竞争优势不仅是爱奇艺也是当前整个视频行业需要考量的战略方向。资本寒冬下的抱团取暖，以维持现有模式打造更大的封闭帝国为基础进行合并解决不了本质问题，它折射出视频网站在面临集体亏损下的集体焦虑。中国在文化层面欠缺一种开放的社交、分享的文化氛围，爱奇艺等视频网站事实上更需要建立一种良好的引导机制。从Youtube的案例来看，国内各大视频平台目前更需要在观看者与发布者之间建立起一种介于深入与肤浅之间的社交关系，让每个人赢得自我表达的机会，而不是将缩小的电视搬到各种移动场景，它的人文意义在于，推动人们有着一个情感的倾泻与压力的释放的渠道，改变现代社会自我表达渠道缺乏的病状，而视频网站的盈利模式与想象空间也在于此。,2015/11/13
151,Gartner预测2016年十大战略科技趋势,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9141,人工智能成为当前最受瞩目的尖端技术；云计算、物联网、大数据、移动互联四大牛叉技术中最受关注的是物联网。Gartner近日于GartnerSymposium/ITxpo中提出十项将在2016年影响多数企业机构战略科技趋势的研究结果。Gartner副总裁DavidCearley表示：“Gartner所列出的十大战略科技趋势，将构成2020年之前的数字业务商机。前三项趋势针对的是实体与虚拟世界的融合，还有数字网络（digitalmesh）的崛起。目前企业机构都把焦点放在数字业务上，但运算业务正在逐渐兴起。借由运算我们可以得知事件之间的关联性与互连性，而这恰恰定义了业务的未来。在运算业务当中，很多都是源于人们并非直接涉入的背景信息。这样的技术依靠智能机器才能实现，在接下来的三种趋势里也会提到。最后四种则是IT领域为了支持数字及运算业务而产生的现有或新型架构及平台趋势。”终端网络（DeviceMesh）终端网络是指为数越来越多、用来存取应用程序与信息或与其他人、社会群体、政府及企业互动的端点。终端网络包含移动设备、可穿戴式产品、消费性与家用电子设备、汽车设备与环境设备——例如物联网（IoT）当中的传感器。DavidClearley指出：“到了后移动时代，趋势的重点将转移到移动用户身上，他们四周将围绕着由各式设备所组成的网络，影响范围远超过传统移动设备所能及。”虽然有越来越多的设备通过各种网络连结后端系统，但往往是各自独立运作。随着终端网络逐渐演进，我们预计联接模式将会扩大，设备之间的合作性互动也将更上一层楼。环境用户体验（AmbientUserExperience）终端网络将为持续不断的新形态环境用户体验提供基础。虽然具备扩充实境与虚拟实境功能的沉浸式环境握有极大商机，但它也只是体验的其中一个方面而已。环境用户体验能跨越终端网络、时间与空间的界线而保有延续性。这样的体验可在各式各样的设备与互动通道之间无缝流动，当用户移动时也能混合实体、虚拟以及电子环境。DavidClearley表示：“对企业来说，移动应用程序的设计仍然是重要的战略重点之一。然而设计的重点优势在于提供的体验是否能跨越物联网传感器等各种设备、汽车等一般物件，甚至是工厂，并且善加利用。到2018年，设计出这种先进体验的能力将成为独立软件厂商（ISV）与企业达成市场区隔的最佳利器。”3D打印材料3D打印技术不断提升，已经可以利用镍合金、碳纤维、玻璃、导电油墨、电子、药品与生物材料等各式各样的材料。在这些创新技术持续带动用户需求的同时，3D打印机的实际用途也拓展到更多产业，包括航空航天、医疗、汽车、能源与军事。适用于3D打印的材料种类越来越多，预计2019年以前将带动企业用3D打印机的出货量达到64.1%的年复合增长率。在这样的进展之下，企业机构必须重新构思组装与供应链流程，才能善加利用3D打印技术。DavidClearley指出：“未来20年内，可用于3D打印的材料种类将稳步增长，打印物品的速度将会加快，并会有新的零件打印与组装模式崛起。”万物联网信息数字网络里的所有物品都能制造、利用并传输信息。这样的信息不限于文字、音频或视频格式，范围涵盖感官与情境信息。万物联网信息可解决这种战略与技术的汇入，连结来源各异的各种信息。信息其实一直存在且来源五花八门，但其往往是孤立的、难以理解的不完整片段，因此无法利用。图形数据库（graphdatabase）等语义工具不断进步，再加上其他数据分类与信息分析技术的逐渐崛起，都将赋予看似杂乱的大批信息更多意义。高等机器学习在高等机器学习方面，深度神经网络（DNN）超越了典型运算与信息管理技术，创造出能独立自主学习如何理解各种事物的系统。数据来源爆炸加上信息日益复杂，让手动分类与分析变得滞碍难行且不合经济效益。深度神经网路能自动执行这些任务，如此一来要解决万物联网信息趋势所带来的各项重大挑战，也就不再遥不可及。深度神经网络（是一种高等形式的机器学习，尤其适用于复杂的大型数据集）就是让智能设备看起来“聪明”的关键所在。深度神经网络能让基于硬件或软件的机器自行学习环境当中所有特征，范围小至细微末节，最大则可扫描抽象类内容。相关领域持续快速演进，企业机构必须评估该如何应用相关技术以取得竞争优势。自主代理与物体（AutonomousAgentsandThings）机器学习提供了实现智能机器自主（或至少半自主）运行的光谱，包含机器人、自动驾驶汽车、虚拟个人助理（VPA）以及智能助手。随着实体智能机器的进步，像是机器人得到极大的关注，以软件为基础的智能机器有了更短期并更广泛的影响，虚拟个人助理，像是微软（Microsoft）的Cortana以及苹果（Apple）的Siri都变得更为智能，可以说是自主代理（autonomousagents）的前身。助理的新兴概念让自主代理成为主要用户界面的环境用户体验，用户直接对着应用程序说话，而非与智能手机上的菜单、表单与按键互动，实际上就是智能代理。DavidClearley表示：“在接下来的五年内，我们会发展到后应用程序（postapp）世界，智能代理将传递动态且连续的动作与界面，IT领导者需探索如何利用自主物体与代理强化人类行为，并将人力解放到只有人类才能够做的事；然而，他们必须认知到智能代理与智能物体都是在接下来20年会持续变革并扩张用途的一种长期现象。”自适应安全架构（AdaptiveSecurityArchitecture）数字经济及运算经济的复杂性与新兴的“黑客产业（hackerindustry）”结合，显著提升了其对企业机构的威胁面。依赖网络外围防御及基于规则的安全（rule-basedsecurity）已显不足，特别是在企业机构采用了更多以云端为基础的服务以及为了整合系统而开放API给客户或合作伙伴的情况下。IT领导者需专注于侦测与响应威胁，同时以更多传统的阻挡与其他方法防范攻击。程序自我保护、用户与实体行为分析都会协助实现自适应安全架构。高级系统架构（AdvancedSystemArchitecture）数字网络与智能机器需要精密的运算架构才能实现，而高能量、超高效率的神经型态架构（neuromorphicarchitecture）才能符合这种需求。以现场可编程门阵列（field-programmablegatearrays，FPGA）驱动的架构是神经型态架构的重点技术，这样的技术有显著的好处，例如能够在比每秒一万亿次浮点运算更高速的高能量效率下运行。DavidClearley表示：“在GPU与FPGA建立的系统会以与人类脑部相似的方式运作，如此一来便特别适合智能机器的深度学习与其他模式匹配算法。以FPGA为基础的架构允许将算法细分，只需要在终端网络中使用相当少的电力就能让高等机器学习物联网最小的端点的能力，例如家庭、汽车、手表，甚至是人类的行为。”网络应用程序与服务架构整体的线性应用设计（例如三层架构，three-tierarchitecture）提供更松散的连接方式，即应用程式和服务架构。这种通过软件定义应用服务（software-definedapplicationservices，SDAS）启动的新途径促成网络规模的性能、灵活性和敏捷性。微型服务结构不论对内部或者云端来说，都是支持应用程序灵活地传输和规模性部署的新兴模式。容器（container）技术的兴起成为关键技术，让结构发展与微型服务更灵活。引领手机与物联网相关要件的应用程序与服务结构，创造了后台云计算规模性与前端终端网络体验全面性的解决方式。应用程序的开发小组必须创造新的现代架构，以提供敏捷、灵活且动态的基于云的应用程序与跨越数字网络的用户体验。物联网平台物联网平台补充了网络应用程序和服务架构。管理、安全、与其他科技的整合以及物联网平台的标准是构建、管理与保障物联网的最基础要素。从建筑和技术的角度来看，物联网平台构筑IT的幕后工作，使物联网成为现实。物联网是数字网络的组成部分，环境用户体验以及新兴且动态的物联网平台则是实现物联网的主要元素。DavidClearley表示，任何拥抱物联网的企业将需要发展物联网平台战略，但在2018年之前，不完全竞争的供应商进逼将使标准化遇上阻碍。,2015/11/11
152,google开源了他们的人工智能引擎，我们的技术大虾们注意了,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9147, Google的人工智能搜索引擎开源啦[日期：2015-11-10]来源：IAMUE作者：[字体：大中小]前不久谷歌刚刚发布的GooglePhoto让人们惊叹。它可以自动收集识别你的相片，并提供惊人的搜索能力。比如你输入“墓碑”，google能挖出你几年前你一次扫墓的照片，即使你当时并没有给这张照片作出任何标记。这只是Google的人工智能服务的冰山一角。在此之前，Google图片搜索、Google翻译等应用的智能程度已经享有盛誉。而今天，Google将其人工智能帝国的核心——深度学习神经网络，开源了。“这是很有趣的一件事，”深度学习初创公司Skymind的CEO克里斯.尼古森(ChrisNicholson)说。“谷歌(在这一领域)领先整个世界五到七年。如果他们将软件开源，那将改进每一项机器学习研究。”Google的图片搜索引擎精确度已经令人咋舌——以至于让人很难理解为什么谷歌不对其收费，让其他软件开发者付费使用其服务。这将给Google带来相当可观的收入——要知道，同样的人工智能引擎，也驱动着谷歌的语音识别服务、翻译、搜索优化等等服务。这些技术将有巨大的商业应用空间，比如广告投放、计算机安全等领域。但谷歌选择了开源其深度学习引擎，同全世界的开发者免费分享其人工智能背后的一条条源代码。这个项目被命名为TensorFlow，任何人都可以在这里访问：当然，谷歌也并非完全毫无保留。目前开源的是其引擎中较为顶层的算法。同时谷歌也没有开源其硬件基础设施系统。Google为什么要这么做?官方的解释是，将自己的技术免(gong)费(shou)开(song)放(ren)，希望可以加速人工智能领域的发展。所有人都可以帮助Google改进其技术，并将成果反馈回来。正如Google深度学习项目的主要推动者杰夫.迪恩(JeffDean)所说：“我们希望的是，整个研究、开发者社区将TensorFlow作为一种很好的手段来实现各种各样的机器学习算法，同时也为其在各种场景下的应用带来改进,2015/11/10
153,jQuery插件zoom实现图片全屏放大弹出层,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9140,"<!DOCTYPEhtml><htmldir=""ltr""lang=""en-US""><head><metacharset=""UTF-8""/><styletype=""text/css"">body{overflow-y:scroll;font-family:""HelveticaNeue-Light"",""HelveticaNeueLight"",""HelveticaNeue"",Helvetica,sans-serif;background:#f4f4f4;padding:0;margin:0;}h1{font-size:31px;line-height:32px;font-weight:normal;margin-bottom:25px;}a,a:hover{border:none;text-decoration:none;}img,aimg{border:none;}pre{overflow-x:scroll;background:#ffffff;border:1pxsolid#cecece;padding:10px;}.clear{clear:both;}.zoomed>.container{-webkit-filter:blur(3px);filter:blur(3px);}.container{width:505px;margin:0auto;}.gallery{float:left;background:#ffffff;padding:20px20px10px20px;margin:0;-webkit-box-shadow:01px3pxrgba(0,0,0,0.25);-moz-box-shadow:01px3pxrgba(0,0,0,0.25);box-shadow:01px3pxrgba(0,0,0,0.25);-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;}.gallerydiv{float:left;padding:010px10px0;}.gallerydiv:nth-child(6n){padding-right:0;}.gallerya,.galleryimg{float:left;}</style><linkrel=""stylesheet""href=""css/zoom.css""media=""all""/></head><body><divclass=""container""><divclass=""gallery""><divclass=""box""><divclass=""pic""><ahref=""1921/deng1921_2.jpg""><imgsrc=""1921/deng1921_2.jpg""/></a></div></div><divclass=""box""><divclass=""pic""><ahref=""1921/deng1921_3.jpg""><imgsrc=""1921/deng1921_3.jpg""/></a></div></div><divclass=""box""><divclass=""pic""><ahref=""1921/deng1921_4.jpg""><imgsrc=""1921/deng1921_4.jpg""/></a></div></div></div><divclass=""clear""></div></div><scriptsrc=""js/jquery-2.1.4.min.js""></script><scriptsrc=""js/zoom.min.js""></script></body></html>yangshi.rar",2015/11/9
154,Web前端开发文档规范你需要知道的事,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9139,"基本准则符合web标准,语义化html,结构表现行为分离,兼容性优良.页面性能方面,代码要求简洁明了有序,尽可能的减小服务器负载,保证最快的解析速度.文件规范1.html,css,js,images文件均归档至<系统开发规范>约定的目录中;2.html文件命名:英文命名,后缀.htm.同时将对应界面稿放于同目录中,若界面稿命名为中文,请重命名与html文件同名,以方便后端添加功能时查找对应页面;3.css文件命名:英文命名,后缀.css.共用base.css,首页index.css,其他页面依实际模块需求命名.;4.Js文件命名:英文命名,后缀.js.共用common.js,其他依实际模块需求命名.html书写规范1.文档类型声明及编码:统一为html5声明类型;编码统一为,书写时利用IDE实现层次分明的缩进;2.非特殊情况下样式文件必须外链至…之间;非特殊情况下JavaScript文件必须外链至页面底部;3.引入样式文件或JavaScript文件时,须略去默认类型声明.4.引入JS库文件,文件名须包含库名称及版本号及是否为压缩版,比如jquery-1.7.1.min.js;引入插件,文件名格式为库名称+插件名称,比如jQuery.cookie.js;5.所有编码均遵循xhtml标准,标签&属性&属性命名必须由小写字母及下划线数字组成,且所有标签必须闭合;属性值必须用双引号包括;6.充分利用无兼容性问题的html自身标签,比如span,em,strong,optgroup,label,等等;需要为html元素添加自定义属性的时候,首先要考虑下有没有默认的已有的合适标签去设置,如果没有,可以使用须以”data-”为前缀来添加自定义属性，避免使用”data:”等其他命名方式;7.语义化html,如标题根据重要性用h(同一页面只能有一个h1),段落标记用p,列表用ul,内联元素中不可嵌套块级元素;8.尽可能减少div嵌套9.书写链接地址时,必须避免重定向，例如：href=” 注释:注释格式,‘–’只能在注释的始末位置,不可置入注释文字区域;2.css注释:注释格式;3.JavaScript注释,单行注释使用’//这儿是单行注释’,多行注释使用;开发及测试工具约定建议使用WebStorm||Aptana||Dw||Vim,亦可根据自己喜好选择,但须遵循如下原则:1.不可利用IDE的视图模式’画’代码;2.不可利用IDE生成相关功能代码,比如Dw内置的一些功能js;3.编码必须格式化,比如缩进;测试工具:前期开发仅测试FireFox&IE6&IE7&IE8&IE9&Opera&Chrome&Safari;其他规范1.开发过程中严格按分工完成页面,以提高css复用率,避免重复开发;2.减小沉冗代码,书写所有人都可以看的懂的代码.简洁易懂是一种美德.为用户着想,为服务器着想.",2015/11/4
155,DAT22-2015《归档文件整理规则》发布，代替2000版,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9138, 我们的产品研发部门需要很对新老标准的区别对并软件功能进行相应修改。DAT22-2015归档文件整理规则.doc,2015/11/3
156,如何在ionic中添加加载提示,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9136,"controller中添加$ionicLoading，通过判断数据载入情况，显示与隐藏加载提示。使用方法：angular.module('LoadingApp',['ionic']).controller('LoadingCtrl',function($scope,$ionicLoading){$scope.show=function(){$ionicLoading.show({template:'Loading...'});};$scope.hide=function(){$ionicLoading.hide();};});方法：show(opts)显示加载提示{string=}templatehtml模板{string=}templateUrl通过url加载模板{object=}scope作用域.默认是$rootScope.{boolean=}noBackdropWhethertohidethebackdrop.Bydefaultitwillbeshown.{boolean=}hideOnStateChangeWhethertohidetheloadingspinnerwhennavigatingtoanewstate.Defaultfalse.{number=}delay延迟显示，多少毫秒后显示加载提示{number=}duration自动隐藏，多少毫秒后自动隐藏加载提示。默认是不自动隐藏hide()隐藏加载提示",2015/11/2
157,一篇对农产品标准化很有价值的文章：中国蔬菜分等分级标准分析,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9137,其中提到的相关标准，都已由市场部收集，有兴趣可以当面向市场部负责人索取。中国蔬菜分等分级标准分析.pdf,2015/10/31
158,2015 OpenStack东京峰会开幕 打造更强健开源平台,赵本,http://180.168.156.212:2262/wecenter/?/article/9135," ?p=3974又是一年OpenStack峰会，既温哥华后OpenStack又重新回到亚洲，日本，东京，这次OpenStack中国社区带大家第一时间了解Keynotes的亮点。共有5000名OpenStacker参加了本次东京峰会首先，由日本OpenStack用户组成员开场，欢迎大家来到日本东京。之后，OpenStack基金会执行董事，JonathanBryce欢迎大家的到来，峰会这次为大家提供了包括英文、中文、韩语、日语四种语言的同传直播，这样，来自世界各地56个国家，5000个OpenStacker将能全程了解OpenStack又经过半年时间的最新变化。Jonathan先向大家介绍了《Superuser》杂志的创刊号，内容涵盖了东京旅游推荐、企业用户的心得以及社区代码贡献者的技术文章，相信未来《Superuser》杂志将成为每个OpenStacker的必读刊物。这里，Jonathan做了一个现场调查，现场有6成的OpenStacker是第一次来到东京，这也是OpenStack的魅力所在，让我们一起期待在OpenStackPoweredPlanet。更具管理性，更具扩展性，更灵活的OpenStackJonathanBryce向大家推出了CertifiedOpenStackadministrator认证，认证在全球范围内有效，社区希望通过官方的虚拟认证，能够有越来越多的有天赋的人加入到OpenStack大家庭当中。OpenStack最新版本Liberty的完成离不开大家的努力，OpenStack现在已经有超过4百万行代码，正如Jonathan在PPT中提出的，可管理性，可扩展性，可伸缩性是未来OpenStack发展的重中之重。首先，可管理性——OpenStack改变了传统软件行业的运营模式，将开发、管理、产品、销售的线性模式打碎，研发者可以同时基于OpenStack进行需求分析，设计，开发，测试，文档，发布的工作，而用户也可以全程参与，OpenStack已不再像传统IT系统一样难以管理。OpenStack基金会执行董事，JonathanBryce其次，可扩展性——目前，OpenStack部分项目已经相对成熟，但是Jonathan在这里向大家说明，OpenStack是包含了很多成熟的云计算需要的项目，此外，OpenStack还是一个创新的平台，包括支持大数据和关系型数据库等功能的项目层出不穷，这些创新的基础就是OpenStack标准性测试，只有通过测试，才能证明你的OpenStack是稳定的。Jonathan也请到了Defcore的负责人，希望大家通过问卷或者邮件列表的方式提供给OpenStack社区用户真正的需求，社区将会对每一个需求的情况，快速调整社区的开发方向。OpenStack各个服务组件成熟度与采用度象限之后，Jonathan向大家引入了四个象限，从采用度和成熟度两个角度讲OpenStack中的各个服务单独划分开了，其中Nova，Glance，Cinder，Swift，Horizon，Neutron，Keystone以及新近的成员Heat，而采用度较高的Ceilometer，其成熟度并没有大家想像的那么好。而新晋的一些项目也逐渐走进大家视野，社区还给出了一套打分系统，从1-5分的成熟度到百分比的采用率以及开发时间，用户可以自己选择成熟的项目来应用部署。最后谈到可伸缩性，由于一些新项目的出现，OpenStack将真正具备管理裸机设备，容器和传统虚拟机管理器，作为负载IT架构的开源标准，OpenStack的扩展性变得更强了，新用户也可以快速的通过象限的方式来了各个项目的成熟度与业界普遍采用率。有了容器，OpenStack更强大接下来，Jonathan向大家介绍来自Lithium的团队带头人，LachlanEvenson,Evenson给大家带来OpenStack与容器是如何为应用开发者提供超快速部署方案的。首先，Evensong向大家展示了Lithium不仅为大家提供了容器的管理平台，同时，平台也具备了如监控或集成Kubernetes技术等特性。通过Lithium，用户可以在OpenStack和AWS上面同时部署容器，并且支持高负载的用户应用。Lithium团队LachlanEvenson介绍容器的管理平台之后，Evenson给大家带来了一个1分钟的Demo：一分钟可以做什么？部署应用，修改应用，再上线，在Evenson修改服务器代码的1分钟后，应用已经重新上线，并且修改生效，对于应用开发商这将是一件非常cool的事情。面对地震，OpenStack无所畏惧之后，来自Yahoo！Japan的TakuyaIto，为大家带来OpenStack是如何在Yahoo！Japan中在月浏览64.99billion，31.9billion移动浏览量的平台中扮演重要角色的，在OpenStack平台上，有超过100个服务部署，环境中超过5w台云主机，20b存储，超过20个集群在提供服务。Ito君特别强调，在一个历史监控数据中，突发的地震将带来平台负载的直线上升，在短短的几分钟时间内，通过OpenStack，在特殊时期，Yahoo还是能够提供包括天气，救援，灾难预告等所有服务，帮助大家度过这困难的时期。Yahoo！Japan的TakuyaIto君介绍OpenStack实践之后，为什么Yahoo采用OpenStack？Ito君表示，因为OpenStack具备用户IaaS基本功能，特殊功能以及服务提供商的研发功能的统一研发能力，这样用户，社区与服务提供商可以相互合作，共同搭建一套功能完整的IaaS平台。统一平台，灵活扩展Jonathan再此之后补充了重要的一点，在不同Hypervisor的平台之上，OpenStack可以作为同一平台向上提供服务，并且通过FederatedIdentity机制，OpenStack可以彼此互联。超级用户大奖，花落NTT东京峰会，Jonathan请到了上次的超级用户大奖得主，来自Comcast的MarkMuehl和ShillaSaebi，此次的候选人包括FICO，GoDaddy，Lithium和NTT，最终NTT获得此项殊荣，此次大会的网络服务就是由NTT团队提供。NTT获得本次东京峰会超级用户奖头条赞助商时间此次峰会，头条赞助商包括NEC，bitnami，Intel，GMO，其中NEC主要向大家介绍了SuperIntegrator，超级集成器，NEC可以通过超级集成器，硬件设备与合作，OpenStack帮助用户将IT基础设施快速整合，NEC在与OpenStack和用户共同成长。之后来自bitnami的COOEricaBrescia为大家介绍了bitnami是一家提供公有云，私有云统一管理的公司，为大家提供包括OpenStack在内的统一云平台管理解决方案。bitnamiCOOEricaBresciaIntel的副总裁ImadSousou，为大家带来cloudinbox概念，企业级的需求将有50billion的设备需求，包括85%的应用将由云来提供最后，来自日本的GMO公有云服务提供商，通过OpenStack提供全Juno版本SSD的公有云服务以及基于havana版本的应用部署云服务，有很多应用和服务在GMO公有云上提供，业务快速发展。",2015/10/30
159,EntityManager使用方法,容琼,http://180.168.156.212:2262/wecenter/?/article/9132,"SessionbeanorMDbean对Entitybean的操作（包括所有的query,insert,update,delete操作）都是通过EntityManager实例来完成的。EntityManager是由EJB容器自动地管理和配置的，不需要用户自己创建。那么SessionbeanorMDbean如何获得EntityManager实例呢？？非常简单，就是通过下列代码进行依赖注入：Publicclasssessionbean1{@PersistenceContextEntityManagerem;。。。}注意：如果persistence.xml文件中配置了多个<persistence-unit>。那么在注入EntityManager对象时必须指定持久化名称，通过@PersistenceContext注释的unitName属性进行指定，例：@PersistenceContext(unitName=""foshanshop"")EntityManagerem;如果只有一个<persistence-unit>，不需要明确指定。请注意：EntityBean被EntityManager管理时，EntityManager会跟踪他的状态改变，在任何决定更新实体Bean的时候便会把发生改变的值同步到数据库中（跟hibernate一样）。但是如果entityBean从EntityManager分离后，他是不受管理的，EntityManager无法跟踪他的任何状态改变。EntityManager一些常用的API（包含query,insert,update,delete操作）1）getentity——find()orgetReference()Personperson=em.find(Person.class,1);当在数据库中没有找到记录时，getReference()和find()是有区别的，find()方法会返回null，而getReference()方法会抛出javax.persistence.EntityNotFoundException例外，另外getReference()方法不保证entityBean已被初始化。如果传递进getReference()或find()方法的参数不是实体Bean，都会引发IllegalArgumentException例外2）insert——persist()Personperson=newPerson();person.setName(name);//把数据保存进数据库中em.persist(person);如果传递进persist()方法的参数不是实体Bean，会引发IllegalArgumentException3）update——分2种情况情况1：当实体正在被容器管理时，你可以调用实体的set方法对数据进行修改，在容器决定flush时（这个由container自行判断），更新的数据才会同步到数据库，而不是在调用了set方法对数据进行修改后马上同步到数据库。如果你希望修改后的数据马上同步到数据库，你可以调用EntityManager.flush()方法。publicvoidupdatePerson(){try{Personperson=em.find(Person.class,1);person.setName(""lihuoming"");//方法执行完后即可更新数据}catch(Exceptione){e.printStackTrace();}}情况2：在实体Bean已经脱离了EntityManager的管理时，你调用实体的set方法对数据进行修改是无法同步更改到数据库的。你必须调用EntityManager.merge()方法。调用之后，在容器决定flush时（这个由container自行判断），更新的数据才会同步到数据库。如果你希望修改后的数据马上同步到数据库，你可以调用EntityManager.flush()方法。publicbooleanupdatePerson(Personperson){try{em.merge(person);}catch(Exceptione){e.printStackTrace();returnfalse;}returntrue;}下面的代码会调用上面的方法。因为下面的第二行代码把实体Bean返回到了客户端，这时的实体Bean已经脱离了容器的管理，在客户端对实体Bean进行修改，最后把他返回给EJB容器进行更新操作：PersonDAOpersondao=(PersonDAO)ctx.lookup(""PersonDAOBean/remote"");Personperson=persondao.getPersonByID(1);//此时的person已经脱离容器的管理person.setName(""张小艳"");persondao.updatePerson(person);执行em.merge(person)方法时，容器的工作规则：1>如果此时容器中已经存在一个受容器管理的具有相同ID的person实例，容器将会把参数person的内容拷贝进这个受管理的实例，merge()方法返回受管理的实例，但参数person仍然是分离的不受管理的。容器在决定Flush时把实例同步到数据库中。2>容器中不存在具有相同ID的person实例。容器根据传进的person参数Copy出一个受容器管理的person实例，同时merge()方法会返回出这个受管理的实例，但参数person仍然是分离的不受管理的。容器在决定Flush时把实例同步到数据库中。如果传递进merge()方法的参数不是实体Bean，会引发一个IllegalArgumentException。4）Delete——Remove()Personperson=em.find(Person.class,2);//如果级联关系cascade=CascadeType.ALL，在删除person时候，也会把级联对象删除。//把cascade属性设为cascade=CascadeType.REMOVE有同样的效果。em.remove(person);如果传递进remove()方法的参数不是实体Bean，会引发一个IllegalArgumentException5）HPQLquery——createQuery()除了使用find()或getReference()方法来获得EntityBean之外，你还可以通过JPQL得到实体Bean。要执行JPQL语句，你必须通过EntityManager的createQuery()或createNamedQuery()方法创建一个Query对象Queryquery=em.createQuery(""selectpfromPersonpwherep.name=’黎明’"");Listresult=query.getResultList();Iteratoriterator=result.iterator();while(iterator.hasNext()){//处理Person}…//执行更新语句Queryquery=em.createQuery(""updatePersonaspsetp.name=?1wherep.personid=?2"");query.setParameter(1,“黎明”);query.setParameter(2,newInteger(1));intresult=query.executeUpdate();//影响的记录数…//执行更新语句Queryquery=em.createQuery(""deletefromPerson"");intresult=query.executeUpdate();//影响的记录数6）SQLquery——createNaiveQuery()注意：该方法是针对SQL语句，而不是HPQL语句//我们可以让EJB3Persistence运行环境将列值直接填充入一个Entity的实例，//并将实例作为结果返回.Queryquery=em.createNativeQuery(""select*fromperson"",Person.class);Listresult=query.getResultList();if(result!=null){Iteratoriterator=result.iterator();while(iterator.hasNext()){Personperson=(Person)iterator.next();…..}}…//直接通过SQL执行更新语句Queryquery=em.createNativeQuery(""updatepersonsetage=age+2"");query.executeUpdate();7）Refreshentity——refresh()如果你怀疑当前被管理的实体已经不是数据库中最新的数据，你可以通过refresh()方法刷新实体，容器会把数据库中的新值重写进实体。这种情况一般发生在你获取了实体之后，有人更新了数据库中的记录，这时你需要得到最新的数据。当然你再次调用find()或getReference()方法也可以得到最新数据，但这种做法并不优雅。Personperson=em.find(Person.class,2);//如果此时person对应的记录在数据库中已经发生了改变，//可以通过refresh()方法得到最新数据。em.refresh(person);8）Checkentity是否在EntityManager管理当中——contains()contains()方法使用一个实体作为参数，如果这个实体对象当前正被持久化内容管理，返回值为true，否则为false。如果传递的参数不是实体Bean，将会引发一个IllegalArgumentException.Personperson=em.find(Person.class,2);。。。if(em.contains(person)){//正在被持久化内容管理}else{//已经不受持久化内容管理}9）分离所有当前正在被管理的实体——clear()在处理大量实体的时候，如果你不把已经处理过的实体从EntityManager中分离出来，将会消耗你大量的内存。调用EntityManager的clear()方法后，所有正在被管理的实体将会从持久化内容中分离出来。有一点需要说明下，在事务没有提交前（事务默认在调用堆栈的最后提交，如：方法的返回），如果调用clear()方法，之前对实体所作的任何改变将会掉失，所以建议你在调用clear()方法之前先调用flush()方法保存更改。10）将实体的改变立刻刷新到数据库中——flush()当EntityManager对象在一个sessionbean中使用时，它是和服务器的事务上下文绑定的。EntityManager在服务器的事务提交时提交并且同步它的内容。在一个sessionbean中，服务器的事务默认地会在调用堆栈的最后提交（如：方法的返回）。例子1：在方法返回时才提交事务publicvoidupdatePerson(Personperson){try{Personperson=em.find(Person.class,2);person.setName(""lihuoming"");em.merge(person);//后面还有众多修改操作}catch(Exceptione){e.printStackTrace();}//更新将会在这个方法的末尾被提交和刷新到数据库中}为了只在当事务提交时才将改变更新到数据库中，容器将所有数据库操作集中到一个批处理中，这样就减少了代价昂贵的与数据库的交互。当你调用persist(),merge()或remove()这些方法时，更新并不会立刻同步到数据库中，直到容器决定刷新到数据库中时才会执行，默认情况下，容器决定刷新是在“相关查询”执行前或事务提交时发生，当然“相关查询”除find()和getreference()之外，这两个方法是不会引起容器触发刷新动作的，默认的刷新模式是可以改变的，具体请考参下节。如果你需要在事务提交之前将更新刷新到数据库中，你可以直接地调用EntityManager.flush()方法。这种情况下，你可以手工地来刷新数据库以获得对数据库操作的最大控制。publicvoidupdatePerson(Personperson){try{Personperson=em.find(Person.class,2);person.setName(""lihuoming"");em.merge(person);em.flush();//手动将更新立刻刷新进数据库//后面还有众多修改操作}catch(Exceptione){e.printStackTrace();}}11）改变实体管理器的Flush模式——setFlushMode()的Flush模式有2种类型：AUTOandCOMMIT。AUTO为缺省模式。你可以改变他的值，如下：entityManager.setFlushMode(FlushModeType.COMMIT);FlushModeType.AUTO：刷新在查询语句执行前(除了find()和getreference()查询)或事务提交时才发生，使用场合：在大量更新数据的过程中没有任何查询语句(除了find()和getreference()查询)的执行。FlushModeType.COMMIT：刷新只有在事务提交时才发生，使用场合：在大量更新数据的过程中存在查询语句(除了find()和getreference()查询)的执行。其实上面两种模式最终反映的结果是：JDBC驱动跟数据库交互的次数。JDBC性能最大的增进是减少JDBC驱动与数据库之间的网络通讯。FlushModeType.COMMIT模式使更新只在一次的网络交互中完成，而FlushModeType.AUTO模式可能需要多次交互（触发了多少次Flush就产生了多少次网络交互）12）获取持久化实现者的引用——getDelegate()用过getDelegate()方法，你可以获取EntityManager持久化实现者的引用，如JbossEJB3的持久化产品采用Hibernate，可以通过getDelegate()方法获取对他的访问，如：HibernateEntityManagermanager=(HibernateEntityManager)em.getDelegate();获得对Hibernate的引用后，可以直接面对Hibernate进行编码，不过这种方法并不可取，强烈建议不要使用。在Weblogic中，你也可以通过此方法获取对Kodo的访问。",2015/10/30
160,Spring JdbcTemplate方法详解,赵本,http://180.168.156.212:2262/wecenter/?/article/9134,"JdbcTemplate主要提供以下五类方法：execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；query方法及queryForXXX方法：用于执行查询相关语句；call方法：用于执行存储过程、函数相关语句。JdbcTemplate类支持的回调类：预编译语句及存储过程创建回调：用于根据JdbcTemplate提供的连接创建相应的语句；PreparedStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的PreparedStatement；CallableStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的CallableStatement；预编译语句设值回调：用于给预编译语句相应参数设值；PreparedStatementSetter：通过回调获取JdbcTemplate提供的PreparedStatement，由用户来对相应的预编译语句相应参数设值；BatchPreparedStatementSetter：；类似于PreparedStatementSetter，但用于批处理，需要指定批处理大小；自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任何数量需要的操作；ConnectionCallback：通过回调获取JdbcTemplate提供的Connection，用户可在该Connection执行任何数量的操作；StatementCallback：通过回调获取JdbcTemplate提供的Statement，用户可以在该Statement执行任何数量的操作；PreparedStatementCallback：通过回调获取JdbcTemplate提供的PreparedStatement，用户可以在该PreparedStatement执行任何数量的操作；CallableStatementCallback：通过回调获取JdbcTemplate提供的CallableStatement，用户可以在该CallableStatement执行任何数量的操作；结果集处理回调：通过回调处理ResultSet或将ResultSet转换为需要的形式；RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSetrs,introwNum)来完成将每行数据转换为相应的类型。RowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSetrs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。ResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSetrs)来处理结果集，用户必须处理整个结果集；接下来让我们看下具体示例吧，在示例中不可能介绍到JdbcTemplate全部方法及回调类的使用方法，我们只介绍代表性的，其余的使用都是类似的；1）预编译语句及存储过程创建回调、自定义功能回调使用：java代码：Java代码@TestpublicvoidtestPpreparedStatement1(){intcount=jdbcTemplate.execute(newPreparedStatementCreator(){@OverridepublicPreparedStatementcreatePreparedStatement(Connectionconn)throwsSQLException{returnconn.prepareStatement(""selectcount(*)fromtest"");}},newPreparedStatementCallback<Integer>(){@OverridepublicIntegerdoInPreparedStatement(PreparedStatementpstmt)throwsSQLException,DataAccessException{pstmt.execute();ResultSetrs=pstmt.getResultSet();rs.next();returnrs.getInt(1);}});Assert.assertEquals(0,count);}首先使用PreparedStatementCreator创建一个预编译语句，其次由JdbcTemplate通过PreparedStatementCallback回调传回，由用户决定如何执行该PreparedStatement。此处我们使用的是execute方法。2）预编译语句设值回调使用：java代码：Java代码@TestpublicvoidtestPreparedStatement2(){StringinsertSql=""insertintotest(name)values(?)"";intcount=jdbcTemplate.update(insertSql,newPreparedStatementSetter(){@OverridepublicvoidsetValues(PreparedStatementpstmt)throwsSQLException{pstmt.setObject(1,""name4"");}});Assert.assertEquals(1,count);StringdeleteSql=""deletefromtestwherename=?"";count=jdbcTemplate.update(deleteSql,newObject[]{""name4""});Assert.assertEquals(1,count);}通过JdbcTemplate的intupdate(Stringsql,PreparedStatementSetterpss)执行预编译sql，其中sql参数为“insertintotest(name)values(?)”，该sql有一个占位符需要在执行前设值，PreparedStatementSetter实现就是为了设值，使用setValues(PreparedStatementpstmt)回调方法设值相应的占位符位置的值。JdbcTemplate也提供一种更简单的方式“update(Stringsql,Object...args)”来实现设值，所以只要当使用该种方式不满足需求时才应使用PreparedStatementSetter。3）结果集处理回调：java代码：Java代码@TestpublicvoidtestResultSet1(){jdbcTemplate.update(""insertintotest(name)values('name5')"");StringlistSql=""select*fromtest"";Listresult=jdbcTemplate.query(listSql,newRowMapper<Map>(){@OverridepublicMapmapRow(ResultSetrs,introwNum)throwsSQLException{Maprow=newHashMap();row.put(rs.getInt(""id""),rs.getString(""name""));returnrow;}});Assert.assertEquals(1,result.size());jdbcTemplate.update(""deletefromtestwherename='name5'"");}RowMapper接口提供mapRow(ResultSetrs,introwNum)方法将结果集的每一行转换为一个Map，当然可以转换为其他类，如表的对象画形式。java代码：Java代码@TestpublicvoidtestResultSet2(){jdbcTemplate.update(""insertintotest(name)values('name5')"");StringlistSql=""select*fromtest"";finalListresult=newArrayList();jdbcTemplate.query(listSql,newRowCallbackHandler(){@OverridepublicvoidprocessRow(ResultSetrs)throwsSQLException{Maprow=newHashMap();row.put(rs.getInt(""id""),rs.getString(""name""));result.add(row);}});Assert.assertEquals(1,result.size());jdbcTemplate.update(""deletefromtestwherename='name5'"");}RowCallbackHandler接口也提供方法processRow(ResultSetrs)，能将结果集的行转换为需要的形式。java代码：Java代码@TestpublicvoidtestResultSet3(){jdbcTemplate.update(""insertintotest(name)values('name5')"");StringlistSql=""select*fromtest"";Listresult=jdbcTemplate.query(listSql,newResultSetExtractor<List>(){@OverridepublicListextractData(ResultSetrs)throwsSQLException,DataAccessException{Listresult=newArrayList();while(rs.next()){Maprow=newHashMap();row.put(rs.getInt(""id""),rs.getString(""name""));result.add(row);}returnresult;}});Assert.assertEquals(0,result.size());jdbcTemplate.update(""deletefromtestwherename='name5'"");}ResultSetExtractor使用回调方法extractData(ResultSetrs)提供给用户整个结果集，让用户决定如何处理该结果集。当然JdbcTemplate提供更简单的queryForXXX方法，来简化开发：java代码：Java代码//1.查询一行数据并返回int型结果jdbcTemplate.queryForInt(""selectcount(*)fromtest"");//2.查询一行数据并将该行数据转换为Map返回jdbcTemplate.queryForMap(""select*fromtestwherename='name5'"");//3.查询一行任何类型的数据，最后一个参数指定返回结果类型jdbcTemplate.queryForObject(""selectcount(*)fromtest"",Integer.class);//4.查询一批数据，默认将每行数据转换为MapjdbcTemplate.queryForList(""select*fromtest"");//5.只查询一列数据列表，列类型是String类型，列名字是namejdbcTemplate.queryForList(""selectnamefromtestwherename=?"",newObject[]{""name5""},String.class);//6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上SqlRowSetrs=jdbcTemplate.queryForRowSet(""select*fromtest"");3）存储过程及函数回调：首先修改JdbcTemplateTest的setUp方法，修改后如下所示：java代码：Java代码@BeforepublicvoidsetUp(){StringcreateTableSql=""creatememorytabletest""+""(idintGENERATEDBYDEFAULTASIDENTITYPRIMARYKEY,""+""namevarchar(100))"";jdbcTemplate.update(createTableSql);StringcreateHsqldbFunctionSql=""CREATEFUNCTIONFUNCTION_TEST(strCHAR(100))""+""returnsINTbeginatomicreturnlength(str);end"";jdbcTemplate.update(createHsqldbFunctionSql);StringcreateHsqldbProcedureSql=""CREATEPROCEDUREPROCEDURE_TEST""+""(INOUTinOutNameVARCHAR(100),OUToutIdINT)""+""MODIFIESSQLDATA""+""BEGINATOMIC""+""insertintotest(name)values(inOutName);""+""SEToutId=IDENTITY();""+""SETinOutName='Hello,'+inOutName;""+""END"";jdbcTemplate.execute(createHsqldbProcedureSql);}其中CREATEFUNCTIONFUNCTION_TEST用于创建自定义函数，CREATEPROCEDUREPROCEDURE_TEST用于创建存储过程，注意这些创建语句是数据库相关的，本示例中的语句只适用于HSQLDB数据库。其次修改JdbcTemplateTest的tearDown方法，修改后如下所示：java代码：Java代码@AfterpublicvoidtearDown(){jdbcTemplate.execute(""DROPFUNCTIONFUNCTION_TEST"");jdbcTemplate.execute(""DROPPROCEDUREPROCEDURE_TEST"");StringdropTableSql=""droptabletest"";jdbcTemplate.execute(dropTableSql);}其中drop语句用于删除创建的存储过程、自定义函数及数据库表。接下来看一下hsqldb如何调用自定义函数：java代码：Java代码@TestpublicvoidtestCallableStatementCreator1(){finalStringcallFunctionSql=""{callFUNCTION_TEST(?)}"";List<SqlParameter>params=newArrayList<SqlParameter>();params.add(newSqlParameter(Types.VARCHAR));params.add(newSqlReturnResultSet(""result"",newResultSetExtractor<Integer>(){@OverridepublicIntegerextractData(ResultSetrs)throwsSQLException,DataAccessException{while(rs.next()){returnrs.getInt(1);}return0;}));Map<String,Object>outValues=jdbcTemplate.call(newCallableStatementCreator(){@OverridepublicCallableStatementcreateCallableStatement(Connectionconn)throwsSQLException{CallableStatementcstmt=conn.prepareCall(callFunctionSql);cstmt.setString(1,""test"");returncstmt;}},params);Assert.assertEquals(4,outValues.get(""result""));}{callFUNCTION_TEST(?)}：定义自定义函数的sql语句，注意hsqldb{?=call…}和{call…}含义是一样的，而比如mysql中两种含义是不一样的；params：用于描述自定义函数占位符参数或命名参数类型；SqlParameter用于描述IN类型参数、SqlOutParameter用于描述OUT类型参数、SqlInOutParameter用于描述INOUT类型参数、SqlReturnResultSet用于描述调用存储过程或自定义函数返回的ResultSet类型数据，其中SqlReturnResultSet需要提供结果集处理回调用于将结果集转换为相应的形式，hsqldb自定义函数返回值是ResultSet类型。CallableStatementCreator：提供Connection对象用于创建CallableStatement对象outValues：调用call方法将返回类型为Map<String,Object>对象；outValues.get(""result"")：获取结果，即通过SqlReturnResultSet对象转换过的数据；其中SqlOutParameter、SqlInOutParameter、SqlReturnResultSet指定的name用于从call执行后返回的Map中获取相应的结果，即name是Map的键。注：因为hsqldb{?=call…}和{call…}含义是一样的，因此调用自定义函数将返回一个包含结果的ResultSet。最后让我们示例下mysql如何调用自定义函数：java代码：Java代码@TestpublicvoidtestCallableStatementCreator2(){JdbcTemplatemysqlJdbcTemplate=newJdbcTemplate(getMysqlDataSource);//2.创建自定义函数StringcreateFunctionSql=""CREATEFUNCTIONFUNCTION_TEST(strVARCHAR(100))""+""returnsINTreturnLENGTH(str)"";StringdropFunctionSql=""DROPFUNCTIONIFEXISTSFUNCTION_TEST"";mysqlJdbcTemplate.update(dropFunctionSql);mysqlJdbcTemplate.update(createFunctionSql);//3.准备sql,mysql支持{?=call…}finalStringcallFunctionSql=""{?=callFUNCTION_TEST(?)}"";//4.定义参数List<SqlParameter>params=newArrayList<SqlParameter>();params.add(newSqlOutParameter(""result"",Types.INTEGER));params.add(newSqlParameter(""str"",Types.VARCHAR));Map<String,Object>outValues=mysqlJdbcTemplate.call(newCallableStatementCreator(){@OverridepublicCallableStatementcreateCallableStatement(Connectionconn)throwsSQLException{CallableStatementcstmt=conn.prepareCall(callFunctionSql);cstmt.registerOutParameter(1,Types.INTEGER);cstmt.setString(2,""test"");returncstmt;}},params);Assert.assertEquals(4,outValues.get(""result""));}publicDataSourcegetMysqlDataSource(){Stringurl=""jdbc:mysql://localhost:3306/test"";DriverManagerDataSourcedataSource=newDriverManagerDataSource(url,""root"","""");dataSource.setDriverClassName(""com.mysql.jdbc.Driver"");returndataSource;}getMysqlDataSource：首先启动mysql（本书使用5.4.3版本），其次登录mysql创建test数据库（“createdatabasetest;”），在进行测试前，请先下载并添加mysql-connector-java-5.1.10.jar到classpath；{?=callFUNCTION_TEST(?)}：可以使用{?=call…}形式调用自定义函数；params：无需使用SqlReturnResultSet提取结果集数据，而是使用SqlOutParameter来描述自定义函数返回值；CallableStatementCreator：同上个例子含义一样；cstmt.registerOutParameter(1,Types.INTEGER)：将OUT类型参数注册为JDBC类型Types.INTEGER，此处即返回值类型为Types.INTEGER。outValues.get(""result"")：获取结果，直接返回Integer类型，比hsqldb简单多了吧。最后看一下如何如何调用存储过程：java代码：Java代码@TestpublicvoidtestCallableStatementCreator3(){finalStringcallProcedureSql=""{callPROCEDURE_TEST(?,?)}"";List<SqlParameter>params=newArrayList<SqlParameter>();params.add(newSqlInOutParameter(""inOutName"",Types.VARCHAR));params.add(newSqlOutParameter(""outId"",Types.INTEGER));Map<String,Object>outValues=jdbcTemplate.call(newCallableStatementCreator(){@OverridepublicCallableStatementcreateCallableStatement(Connectionconn)throwsSQLException{CallableStatementcstmt=conn.prepareCall(callProcedureSql);cstmt.registerOutParameter(1,Types.VARCHAR);cstmt.registerOutParameter(2,Types.INTEGER);cstmt.setString(1,""test"");returncstmt;}},params);Assert.assertEquals(""Hello,test"",outValues.get(""inOutName""));Assert.assertEquals(0,outValues.get(""outId""));}{callPROCEDURE_TEST(?,?)}：定义存储过程sql；params：定义存储过程参数；SqlInOutParameter描述INOUT类型参数、SqlOutParameter描述OUT类型参数；CallableStatementCreator：用于创建CallableStatement，并设值及注册OUT参数类型；outValues：通过SqlInOutParameter及SqlOutParameter参数定义的name来获取存储过程结果。JdbcTemplate类还提供了很多便利方法，在此就不一一介绍了，但这些方法是由规律可循的，第一种就是提供回调接口让用户决定做什么，第二种可以认为是便利方法（如queryForXXX），用于那些比较简单的操作。",2015/10/30
161,Linux 下部署web项目,赵本,http://180.168.156.212:2262/wecenter/?/article/9133,"1、当把项目配上域名时，必须把tomcat的端口改为80，注意当替换配置文件时，要记得把tomcat端口改一下。2、C盘下的hosts文件，是配置域名用的，当不在hosts配置域名时，windows系统会到外网去找符合的域名，当在hosts下配置域名时，就不会到外网去找了。3、文件更新的整个流程：（1）：用远程控制连接到11或12服务器。（2）：登陆ftp，替换要替换的文件。（3）：用SSH连接到外网服务器，执行一个shell脚本，mis_updata.sh这个shell脚本执行的整个过程：【1】：判断登录者是否是root用户，如果不是root用户，su到root用户。【2】：获得系统时间，停止tomcat服务，这里有的时候会报Connectionrefused错误，原因是：本来tomcat没有启动，但执行shell脚本时，首先会去关闭tomcat所以就报了这个错误。【3】：移动原来的mainone项目，并在项目后面加上系统时间。这里须注意一下路径问题，复制后的项目放到/app/java_project/mis/updata目录下。【4】：把备份后的项目移动到原来项目的路径下(/app/java_project/mis/mainone)，并把名字改为原来项目的名字，这里也要注意路径的问题。（当自己写shell脚本时）【5】：开启tomcat服务，并把改好后的项目复制一份到updata目录下，并重命名为mis_beifen。这以步其实就是项目的备份。【6】：把备份项目的权限改为777最大权限。【7】：退出root用户。4、当配置全局数据源时，需要在app/java_project/tomcat5.0/conf/Catalina/www.dayumi11.com目录下添加ROOT.xml，注：这个配置文件里必须有全局数据源的配置。/www.dayumi11.com这个目录是启动tomcat后自动生成的，不用自己手动建。但生成这个目录时会报错，因为配置全局数据源需要添加ROOT.xml文件。5、项目的运行目录：/app/java_project/mis/mainone项目的备份目录：/app/java_project/mis/updata/mis_beifen6、shell脚本的目录：/home/mis/updata7、定时清空catalina.out文件：系统自动执行/home/mis/clear_logs下的clear_logs.sh脚本。要不catalina.out文件会慢慢变大，吃内存！8、注意：当你更新完项目后，mainone与mis_beifen是完全相同的，当你要再更新项目时，其实是三个文件是完全相同的，mainone、mis_beifen、mainone_back2007_10_10_10_46_179、shell脚本更新的步骤：（1）、先停tomcat。（2）、把当前正在跑的项目（mainone），移动到/app/java_project/mis/updata下作下备份，在后面加上系统的时间（mainone_2007_10_10_14_38）。（3）、把改好的项目（mis_beifen）移动到/app/java_project/mis下，并重命名为mainone。（4）、开启tomcat。（5）、把现在正在跑的项目mainone，cp-R到/app/java_project/mis/updata/目录下，并重命名为mis_beifen。（6）、把mis_beifen的权限改为最大777。10、mis_updata.sh是在备份里（mis_beifen）里更新，这个要重启tomcat。jsp_updata.sh是在正在跑的项目（mainone）里更新，这个不用重启tomcat。11、进程:ps-aux|grepmysql可以查看进程ps-9（强制杀进程）12、到的问题：在虚拟机下挂载windows盘，不怎么好挂，因为虚拟机相当于一台新的机器，不是双系统，是双系统的话，直接挂载就可以了,也可以设置为linux系统启动就自动挂载windows盘符。13、tomcat启动加载ROOT.xml：正如笔者所说：第一次tomcat启动加载的是server.xml，在server.xml中找到项目的路径，然后在localhost目录下，自动生成一个ROOT.xml文件，这个文件也保存项目路径的信息。等你第二次启动tomcat时，就会发现tomcat会自动加载ROOT.xml而不去加载server.xml文件，因为ROOT.xml文件中也有项目的路径。14、Linux下的crontab是Linux下对某个文件进行备份的一个服务，可以自动备份，但得要配置，配置就google一下！！例子：crontab-uroot/app/java_project/dayumi/oa.txt设置某个用户对某个文件得crontab服务。15、这次问题小结：（1）、首先是tomcat的配置有问题，jdk1.5以上的只需要配置JAVA_HOME即可，不用配置Catalina_home。（2）、当配置全局数据源时，必须加上ROOT.xml。（3）、在tomcat的配置文件server.xml中，配置了域名、加载项目的路径、数据库连接池、数据源。注：不太清楚tomcat启动时，怎么加载server.xml文件的，正常情况下，tomcat启动时，会加载web.xml文件，而其他想要被加载的文件，都应该在web.xml中配置，例如sturts-config.xml。也可能是，tomcat启动时自动加载server.xml，根据server.xml的配置找到项目的路径，加载项目。（4）、陈雷给我的是编译好的文件，只有jsp、js、css、和.class文件，没有java文件。（5）、正常情况下：应该把编译好的.class文件放到webapp目录下，tomcat启动时才会加载.class文件，这是一个符合J2EE标准的项目。（见：老李建的目录），但在本项目中没有把.class文件放到webapp目录下，可能就是配置了tomcat数据源的缘故，在server.xml文件中配置了加载项目的路径。16、tomcat启动后，等项目完全加载后，在用浏览器访问时，不要急于访问。",2015/10/30
162,怎么解决MyEclipse 在写代码的时候不进行自动检查文件错误,赵本,http://180.168.156.212:2262/wecenter/?/article/9131,"优化MyEclipse1、关闭MyEclipse的自动validationwindows>perferences>myeclipse>validation,将Build下全部勾取消需要验证某个文件的时候，可以单独去验证。方法是：在需要验证的文件上(右键->MyEclipse->RunValidation。2、启动优化，关闭不需要使用的模块Window>perferences>General>StartupandShutdown>将Plug-insactivatedonstartup中的复选框有选择性的勾选去掉。3、去掉MyEclipse的拼写检查（如果你觉的有用可以不去）拼写检查会给我们带来不少的麻烦，我们的方法命名都会是单词的缩写，他也会提示有错，所以最好去掉，没有多大的用处Window>perferences>General>Editors>TextEditors>Spelling>将Enablespellchecking复选框的勾选去掉。4、修改MyEclipse编辑JSP页面时的编辑工具Window>perferences>General>Editors>FileAssociations>在Filetypes中选择*.jsp>在Associatededitors中将""MyEclipseJSPEditor""设置为默认。还有XML文件的默认编辑器5、老是弹出Quickupdateerror、关闭myeclipse的QuickUpdate自动更新功能这个问题的解决办法是关闭自动更新Windows>Preferences>MyEclipseEnterpriseWorkbench>CommunityEssentials,把选项""Searchfornewfeaturesonstartup""的前勾去掉即可。6、使用JRockit作为Eclipse的JavaVMEclipse启动参数，指定eclipse启动时使用的jre""E:\MyEclipse8.0\MyEclipseBlueEdition8.0GA\myeclipse-blue.exe""-vmE:\JRockit\jrrt-3.1.2-1.6.0\bin\javaw.exe-vmargs-Xms256m-Xmx512m在Eclipse里面，Window>Preferences，然后选择Java>InstalledJREs添加JRockit，并设置为默认。这样，就可以用JRockit来编译项目了。7.关闭自动更新1.window->Perferences->General->StartupandShutdown勾掉AutomaticUpdatesScheduler(自动更新调度程序)2.window->Perferences->MyEclipse->Maven4MyEclipse勾上EnableMaven4MyEclipsefeatrures;确定关闭窗口;该步骤是为了显示第3步中的Maven节点3.window->Perferences->MyEclipse->Maven4MyEclipse–>Maven勾掉Downloadrepositoryindexupdatesonstartup8、修改MyEclipse安装目录的eclipse.ini文件，加大JVM的非堆内存具体内容如下：-clean-showsplashcom.genuitec.myeclipse.product.ide–launcher.XXMaxPermSize256m-vmargs-Xms128m-Xmx512m-Duser.language=en-XX:PermSize=128M-XX:MaxPermSize=256M把下面的那个-XX:MaxPermSize调大，比如-XX:MaxPermSize=512M，再把-XX:PermSize调成跟-XX:MaxPermSize一样大9.代码自动提示的设置：“window”→“Preferences”→“java”→“Editor”→“ContentAssist”→“ContentAssist”→右边的“Auto-Activation”下面的“AutoActivationtriggersforjava”选项10.别同时跑多个项目，暂时用不到的就close掉，用到再开",2015/10/30
163,“三品一标”还是“四品一标”？,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9130,无公害农产品、绿色食品、有机农产品和农产品地理标志统称“三品一标”。“三品一标”是政府主导的安全优质农产品公共品牌，是当前和今后一个时期农产品生产消费的主导产品。“四品一标”则是在“三品一标”的基础上增加了“决不食品”，但由于主导“决不食品”（ portal.php）推广的是一个民间组织，并没有得到官方认可，所以正规的说法应该是“三品一标”！三品一标管理办法.zip,2015/10/30
164,信息发展2016校园招聘——西安站 首站告捷,李宏辉,http://180.168.156.212:2262/wecenter/?/article/9129,同学们，原谅小编到现在才发布消息，因为小编忙着在整理西安场的简历，各位同学如果有接到区号为021的电话请速度接起吧，电话的那头可是有好消息通知你的哦，哈哈~~回顾我们的西安之行，同学们的热情让小编感觉满满都是爱呀。DAY1：暖场篇：宣讲会正式开始之前，陆陆续续有很多的同学们进场了，小编看着一个个空位被填满，心里甚是满足…宣讲会正式开始：担任本次主讲人的是人力资源部经理，她基于自己多年的就职经历和长期人力资源的经验，结合应届生的求职关注点侧重介绍了公司的发展历程和行业定位，同时对于同学们最为关注的晋升体制和培养体系都做了详细的讲解，学生们都听的津津有味。宣讲中更增加互动环节，更是本次宣讲的亮点，同学们对于信息发展对于公司的业务都有了更进一步的了解。两位信息发展的技术大咖，借此机会也与同学们分享了他们与信息发展共同成长的点滴，希望也可以给目前在择业的同学们一些明确的方向。同学们一双双期望的小眼神，相信从各位前辈语重心长的成长历程中也得到了些许的小领悟吧。小编希望，多年之后，站在舞台进行分享的会是在座的各位……回顾宣讲会现场，小编不经感叹小伙伴们的热情，如果你们仅仅以为是坐无缺席…那你们就错了哟，西电同学们的热情，爆棚的场景让我们都震惊了……相信定是我们信息发展的魅力无法挡呦，整场的宣讲会的队伍一直排到了教室外楼梯口……同学们，你们也真真是辛苦了……旁听的同学们明年我们一定安排足够多的坐席提供给各位，今年不好意思了呦）笔试篇：宣讲会结束后，我们预留了45分钟给到各位做了相应岗位的试卷，考题不难吧……笔试阅卷ing笔试结束、同学们散场后，各位面试官回到酒店连夜批阅了各位的试卷，同学们相信也在当晚的第一时间收到了通知面试的电话了吧。不得不说，为了让各位同学第一时间收到面试通知，我们的面试官们也够拼的呀。DAY2致我们4位认真工作的面试官们，他们都超nice，小伙伴们面试都要加油哦…放眼望去，我们超nice超职业的4位面试官在对于初出茅庐的同学们的面试上也做到了绝对的专业，希望可以通过短短的面试时间让同学们更了解我们的公司，更了解我们招聘的岗位。PS:不得不在这里再恭喜一下获大奖的这个同学，希望信息发展可以给你一个平台，可以你可以找到属于你的一片天空。感谢西安电子科技大学的小伙伴们对于信息发展慢慢的爱意，你们的热情小编已经感受到了。期待10月28日（星期三）上海站——上海海事大学顺利拉开序幕。小编要继续去电话通知各位西电小伙伴了，其他各站的校园宣讲信息务必留意我们的微信号。详情点击： /s?__biz=MzIyNzAzODg5OQ==&mid=400257181&idx=1&sn=fb6755a5abaccb1dda69886cdbd2ffe6&scene=1&srcid=1026HLDiJUSxh3oTapxG4tzX&from=groupmessage&isappinstalled=0#rd中信学院,2015/10/30
165,行业标准项目《档案社会保管服务机构管理规范》征求意见,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9128, 档案寄存托管业务大有可为，但显然江苏仁通档案管理咨询服务有限公司等第三方档案服务机构已经走在了我们前面。档案社会保管服务机构管理规范（征求意见稿）.doc《档案管理服务外包工作规范第1部分：总则》.doc,2015/10/30
166,2015年8月经验共享,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9127,2015年8月经验共享Nginx反向代理tomcat及动静态资源分离.html,2015/9/30
167,Flash矢量图与位图性能对比,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9126,Flash中使用位图的性能要高于矢量图，究竟有多大区别呢？数据有最好的说服力，开始测试：一、机器配置二、测试过程测试程序控制红色小球在舞台中不停匀速移动，通过改变小球数量控制实际帧率在24帧/秒。Fla默认帧率设置为25帧/秒，比较主流的游戏帧率，24帧可以认为已经达到处理瓶颈。增减小球：上（↑）：增加10个小球，按住Shift键为100个下（↓）：删除10个小球，按住Shift键为100个考虑到鼠标事件对影响性能，禁止了小球的鼠标事件下面开始测试：1、矢量图2、使用“缓存为位图”选项3、位图无导出类4、位图有导出类（我管这叫“纯位图”）三、结果分析以下是收集到的测试数据，手边没有收集CPU的工具，用的任务管理器，但误差不大另外不同CPU在最终元件数量上可能有较大区别，整体比较应该差不多从统计中可以看出Flash在不同图形式上的处理差异很大：Flash的矢量图渲染性能真的很差，不到纯位图的10%。有意思的是CPU使用没有限制有多少用多少，因为有其他程序在跑无法达到100%，此时的机器使用量已经在95%以上；“缓存为位图”选项，在性能提升上非常明显示，应该可以满足大部份情况下的性能要求，遗憾的是内存增加不少，这里没有收集内存了，有兴趣的可以跑起来观察下；没有导出类的位图作为动画元素时，几乎不能带来性能提升，这个问题很严重，你有没有偷懒忘了给位图设置导出类呢？如果只是单一背景这个并不明显，有兴趣也可以试试；有导出类的位图性能没得说了，稍有点遗憾的是swf文件会变大；位图渲染时，CPU使用上限有明显的限制——仅能使用单核的比例。,2015/9/28
168,[Flex] 手机号码归属地查询,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9125,"<?xmlversion=""1.0""encoding=""utf-8""?><s:Applicationxmlns:fx="" .cn"":Alert.show(""手机号码错误"");return;break;}vararr:Array=str.split(""："");vararr1:Array=arr[1].split("""");varlen:uint=arr1.length;for(vari:uint=0;i<len;i++){arrMobile.addItem(arr1[i]);}}privatefunctionhandleFault(event:FaultEvent):void{Alert.show(""出现网络，请确保您的网络正常"");}]]></fx:Script><s:Panelid=""panContainer""title=""手机号码归属地查询""width=""480""height=""320""cornerRadius=""4""><s:Labelx=""72""y=""57""text=""请输入手机号码:""/><s:Buttonid=""btnSearch""x=""343""y=""52""label=""查询""click=""searchMobile(event)""/><s:TextInputid=""tiMobile""x=""184""y=""51""enter=""searchMobile(null)""/><s:Labelx=""143""y=""117""text=""省份:""/><s:TextInputid=""tiProvince""text=""{arrMobile.getItemAt(0)}""x=""186""y=""110""editable=""false""/><s:Labelx=""142""y=""154""text=""城市:""/><s:TextInputid=""tiCity""text=""{arrMobile.getItemAt(1)}""x=""186""y=""148""editable=""false""/><s:Labelx=""142""y=""190""text=""类型:""/><s:TextInputid=""tiType""text=""{arrMobile.getItemAt(2)}""x=""186""y=""184""editable=""false""/></s:Panel></s:Application>",2015/9/28
169,tomcat手动指定jdk（setclasspath.bat文件中设置）,黄珍石,http://180.168.156.212:2262/wecenter/?/article/9124,"给客户安装软件的时候，也许客户不想你在人间的环境变量里设置来设置去，那么就要在tomcat里指定要使用的jdk了，其实很简单，只需要在setcl...给客户安装软件的时候，也许客户不想你在人间的环境变量里设置来设置去，那么就要在tomcat里指定要使用的jdk了，其实很简单，只需要在setclasspath.bat文件里的开头加上以下代码就可以了：setJRE_HOME=d:\jdk5.0setJAVA_HOME=d:\jdk5.0setJSSE_HOME=d:\jdk5.0假设jdk在d盘，但是如果照上面那样写，万一有时候客户不允许我们把jdk放在d盘，那就又要更改setclasspath.bat文件了，为了一劳永逸，可以这样做：将jdk放在tomcat目录下，然后将上面的内容更改为：setJRE_HOME=""%ATALINA_HOME%d:\jdk5.0""setJAVA_HOME=""%ATALINA_HOME%d:\jdk5.0""setJSSE_HOME=""%ATALINA_HOME%d:\jdk5.0""这样部署项目的时候我们只需要把tomcat放到任意的目录就OK了",2015/9/25
170,如何使用 Red5 插件创建 Red5 项目？,黄珍石,http://180.168.156.212:2262/wecenter/?/article/9123,Windows环境搭建Red5流媒体服务器指南测试环境：Windows7一、下载安装程序red5-server下载地址 搭建WindowsRed5流媒体服务器详解 keepingst...80961,2015/9/25
171,使用solr搭建你的全文检索,黄珍石,http://180.168.156.212:2262/wecenter/?/article/9122,"Solr是一个可供企业使用的、基于Lucene的开箱即用的搜索服务器。对Lucene不熟？那么建议先看看下面两篇文档：<o:p></o:p>实战Lucene，第1部分:初识Lucene： <o:p></o:p>下面主要说说需要注意的地方。<o:p></o:p>Solr的安装非常简单，下载solr的zip包后解压缩将dist目录下的war文件改名为solr.war直接复制到tomcat5.5的webapps目录即可。注意一定要设置solr的主位置。有三种方法。我采用的是在tomcat里配置java:comp/env/solr/home的一个JNDI指向solr的主目录（example目录下），建立/tomcat55/conf/Catalina/localhost/solr.xml文件。xml代码<ContextdocBase=""D:/solr.war""debug=""0""crossContext=""true""><Environmentname=""solr/home""type=""java.lang.String""value=""D:/solr/solr""override=""true""/></Context><o:p></o:p><o:p></o:p>观察这个指定的solr主位置，里面存在两个文件夹：conf和data。其中conf里存放了对solr而言最为重要的两个配置文件schema.xml和solrconfig.xml。data则用于存放索引文件。<o:p></o:p>schema.xml主要包括types、fields和其他的一些缺省设置。<o:p></o:p>solrconfig.xml用来配置Solr的一些系统属性，例如与索引和查询处理有关的一些常见的配置选项，以及缓存、扩展等等。<o:p></o:p>上面的文档对这两个文件有比较详细的说明，非常容易上手。注意到schema.xml里有一个xml代码<uniqueKey>url</uniqueKey>的配置，这里将url字段作为索引文档的唯一标识符，非常重要。<o:p></o:p>加入中文分词对全文检索而言，中文分词非常的重要，这里采用了qieqie庖丁分词（非常不错：））。集成非常的容易，我下载的是2.0.4-alpha2版本，其中它支持最多切分和按最大切分。创建自己的一个中文TokenizerFactory继承自solr的BaseTokenizerFactory。java代码/***CreatedbyIntelliJIDEA.*User:ronghao*Date:2007-11-3*Time:14:40:59*中文切词对庖丁切词的封装*/publicclassChineseTokenizerFactoryextendsBaseTokenizerFactory{/***最多切分默认模式*/publicstaticfinalStringMOST_WORDS_MODE=""most-words"";/***按最大切分*/publicstaticfinalStringMAX_WORD_LENGTH_MODE=""max-word-length"";privateStringmode=null;publicvoidsetMode(Stringmode){if(mode==null||MOST_WORDS_MODE.equalsIgnoreCase(mode)||""default"".equalsIgnoreCase(mode)){this.mode=MOST_WORDS_MODE;}elseif(MAX_WORD_LENGTH_MODE.equalsIgnoreCase(mode)){this.mode=MAX_WORD_LENGTH_MODE;}else{thrownewIllegalArgumentException(""不合法的分析器Mode参数设置:""+mode);}}@Overridepublicvoidinit(Map<String,String>args){super.init(args);setMode(args.get(""mode""));}publicTokenStreamcreate(Readerinput){returnnewPaodingTokenizer(input,PaodingMaker.make(),createTokenCollector());}privateTokenCollectorcreateTokenCollector(){if(MOST_WORDS_MODE.equals(mode))returnnewMostWordsTokenCollector();if(MAX_WORD_LENGTH_MODE.equals(mode))returnnewMaxWordLengthTokenCollector();thrownewError(""neverhappened"");}}<o:p></o:p><o:p></o:p>在schema.xml的字段text配置里加入该分词器。<o:p></o:p>xml代码<fieldtypename=""text""class=""solr.TextField""positionIncrementGap=""100""><analyzertype=""index""><tokenizerclass=""com.ronghao.fulltextsearch.analyzer.ChineseTokenizerFactory""mode=""most-words""/><filterclass=""solr.StopFilterFactory""ignoreCase=""true""words=""stopwords.txt""/><filterclass=""solr.WordDelimiterFilterFactory""generateWordParts=""1""generateNumberParts=""1""catenateWords=""1""catenateNumbers=""1""catenateAll=""0""/><filterclass=""solr.LowerCaseFilterFactory""/><filterclass=""solr.RemoveDuplicatesTokenFilterFactory""/></analyzer><analyzertype=""query""><tokenizerclass=""com.ronghao.fulltextsearch.analyzer.ChineseTokenizerFactory""mode=""most-words""/><filterclass=""solr.SynonymFilterFactory""synonyms=""synonyms.txt""ignoreCase=""true""expand=""true""/><filterclass=""solr.StopFilterFactory""ignoreCase=""true""words=""stopwords.txt""/><filterclass=""solr.WordDelimiterFilterFactory""generateWordParts=""1""generateNumberParts=""1""catenateWords=""0""catenateNumbers=""0""catenateAll=""0""/><filterclass=""solr.LowerCaseFilterFactory""/><filterclass=""solr.RemoveDuplicatesTokenFilterFactory""/></analyzer></fieldtype></types><o:p></o:p>完成后重启tomcat，即可在 p<o:p></o:p>体验到庖丁的中文分词。注意要将paoding-analysis.jar复制到solr的lib下，注意修改jar包里字典的home。<o:p></o:p>与自己的应用进行集成Solr安装完毕，现在可以将自己的应用与solr集成。其实过程非常的简单，应用增加数据-->根据配置的字段构建add的xml文档-->post至solr/update。<o:p></o:p>应用删除数据-->根据配置的索引文档唯一标识符构建delete的xml文档-->post至solr/update。<o:p></o:p>检索数据à构建查询xml—>get至/solr/select/-->对solr返回的xml进行处理-->页面展现。<o:p></o:p>具体的xml格式可以在solr网站找到。另外就是solr支持高亮显示，非常方便。<o:p></o:p>关于中文，solr内核支持UTF-8编码，所以在tomcat里的server.xml需要进行配置<o:p></o:p>xml代码<Connectorport=""8080""maxHttpHeaderSize=""8192""URIEncoding=""UTF-8""…/><o:p></o:p>另外，向solrPost请求的时候需要转为utf-8编码。对solr返回的查询结果也需要进行一次utf-8的转码。检索数据时对查询的关键字也需要转码，然后用“+”连接。<o:p></o:p>java代码String[]array=StringUtils.split(query,null,0);for(Stringstr:array){result=result+URLEncoder.encode(str,""UTF-8"")+""+"";}<o:p></o:p>",2015/9/25
172,Nginx基本配置、性能优化指南,黄珍石,http://180.168.156.212:2262/wecenter/?/article/9121,"基本的(优化过的)配置我们将修改的唯一文件是Nginx.conf，其中包含Nginx不同模块的所有设置。你应该能够在服务器的/etc/nginx目录中找到nginx.conf。首先，我们将谈论一些全局设置，然后按文件中的模块挨个来，谈一下哪些设置能够让你在大量客户端访问时拥有良好的性能，为什么它们会提高性能。本文的结尾有一个完整的配置文件。高层的配置Nginx.conf文件中，Nginx中有少数的几个高级配置在模块部分之上。userwww-data;pid/var/run/nginx.pid;worker_processesauto;worker_rlimit_nofile100000;user和pid应该按默认设置-我们不会更改这些内容，因为更改与否没有什么不同。worker_processes定义了nginx对外提供web服务时的worker进程数。最优值取决于许多因素，包括（但不限于）CPU核的数量、存储数据的硬盘数量及负载模式。不能确定的时候，将其设置为可用的CPU内核数将是一个好的开始（设置为“auto”将尝试自动检测它）。worker_rlimit_nofile更改worker进程的最大打开文件数限制。如果没设置的话，这个值为操作系统的限制。设置后你的操作系统和Nginx可以处理比“ulimit-a”更多的文件，所以把这个值设高，这样nginx就不会有“toomanyopenfiles”问题了。Events模块events模块中包含Nginx中所有处理连接的设置。events{worker_connections2048;multi_accepton;useepoll;}worker_connections设置可由一个worker进程同时打开的最大连接数。如果设置了上面提到的worker_rlimit_nofile，我们可以将这个值设得很高。记住，最大客户数也由系统的可用socket连接数限制（~64K），所以设置不切实际的高没什么好处。multi_accept告诉nginx收到一个新连接通知后接受尽可能多的连接。use设置用于复用客户端线程的轮询方法。如果你使用Linux2.6+，你应该使用epoll。如果你使用*BSD，你应该使用kqueue。（值得注意的是如果你不知道Nginx该使用哪种轮询方法的话，它会选择一个最适合你操作系统的）HTTP模块HTTP模块控制着Nginxhttp处理的所有核心特性。因为这里只有很少的配置，所以我们只节选配置的一小部分。所有这些设置都应该在http模块中，甚至你不会特别的注意到这段设置。http{server_tokensoff;sendfileon;tcp_nopushon;tcp_nodelayon;...}server_tokens并不会让nginx执行的速度更快，但它可以关闭在错误页面中的nginx版本数字，这样对于安全性是有好处的。sendfile可以让sendfile()发挥作用。sendfile()可以在磁盘和TCPsocket之间互相拷贝数据(或任意两个文件描述符)。Pre-sendfile是传送数据之前在用户空间申请数据缓冲区。之后用read()将数据从文件拷贝到这个缓冲区，write()将缓冲区数据写入网络。sendfile()是立即将数据从磁盘读到OS缓存。因为这种拷贝是在内核完成的，sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效(更多有关于sendfile)。tcp_nopush告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。tcp_nodelay告诉nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。access_logoff;error_log/var/log/nginx/error.logcrit;access_log设置nginx是否将存储访问日志。关闭这个选项可以让读取磁盘IO操作更快(aka,YOLO)error_log告诉nginx只能记录严重的错误：keepalive_timeout10;client_header_timeout10;client_body_timeout10;reset_timedout_connectionon;send_timeout10;keepalive_timeout给客户端分配keep-alive链接超时时间。服务器将在这个超时时间过后关闭链接。我们将它设置低些可以让ngnix持续工作的时间更长。client_header_timeout和client_body_timeout设置请求头和请求体(各自)的超时时间。我们也可以把这个设置低些。reset_timeout_connection告诉nginx关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间。send_timeout指定客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接。limit_conn_zone$binary_remote_addrzone=addr:5m;limit_connaddr100;limit_conn_zone设置用于保存各种key（比如当前连接数）的共享内存的参数。5m就是5兆字节，这个值应该被设置的足够大以存储（32K*5）32byte状态或者（16K*5）64byte状态。limit_conn为给定的key设置最大连接数。这里key是addr，我们设置的值是100，也就是说我们允许每一个IP地址最多同时打开有100个连接。include/etc/nginx/mime.types;default_typetext/html;charsetUTF-8;include只是一个在当前文件中包含另一个文件内容的指令。这里我们使用它来加载稍后会用到的一系列的MIME类型。default_type设置文件使用的默认的MIME-type。charset设置我们的头文件中的默认的字符集gzipon;gzip_disable""msie6"";#gzip_staticon;gzip_proxiedany;gzip_min_length1000;gzip_comp_level4;gzip_typestext/plaintext/cssapplication/jsonapplication/x-javascripttext/xmlapplication/xmlapplication/xml+rsstext/javascript;gzip是告诉nginx采用gzip压缩的形式发送数据。这将会减少我们发送的数据量。gzip_disable为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。gzip_static告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了（想要更详尽的gzip_static的信息，请点击这里）。gzip_proxied允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求。gzip_min_length设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。gzip_comp_level设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置。gzip_type设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。#cacheinformationsaboutfiledescriptors,frequentlyaccessedfiles#canboostperformance,butyouneedtotestthosevaluesopen_file_cachemax=100000inactive=20s;open_file_cache_valid30s;open_file_cache_min_uses2;open_file_cache_errorson;###VirtualHostConfigs#akaoursettingsforspecificservers##include/etc/nginx/conf.d/*.conf;include/etc/nginx/sites-enabled/*;open_file_cache打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉。open_file_cache_valid在open_file_cache中指定检测正确信息的间隔时间。open_file_cache_min_uses定义了open_file_cache中指令参数不活动时间期间里最小的文件数。open_file_cache_errors指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。一个完整的配置userwww-data;pid/var/run/nginx.pid;worker_processesauto;worker_rlimit_nofile100000;events{worker_connections2048;multi_accepton;useepoll;}http{server_tokensoff;sendfileon;tcp_nopushon;tcp_nodelayon;access_logoff;error_log/var/log/nginx/error.logcrit;keepalive_timeout10;client_header_timeout10;client_body_timeout10;reset_timedout_connectionon;send_timeout10;limit_conn_zone$binary_remote_addrzone=addr:5m;limit_connaddr100;include/etc/nginx/mime.types;default_typetext/html;charsetUTF-8;gzipon;gzip_disable""msie6"";gzip_proxiedany;gzip_min_length1000;gzip_comp_level6;gzip_typestext/plaintext/cssapplication/jsonapplication/x-javascripttext/xmlapplication/xmlapplication/xml+rsstext/javascript;open_file_cachemax=100000inactive=20s;open_file_cache_valid30s;open_file_cache_min_uses2;open_file_cache_errorson;include/etc/nginx/conf.d/*.conf;include/etc/nginx/sites-enabled/*;}编辑完配置后，确认重启nginx使设置生效。sudoservicenginxrestart",2015/9/25
173,docker初体验之docker-tomcat,管俊,http://180.168.156.212:2262/wecenter/?/article/9120,docker已经是现在最热的容器技术，最近也去体验了一下，在daocloud注册了一个账号，并开始本机实战docker。daocloud免费有两个容器可用，体验送T恤，邀请送书，这里我分享一个daocloud的邀请码 2，dockerfile编写 38445979,2015/9/25
174,RESTful架构详解,管俊,http://180.168.156.212:2262/wecenter/?/article/9119,1.什么是RESTREST全称是RepresentationalStateTransfer，中文意思是表述（编者注：通常译为表征）性状态转移。它首次出现在2000年RoyFielding的博士论文中，RoyFielding是HTTP规范的主要编写者之一。他在论文中提到：“我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。”如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力，更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深，但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。所以我们这里描述的REST也是通过HTTP实现的REST。2.理解RESTful要理解RESTful架构，需要理解RepresentationalStateTransfer这个词组到底是什么意思，它的每一个词都有些什么涵义。下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。资源与URI统一资源接口资源的表述资源的链接状态的转移2.1资源与URIREST全称是表述性状态转移，那究竟指的是什么的表述?其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值)。下面是一些资源的例子：某用户的手机号码某用户的个人信息最多用户订购的GPRS套餐两个产品之间的依赖关系某用户可以办理的优惠套餐某手机号码的潜在价值要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(UniformResourceIdentifier)。URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源，只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI： on来区分不同的格式。这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。我个人认为，还是应该优先使用内容协商来区分表述格式。如何处理不支持的表述格式当服务器不支持所请求的表述格式，那么应该怎么办？若服务器不支持，它应该返回一个HTTP406响应，表示拒绝处理该请求。下面以github为例，展示了一个请求XML表述资源的结果：2.4资源的链接我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。这种反模式忽略了一个核心概念：“超媒体即应用状态引擎（hypermediaastheengineofapplicationstate）”。超媒体是什么?当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTfulWebServices》一书中，作者把这种具有链接的特性成为连通性。下面我们具体来看一些例子。下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。而在响应体里边，用url来链接项目所有者和项目地址。又例如下面这个例子，创建订单后通过链接引导客户端如何去付款。上面的例子展示了如何使用超媒体来增强资源的连通性。很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。所以，应该多花一些时间来给资源的表述提供链接，而不是专注于“资源的CRUD”。2.5状态的转移有了上面的铺垫，再讨论REST里边的状态转移就会很容易理解了。不过，我们先来讨论一下REST原则中的无状态通信原则。初看一下，好像自相矛盾了，既然无状态，何来状态转移一说?其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。2.5.1应用状态与资源状态实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。2.5.2应用状态的转移状态转移到这里已经很好理解了，“会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。这些类似“下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。3.总结现在广东XXX版本、XXX等项目中均使用传统的RPC、SOAP方式的Web服务，而移动南方基地XXXX项目的后台，虽然采用了JSON格式进行交互，但还是属于RPC风格的。本文从资源的定义、获取、表述、关联、状态变迁等角度，试图快速理解RESTful架构背后的概念。RESTful架构与传统的RPC、SOAP等方式在理念上有很大的不同，希望本文能对各位理解REST有所帮助。,2015/9/25
175,下一代云计算模式：Docker正掀起个性化商业革命,管俊,http://180.168.156.212:2262/wecenter/?/article/9118,"从2008年开始进入公众视野，到亚马逊与微软于近期获得1亿美元的美国联邦管理局云计算合同，云计算整整走过了7年。7年间，以第一代云计算技术为基础的移动计算、社交网络、大数据等新信息技术在全球商业领域掀起了一场新商业运动，这场商业运动创造出以消费者和用户为核心的个性化商业模式。从去年开始席卷云计算领域的Docker技术风潮，恰恰就是推动企业走近消费者和用户的一大步。本文通过深入分析，带你了解什么是Docker以及Docker将如何改变云计算，进而孵化出能够工业化生产个性化产品与服务的下一代商业模式。什么是Docker？答案是：Docker是下一代的云计算模式。Docker翻译成中文是“码头搬运工”的意思，那么“码头搬运工”搬运的是什么？是标准化的“集装箱”，这个标准化“集装箱”里装的是应用程序。“码头搬运工”在世界上任何提供了标准化接驳的“码头”就可以接收标准化“集装箱”，然后快速安装、运行和管理“集装箱”里的应用程序，而提供标准化接驳“码头”的就是各类云服务商。借此，Docker把云计算环境下的应用程序开发和分发带进了工业化生产的时代，这就是Docker的意义。在Docker环境下，程序开发者按一定的打包标准生产程序，生产出来的标准化程序被装进标准化的容器（Container）里，也就是“集装箱”。世界各国的云服务商都提供了标准化的“码头”，可以很容易地接收标准化的容器和里面的应用程序，再把这些标准化的应用程序以即插即用的方式组装到自己的个性化解决方案里，然后提供给最终用户。而与Docker“集装箱”对应的标准化程序架构，就是大家所熟悉的微服务。在Docker时代，第一代云计算中的IaaS层与PaaS层合二为一成为了CaaS（Container-as-a-Service，即容器即服务），这就是下一代云计算架构。基于CaaS的下一代云计算架构赋予了企业强大的工业化生产通用软件的能力，再根据消费者和用户的个性化需求，快速组装通用软件形成个性化的解决方案，这就是下一代的商业模式。容器时代的开拓者们根据美国市场调查公司SynergyResearch于2015年7月发布的Q2数据，全球云服务市场如今已经牢牢被四大厂商所垄断，AWS亚马逊云、微软、IBM和谷歌占据全球54%的云服务市场份额，而四大厂商的平均云计算业务年增长高达84%，相比之下市场上其它云计算厂商只有33%的年增长。其中AWS亚马逊云在今年第二季创造了18.2亿美元的营收，同比增长81%；而微软已经向其全球数据中心投入了150亿美元。显然，作为第一代云计算产业中的四大厂商，特别是谷歌、亚马逊和微软三大公有云已经远远将其它云服务商甩到了后面，而这三家自有的海量资金及融资能力则牢牢地建立起了第一代公有云的市场格局。2014年和2015年初，第一代主流公有云服务商核心技术团队中的华人技术专家开始不约而同地离开原来的公司，纷纷回到国内创业容器/Docker领域。这其中包括来自微软WindowsAzure核心技术团队的灵雀云、来自谷歌广告业务核心技术部门的数人云、来自EMC和VMware核心技术团队的DaoCloud道客云、来自IBMBluemix和阿里云盾核心技术团队的时速云，以及来自中国移动研究院云计算技术团队的Hyper云。这批创业公司的共同特点是创始人均来自第一代公有云核心技术团队，他们一方面发现了容器/Docker是下一代云计算的主流趋势，另一方面他们离开原有公司也是因为第一代公有云已经基本成熟。“为什么说云计算人才都在西雅图？这是因为亚马逊云和微软都在西雅图，而云计算的技术能力主要来自运维的经验，具有运维百万台以上服务器经验的技术人才只有谷歌、亚马逊云和微软三家而已。”灵雀云创始人、原微软WindowsAzure美国核心技术团队容器项目负责人左玥如是表示。灵雀云联合创始人、CTO陈恺也来自美国微软WindowsAzure核心技术团队并曾负责WindowsAzure的全球调度系统FabricController，陈恺经历了WindowsAzure从无到有、从几百台服务器到如今百万台服务器的全过程。另一家数人云的创始人王璞来自美国谷歌广告业务部门核心技术团队，他告诉记者全球公有服务商中拥有服务器数量第一的是谷歌，成立于1998年的谷歌在全球运维着上千万台服务器；其次是AWS亚马逊云和微软WindowsAzure，他们各自拥有和运维着数百万台服务器；再次是IBMSoftLayer拥有和运维着数十万台服务器；最后是各个国家的区域性公有云服务商，拥有和运维着从数百台到数千台不等的服务器，从运维服务器的规模就能直接判断公有云服务商的运维经验和技术水平。进化到容器时代容器（Container）是什么？这必须提到一个人和一家公司。这一个人就是著名的微软第二任也是最后一任首席架构师RayOzzie。2005年10月，刚加入微软不久的RayOzzie发布了一份名为“TheInternetServicesDisruption”（互联网服务时代来临）的备忘录，这份备忘录的主要目的是推动微软整体向互联网服务转型。在这篇文章中，RayOzzie提出著名的由面向服务软件架构所实现的“无缝用户体验”，并将之解析为“无缝沟通”、“无缝生产力”、“无缝娱乐”、“无缝市场”、“无缝操作系统”、“无缝解决方案”和“无缝IT”，这其中的核心就是“无缝操作系统”、“无缝解决方案”和“无缝IT”。在“无缝操作系统”、“无缝解决方案”和“无缝IT”实践方面，谷歌是一个先行者。著名的博主、原亚马逊中国研发经理、阿里巴巴资深专家陈皓有一个形象的比喻，云计算“就是要夏利车开出奔驰车的感觉”。谷歌就是把“夏利车开出奔驰车”的骨灰级玩家，说它是互联网公司和互联网技术的鼻祖都当之无愧。王璞介绍说谷歌在全球运维了上千万台的服务器，这个规模已经远远超出了很多现有技术供应商的上限，因此谷歌自己发明了诸多技术用于管理千万台规模服务器，“比如谷歌研发了顶级的网络交换机，就连思科都造不出来这样的网络交换机。原因很简单，因为没有相应的实验环境。”谷歌自1998年成立至今已经研发和储备了很多“核弹级技术”，但这些技术绝大多数都被谷歌封锁，只能通过谷歌对外发表的学术论文找到蛛丝马迹。谷歌为了避免使用市面上昂贵的基于物理机的虚拟化产品，同时也是为了更快、更便宜的发布自己的软件和服务，从一开始就研发了基于容器（Container）的新型虚拟化技术，通过这一技术简化了谷歌全部服务运行所需要的底层操作系统环境。在2015年8月的CNUTCon全球容器技术大会上，有超过8年谷歌经验的谷歌云平台软件工程师DawnChen介绍说，她8年半前加入谷歌的时候，那个时候谷歌刚开始研发容器技术，当时谷歌容器技术团队加上她只有两个人。如今谷歌所有的服务都运行在容器中，这包括了Gmail、地图、GFS文件系统、MapReduce等。谷歌现在每秒会启动大约7000个容器，每周会发布超过20亿个容器。谷歌实际上通过容器实现了“无缝操作系统”的愿景。稍微了解云计算的人都知道虚拟机在IaaS层的重要性，改变了虚拟机的方式就相当于改变了IaaS层的结构，这就是为什么说容器是下一代云计算模式的重要原因。容器本质上是一种操作系统技术，是基于操作系统的虚拟化技术。基于容器开发的应用软件可以达到“一处开发、处处运行”的效果，而无关乎底层到底是什么样的操作系统或什么样的IaaS云服务环境，这实际上就是“无缝操作系统”的概念，与之相适应的就是“无缝解决方案”和“无缝IT”。Docker一统江湖容器Container与Docker是两个英文单词，Docker相当于是标准化了的容器，是容器技术近30多年历史发展出的最新结果。作为操作系统级的虚拟化技术，容器技术本身的历史最早可以追溯到1982年。当时Unix推出的Chroot技术被公认为操作系统级虚拟化的起源，也就是容器技术最早的状态。随后，操作系统虚拟化技术与Linux内核及Linux操作系统的发展就交织在一起。因为操作系统虚拟化主要是针对廉价的X86服务器，因此英特尔和AMD服务器芯片技术的发展也影响了容器技术的发展。1991年，芬兰赫尔辛基大学研究生LinusTorvalds开发了针对386机器的Linux内核。在Linux内核的基础上，不同的厂商开发了商用化的Linux操作系统。1995年1月RedHat成立了，推出了RedHatLinux即为Linux“发行版”。随后，Linux内核不断更新，一直到2007年的时候，发展比较成熟的容器技术才进入了Linux内核，而这还要利益于2005年前后英特尔和AMD相继推出的64位服务器芯片。正因为有了CPU和内存芯片容量的大幅提升，才能在一个操作系统中虚拟出多个空间。2008年的时候，LXC也就是Linux容器开源项目成立，容器技术开始在业界广泛使用，而这一年微软也推出了第一代WindowsAzure公有云。2010年，一家叫作dotCloud的创业公司在美国成立了，dotCloud早期是基于LXC技术的PaaS平台，它的理念是提供跨底层IaaS云、支持多种开发语言的开发云平台。2011年初的时候，dotCloud获得了1000万美元的A轮融资。DotCloud最早运行在AWS的EC2上，但随着越来越多的公有云服务商进入，dotCloud的理念很难依靠一家公司专有的技术实现。于是，dotCloud的创始人在LXC的基础上，对容器技术进行了简化和标准化，命名为Docker后将其开源，同时推出了开放容器计划（OCI），Docker和Docker开源社区随后迅速火起来。2013年10月29日，dotCloud公司更名为Docker公司。随后，多家厂商开始宣布支持Docker。截止到2015年8月，公共的容器包应用程序Registry（由Docker维护）在公共社区发行了超过180000个应用程序。可以说X86架构的PC服务器是异构硬件架构的赢家，Linux和Windows是异构操作系统的赢家，Docker为基于X86服务器和Linux/Windows操作系统的云数据中心提供了统一的虚拟操作系统，异构架构时代开始结束。容器时代已经到来除了创业公司外，大厂商也不甘示弱，纷纷快速跟进。去年10月份，微软就宣布了在Windows服务器实现容器技术的计划，宣布了与Docker的合作伙伴关系，以保证无论是在Linux还是在WindowsServer，都可以获得一个统一、开放的体验。尽管Linux容器与Windows容器基于不同的操作系统而互不兼容，但容器管理器是统一的。近期，微软进一步宣布将针对WindowsServer2016发布WindowsServer容器和Hyper-V容器，两种容器都支持DockerAPI和Docker客户端。另一家受Docker冲击比较大的VMWare也迫不急待的在VMWareWorld2014上就宣布了对Docker的支持。VMware对容器的态度是积极的，尽管容器和基于物理机的虚拟机VM之间存在着竞争，但VMware仍然致力于扩大与容器生态合作。在2015年8月底的VMWareWorld2015大会上，VMware推出了一系列新的支持Docker的技术，并提出了未来全新的全面支持容器的技术架构，让Docker程序也能运行在虚拟机VM里了。此外，AWS亚马逊云从去年11月推出了EC2容器服务AWSECS，用户不再需要安装、运维、扩展集群管理基础设施，而只需进行简单的API调用就可以启动和停止支持Docker应用程序，随后阿里云等国内云厂商也推出了类似的服务。国内华为一直是各类开源项目、基金会、组织、峰会的活跃赞助商。2015年，华为作为创始成员相继加入开放容器标准组织OCI及CNCF（CloudNativeComputingFoundation），成为唯一在列的中国公司。华为开源能力中心的高级研发工程师梁辰晔在2015CNUT全球容器大会上表示，华为积极参与了开放容器测试项目（OCT），并与OCI组织一起促进开放容器标准的实现和普及。2015年至今，华为在Docker社区的贡献排名稳居前三位，而目前国内最早的Docker社区maintainer就来自华为。除了华为、阿里等国内云服务商外，腾讯、百度、360、京东、搜狐等国内互联网公司从2011年开始就已经开始全面实践容器技术了。据京东云平台首席架构师刘海峰在2015CNUT全球容器大会上的介绍，京东从2014年10月开始引入Docker，2015年2月对Docker进行战略立项，2015年618的时候在生产环境中发布了11000多个容器实例并接入了1000多个应用，从2015年8月开始的新数据中心全面采用容器技术。目前京东已上线Docker实例2万多，预计到年底将翻番，届时京东大部分应用程序将通过Docker的方式发布。未来京东的Docker愿景是通过Docker管理所有的机器，应用程序与物理资源之间完全解耦，实现全自动化的系统维护，研发人员可以集中精力于新应用程序的开发。说了这么多，其实对于容器贡献最大的还是谷歌。Docker技术就是用谷歌的Go语言编写的，这是谷歌2009发布的第二款开源编程语言。谷歌每周发布2亿多的容器，这让谷歌有能力发明很多关键性的容器技术。其中包括容器管理系统，这个管理系统的第一个版本被称为Borg，后续又发布了名为Omega的版本。通过这个管理系统，可以在谷歌的大规模集群资源上使用容器技术。后来业界根据谷歌的相关学术论文，模仿Borg开发出来的Mesos系统，正在被Airbnb、Twitter、苹果Siri等在使用。个性化商业：未来的企业都是软件企业财富500强艺康化工有限公司（Ecolab）董事长兼CEODouglasM.Baker,Jr.在参与普华永道的“2015全球CEO调查报告”调研中表示：“任何一家公司都不能想当然的认为今天的业务能够保证未来的成功。人们理所当然的认为大公司更加安全也更加稳定，但过去50年的事实证明了截然相反的结果。如果企业不能持续的快速变化，风险只能增加而不是减小。”变化的能力显然已经成为今后商业的核心竞争力。而随着互联网产业的影响力越来越庞大，互联网对于传统行业的入侵越来越剧烈、越来越深入，特别是中国“互联网+”国家战略的强力出台，未来的企业将越来越被互联网化。在这样一个全面互联网化的商业环境中，未来的企业将或多或少具备软件的能力。除了未来企业的业务将部分或全面架构在互联网上，企业为消费者和用户提供个性化服务也有赖于软件能力。如果未来的企业都是软件企业的话，Docker的重要性可想而之。硅谷老牌风投机构BatteryVetures的技术专家AdrianCockcroft在2015年中发布了一份《2015年度云之白皮书：业界里程碑回顾与未来展望》，他曾是美国流媒体服务商Netflix的云平台架构师，也是eBayResearchLabs的创始成员之一以及SunMicrosystems杰出工程师和高性能技术计算部门的首席架构师。他认为，Docker会逐渐成长为标准化的生产工具，这也从一个侧面反映出Docker的高接受度。Adrian表示，Docker的挑战是要谨慎管理生态系统，同时快速添加功能以支持生产环境的部署。目前为止，Docker已经阻止了一次生态系统的分裂。如今，甚至连芯片厂商英特尔公司也跨界加入了Docker的生态。今年5月，英特尔推出了以容器为中心的OS项目ClearLinux，目前已处于试验阶段，英特尔表明该系统未来可用于生产环境中。可以看出，在迈向未来商业的过程中，将出现越来越多的跨界行为。根据ThomsonReuters的数据，在美国仅2014年11月就涌现了10330起并购或收购，共代表了1.9万亿美元的交易金额。这些并购或收购更多的是为了扩大商业联盟，通过并购或收购具有不同业务或能力的公司，创造单一公司所无法实现的商业价值。普华永道“2015全球CEO调查报告”显示，美国约有44%的CEO将在调研后的12个月内启动新的战略联盟。过去的商业联盟主要是与供应商或用户连接，而在未来越来越多的CEO将选择与竞争对手、创业公司或不同领域的公司结为联盟。当然，包括DaoCloud核心团队成员孙宏亮在内的多个Docker技术专家都在不同场合表示，Docker还在发展的早期，存在网络功能薄弱、安全性、运行传统业务困难等挑战。正因为这些技术上的不成熟，于是在美国和中国出现了一批Docker创业公司，八仙过海、各显神通，勇于布局下一代云计算以及下一代商业。国内较早从事容器和Docker研究的浙江大学软件工程实验室（SoftwareEngineeringLab，SEL）云计算团队组建于2011年，专门搭建、分析和钻研开源的云计算技术。浙大SEL团队在其新出的《Docker—容器与容器云》一书中这样写道：“依靠容器技术支撑的Docker已经迅速成为国内外各大云计算厂商及开发者手中的至宝。在一片热火朝天之中，新的革命已经悄然来临。”附录：目前在中国从事Docker创业的公司灵雀云，创始团队成员是微软WindowsAzure的元老级核心技术成员，曾主导全球第一代云计算平台研发，其CaaS容器即服务具备企业级和全球化优势；数人云，创始团队成员来自美国谷歌的广告核心技术部门，主打Mesos+Docker的CaaS容器即服务，尽管Mesos有不少问题，但也是到目前为止成功在生产环境中应用过的管理工具；时速云，创始团队成员来自IBMBluemix和阿里云盾核心技术团队，其CaaS容器即服务带有对企业级私有云环境的技术优势；DaoCloud道客云，创始团队成员来自EMC和VMware核心技术团队，其CaaS容器即服务主打混合云和持续集成；Hyper，创始团队成员来自中国移动研究院云计算技术团队，其CaaS容器即服务主打在hypervisor虚拟机上运行Docker引擎，融合了Docker和虚拟机的优点。",2015/9/25
176,架构之路（三） 单元测试,管俊,http://180.168.156.212:2262/wecenter/?/article/9117,实事求是的讲，写《【野生程序员】：优先招聘》的时候，是带着情绪的。其后也有反思，是不是我杞人忧天了？尤其是下面开始的几条评论，如“都是混口饭吃的不容易”，“何以内外之分，中华儿女非山倾河泄而不能一气前指，千年亦是如此”等，让我感觉可能是我过于敏感了。但随后一些人长篇大论，让我明白，这篇博客还是有意义的。想一想，招聘启示里，你们要求“计算机专业本科以上学位”，我“无计算机专业相关专业文凭”优先；然后，你们就炸了！我们没有歧视，你这才是歧视！你自卑你愤青你酸你难成大器……我无力反驳，只是想说，每个人的言行都是他心灵的镜子。谢谢你们！其实，我没有想挑起科班/非科班之争（虽然可能结果会超出我的预料），我的本意是想给“非科班”的同学鼓气，缓解他们身上的压力，让他们看到希望，给他们力量，让他们相信，完全可以在更艰苦的环境下自学成才，而且结果不会比“科班”的差！但你一定要委下身段踏踏实实的去学，一步一个脚印的去做，自卑自大争吵辩驳都无助于你的成长。请牢记：言语没有力量！另外，愿意听一句的“科班”同学，“无计算机专业相关专业文凭”优先，并非完全出于义愤。都是筑基，你是名门大派用资源用丹药堆出来的，他是一路苦修战斗领悟突破的，你觉得谁更有潜力？所以啊，放下那些虚荣骄傲，真正的去战斗吧！毕业三年以后，是没人再看你的学历的。另外声明一点，对老赵没有任何意见，除了景仰。他针对的是培训机构我完全明白，但仍然不能赞同。所以我说，“每一次看到这一段文字，我的心里就会有一种难以言表的复杂情绪”，至于如何复杂，不是说了吗？难以言表啊。======================好，心平气和之后我们继续讨论技术问题。在带队的过程中，性能的问题还比较好解决，最消极的想法，“好啊，多一事不如少一事，你让我不管还不简单？”，但要求写测试代码，那就炸锅了！以我的经历，“测试驱动”是一个最具争议的话题，没有之一。吹捧者和反对者泾渭分明，而且都有大量的论据和证明。记得博客园曾经有一篇文章，大意是：“公司付钱给你不是让你写测试代码的”，下面一片狂赞。在我自己的项目开始的时候，我是放弃了测试驱动的（呵呵，还找到了原文），里面总结得很准确，最大的原因是“懒”。但最后让我下定决心开始“测试驱动”实践的，是我一次花了两天一夜都没调出一个Bug，垂头丧气筋疲力尽之后，无可奈何的接受了这个现实：测试还是很有用的——即使是自己写的代码。我之前的系列博客，也已经反复的强调，架构是一种“无奈”，是现实是问题驱使你去做一些其实你本来不想做的事情。你无法理解一些看起来像“脱了裤子放屁”一样的行为，通常只是因为你没有遭遇过那些现实那些问题。（看看，大学能教你这些东西么？）即使你没有多少开发经验，你也应该能够想象，单元测试最大的问题，就是它需要花时间花精力去写，那么这个花费是否值得呢？这还是由你架构的目标决定的，或者你的需求决定的。如果系统是一次成型交付使用，此后几乎不会更改的，那么一次性的手工测试就够了；但如果你的系统是会被“千锤百炼”的不断折腾修改的，那么这个测试就是很有必要的。最简单的考虑：每一次更改，我都要手工测试一次；那还不会如我多花点时间，弄个“自动化”的东西出来。单元测试，其实就可以理解为一种自动化的测试工具。但是“自动化”的理由还远远不够。因为你马上想到的，每一次需求变更代码调整，测试代码也得相应的改呀？没有测试代码，我就只需要改开发代码；现在有了单元测试，我还得再改测试代码。本来我只维护一套代码，现在我凭空增加了一套代码也需要维护，这不是增加了维护成本，不是和你“可维护性”的架构目标背道而驰了么？是一套代码好维护呢，还是两套代码更好维护？这是一个非常好的问题，适用于很多情景（比如分层架构，你说分层解耦，实际上还不是一改就得从UI层改到数据库，每一层都得改？）。我能给出的回答大概有：一、无论有无单元测试，开发代码进行修改之后，是不是都要进行测试？没有单元测试，并不代表你的代码就不需要测试了，只不过是你手工的去测试了一遍而已。切记：你的工作并不只是把代码写出来而已！二、进行手工测试，和更改单元测试，两者的耗费比，会根据测试重用的次数而变化。一次手工测试可能需要5分钟跑完，更改单元测试代码可能需要20分钟，但如果这测试会跑100遍，单元测试完胜手工测试。三、你说，哪里哟？什么功能会改100遍？我没说你的功能会改100遍，我说的是测试会跑100遍。有区别么？你可能还在犯迷糊，是吧？好吧，我们讲个故事。有一个小伙子，他很不情愿写测试代码。老板拿他没辙啊，也没那么多精力和他磨牙，于是老板自己写单元测试。这小伙子的代码提交之前要review，老板总能一次次的找出它代码的问题。他改的是登录，老板告诉他积分系统被他改出了问题；他又去改积分，老板又告诉他消息通知系统被他改坏了；他又去改消息系统，老板告诉他登录还是有问题……于是他崩溃了，“这TM什么一个烂系统”？最终他终于回过神来了，为什么老板总能知道这里的改动会影响那里呢？老板的思维有这么严谨？老板躲在一旁偷笑，就不告诉你，“其实我就是跑了一遍单元测试而已”。这个老板就是我。我故意的，就不一次性的告诉他所有的问题，就要这样一次次的折磨他，让他的痛苦能刻入骨子里去。最后，我还要问他：你现在对你的代码是不是还那么自信？如果没有我的review（我也是靠单元测试），你能不能发现这些问题？如果我们的项目已经部署到生产环境，而且你的改动带来的破坏没有被发现就上线了，会带来什么样的后果？这一次，他服气了。后来他用NUnit用得麻溜麻溜的。每一次改动，如果有意想不到的未通过testcase，他都会很激动的给我张截图，顺便发发牢骚。我微笑不语，那种满屏绿灯通过的踏实，和意外爆出红灯之后的惊喜，没有经历过的人，是无法体会的。所以其实当对象间的关系变得越来越错综复杂，像一张密密麻麻的网一样之后，一个局部的改动就很有可能会触发极其复杂的连锁反应。所以为了保险起见，所有可能相关的组件都应该进行测试（所谓的“回归测试”）。这时候如果只有纯粹的手工测试，会面临两个问题：难以确定测试的边界（那些部分可能会被影响），这得我们脑袋凭空硬想啊，兄弟！极大的测试耗费。而且这种耗费是相当的无聊繁琐伤人心的——没人愿意做这种事。据说所知，现在很多公司测试人员的工资已经比开发人员还高了。为什么？简单枯燥无聊，没人愿意做啊！好的，我假设你已经认识到了单元测试的重要性，并开始摩拳擦掌，跃跃欲试。接下来我得给你泼一大瓢冷水：单元测试不是那么好写的！从某种程度上讲，写单元测试比写开发代码还难。难得我工作的所有公司，没有一家有过成功的案例。大概是几年前，我在公司修bug，老大告诉我，“你这个功能比较核心，跑一下单元测试吧”。“哇塞！我们有单元测试？”一种高大上的感觉迅速弥漫全身，终于见到传说中的Unit了！捣鼓了一会，能跑了，试试看——我的个妈呀？怎么这么多红灯？我真被吓住了，这都是我的改动造成的？老大就是老大，不慌不忙，“数一下有多少个通不过？”“啊？”我以为我听错了，数多少个通不过有什么用？得把他们全部弄通过啊？！搞了一会儿，才终于弄明白了，把我改动前后的代码分别跑一遍，对照一下通过失败是不是一样的，只要是一样的，就OK了。比如，以前是8个通不过，现在还是8个通不过，这样就可以了！我一直不明白，为什么不把那8个通不过的单元测试给弄成通过呢？这样摆着究竟算什么？直到我自己开始写单元测试。坑爹啊！到处都是坑，跳出小坑进大坑，大坑下面还连着小坑，前面是坑后面是坑，一堆一堆的连环坑……单元测试写出来容易跑过难！而且跑不过的原因还不是你的开发代码逻辑错了，而是测试环境/数据出问题。要测试，一定要有数据，这个数据的构建，完全不是我们所想象的那么简单。以我们创业家园项目里的积分系统为例，假设一个简单的需求：博客被点赞，博客的作者应该获得一定积分，该积分数量是由点赞人目前所有的可用币转换而得来的（已简化，具体可参考文档：积分）。要准备的数据就有：博客一篇，要有作者，作者已有积分；点赞人一名，有一定数量可用币。如果只是这样，还可以接受，但其实下面会有一堆的问题：作者的积分从哪里来？我们的开发代码，出于封装的考虑，用户的积分是只读的，你单元测试怎么设这个值？要么写代码，模拟作者通过其他行为（发布文章回答问题等）获得积分，这将开启新一轮噩梦；如果用Mock或者反射强行设置，事实上省略了作者获得积分的历史，所以用户“积分历史”为null，之后对其“加积分”时，就会报异常。更坑的是，你以为你什么都处理好了的时候，你突然悲哀的发现，这个博客得首先“被发布”，而博客一经发布，其作者就获得了一定数量的积分，所以你以前设置的积分又变了！……点赞人的可用币，同样可能遇到类似的问题。可用币怎么设置，设置之后会不会在跑测试时被意外更改？点赞的行为，被封装成一个方法，运行这个方法，会检查点赞人之前是否已经对该文章点过赞，所以还应该有一个“点赞历史记录”，哪怕是空的，都得new一个，否则就空异常……反正当时是写得我直接摔了鼠标！写得憋屈啊！而且我还是完全隔绝了数据库的，真不知道那些要从数据库里取数据来跑单元测试的，是怎么做的？这时候我一下子就明白了，实际工作中加班赶进度，一个接一个的填坑，连重构的时间都没有，怎么可能还挤得出时间来写单元测试？就算开始雄心勃勃的写了，随着系统日益复杂，维护单元测试的成本也与日俱增，甚至复杂度更甚开发，所以放弃也就成了绝大多数项目的唯一选择。在公司上班么，大多数人都是这样的，能推就推。我们开发写完了代码，基本上能跑了，就该交给测试人员了呀！天经地义的嘛，是不是？而且测试的时间是不会计算到我的项目开发时间里的，我总算是按时完成了开发任务。累坏了，休息一下，让测试的忙活去吧，哈哈……但我是个光杆司令，我没测试人员啊！曾经有那么一两个时候，我真准备招一两个测试人员的。但好在我天生的节俭美德（也就是“抠”啦）让我冷静下来。我就想啊：测试只能告诉你出了bug，不能告诉你根源啊。没有单元测试，我单步调试，不也折腾了两天了么？这是系统本身的复杂性，或者代码组织的不合理造成的，不能归咎于单元测试。不还是有这么多开源代码都有详尽的单元测试么？他们是怎么做到的呢？在单元测试上的付出，最终一定会获得超值回报！想想没有单元测试的公司，那超级庞大的测试团队，或者四处冒烟的系统，你愿意走这么一条路么？所以我不断的告诫自己，不要着急，冷静细致。终于一步步抽丝剥茧，把这一团乱麻一点点的归纳整理，最终还真被我找到了一条路子，一个个的单元测试都慢慢完成通过了，开发代码里潜在的一些问题也浮出水面，被我一个个的消灭。最后再跑一遍单元测试，一路绿灯，哈哈！更奇迹的是，困扰我两天的bug不知道什么时候消失了？后来，我看到这样一种说法：可测试的代码不一定是好代码，但坏代码几乎是不可能被测试的。深以为然！深度耦合的代码，写他们的单元测试，难于上青天；但反过来，我们可以以可测试为标准，不断的完善重构开发代码，只要这样坚持下来，最终代码的质量怎么都不会差到哪里去。所以，于我而言，单元测试是否有价值的争论可以休矣！不如换个角度，想一想，怎样才能把单元测试坚持下去。最后，如果有心的同学就会注意到，我一直用的是“单元测试”，而不是“测试驱动”。因为测试驱动是一个更广阔的概念，是一个更崭新的天地！单元测试只是其中的一小部分，在下一篇博客，我会讲解我是如何试着将测试驱动的概念运用到项目开发管理中去的。这里，需要强调的一点：先写测试。一上手就写开发代码，写完了才写单元测试。这是很多开发人员的习惯，我也经常犯这样的毛病，一不留神就忘了。这样做最大的问题就是，没有真正实现“测试驱动”。你实际上还是由开发在驱动，那么很自然的，测试照着开发的if...else...写一遍，有什么意义呢？这样做下去，就会不断的强化“测试无用累赘”的印象，因为测试就是简单的把开发代码重写一遍而已。我开的药方是：单元测试代码和开发代码由不同的人员编写如果做不到上面一点，先写单元测试如果连上面一点也做不到，直到出了bug了再写单元测试第三条可能有同学无法理解，不是说单元测试很重要么？为什么要等到出了bug才写？答案是：偷懒呗！记住，我们程序员是世界上最懒的人，没意义的事从来不做！你先写开发代码再写测试真的没意义，没意义就干脆不要做了。但你可以开启“乐观模式”（或者“Lazy模式”？），先乐观的认为，我的代码没问题，或许真的就没问题呢，是吧？如果真出了问题，做一个补救，这个时候就应该用单元测试把这个问题表现出来，因为他根据墨菲定律，它这里出了问题，以后就很有可能继续出问题。这个时候，就不要再偷懒了。,2015/9/25
177,架构之路（二）：性能,管俊,http://180.168.156.212:2262/wecenter/?/article/9116,"我们在上一篇博客中设定了架构的目标，只有一个，就是可维护性。完全没有提性能，这是故意的。似乎程序员都是急性子，或许是被windows冗长的开机时间折磨够了，有可能是因为提升性能的效果是最显而易见的……总之，我发现，绝大部分程序员对性能的关注和热情是无与伦比的！C#刚刚推出的时候，就有人摇头晃脑的说，“嗯，自动垃圾回收，性能不行吧？”DataSet横空出世，马上有很多人写代码，在DataSet里插入几百万条数据，证明DataSet的性能问题Linq当然更要被骂了，尼玛用反射？反射是什么，同学们知道么？性能大老虎呀！更不用说那些自动生成的sql了，有我手写的高效么？……所以直到今天，我仍然看到很多程序员无怨无悔的用存储过程来构建他们的系统，一个存储过程可以有几千行！然后，他们很无辜的问，“业务层有什么用？究竟能干些什么呢？”在带团队的时候，我最怕讲的就是性能有关的问题。你要是不谈性能呢，那代码有时候真心看不下去；你要是强调性能呢，不知道他会给你整出什么幺蛾子出来。其实这就是一个“度”的掌握，所以非常难以用语言予以表示清楚。所以无数次挫败之后，我只好咬牙切齿的说，“你的代码，只有一个评判标准，可维护性。性能的问题先不管！”这个答案似乎并不能服众——尤其是对有上进心的程序员而言。所以，我先专篇讲性能，希望能帮助大家更清楚的认识这个问题。一、性能不是不重要，而是他没有可维护性重要。要理解这一点，首先要理解可维护性的重要（请再读上一篇我花数周找bug的段子）；然后要明白：解决性能问题，我们可以有很多代码以外行之有效的方法，而可维护性基本上就只能靠代码了；最后，还是要牢记：没有牺牲，就没有胜利！二、所以，在绝大多数情况下，当性能和可维护性相冲突的时候，性能让位于可维护性。我们采用其他办法来弥补代码性能不够高的问题。空洞的说教没有意义。我们还是举例来说明吧！破坏可读性前段时间我review代码的时候发现，这个程序员用Linq之后老是用First()而不是Single()，我就奇怪了，按业务逻辑，返回的值就应该是一个，难道可能会是多个，多个应报异常，不应该取First()就完事了呀？想了一会儿，问这个程序员，他的回答让我瞬间一种无力感，“First()性能更高呀！”以下为对话实录：“你怎么知道First()性能更高呢？”我问。“First()嘛，取了第一个合格的值就返回，就不会继续查下去了；Single()的话，就会一直查，查出所有数据，然后再取其中的一个。”“你确定？你知道有一种东西叫做索引不？”“啊？……”然后我简单的告诉他，索引是一种树状结构，可以让查询更快等等。“但我还是觉得应该用First()”，他想了一会儿，还是很坚定。“为什么？”，我不明白了。“就算有索引加快了查询速度，但用First()在加快了速度上更快呀！更快总是没错的吧？”“……”，我真不知道该怎么说了，最后突然灵光一闪，“好吧，那你说说，微软为什么要搞一个Single()方法出来呢？就为了搞出来误导你们？让用First()的产生优越感，嘲笑用Single()的？”他陷入了沉思。评论里还在纠结Single()/First()的同学，请大声的吼三遍：可读性！可读性！！可读性！！！发现同学们还在纠结这个细节。好吧，再解释一下：1、你怎么知道数据库用的就是MSSQL呢？你怎么知道就是用的关系数据库呢？NoSQL不行么？所以，你怎么就知道Single()/First()具体是怎么执行的呢？比如我就要写个Linq实现，把所有的数据全取出来，然后再在内存里排序，最后取First呢？2、这里我们考虑可读性，意思是：读代码时，看到Single()就能瞬间知道coder的意思是取唯一的一个；看到First()就知道coder的意思是要取第一个。和性能没关系，如果一定要纠缠性能，那好：你要确定唯一性，当然要做检查（包括不唯一时抛异常），这个性能损失是应该的呀；你要取第一个，当然要进行排序，排序也会有性能损失呀！我刚入行的时候，还很是收藏了几篇文章，比如《高性能编程的十大准则》之类的，里面的内容大致就是，“总是使用StringBuilder，不要使用‘+’；总是使用……，不要使用……”。这类文章下面总是有一堆人叫好，“不错！”，“谢谢分享！”但慢慢的，我就对这些文章产生了怀疑（也应该感谢园子里的老赵，csdn里面的sp1234之类的大神）；直到很后来，我才明白为什么这种说法是肤浅的；而只有通过上面的对话，我才能清晰的把我的理解说出来。所有这些牺牲性能的简单封装，都是有其目的的；而其中一个很重要的目的，就是为了提高可读性。你为了性能，故意不使用这些现成的封装，通常，丧失的就是可读性。想当然继续上面这个例子。最开始的时候，这个程序员关于性能的考虑其实是想当然的。这种想当然的情形很多，大致有这几种：自己的理解完全就是错的自己的理解不能算错，但实际上底层已经对该问题做了优化自己的理解没错，底层也没优化第1、2种比较好理解，第3种为什么也说他“想当然”呢？因为没有和硬件环境相契合。最简单的例子就是“缓存”。比如面试的时候，问你一个问题，“缓存能不能提高性能？”请注意，这是一个陷阱。答案应该是：“不一定”。几乎所有的人都认为，缓存可以迅速改善性能，是因为今天计算机的CPU和磁盘运行速度，远跟不上内存的发展。但即使如此，无节制的缓存，一样可以拖垮整个系统。类似的例子还有很多。你沾沾自喜，我节约了一次磁盘读写的时候，你同时增加了CPU的负荷；你优化了算法，减少了CPU的运算，但其实增加了内存的压力……天下没有免费的午餐。同样的代码，随着数据的增加，硬件的改变，会呈现出截然不同的性能表现。所以，开发过程中，很多的“优化”，其实只是你的想当然。与其这样想当然的优化，不如在拿到性能测试结果之后再有的放矢的进行优化。这时候，又回到了我们之前说的，是不是代码的可读性更重要？这样你才能迅速的找到该优化的瓶颈啊！否则，一堆乱七八糟看都看不懂的代码，你怎么去优化，你连该优化的点都找不到。难以维护另一个搞笑的例子是关于我自己的。创业家园项目里有一个功能：显示博客正文的同时提供一个上一页下一页的链接。惯常的做法就是直接在数据库里查就是了，但我总觉得不对，这样做两次查询有必要么？能不能优化？于是我想到了一个“绝妙”的点子：为什么不直接在博客里存储上一篇和下一篇的Id呢？这样我一次性数据往返就能取到所有数据了嘛！各位同学是不是觉得我这个主意很棒？噩梦由此开始了。首先，我们是想在发布博客的时候，设置他的上一篇和下一篇。但是，上一篇好设置，下一篇呢？还没有啊！怎么弄，就只好在博客发布的时候，设置他的前一篇，同时设置他前一篇的后一篇。然后，我们新添加了一个功能，除了上一篇下一篇以外，还需要在当前博客所在分类中的上一篇和下一篇。怎么办？再加字段呗。所以，博客里就有了Previous,PreviousInCategory,Next,NextInCategory。这时候，就感觉到有点不妥，但还可以接受。接着，出现了一个问题，上一篇下一篇博客被删除了，怎么办？这个过程，就相当于从一个双向链表里移出一个节点一样麻烦。头开始有点大了。再接着，博客除了发布删除以外，还有各种其他状态，比如被屏蔽。而且被屏蔽之后，能否显示和当前用户又有关系。当前用户是普通用户，不能阅读；当前用户是作者自己，就能够阅读。怎么办？首先，屏蔽的时候，要设置上一篇下一篇；屏蔽取消的时候，还是要设置上一篇下一篇。然后，上一篇下一篇得根据当前用户不同变化的这个问题，基本上就傻眼了……最后流着泪把辛辛苦苦折腾了好久的代码全改回来，就通过数据库查呗，多么清晰简洁的逻辑啊！性能问题？首先，这样做造成了性能问题么？然后，就算有问题，用一个缓存能解决不？合理浪费堆硬件说了这么多，不知道有没有引起同学们的反思。可能大家还是过不去心里那道坎：明明有一种性能更高的方法我们为什么不用？因为浪费呗！什么？你有没有搞错？我的代码，至少省了一块内存条！那是你还没从“穷学生”的角色里转换过来。你花一周的时间对代码进行了优化（就先不考虑你的优化带来的维护成本增加了），为老板省下了一块内存条的钱。你以为老板会拍着你的肩膀表扬你么？老板打不死你！兄弟，账不是你那样算的。当你是学生的时候，你的时间成本是0；但你进入工作岗位，每一天都是要发工资的。通过代码来调高性能，是一种无奈——对硬件性能不够的妥协（参考：80年代游戏开发者的辛苦困境。这样写性能就高，但为什么现在没有谁再这么写代码了？）。否则，绝大多数情况下，堆硬件比优化代码的效果好得多，而且便宜得多。硬件的成本按摩尔定律往下降，我们程序员的工资也能按摩尔定律减么？明明window10比window95更耗性能，为什么今天没人用window95？为什么VS2013要10G的空间我们都还屁颠屁颠的赶紧装上？为什么现在大家都用C#，没人用汇编？我们站在人类文明积累的今天，就应该理所当然的享受这一切成果。有打火机你不用，你要钻木取火。如果你是因为要学贝爷荒野求生装逼，可以理解；如果你说你是因为怕浪费天然气，我……我……我怎么说你呢？“给做打火机的一条活路，行不？”同样的，程序员大神同学，你就当做好事，给下面写底层做硬件的一条活路吧！你的代码都是010001000010000001010101……了，你让其他人怎么活啊？最后，我突然想到的一个程序员为什么对性能如此敏感疯狂，对可维护性毫不在意的一个可能原因：性能很好理解，卡得要死和跑得飞快；可维护性很不好理解，至少得跑个两三年才能体现，那时候，谁知道爷在哪里偷着乐呢性能上不来，程序员只有羞愧的低着头，都是我的错；需求有变更，开口就骂，“哪个SB又要改……”；大家觉得是不是这样的？所以，愿意把代码百炼成钢绕指柔的人少。想来，是一种莫名的悲哀和凄凉。最后最后，有一些我能想到的名言警句供大家参详：过早的优化是万恶之源优化首先需要找到性能“瓶颈”。否则，任何人都可以随手一指，“这段代码需要优化”。可读性更强的代码总是更好优化硬件永远比软件便宜",2015/9/25
178,架构之路（一）：目标,管俊,http://180.168.156.212:2262/wecenter/?/article/9115,标准来源于目标前文说过，评价架构好坏是一个很主观的东西。既然大家写出来的程序都能跑，凭什么就说你架构好，我的架构就差？拿出来大家评评理，张三说好，李四说不行，王五说将就……究竟谁说了算？现在已经不是一个迷信权威的时代了，所以不管你多少光环加持，你都得说出子丑寅卯来，都得服众才行。我觉得，这种现象的产生，抛开“同行相轻”和“流派之争”之类无厘头的东西，一个很重要的原因就是没有明确判断标准。所以在网上，常常就出现这样一种很热闹很奇葩很无奈的现象：我和你说性能，你跟我说安全；我跟你说安全，你跟我说扩展；我跟你说扩展，你跟我说维护；我跟你说维护，你跟我说成本……这是一个很简单的道理，没有标准，就无法进行评判！所以，如果不能统一一个评判架构优劣的标准，我们永远无法达成一致。你说有标准啊，性能安全可扩展……但这样还是不行，标准过多，一样等同于没有标准。假设以100分为满分，性能占多少分？安全占多少分？可扩展又占多少分？因为要想提高性能，就可能就要牺牲可扩展性；要想安全，就会牺牲性能；要想……就会……；哪一方面更重要，哪一些可以牺牲？如果不是胸有成竹的话，最后还是会左支右绌手忙脚乱，乱成一锅粥。所以我再提出一个观点：以是否实现架构师的设计目标为标准。如果说一个系统的架构，最终实现了架构师的设计目标，我们就可以说这是一个好架构；如果说没有能实现架构师的目标，这就是一个不那么好的架构。“等一下等一下”，你要是反应够敏锐的话，肯定会跳起来，“这是不是太主观（儿戏）了？我随便一堆烂代码，然后告诉你，‘是啊，我设计的目的就是让他烂，越难越好’，按你的逻辑，这样也行？”(⊙_⊙)，嗯，你要是这样玩儿我还真没办法。但是话又说回来，要让一堆代码能跑又还够“烂”，也还不是一件容易的事，你觉得呢？总之，我希望大家能明白我的意思：架构师开始一个新项目，应当设立一个适当的设计目标；然后通过架构，努力实现其预定目标。如果最终系统的运行，符合其设计预期，我们就可以说：这个架构不错还行！反正，架构就出了问题。我们的目标软件行业有各种各样的系统，每一种系统的开发都可能会有不同的目标。比如导弹发射的系统，我们可以想象，目标（甚至是基本要求）肯定是：1、稳定（绝对不能走火）；2、迅速反应（不允许按下发射按钮后一分钟导弹才开始发射）。你可能觉得这种要求很好啊！任何系统不都是应该满足这样要求的吗？比如我在淘宝买T恤，结果给我发一条丁字裤，这怎么行？一个网页半天打不开还有理了？我还真得答一句，它就是有理了。“存在即合理”，这里的合理，合理在成本。我们目前日常使用到的绝大部分软件，都是有bug的，而且是一堆的bug，但我们仍然在使用它们。如果你想使用像“导弹发射”一样稳定精确迅捷的软件，可能最后的结果只有一个：你用不起。（请自行脑补）所以，其实我们是做了一个妥协，“便宜点，将就用吧”。我们为了达到我们的基本目的，牺牲掉一些“无关紧要”的东西。对于很多追求卓越的程序员来说，这种牺牲妥协是难以接受的。“白玉微瑕，你让我怎么能够接受？”——但很多时候，你必须接受。这个问题这个观点，我们会在整个系列中不断的提及。请试着接受；如果你暂时还不能接受，请牢记：没有牺牲，就没有胜利！那么，我们的策略是：特色突出、整体均衡。说得更直白一点：有亮点，没硬伤。这就够了！而我们的亮点就是：可维护性。（注意：不是可扩展，可维护性包含可扩展，但不仅仅是可扩展）为什么是可维护性幸或者不幸，我进入软件行业之后，绝大部分的工作是几乎所有程序员都不齿厌恶的维护。我曾经维护过一个有十年历史的、糅合了C、VB、java、C#各种语言在内的一个物流系统的部件。我在那家公司工作了一年多，说实话，直到我离职，对整个系统，我连边都没摸到——这个系统太大了，而且连我们公司都只是其主营公司众多外包公司中的一个。在我花了两周的时间找到一个bug的位置之后，我以为我终于明白了为什么会说：“维护和开发的花费比是80:20”。但这只是我以为——现实更加残忍：差不多一个月后，我又花了一个星期的时间，找到了另外一个bug的根源，正是我fix前一个bug所产生的。我泪流满面，有没有？脑子里一下就蹦出个词：“按下了葫芦浮起了瓢”！总之，如果fix前一个bug就会导致后一个bug；如果fix后一个bug，就会导致前面的bug。我忘了最后是怎么处理这个问题的，依稀记得是让项目经理去和稀泥去了。因为这不是一个很关键很常用的功能，所以最后大概是不了了之吧。后来我了解到，很多的开发项目，是这样一个流程：一群人根据文档开始开发，几个月后通过验收上线；然后开发团队解散，留下一两个项目组里最菜的菜鸟做“维护”。GameOver！皆大欢喜。这种现象，在各种外包团队（尤其是以项目计价的廉价外包团队）中更加的突出（这或许也是大家普遍歧视外包公司的一个原因？）既然是这样一种开发模式，很多开发人员根本体会不到维护的痛苦。在他们看来，“维护嘛，修修补补，加一两个if...else而已，让我们开发人员做更高大上的工作吧！”但他们也不是总这么幸运，有时候，他们会被抓去“填坑”。据说最通常的做法，就是在“老坑”周围再挖一堆“新坑”，填平之前的老坑即可。周而复始，直到有一天，“受不了啦！我们重写吧！”——等等，为什么不重构？呵呵，好问题，你觉得呢？需求变更很多程序员把这种困境归咎于“需求变更”。如果不是那些傻逼客户一天到晚的改需求，我一定会做出一个完美的作品！或许是因为我是半路出家的原因，和很多程序员相反，我觉得：不是需求变更驱动着软件的不断更改，而是“软件可以随意更改”的这种特性刺激了不断的需求变更。你装修好的房子，是不是住一段时间之后就会觉得这里那里不合适？这里少了一个插座，阳台上该加一个龙头，橱柜用着不顺手……“要是能改改就更好了！”，只是这样的改动太费力，所以大多数时间我们都还是算了。但软件可以！理论上怎么改都可以。想想软件真的是一种很特殊的商品——它是可以交付“半成品”的。你先用着，如果有问题我再改改，有新需求我再改改，一直可以改到面目全非。没有在其他传统行业里待过的程序员无法理解，“可以随意更改”是一种多么出色的特质。这意味着产品可以自我进化，应对各种变化，可以永生！想象这样一台“汽车”，开始可以在马路上跑，过段时间改一下就可以在水里游，再拆装一下可以当摩托拉风，堵车的时候展开翅膀……这是什么样一种屌爆天的体验啊？所以，“拥抱变化”绝不是一句口号，这是一种胸怀。作为示例的这两个系统，我是希望能用他们一辈子的。但我甚至无法想象一年之后他们会是什么样子——他们需要接受市场的检验，应对技术的升级换代，会有各种想象不到的变化。所以，可维护性无疑是必须放到首位的。为了可维护明确了架构的首要目标，我们就可以做一些基础的选择了。比如开发语言，可是是面向对象的C#，不需要“性能卓越”的C。说道“面向对象”，可能有些同学就会比较high，脑子里就会冒出“抽象”、“封装”、“设计模式”等各种高大上的东西出来。但我不得不提醒你们：首先，这些都是微观层面考虑的东西，而架构是宏观的；然后，这些都不是架构，而是润滑黏合支持架构的东西；最后，在其他条件不变的情况下，系统中这些东西用得越少，说明架构越好。我们以“设计模式”为例。大家在学习设计模式的过程中有没有这样一种困惑，“这样继承封装多态乱七八糟的绕来绕去的干嘛？”我花了很长一段时间才明白，要理解设计模式，必须要明白三个字：“不得已”。是迫不得已，才用设计模式来解决一些特定的问题，而不是说正常的代码就应该这样写！这种迫不得已，有很多种原因。个人觉得最容易理解的就是“适配器模式”，因为出现了接口的冲突，所以我们不得不进行适配。但一个很自然的问题就是：为什么不直接改接口让他们自然融洽呢？这不是一种更自然更直观的解决方案吗？答案很有可能就是因为架构——大的架构已经确立，局部必须服从整体。那么，如果一个完全理想化的架构，是不是根本就不应该出现这种问题接口冲突的问题，因而根本就不需要这种设计模式？所以，我说设计模式之类的东西是润滑剂是黏合剂，他们的作用是弥补架构的局部缺陷，更好的支撑架构。更极端的一种说法可以送给痴迷于设计模式的同学：设计模式是药，没病就不要吃药！那么，为了可维护性，架构中究竟应该注意些什么？这是一个很大的话题，开篇我们只说一点。模块划分模块有大有小，大可以是一个分层一个项目，小可以是一个方法一个类。我们通常的做法是由大到小，逐步细分。模块的划分是相当的考验架构能力的。良好的模块划分，能够让我们方便的安排人手、合理的组织项目进度、迅速的定位代码……各种好处说都说不完。所以还是说说不好的模块划分有什么问题更容易一些，嗯，这个好像根本就不要说，想想你在一堆乱七八糟的代码里不断的F11的情形吧！我个人认为，模块划分的难度在于“整齐”和“灵活”之间取舍。通常来说，大的模块我们都是“一刀切”，着重强调的是“整齐”，比如口熟能详的UI层、BLL层和DAL层，但这种“一刀切”的做法，更多的是一种无奈。我们的人类的思维局限决定了我们在考虑复杂问题时无法深入到每一个细节，所以只能先“大而化之”的把一个复杂问题先进行简单化。这样带来的一个严重的副作用就是，限制了代码的灵活性；而灵活性，正是应对复杂变化的有效武器。所以，在更小一些的模块（比如说：类）里，我们引入了丰富多彩的抽象继承设计模式等一系列充满各种灵活性的机制，以弥合“一刀切”造成的问题。这一松一紧一张一弛中“度”的掌握，就只能说是一种艺术了。模块划分，笼统的说教用处不大，我们将在后面的文章中结合具体情况逐一说明。但我希望大家能够明白：模块划分是必须的——这种必须，是一种无可奈何的选择。所以，喜欢从页面直接写sql到数据库的同学，老大让你把你的代码拆成几段放到不同地方的时候，不要嫌麻烦；喜欢把一个简单项目切成七层的同学，先仔细想不想这样做是不是真的有必要。代码之外为了代码能够长期有效的维护，我们还需要做很多工作，比如良好的文档、完善的项目管理流程。但我想说的，还是不是这个，而是代码之外的因素对项目架构的影响。比如开发团队的背景能力偏好，一群C#程序员，你一定要整个node.js，这纯粹是给自己找不痛快。除了这些稍稍用脑袋想一想就能明白的东西，有一件事，很多程序员并没有意识到。架构的一个天然目的就是：让代码更智能让程序员更傻瓜。换一张说法就是，架构要“创造便利，让程序员更关注业务”。这可能是一个让程序员感到悲哀的事实。正如机械师不停的发明，让机器变得越来越聪明，取代流水线上的工人，最终取代了他们自己。从某种意义上说，我们都是自掘坟墓的人。一个良好的架构，就应该是让每一个普通开发人员，都是一个个尽量廉价随时可以替换的螺丝钉，这样才能保证系统永远健康正常的运行下去。告诉你这个事实可能让你一整天都不开心，但接受这个事实之后能帮助你在工作中变得更加的“心平气和”。螺丝钉就要有螺丝钉的觉悟；更何况，当好一颗螺丝钉也不是一件很容易的事。,2015/9/25
179,打造Android的中文Siri语音助手(一)——小I机器人的接口,管俊,http://180.168.156.212:2262/wecenter/?/article/9114,"Iphone4S的Siri让人眼前一亮，网上出现了无数调戏Siri的视频。真是让android用户们心痒不已。好在随后android阵营中的高手迅速反击，推出了Iris。悲剧的是Iris仅支持英文，让我们这些英语烂的无比的人调戏Iris不成，反被它给调戏了。真是郁闷的不行啊~_~所以我打算使用android的资源自己打造一个中文版的Siri，让我们用中文随意的来调戏它。(我自己做了一个简单的，哈哈，放在优亿市场里，有兴趣的童鞋可以去体验下 p sk...rr.png);background-color:inherit;background-position:9px8px;background-repeat:no-repeat;"">}",2015/9/25
180,DbUtils(二) 结果集实例,管俊,http://180.168.156.212:2262/wecenter/?/article/9113,"单行数据处理：ScalarHandlerArrayHandlerMapHandlerBeanHandler多行数据处理：BeanListHandlerAbstractListHandler（ArrayListHandlerMapListHandlerColumnListHandler）AbstractKeyedHandler（KeyedHandlerBeanMapHandler）可供扩展的类：BaseResultSetHandlerDbutils使用结果集的方法有query、insert、insertBatch三个。这些方法都在QueryRunner类中，需要注意的是insert和update方法都能执行“insert”开头的sql语句，但是返回值有区别。insert执行后返回的是表中的插入行生成的主键值，update返回的是受语句影响的行数。所以，如果目标表中有主键且需要返回插入行的主键值就用insert方法，如果表没有主键或者不需要返回主键值可使用update方法。先建立测试用数据表[users]：iduserNameloginNameuserPassworduserLeveluserLock1测试用户1test1jiseflwes1002知道什么hello2556sefsfs1013编程就编程cjavasfsfsef254sefs20字段类型，id为主键：123456[id][int]IDENTITY(1,1)NOTNULL,[userName][nchar](20)NOTNULL,[loginName][nchar](20)NOTNULL,[userPassword][nchar](100)NOTNULL,[userLevel][int]NOTNULL,[userLock][bit]NOTNULL,1、ScalarHandler<T>用于获取结果集中第一行某列的数据并转换成T表示的实际对象。该类对结果集的处理直接在handle方法中进行，不涉及dbutils库的其他类。1234567891011121314151617Stringsql=""select*fromusers"";//----query语句----//ScalarHandler的参数为空或null时，返回第一行第一列的数据intrs=runner.query(sql,newScalarHandler<Integer>());System.out.println(""ScalarHandler:""+rs);//Print:[ScalarHandler:1]//ScalarHandler的参数可以是列的索引（从1开始）或列名Stringrs=runner.query(sql,newScalarHandler<String>(2));//或者Stringrs=runner.query(sql,newScalarHandler<String>(""userName""));System.out.println(""ScalarHandler:""+rs);//Print:[ScalarHandler:测试用户1]//----insert语句----//因为我使用的是mssql数据库，QueryRunner的insert获取插入数据的主键其实调用的是selectSCOPE_IDENTITY()//数据库执行后返回的类型是numeric，映射到java类型就是java.math.BigDecimalStringinSql=""insertusers(userName,loginName,userPassword,userLevel,userLock)values(?,?,?,?,?)"";BigDecimalinsertRs=runner.insert(inSql,newScalarHandler(),""java程序编写"",""javahello"",""sefsfsfwew"",""15"",false);System.out.println(""ScalarHandler:""+insertRs);//Print:[ScalarHandler:4]使用的时候一定要保证提供正确的列索引或列名，并且结果类型也要正确可转换。2、ArrayHandler用于获取结果集中的第一行数据，并将其封装到一个数组中，一列值对应一个数组元素。handle源码：12345publicObject[]handle(ResultSetrs)throwsSQLException{//convert=newBasicRowProcessor()//如果有数据，将调用BasicRowProcessor的toArray(rs)方法处理returnrs.next()?this.convert.toArray(rs):EMPTY_ARRAY;}1234567891011//----query语句----Stringsql=""select*fromusers"";Object[]rs=runner.query(sql,newArrayHandler());//Print:ArrayHandler:[1,测试用户1,test1,jiseflwes,10,false]System.out.println(""ArrayHandler:""+Arrays.toString(rs));//----insert语句----StringinSql=""insertusers_t(userName,loginName,userPassword,userLevel,userLock)values(?,?,?,?,?)"";Object[]insertRs=runner.insert(inSql,newArrayHandler(),""java程序编写"",""javahello"",""sefsfsfwew"",""15"",false);//Print:ArrayHandler:[5]System.out.println(""ArrayHandler:""+Arrays.toString(insertRs));3、MapHandler用于获取结果集中的第一行数据，并将其封装到一个Map中，Map中key是数据的列别名（aslabel）,如果没有就是列的实际名称，Map中value就是列的值，注意代表列的key不区分大小写。handle源码：12345publicMap<String,Object>handle(ResultSetrs)throwsSQLException{//convert=newBasicRowProcessor()//如果有数据，将调用BasicRowProcessor的toMap(rs)方法处理returnrs.next()?this.convert.toMap(rs):null;}通过查看BasicRowProcessor代码，可以知道封装结果集的Map其实是一个LinkedHashMap对象。12345678910111213141516171819202122232425//----query语句----Stringsql=""selectuserName,loginName,userPasswordaspassword,userLevel,userLockfromusers"";Map<String,Object>rs=runner.query(sql,newMapHandler());//Print:MapHandler:{userName=测试用户1,loginName=test1,password=jiseflwes,userLevel=10,userLock=false}System.out.println(""MapHandler:""+rs);//列名小写Print:username:测试用户1System.out.println(""username:""+rs.get(""username""));//列名大写Print:USERNAME:测试用户1System.out.println(""USERNAME:""+rs.get(""USERNAME""));//使用了as指定别名，那么取数据的时候一定要用别名，否则返回null。//Print:userPasswordaspassword:jiseflwesSystem.out.println(""userPasswordaspassword:""+rs.get(""password""));//Print:userPasswordaspassword:nullSystem.out.println(""userPasswordaspassword:""+rs.get(""userPassword""));//----insert语句----StringinSql=""insertusers(userName,loginName,userPassword,userLevel,userLock)values(?,?,?,?,?)"";Map<String,Object>insertRs=runner.insert(inSql,newMapHandler(),""java程序编写"",""javahello"",""sefsfsfwew"",""15"",false);//注意这个键（key）是由数据库驱动定义的。//Print:MapHandler:{GENERATED_KEYS=6}System.out.println(""MapHandler:""+insertRs);//我用的是微软提供的驱动，所以是GENERATED_KEYS，如果是其他驱动就又不同了（比如jtds驱动key是ID）//jtds驱动使用insertRs.get(""ID"")//Print:MapHandler:6System.out.println(""MapHandler:""+insertRs.get(""GENERATED_KEYS""));4、BeanHandler<T>用于获取结果集中的第一行数据，并将其封装到JavaBean对象。整个转换过程最终会在BeanProcessor类中完成。+ViewCode执行代码：1234567//----query语句----Stringsql=""select*fromusers"";Usersrs=runner.query(sql,newBeanHandler<Users>(Users.class));//Print:BeanHandler:Users{id=1,userName='测试用户1',loginName='test1',userPassword='jiseflwes',userLevel=10,userLock=true}System.out.println(""BeanHandler:""+rs);//Print:BeanHandler:test1System.out.println(""BeanHandler:""+rs.getLoginName());需要注意的是，默认的情况下要保证表的字段和javabean的属性一致（字符一致即可，对大小写不敏感），比如字段是userLock，那么javabean中属性必须是userLock这几个字母（可以是userlock，userLock，userLOCK，不过还是建议按照规范来定义）。但有个问题，数据表中的字段可能已经定下来了，而且名称可能不太规范，比如用下划线（login_name），或者加了一个类型前缀（chrLoginName），如果修改表字段，那么涉及到的修改地方太多了，其实查看源码可以知道BeanHandler有两个构造方法:12345678//BeanHandler构造方法publicBeanHandler(Class<T>type){this(type,ArrayHandler.ROW_PROCESSOR);}publicBeanHandler(Class<T>type,RowProcessorconvert){this.type=type;this.convert=convert;}可以看出其实都是调用的第二个方法。123456runner.query(sql,newBeanHandler<Users>(Users.class));//等价于runner.query(sql,newBeanHandler<Users>(Users.class,newBasicRowProcessor()));//等价于runner.query(sql,newBeanHandler<Users>(Users.class,newBasicRowProcessor(newBeanProcessor())));//所以关键的地方在newBeanProcessor()这个具体处理结果的对象情况一：只涉及到下划线，表字段名用下划线间隔（如表users_t字段：[id]，[user_name]，[login_name]，[user_password]，[user_level]，[user_lock]），现在要封装到Javabean中Users类（代码见上），其中属性使用驼峰命名。可以用dbutils1.6提供的BeanProcessor类的子类GenerousBeanProcessor。12345678910Stringsql=""selectid,user_name,login_name,user_password,user_level,user_lockfromusers_t"";//创建一个BeanProcessor对象//GenerousBeanProcessor仅仅重写了父类BeanProcessor的mapColumnsToProperties方法BeanProcessorbean=newGenerousBeanProcessor();//将GenerousBeanProcessor对象传递给BasicRowProcessorRowProcessorprocessor=newBasicRowProcessor(bean);//最后使用GenerousBeanProcessor的mapColumnsToProperties处理表字段到javabean的属性映射Usersrs=runner.query(sql,newBeanHandler<Users>(Users.class,processor));//Print:BeanHandler:Users{id=1,userName='测试用户1',loginName='test1',userPassword='jiseflwes',userLevel=10,userLock=true}System.out.println(""BeanHandler:""+rs);情况二：完全改变表字段到Javabean属性的映射（如表users_m字段：[yhmid]，[charUsername]，[charLoginName]，[charPassword]，[intLevel]，[boolLock]）映射到Users类（代码同上）：12345678910111213141516//BeanProcessor有两个构造方法，可以传入一个HashMap集合//HashMap规定了表字段映射到Javabean的哪个属性，即key为字段名称，value为对应的javabean属性//map.put(表字段名称,Javabean属性名称)Map<String,String>map=newHashMap<String,String>();map.put(""yhmid"",""id"");map.put(""charUsername"",""userName"");map.put(""charLoginName"",""loginName"");map.put(""charPassword"",""userPassword"");map.put(""intLevel"",""userLevel"");map.put(""boolLock"",""userLock"");//用构建好的HashMap建立一个BeanProcessor对象BeanProcessorbean=newBeanProcessor(map);RowProcessorprocessor=newBasicRowProcessor(bean);Usersrs=runner.query(sql,newBeanHandler<Users>(Users.class,processor));//Print:BeanHandler:Users{id=1,userName='测试用户1',loginName='test1',userPassword='jiseflwes',userLevel=10,userLock=true}System.out.println(""BeanHandler:""+rs);5、BeanListHandler<T>用于将结果集的每一行数据转换为Javabean，再将这个Javabean添加到ArrayList中。可以简单的看着是BeanHandler的高级版，只不过是多了一步，就是将生成的Javabean添加到ArrayList中，其他的处理都和BeanHandler一样。1234567Stringsql=""select*fromusers"";List<Users>rs=runner.query(sql,newBeanListHandler<Users>(Users.class));//Print:BeanListHandler:[//Users{id=1,userName='测试用户1',loginName='test1',userPassword='jiseflwes',userLevel=10,userLock=true},//Users{id=1,userName='知道什么',loginName='hello',userPassword='2556sefsfs',userLevel=10,userLock=true},//Users{id=1,userName='编程就编程',loginName='cjava',userPassword='sfsfsef254sefs',userLevel=2,userLock=false}]System.out.println(""BeanListHandler:""+rs);6、AbstractListHandler<T>123456789//AbstractListHandler类实现了handle方法@OverridepublicList<T>handle(ResultSetrs)throwsSQLException{List<T>rows=newArrayList<T>();while(rs.next()){rows.add(this.handleRow(rs));//每个子类实现自己的handleRow方法}returnrows;}AbstractListHandler抽象类已经实现handle方法，该方法其实只是起到一个包装作用，将处理好的每行数据添加到ArrayList中。每行的数据处理通过调用handleRow方法实现，所有它的3个子类都必须实现这个方法。6.1ArrayListHandler(extendsAbstractListHandler<Object[]>)用于将结果集每行数据转换为Object数组（处理过程等同与ArrayHandler），再将该数组添加到ArrayList中。简单点，就是将每行数据经过ArrayHandler处理后添加到ArrayList中。123456789Stringsql=""select*fromusers"";Listrs=runner.query(sql,newArrayListHandler());//Print://[1,测试用户1,test1,jiseflwes,10,true]//[2,知道什么,hello,2556sefsfs,10,true]//[3,编程就编程,cjava,sfsfsef254sefs,2,false]for(Objectuser:rs){System.out.println(Arrays.toString((Object[])user));}6.2MapListHandler(extendsAbstractListHandler<Map<String,Object>>)用于将结果集每行数据转换为Map（处理过程等同与MapHandler），再将Map添加到ArrayList中。简单点，就是将每行数据经过MapHandler处理后添加到ArrayList中。123456789Stringsql=""select*fromusers"";Listrs=runner.query(sql,newMapListHandler());//Print://{1,测试用户1,test1,jiseflwes,10,true}//{2,知道什么,hello,2556sefsfs,10,true}//{3,编程就编程,cjava,sfsfsef254sefs,2,false}for(Objectuser:rs){System.out.println(Arrays.toString((Map<String,Object>)user));}6.3ColumnListHandler<T>(extendsAbstractListHandler<T>)根据列索引或列名获取结果集中某列的所有数据，并添加到ArrayList中。可以理解为ScalarHandler<T>的加强版。12345678910Stringsql=""select*fromusers"";List<String>rs=runner.query(sql,newColumnListHandler<String>(2));//等同List<String>rs=runner.query(sql,newColumnListHandler<String>(""userName""));//Print://测试用户1//知道什么//编程就编程for(Stringuser:rs){System.out.println(user);}7、AbstractKeyedHandler<K,V>AbstractKeyedHandler是一个抽象类，已经实现了handle方法，其子类必须实现createKey(ResultSetrs)和createRow(ResultSetrs)方法，以便handle()的调用。12345678910111213/***返回一个HashMap<K,V>*createKey(rs)将某列的值作为HashMap的key*createRow(rs)将结果集转换后作为HashMap的value*/@OverridepublicMap<K,V>handle(ResultSetrs)throwsSQLException{Map<K,V>result=createMap();while(rs.next()){result.put(createKey(rs),createRow(rs));//需要子类自己实现}returnresult;}7.1KeyedHandler<K>(extendsAbstractKeyedHandler<K,Map<String,Object>>)用于获取所有结果集，将每行结果集转换为Map<String,Object>，并指定某列为key。可以简单的认为是一个双层Map，相当于先对每行数据执行MapHandler，再为其指定key添加到一个HaspMap中。KeyedHandler<K>中的<K>是指定的列值的类型。12345678910111213141516Stringsql=""select*fromusers"";//在这儿指定主键id为结果key，也可以传入列名newKeyedHandler<Integer>(""id"")Map<Integer,Map<String,Object>>rs=runner.query(sql,newKeyedHandler<Integer>(1));//Print:KeyedHandler:{//1={id=1,userName=测试用户1,loginName=test1,userPassword=jiseflwes,userLevel=10,userLock=true},//2={id=2,userName=知道什么,loginName=hello,userPassword=2556sefsfs,userLevel=10,userLock=true},//3={id=3,userName=编程就编程,loginName=cjava,userPassword=sfsfsef254sefs,userLevel=2,userLock=false}}System.out.println(""KeyedHandler:""+rs);//也可以指定其他列作为key，但是需要注意如果指定的列值存在重复值，那么后面的值将覆盖前面的，最终HashMap中key都是唯一的。//如指定列userLevel为key，最终只有两个结果，因为前两行userLevel值都是10。Map<Integer,Map<String,Object>>rs=runner.query(sql,newKeyedHandler<Integer>(""userLevel""));//Print:KeyedHandler:{//2={id=3,userName=编程就编程,loginName=cjava,userPassword=sfsfsef254sefs,userLevel=2,userLock=false},//10={id=2,userName=知道什么,loginName=hello,userPassword=2556sefsfs,userLevel=10,userLock=true}}System.out.println(""KeyedHandler:""+rs);7.2BeanMapHandler<K,V>(extendsAbstractKeyedHandler<K,V>)用于获取所有结果集，将每行结果集转换为Javabean作为value，并指定某列为key，封装到HashMap中。相当于对每行数据的做BeanHandler一样的处理后，再指定列值为Key封装到HashMap中。12345678Stringsql=""select*fromusers"";//newBeanMapHandler<Integer,Users>(Users.class,""id"")Map<Integer,Users>rs=runner.query(sql,newBeanMapHandler<Integer,Users>(Users.class,1));//Print:BeanMapHandler:{//1=Users{id=1,userName='测试用户1',loginName='test1',userPassword='jiseflwes',userLevel=10,userLock=true},//2=Users{id=2,userName='知道什么',loginName='hello',userPassword='2556sefsfs',userLevel=10,userLock=true},//3=Users{id=3,userName='编程就编程',loginName='cjava',userPassword='sfsfsef254sefs',userLevel=2,userLock=false}}System.out.println(""BeanMapHandler:""+rs);需要注意这个结果转换类也可以像BeanHandler的情况一和情况二介绍的那样定义一个processor，但默认情况下这么做了就会以每行的第一列作为Key，不能指定其他列为Key。12//这种情况下，以每行第一列为keyMap<Integer,Users>rs=runner.query(sql,newBeanMapHandler<Integer,Users>(Users.class,processor));8、BaseResultSetHandler<T>根据文档介绍，如果上面的结果集处理类都不能满足你的要求，可以通过继承这个抽象类定义自己的结果处理类，子类必须实现无参方法handle()。做个简单的例子，比如要将指定列值加一个前缀""class-""后添加到ArrayList中：123456789101112131415161718192021222324252627282930313233343536//-------------定义类MeResultHandler.java-------------/***自定义的结果处理类，对结果集的操作直接调用父类已经封装好的方法。*这儿只是对取到的结果包装加工。*/publicclassMeResultHandlerextendsBaseResultSetHandler<List<String>>{privatefinalintcolumnIndex;//指定要获取值的列索引publicMeResultHandler(intcolumnIndex){this.columnIndex=columnIndex;}//重写父类的方法，封装每行数据@OverrideprotectedList<String>handle()throwsSQLException{List<String>rows=newArrayList<String>();//因为父类已经封装好了对ResultSet各种操作，直接调用父类方法next()while(this.next()){rows.add(handleRow());}returnrows;}//自定义的数据处理方法@SuppressWarnings(""unchecked"")privateStringhandleRow()throwsSQLException{//直接调用父类方法getObject()return""class-""+String.valueOf(this.getObject(this.columnIndex));}}//-------------使用类-------------List<String>rs=runner.query(sql,newMeResultHandler(1));//Print:MeResultHandler:[class-1,class-2,class-3]System.out.println(""MeResultHandler:""+rs);======================================================================总的来说，最终的数据处理是在BasicRowProcessor的四个方法中进行，涉及到JavaBean的话会通过BasicRowProcessor调用BeanProcessor的两个方法。其他的都是对每行数据转换后的结果的封装。喜欢简洁，远离繁琐",2015/9/25
181,DbUtils(一) 结果集概览,管俊,http://180.168.156.212:2262/wecenter/?/article/9112,"记录自己对DbUtils的学习和了解我感觉Dbutils用的最多的就是对查询结果集的处理，就以这个开始了解Dbutils库。查看源代码发现结果集的转换主要用于query,insert,insertBatch方法。123456789//仅仅列出QueryRunner类的相关代码，其他略过//-----------源码1query方法------------------stmt=this.prepareStatement(conn,sql);this.fillStatement(stmt,params);rs=this.wrap(stmt.executeQuery());result=rsh.handle(rs);//处理结果集//-----------源码2insert方法------------------stmt=conn.prepareStatement(sql,tatement.RETURN_GENERATED_KEYS);12345678this.fillStatement(stmt,params);stmt.executeUpdate();ResultSetresultSet=stmt.getGeneratedKeys();generatedKeys=rsh.handle(resultSet);//处理结果集//-----------源码3insertBatch方法------------------ResultSetrs=stmt.getGeneratedKeys();generatedKeys=rsh.handle(rs);//处理结果集对ResultSet的转换主要围绕两个接口展开（ResultSetHandler<T>和RowProcessor）。1、ResultSetHandler<T>，关系图如下：接口ResultSetHandler只有一个需要实现的方法handle(ResultSetrs)，我的理解这个方法是处理结果集的一个入口，每个结果集转换类都在自己的handle方法中处理自己的事情，这个可从前面的源码1、2、3中看出来，都是调用实现类的handle方法，再返回结果。ResultSetHandler的实现类（结果集转换类）在handle方法中实现对结果集的处理，大部分会涉及到另一个接口RowProcessor及其实现类BasicRowProcessor。2、RowProcessor，关系图如下：RowProcessor接口有4个需要实现的方法，具体用途可以很直观的从方法名中看出来。这几个方法都在结果转换类的handle方法中调用。需要注意如果需要将结果集转换为Bean，那么还会涉及到一个类BeanProcessor的使用。3、ResultSetHandler和RowProcessor的关系图虽然有点乱，凑合看也能看清楚。大部分的结果集都持有一个RowProcessor接口的引用。需要注意的是ArrayHandler这个类，因为其他类RowProcessor的引用都是从这个类获取的，这个类建立了RowProcessor实现类BasicRowProcessor的对象。需要注意其中的3个抽象类（AbstractKeyedHandler、AbstractListHandler、BaseResultSetHandler），它们的派生类才是可以使用的结果转换类。根据文档的说明，如果官方提供的这些转换类都不能满足你的要求，可以通过继承BaseResultSetHandler实现自己的结果集转换类。喜欢简洁，远离繁琐",2015/9/25
182,深入浅出 妙用Javascript中apply、call、bind,管俊,http://180.168.156.212:2262/wecenter/?/article/9111,"apply、call在javascript中，call和apply都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部this的指向。JavaScript的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。先来一个栗子：1234567891011functionfruits(){}fruits.prototype={color:""red"",say:function(){console.log(""Mycoloris""+this.color);}}varapple=newfruits;apple.say();//Mycolorisred但是如果我们有一个对象banana={color:""yellow""},我们不想对它重新定义say方法，那么我们可以通过call或apply用apple的say方法：12345banana={color:""yellow""}apple.say.call(banana);//Mycolorisyellowapple.say.apply(banana);//Mycolorisyellow所以，可以看出call和apply是为了动态改变this而出现的，当一个object没有某个方法（本栗子中banana没有say方法），但是其他的有（本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。apply、call的区别对于apply、call二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：123varfunc=function(arg1,arg2){};就可以通过如下方式来调用：12func.call(this,arg1,arg2);func.apply(this,[arg1,arg2])其中this是你想指定的上下文，他可以是任何一个JavaScript对象(JavaScript中一切皆对象)，call需要把参数按顺序传递进去，而apply则是把参数放在数组里。JavaScript中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用call。而不确定的时候用apply，然后把参数push进数组传递进去。当参数数量不确定时，函数内部也可以通过arguments这个数组来遍历所有的参数。为了巩固加深记忆，下面列举一些常用用法：1、数组之间追加1234vararray1=[12,""foo"",{name""Joe""},-2458];vararray2=[""Doe"",555,100];Array.prototype.push.apply(array1,array2);/*array1值为[12,""foo"",{name""Joe""},-2458,""Doe"",555,100]*/2、获取数组中的最大值和最小值123varnumbers=[5,458,120,-215];varmaxInNumbers=Math.max.apply(Math,numbers),//458maxInNumbers=Math.max.call(Math,5,458,120,-215);//458number本身没有max方法，但是Math有，我们就可以借助call或者apply使用其方法。3、验证是否是数组（前提是toString()方法没有被重写过）123functionisArray(obj){returnObject.prototype.toString.call(obj)==='[objectArray]';}4、类（伪）数组使用数组方法1vardomNodes=Array.prototype.slice.call(document.getElementsByTagName(""*""));Javascript中存在一种名为伪数组的对象结构。比较特别的是arguments对象，还有像调用getElementsByTagName,document.childNodes之类的，它们返回NodeList对象都属于伪数组。不能应用Array下的push,pop等方法。但是我们能通过Array.prototype.slice.call转换为真正的数组的带有length属性的对象，这样domNodes就可以应用Array下的所有方法了。深入理解运用apply、call下面就借用一道面试题，来更深入的去理解下apply和call。定义一个log方法，让它可以代理console.log方法，常见的解决方法是：12345functionlog(msg){console.log(msg);}log(1);//1log(1,2);//1上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用apply或者call，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下：12345functionlog(){console.log.apply(console,arguments);};log(1);//1log(1,2);//12接下来的要求是给每一个log消息添加一个""(app)""的前辍，比如：1log(""helloworld"");//(app)helloworld该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过Array.prototype.slice.call转化为标准数组，再使用数组方法unshift，像这样：123456functionlog(){varargs=Array.prototype.slice.call(arguments);args.unshift('(app)');console.log.apply(console,args);};bind说完了apply和call，再来说说bind。bind()方法与apply和call很相似，也是可以改变函数体内this的指向。MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入bind()方法的第一个参数作为this，传入bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。直接来看看具体如何使用，在常见的单体模式中，通常我们会使用_this,that,self等保存this，这样我们可以在改变了上下文之后继续引用到它。像这样：12345678910varfoo={bar:1,eventBind:function(){var_this=this;$('.someClass').on('click',function(event){/*Actontheevent*/console.log(_this.bar);//1});}}由于Javascript特有的机制，上下文环境在eventBind:function(){}过渡到$('.someClass').on('click',function(event){})发生了改变，上述使用变量保存this这些方式都是有用的，也没有什么问题。当然使用bind()可以更加优雅的解决这个问题：123456789varfoo={bar:1,eventBind:function(){$('.someClass').on('click',function(event){/*Actontheevent*/console.log(this.bar);//1}.bind(this));}}在上述代码里，bind()创建了一个函数，当这个click事件绑定在被调用的时候，它的this关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文this(其实就是foo)，到bind()函数中。然后，当回调函数被执行的时候，this便指向foo对象。再来一个简单的栗子：1234567varbar=function(){console.log(this.x);}bar();//undefinedvarfunc=bar.bind(foo);func();//3这里我们创建了一个新的函数func，当使用bind()创建一个绑定函数之后，它被执行的时候，它的this会被设置成foo，而不是像我们调用bar()时的全局作用域。apply、call、bind比较那么apply、call、bind三者相比较，之间又有什么异同呢？何时使用apply、call，何时使用bind呢。简单的一个栗子：12345678910111213varobj={x:81,};varfoo={getX:function(){returnthis.x;}}console.log(foo.getX.bind(obj)());//81console.log(foo.getX.call(obj));//81console.log(foo.getX.apply(obj));//81三个输出的都是81，但是注意看使用bind()方法的，他后面多了对括号。也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用bind()方法。而apply/call则会立即执行函数。再总结一下：apply、call、bind三者都是用来改变函数的this对象的指向的；apply、call、bind三者第一个参数都是this要指向的对象，也就是想指定的上下文；apply、call、bind三者都可以利用后续参数传参；bind是返回对应函数，便于稍后调用；apply、call则是立即调用。",2015/9/25
183,速懂史上最严食品安全法,曹义敏,http://180.168.156.212:2262/wecenter/?/article/9110,速懂史上最严食品安全法今年10月1日，被称为“史上最严食品安全法”的《中华人民共和国食品安全法》(下称新食安法)将正式实施。近年来，国内食品安全事件时有发生，监管体系、手段和制度等不能完全适应食品安全需要，食品安全问题仍然令人堪忧。新食安法即将走马上任，应该关注哪些要点呢?一、消费者看这里1.婴幼儿奶粉管理上升到药品级别新食安法规定婴幼儿奶粉的配方将从备案制改为注册制。所谓注册制，即要对奶粉的配方进行注册，这意味着我国对婴幼儿奶粉的管理上升到药品的级别。9月2日，《婴幼儿配方乳粉配方注册管理办法》正式公开征求意见，这份由国家食品药品监督管理总局起草的征求意见稿，对在国内生产的婴幼儿配方乳粉作出了更加严格的规定。根据征求意见稿，同一企业注册的一个产品配方只能生产一种产品，不得用同一配方生产不同品牌的婴幼儿配方奶粉，不得限定区域销售，不得为销售商专门定制生产。业内人士表示，这一严苛的规定将有利于规范混乱的婴幼儿奶粉市场。2.转基因食品标示要放在显着位置新食安法对转基因食品标示做出要求。现在转基因食品的标示，要么标识很小，消费者很难注意到;要么有些商家乱标示，以“非转基因”作为炒作噱头。新法规定生产经营转基因食品应当按照规定显着标示，并设置了相应的法律责任。未按规定标示的，企业或将最高可面临货值金额五倍以上十倍以下罚款，情节严重者甚至停产停业，吊销许可证。3.剧毒、高毒农药禁用于蔬菜瓜果新食安法明确剧毒、高毒农药禁用于蔬菜瓜果。利用剧毒农药、化肥、膨大剂等对蔬菜瓜果进行病虫害防治、催肥，是消费者最担忧的食品安全问题之一。新法明确规定，剧毒、高毒农药不得用于蔬菜、瓜果、茶叶和中草药材。这有利于进一步确保消费者的饮食安全，消除消费者对有“毒”蔬菜瓜果的担忧，提升消费者对普通食品的消费信心。4.保健品说明书不能涉及治疗功能新食安法明确，保健食品声明“不能替代药物”保健食品的标签、说明书不得涉及疾病预防、治疗功能，内容应与注册或备案一致，载明适宜人群、不适宜人群、功效成分或标志性成分及其含量等，并声明“本品不能代替药物”。5.网购到不合格食品可索赔新食安法规定，网络食品生产经营者必须持照经营，同时提供生产经营的第三方平台有审核经营者证照的责任，也就是说，以后对入网的食品经营者要需做三件事：实名登记、明确责任、审查许可证。现各大网络平台上卖的食品可谓鱼龙混杂，消费者在网购中买到不合格产品，大多数人只能吃哑巴亏，而新食安法将对网购食品监管乱的现象带来改变：消费者通过第三方平台购买食品其合法权益受到损害的，可以向入网的食品经营者或者食品生产者要求赔偿，或由交易平台提供赔偿。二、经营者看这里1.食品经营许可实行“一地一证”从管理上看，新食安法进一步简政放权，将食品流通许可与餐饮服务许可两个许可整合为食品经营许可，减少许可数量，并将食品添加剂生产许可纳入《食品生产许可管理办法》，规定食品添加剂生产许可申请符合条件的，颁发食品生产许可证，并标注食品添加剂。同时明确规定了一企一证原则和食品经营许可实行一地一证原则，食品药品监督管理部门按照食品的风险程度对食品生产经营实施分类许可，将食品生产分为粮食加工品等31个类别，食品经营主体业态分为食品销售经营者等10个类别。2.要建立食品安全追溯体系新法规定食品生产经营者应当依法建立食品安全追溯体系，保证食品可追溯。食品安全追溯体系的建立，便于有效追溯食品源头，分清各生产环节的责任，对提高我国整个食品安全可信度和食品企业竞争力具有重要作用。同时，通过追溯体系的健全，有利于追踪溯源地查处各类食品违法行为，对净化整个食品行业环境，促进食品产业发展意义重大。3.“风控”监测更加突出预防为主对比之下，新食安法的管理理念明显加强了“风控”监测，更加突出预防为主、风险防范。进一步完善了食品安全风险监测、风险评估制度，增设了责任约谈、风险分级管理等重点制度，还通过建立信用档案，制定年度监管计划等多重方式全面降低风险。具体的规定如建立风险监测，监测食源性疾病、食品污染以及食品中的有害因素;实施风险分级，对食品确定重点、方式和频次，实施风险分级管理;建立食品安全风险评估，对食品、食品添加剂、相关产品的危害因素进行评估等。4.大幅强化和提高了惩罚力度对之前法律责任过轻的诟病，新法对违反规定的行为采取更加具体和严厉的措施。首先，强化了刑事责任追究，如果构成犯罪，就直接由公安部门进行侦查，追究刑事责任。行为人因食品安全犯罪被判处有期徒刑以上刑罚，则终身不得从事食品生产经营的管理工作。第二，大幅提高了罚款额度。比如，生产经营性质恶劣的违法行为，现行食品安全法规定最高处罚货值金额10倍的罚款，新法则提高到处以30倍的罚款。第三，非法提供场所增设罚则。为了加强源头监管、全程监管，新法对明知从事无证生产经营或者从事非法添加非食用物质等违法行为，仍然为其提供生产经营场所的行为，规定最高处以10万元罚款。,2015/9/23
184,国发〔2015〕50号《国务院关于印发促进大数据发展行动纲要的通知》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9109,建设社会治理大数据应用体系。到2018年，围绕实施区域协调发展、新型城镇化等重大战略和主体功能区规划，在企业监管、质量安全、质量诚信、节能降耗、环境保护、食品安全、安全生产、信用体系建设、旅游服务等领域探索开展一批应用试点，打通政府部门、企事业单位之间的数据壁垒，实现合作开发和综合利用。实时采集并汇总分析政府部门和企事业单位的市场监管、检验检测、违法失信、企业生产经营、销售物流、投诉举报、消费维权等数据，有效促进各级政府社会治理能力提升。探索发挥大数据对变革教育方式、促进教育公平、提升教育质量的支撑作用。加强数字图书馆、档案馆、博物馆、美术馆和文化馆等公益设施建设，构建文化传播大数据综合服务平台，传播中国文化，为社会提供文化服务。国发〔2015〕50号《国务院关于印发促进大数据发展行动纲要的通知》.mht,2015/9/17
185,机器换人靠谱吗?智能制造还是要“以人为本”,马习,http://180.168.156.212:2262/wecenter/?/article/9107,"一、“中国制造2025”与“互联网+”发展背景21世纪以来，全球信息技术与互联网加速发展；与此同时，制造业面临着产业结构调整带来的机遇和挑战。美国发布《先进制造业国家战略计划》,德国政府推出《德国工业4.0战略》。随着美国“制造业回归”的强力推动以及我国国内劳动力、土地、环境保护等成本的上升，我国制造业依赖传统比较成本优势参与国际竞争的局面充满挑战；同时我国制造业出现了严重的产能过剩，结构性矛盾愈加突出，导致经济增速放缓，经济发展进入“新常态”。2015年3月25日，国务院总理李克强在主持召开国务院常务会议，正式提出了“中国制造2025”行动计划。二、传统产业如何借助“互联网+”，向先进制造业转变？1、“互联网+制造业”是未来中国经济增长的巨大潜力如果将2015年作为一个分水岭的话，前十年是消费互联网的时代，后十年（即2016~2025年）将是“互联网+制造业”（工业互联网）的时代。“互联网+制造业”，我国在服装、家电等领域已有一些走在时代前列的成功案例，如红领集团、海尔集团都很好地诠释了传统制造业运用“互联网+”手段，实现转型升级的发展路径。但“互联网+”是重要的手段，绝不是目的；“制造”为根基，“产品和服务”才是核心。这是我们研究“互联网+”时必须要坚持的原则。2、以“互联网+”促进制造业全产业链的转型升级根据世界银行统计，中美两国分别占全世界制造业增加值的20%左右和16%左右，中国已成为世界第一制造大国。然而中国制造大多数处于产业链的低端，中国当前面临的产能过剩是低端过剩，许多高端装备、新材料和核心零部件还依赖进口。例如80%的高端数控机床、80%的工业机器人床至今仍依赖进口，中国的自主品牌汽车至今仍无法与国际品牌抗衡，世界汽车零部件百强企业中，中国企业寥寥无几，工程机械中的液压气动元器件基本被外国品牌所垄断，粗放式的增长方式造成了严重的环境污染，使得我们必须要付出巨大的代价来修复。因此，我们研究“互联网+制造业”必须站在全产业链的角度去分析，以互联网为手段，促进制造业全产业链的转型升级才是最根本的方法。我们总结“互联网+制造”的新“6+1”微笑曲线如下图所示： >因此，智能制造要以产品设计创新为源头、以产品升级为目标才具有真正的意义，而不是简单的机器人换人。中国企业必须以这样的思维方式来看待与发展智能制造，才能从根本上寻求突破，在新一轮经济周期中找到根本出路。",2015/9/15
186,史上最完整的土壤知识,马习,http://180.168.156.212:2262/wecenter/?/article/9106,"（一）土壤及其性状1、土壤的概念：苏联土壤学家威廉斯指出：“土壤是地球陆地上能够生长绿色植物的疏松表层。”这个定义正确地表示了土壤的基本功能和特性。土壤之所以能生长绿色植物，是由于它具有一种独特的性质——肥力。土壤这种特殊本质，就是土壤区别于其它任何事物的依据。土壤肥力虽与土壤物质组成有联系，但主要受土壤性状的影响。2、土壤的主要性状(1)土壤质地：土壤的泥砂比例称为土壤质地。直径小于0.01毫米的土粒称泥;直径为1—0.01毫米的土粒称砂;直径大于1毫米的土粒称砾石。根据土壤质地不同将土壤分为砂质土、粘质土和壤质土。①砂土：这类土壤含砂粒在80%以上，土粒间大孔隙多，土壤容积比重在1.4—1.7克/厘米3之间，因此，土壤昼夜温差大，通透性好，有机质矿质化快，易耕作，但保水保肥能力差，遇水易板结，肥力一般较低。种植作物要增施有机肥和少量多次地勤追化肥。②粘土：这种土壤含泥粒在60%以上，土壤比重在2.6—2.7克/厘米3之间。土壤硬度大，粘着性、粘结性和可塑性都强，故适耕性差。土壤保水保肥力强，潜在肥力较高。但土紧难耕，土温低，肥效不易发挥。因此，水田要注意管水，提高泥温，多施腐熟性有机肥和热性化肥。③壤土：这种土壤泥砂比例适中，一般砂粘占40—55%，粘(泥)粒占45—60%。土壤容重1.1—1.4克/厘米3之间。质地轻松，通气透水，保水保肥力强，耕作爽犁。因此，它是水、肥、气、热协调的优质土壤。(2)土壤结构：土壤形成团聚体的性能，称为土壤的结构性。凡土粒胶结成直径为1—10毫米的团粒状土壤结构，称为团粒结构。这是土壤结构中最好的一种。其形成条件有两个：一是胶结物质。土壤中的胶结物质最主要是粘粒，新形成的腐殖质和微生物的菌丝及分泌物。这些物质与钙胶结在一起，就形成了具有多孔性和养分丰富、不易被水泡散的水稳性团粒状土壤结构。因此，增施钙质肥料(石灰、石膏)有利团粒结构形成。二是外力挤压作用。凡是作物根系穿插、干湿交替、冻融交替和耕作都对粘聚起来的土粒产生一定的外力挤压作用，使之散碎成一定大小的团粒。深耕、免耕、滴灌、水旱轮作，都有利土壤团粒结构的形成。团粒结构优越性的具体表现：其一，能协调土壤水分和空气的矛盾。由于团粒间存在大孔隙，团粒内又有毛细管孔隙，这就有利于水分、养分、空气三者间的同时存在。从而土壤水、肥、气、热状况协调。其二，具有良好的养分状况。随着水、气矛盾的解决，也解决了水分与养分的矛盾。因团粒表面常为好气分解，团粒内部又为嫌气分解，前者有利于土壤养分释放给作物吸收，后者有利土壤腐殖质累积，养分保蓄。矛盾协调后的水分与养分就能同时而不断地供给作物需要。其三，使土壤松软适度。具有团粒结构的土壤，疏松多孔，犁耕阻力小，耕作省力，耕翻质量好;土壤细碎而均匀，既不紧硬，又不起浆浮泥;干燥不开大坼，泡田渗漏损失也小。(3)土壤吸收性能。土壤有吸收固体、液体和气体的能力。其吸收方式分为五种。①机械吸收作用：这是指土壤将大于土壤孔隙而悬浮于溶液中(如骨粉、饼肥、磷矿粉及粪便残渣等)的微细颗粒机械地阻留下来，使之不随土壤中渗水而流走的一种作用。由于土壤颗粒愈小，排列愈紧密，土壤孔隙愈细，因此机械吸收作用就越强，则土壤保肥性能就好。这种作用对新改稻田、新水库、塘坝有利增强保水蓄水的功能。②物理吸收作用：它是指土壤胶体依靠其表面能将分子态养分吸附在表面上，而胶体与被吸附物不起任何化学反应的一种作用。这种作用，由于对分子态养分有保持能力，因此，土壤中的氨气、尿素、氨基酸等分子态氮就会减少挥发损失。平常在施用易挥发的铵态氮肥时要求复好土就是这个道理。③化学吸收作用：这是指土壤中可溶性养分(如某些离子与带不同电荷的离子发生化学作用)，由纯化学作用产生不溶性沉淀而固定在土壤内的作用。这种作用，虽然有减少可溶性养分的流失，但被固定下来的养分就难以再被作物吸收利用，故降低了养分的利用率。因此，把磷肥集中施或与有机肥混和施，制成颗粒球肥施和根外喷施，就是避免化学吸收作用的发生，减少土壤对磷酸的固定。④代换吸收作用：这又叫物理化学吸收作用。它是指土壤胶体表面吸着许多与它带相反电荷离子的同时，其表面上又有等当量的同电荷的其它离子被代换出来的作用。其实质是一种离子(阳离子或阴离子)代换过程，是土壤胶体所吸收的离子和土壤溶液中的离子在相互代换。所以这种作用是可逆的，即胶体所吸收的离子，又能重新被其它离子代换到溶液中去。从而，这种作用在调节土壤中可溶性养分的保蓄和供应，具有重要意义。⑤生物吸收作用：这是指生活在土壤中的微生物及作物根系和动物等，吸收养分构成有机体而保留在土壤中的一种性能。由于生物是根据自身需要，从土壤溶液中选择吸收各种可溶性养分，形成有机体。当它们死亡后，有机残体又逐渐分解，把营养物质释放出来，供作物吸收利用。所以生物吸收作用，能保持养分，积累养分，提高土壤肥力。(4)土壤酸碱度。土壤酸碱度是指土壤溶液中存在的H+和OHˉ的量。通常用PH值表示。PH=7时是中性反应，这时溶液中H+和OHˉ数量相等；pH小于7表示是酸性反应，这时H+多于OHˉ；H大于7表示是碱性反应，这时H+少于OHˉ。土壤酸碱度按其PH值的大小分为七级：PH<4.5强酸性PH4.5—5.5酸性PH5.5—6.5微酸性PH6.5—7.5中性或近于中性PH7.5—8.5微碱性PH8.5—9.5碱性PH>9.5强碱性①土壤酸碱性产生原因：土壤之所以有酸碱性，主要是土壤中存在酸碱物质。H+来源主要是土壤胶体上吸附的H+和Al+3;其次是二氧化碳溶于水形成碳酸解离的结果：H2CO3=H++HCO3ˉ，HCO3ˉ=H++CO3ˉ除此之外，还有有机质转化过程中，分解产生的有机酸(丁酸、草酸、柠檬酸等)、岩石风化过程中，化学变化(如含硫矿物氧化)成的酸以及施用肥料加进的酸性物质[如(NH4)2SO4、NH4Cl]，当NH4+被作物吸收后，常遗留在土壤中的酸根(SO4-2，Clˉ)都能使土壤酸性增加。OHˉ的来源主要是土壤中碳酸钠、碳酸氢钠等盐类水解以及土壤胶体上含的代换性钠形成强碱转化结果。例如：Na2CO3+2H2O2NaOH+H2CO3NaHCO3+H2ONaOH+H2CO3②作物对土壤酸碱度的适应能力：强酸性与强碱性土壤都不利于作物生长。不同的作物要求土壤酸碱度不同。如茶树只适宜在酸性土壤上生长，像映山红、马尾松、杨梅、蒜盘子等，就是酸性土壤的指示植物;而天竺、圆叶包柏、柏木又是石灰性土壤的指示植物。此外，土壤酸碱度对营养元素的有效性及有益微生物的活动都有很大的影响，土壤过酸过碱还影响土壤良好结构的形成(现不作详细阐述)，这些无疑的都直接或间接地影响着作物的生长和发育。(5)土壤缓冲性能：在土壤加入酸、碱物质后，土壤所具有的抵抗土壤溶液酸化或碱化的能力，称为土壤缓冲性能。土壤胶体上代换性阳离子存在，对酸碱有缓冲作用。这是由于土壤胶体上代换性阳离子(盐基离子或H+)被代换到溶液中生成了中性盐或H2O，可以使土壤的酸碱度经常保持稳定，为作物和微生物生长发育提供良好的环境条件，同时也为指导施肥提供依据。向土壤中施用有机肥料、泥土类(塘泥)肥料、石灰和种植绿肥等，都是提高土壤缓冲性能的有效措施。(二)土壤肥力及其因素1、土壤肥力种类：土壤肥力就是指土壤能够满足作物生长发育所必需的水分、养分、空气、热量的能力而称之。土壤肥力分为自然肥力和人为肥力;潜在肥力和有效肥力。所谓自然肥力，是指自然土壤在未开垦利用之前所具有的肥力;人为肥力是指人们对土壤进行耕种、施肥、灌溉等农业技术措施而创造出来新的肥力。因此，任何土壤，耕作栽培作物愈久，可采用的农业技术措施愈完善，人为肥力所占比重就越大。所以说，土壤是劳动的对象，又是劳动的产物。所谓有效肥力，是指栽培作物时，被当季作物吸收利用的那部份肥力;潜在肥力是指在土壤中存在，不能立即被当季作物利用的那些肥力。潜在肥力和有效肥力，在得当的农业技术措施实施下，是可以相互转化的。2、土壤肥力因素：土壤水分、养分、空气和温度，称为土壤肥力四大因素。土壤肥力的高低，不只是受每个肥力因素数量适当与否的影响，而主要取决于水、肥、气、热之间在一定条件下协调程度的左右。因此，必须研究掌握土壤各个肥力因素状况和它们的相互关系。(1)土壤水分状况。“水利是农业的命脉”，首先，作物的生长发育需要大量的水。这是因为：一般作物要获得一分产量，必须消耗500—1000分的水，这些水都是从土壤中供给;作物吸收的养分也需要溶于水后才能被利用;土壤微生物的活动以及土壤养分的分解和转化都需要水。其次，水分直接对土壤空气与热量状况起着制约的作用，同时还影响着土壤的胀缩性、粘着性、粘结性和耕性等性质。这表明，土壤水分不仅为作物生长发育之必需，而且还可以通过控制土壤水分状况来使肥、气、热关系协调。①土壤水分类型：土壤水分按其受作用力的不同，一般分为三种：A、束缚水：这是在土粒表面引力作用下，紧紧地束缚在土粒周围的水分而称之。这种水在土壤中移动极慢，且有一部份在土粒表面不移动，所以很难被作物吸收利用。当土壤含水量达到仅有束缚水量时，作物就出现凋萎现象。由于土粒愈细，吸住的水分愈多，所以粘土的束缚水量大于砂土。B、毛管水：这是在土壤毛细管引力作用下，保持在曲折微细的土壤孔隙里的水而称之。这种水能沿着毛细管孔隙向上下左右的各个方向移动。其移动规律是从湿度大的土层移向湿度小的土层。它是土壤中最适于作物吸收利用的水分。由于水中溶有各种作物的养分，所以又为作物提供了营养物质。油砂土、潮砂土，出现的“回潮”或“回润”现象，就是毛管水的上升运动，把地下水引到耕层的缘故。但是毛管水运动会带来地表蒸发不断发生，造成土壤水分损失，所以生产中常采取中耕松土，这有切断土壤毛细管，减少土壤水分蒸发的作用。C、重力水：这是在土壤水分含量超过土壤毛管力的作用范围时，过多的水受重力的影响向下渗漏，这种渗漏水称为重力水。它是水稻最有效的水分。尽管渗漏作用有造成漏水漏肥的现象，但不论对水田还是旱土，适当的渗漏是必要的，它有利于土壤空气的更新及有害还原物质的向下移动和淋失。②水稻土壤水分状况：水稻土壤在淹水时期，耕作层水分呈现过饱和状态，由于重力作用,不断地垂直渗漏。根据水分的垂直渗漏特点，水稻土分成三个类型。A、地下水型：这类水稻土，地下水位高(地下水位距地表在60厘米以内)，排水不良，灌溉水层和地下水相连，通透性能差，泥温低，如冷浸田、滂泥田和深脚鸭屎泥土属之。B、地表水型：这类水稻土，地下水位很深(超过150厘米)，灌溉水下渗不能达到地下水层，排水虽良好，但不耐干旱。如高岸田、天水田和大部份梯田属之。C、良水型：这类水稻土，地下水位在60—150厘米之间，灌溉水层与地下水位不相连接，但土壤毛管水可以上下流通，这类田一般分布在垅田上面或一排、二排田属之。三种类型水稻土，以良水型的土壤肥力最好，一般是高产稳产稻田。适当渗漏对水稻土是必要的，它有助于土壤空气的更新和有毒物质的排除。当然也不可过大，以免造成养分淋失。一般在灌1寸水能保存三天为限，即渗漏量为0.5—1.0厘米/24小时最适当。(2)土壤空气状况：土壤空气对土壤微生物活动和养分转化有密切关系，对作物根系发育亦有影响。作物生长发育各个时期对土壤空气都有一定的要求。①土壤空气的成分：土壤中的空气，一部份是由大气进入;一部份是由土壤中生物化学过程所产生。由于土壤中生物(作物根系和微生物)生命活动的影响和有机质的分解作用，不断地消耗氧气和产生二氧化碳及其它气体，致使土壤空气与大气的成分有显著的区别：土壤空气中氧气含量低于大气，而二氧化碳的含量则高于大气;另外土壤空气经常为水汽所饱和，大气湿度一般只达50—90%;土壤空气有时还含有少量的还原性气体，如甲烷、氢气、氨和硫化氢。②水稻土空气状况的特点：水稻土壤由于季节性或常年淹水，土壤空气与大气之间的气体交换被水层隔绝，常处于还原状态。作物生命活动消耗的氧，只能靠作物茎叶的输氧组织将大气中的氧输入根部，由根再将氧分秘出来，造成根际微域氧化环境，防止稻根被周围还原性物质的毒害。这正是水稻能在缺氧环境中生长的秘密所在。所以水田土壤空气状况的特点具有明显的层次性和微域性。在耕作层表面数毫米至1厘米处为氧化层，因铁成高价化合物状况，土色呈黄褐或黄棕色。在氧化层以下的耕作层为还原层，铁成低价化合物状况，土色呈青灰或兰灰色。但在靠近根际周围的土壤，常因水稻根群的泌氧作用而出现锈斑和锈纹。③土壤空气在土壤肥力中的地位：土壤空气供给作物根系呼吸作用所需要的氧。如缺氧，根系发育受到影响，吸水吸肥机能减弱，甚至死亡。尤其种子发芽期及幼苗期更加如此。水稻虽具通气组织，土壤也应具有一定的通气性能，以利稻根生长。另外，土壤空气状况影响土壤微生物的活动和养分的转化。缺氧微生物活动以嫌气性为主，使有机质分解缓慢，造成养分不足，甚至引起氮素损失，同时，还产生不利于作物营养的还原性有毒物质，如乙酸、丁酸、硫化氢等。此外，土壤通气不良，有利于病菌滋生，引起作物感染病害，影响作物生长，降低产量。因此，稻田常采用排水露田和晒田进行调节。(3)土壤温热状况：土壤温度对作物生育和土壤中微生物活动以及各种养分的转化、土壤水分蒸发和运动都有很大影响。作物从播种到成熟都需要一定的温度条件，如大麦、小麦在1—2℃时就能发芽，而水稻、棉花要在10—12℃时才发芽。所以不同作物的适时播种，就是由土壤温度来决定的。一般土壤微生物生活，以土温25℃—37℃为适宜，最低是5℃，最高不超过45℃—50℃。土温过低，微生物活动减弱，甚至完全停止，有机质难于分解，有效养分缺乏。冷浸田就是如此，所以要排除冷浸水，增施猪牛栏粪、石灰、草木灰和火土灰，以提高土温。①影响土壤温度的因素：温度是热的表现。土壤热量主要来源于太阳辐射热，其次是微生物对有机质的分解作用，放出一定的热量，使土温增高。影响土壤温度变化的因素很多，有纬度、海拨高度、地形和坡向。但主要是土壤本身的土壤热特性，如土壤热容量、导热性、吸热性和散热性等。尤其是热容量和导热性是决定土温最重要的内因。A、土壤热容量：每1立方厘米的干土增温1℃时所需的热量卡数(卡/立方厘米/度)，称为土壤热容量。水的热容量为1;空气为0.0003;土粒介于二者之间，约为0.5—0.6。由于土壤固体部分变化很小，因此，土壤热容量的大小主要决定于土壤水分和空气的数量，凡水多气少的土壤，热容量就大，增温慢，冷却也慢，温度变化小;反之，土温变化就大。所以稻田管理，早春白天排水增温，夜间灌水保温;夏季运用深灌降温。B、土壤导热性：土壤导热是指从温度较高的土层向温度较低的土层传导热量的性能。其大小与土壤固、液、气三相组成比例有关。土壤矿物质的导热性为空气的100倍;水为空气的25倍;有机质为空气的5倍;空气几乎不传热。由此可知，土壤导热性的大小取决于空气和水分之间的相对比例。因此，中耕松土有减小土壤导热性，使表土温度不易向下传递，深土温度不易向上散失。②土温变化的调节：土壤温度随气象因子的影响而经常变化，为了满足作物生长发育的需要，必须围绕早春增加土温，夏季降低土温，秋冬保持土温的目标，采取行之有效的措施。A、合理灌溉：早春寒潮期间多灌水、灌深水，避免土温骤然下降，增强幼苗抵御低温能力;一般天气期间采用浅水间灌，升温通气，促进作物生长。夏季以增强土壤散热性为主，采取短期灌深水和经常性的灌水露田相结合，达到散热、通气、供水的目的，促进作物生长发育。秋冬时节，一般结合施肥，推行霜前灌水，以减轻作物冻害。B、合理施肥：在保证施足肥的前提下，增施有机肥，如火土灰、腐熟的猪牛栏淤等等，来提高土壤温度。其一，加深土色，增加土壤吸热力;其二，有机肥料分解中放出热量;其三，土壤疏松，增加空气容量，降低土壤热容量。此外，还直接提高作物的营养。C、实行覆盖：早春和秋冬低温季节，运用草木灰、切碎的草子(紫云英)、干(湿)牛粪、苔藓、塑料薄膜等覆盖地面，能提高土壤吸热，减少散热，有保温防冻作用;夏秋高温干旱期间，采用稻草或其它作物秸秆覆盖地面，有遮荫防晒，降低土温的作用，同时，还能减少水分蒸发和消灭杂草。D、中耕松土：这有利于土壤空气容量增加，减少表土热量向下传导和下层土温上升的作用。因此，早春，对粘重紧实土壤进行中耕松土来提高土温，加快种子萌芽;夏季中耕松土，缓和根系活动层土温过高，促进作物根系生长。此外，利用风障、防风林、熏烟及施用化学增温剂等，均可调节土壤温度，可以因地制宜进行应用。(4)土壤养分状况：作物需要的养分绝大部份来自土壤，但是，土壤里的养分绝大部份存在于难溶性的矿物质中和有机质中，为迟效性，作物难以吸收利用。而能被当季作物吸收利用的离子态速效养分，只占土重0.005—0.1%，存在于水溶液中和被吸附在土壤胶体表面上。不过，这种迟效养分和速效养分在一定条件下能够相互转化。①有机碳化合物的转化：土壤中的纤维素、淀粉、双糖、单糖以及脂肪等有机物，都不含氮。它们在土壤中转化有两种情况：一是通气良好时，受好气性细菌和真菌作用，迅速分解，最后产生CO2和H2O，并放出大量的热。这种热是土壤生物化学作用的原动力和土壤微生物生命活动所需能量的来源。CO2是作物进行光合作用的重要原料。二是通气不良时，受嫌气性细菌作用，缓慢分解，只是放出少量的热和CO2，而累积大量的有机酸(乙酸、丁酸)、甲烷、氢等还原性物质，障碍作物生长发育。如水稻“翻秋”或“溶蔸”现象，就是丁酸所害。因此，水田翻压绿肥，结合施石灰，就是为了中和有机酸，消除稻田毒害。②土壤中氮素的转化：土壤中有机态氮占99%以上，无机态氮不足1%;水田的全氮含量约为0.1—0.2%，无机态氮更少。作物从土壤中吸收的氮素，绝大部份由有机氮转化而来。其转化形成主要有四种：A、氨化作用：土壤中含氮的有机物，如蛋白质、尿素和壳糖(几丁质)等在氨化细菌作用下，逐渐分解释放出氨，称之氨化作用。不论通气好坏，此过程都能进行。氨与土壤中的酸根结合成铵盐,为作物吸收利用，或被土壤胶体吸附保存。B、硝化作用：氨或铵盐在通气良好的条件下，经亚硝酸细菌、硝酸细菌等的作用，转化成硝酸的过程，称为硝化作用。由于这种作用是在通气良好的情况下进行，所以NO3-N存在于旱土中，而水田中很少见。NO3-N是作物良好的有效态养分，但不能被土壤胶体吸附，易于随水流失，故深耕松土，保持土壤湿润，有利硝化作用和防止土壤中氨的散失。C、反硝化作用：当土壤通气不良，并含有大量新鲜有机质和硝酸盐的土壤中，在反硝化细菌的作用下，将硝酸盐还原成作物不能利用的氮气而损失，这个过程称为反硝化作用。这种作用对作物吸收养分和生长带来不利，务必加以阻止。稻田采用浅水间灌，露田通气和施用铵态氮肥，旱土雨后中耕松土，均可防止反硝化作用的发生。D、生物夺氮作用：土壤中的无机态氮(如铵盐、硝酸盐)部份被微生物、杂草、土壤动物吸收利用，合成生物机体，使土壤有效态氮减少，称生物夺氮作用。尤以微生物夺氮最突出，当土壤中施用大量新鲜的、含纤维素多的有机肥和其它环境条件又适宜，微生物就大量活动与繁殖，消耗掉土壤中有效氮素，从而导致作物氮素养分缺乏或严重不足。因此，凡秸秆还田或施用大量未腐熟的含纤维多的有机肥料，必须配合施用适当的速效氮肥，以补充土壤有效氮素，供作物吸收。但是生物夺氮作用是暂时的，直到有机肥分解就会停止，同时，微生物死亡后，氮素仍就归还给土壤，让作物吸收利用。所以这与反硝化作用造成的氮素损失是完全不同的。③土壤中磷素的转化：一般土壤中磷酸总量(以P2O5计算)约在0.05—0.2%之间。红黄壤仅为0.06%左右，就按此计算，这些磷也够供作物若干年丰收所需要。但是，土壤中能为作物很好吸收利用的水溶性磷(如Na、K、NH4等磷酸盐及磷酸一钙)和弱酸溶性磷(如磷酸二钙)很少;而多数为难溶性磷(磷酸二钙)和极难溶性磷(如磷酸铁、磷酸铝)以及有机态磷。它们需经各种转化，才能被作物吸收利用。土壤无机磷的转化，主要受土壤反应的影响。在强酸性土壤中，磷与铁、铝离子化合生成难溶性的磷酸铁、磷酸铝沉淀而被土壤固定;在石灰性土壤中，磷则成为磷酸三钙被土壤固定。只有当土壤反应处于中性或接近中性(PH值为6.5—7.5)的条件，磷的有效性才提高。土壤有机磷的转化。土壤中，有机磷化合物主要有核蛋白、核酸、卵磷脂、植素以及植物体内其他含磷化合物。它们是在土壤微生物的作用下，进行水解释放出磷酸。这种磷酸和水解性磷一样，在土壤中再进行着各种转化，变成有效磷酸盐供作物吸收利用。④土壤中钾素的转化：土壤中钾的含量与成土母质、土壤质地和有机肥料的施用关系极大。据有关资料记载，发育于紫色土、花岗岩的土壤，全钾量为2.5—5.0%;发育于第四纪红色粘土的红壤，全钾量为0.8—1.8%;而发育于石灰岩的土壤，全钾量仅0.68—1.12%。粘质土壤含钾量比砂质土壤高。土壤中的钾，根据对作物有效性的高低，分为四大类：一曰水溶性钾。如KNO3、KCl、KHCO3等，可以被作物直接吸收，但土壤中的含量却极少;二曰代换性钾。系土壤胶体上吸附的钾，作物亦可以直接利用，但土壤中含量也少，仅占土壤全钾量的0.15—0.5%。通常说的有效钾，是指水溶性钾与代换性钾的总和。但它只占土壤总钾量的1—2%;三曰微生物活体钾。这类钾存在微生物活体内，但在微生物死亡分解后，可被作物吸收利用;四曰矿物钾。系指矿石(钾云母、正长石)中含的钾，是矿物在钾细菌和各种酸的作用下，释放出的水溶性钾。这类钾在土壤中含量最多，占土壤含钾总量98%以上。不过，土壤中的钾和氮、磷一样，并不能满足作物生活的需要，亦须依靠施肥来补充。土壤中各种类型的钾，在一定的条件下，也可相互转化。难溶性含钾矿物，在各种酸类或钾细菌的作用下，可以释放出水溶性钾。但在含粘粒多的土壤中，由于粘土具有湿胀干缩的特性，在土壤干湿交替频繁中，土壤中的水溶性钾或代换性钾被粘土矿物固定起来，成为一种不能移动的钾，使作物根系无法吸收。",2015/9/15
187,Ionic简单学习,沈晓芸,http://180.168.156.212:2262/wecenter/?/article/9105,"Ionic搭建开发环境1.准备工作下载Ant（打包使用），Node.js（下载包），HBuilder（IDE，编写代码，真机调试）,AndroidSDK(Android编译)加群：2452857682.配置环境变量：ANDROID_HOMED:\ProgramFiles\adt\sdk（对应sdk路径）Path;D:\ProgramFiles\apache-ant-1.9.4\bin（对应ant下bin路径）3.安装ionic等，运行命令提示符（管理员）输入a.将cordova和ionic包安装到全局环境中（可供命令行使用）：[plain]viewplaincopyprint?npminstall-gcordovaionicb.进入你要创建项目的路径：[plain]viewplaincopyprint?cdE:\Study\Android\ionic\Projecte:c.创建一个名为myApp的还有tabs的项目（ionicstart<project-name><optional-template>）可选模板为sidemenu侧滑、tabs底部tab切换、blank空白）:[plain]viewplaincopyprint?ionicstartmyApptabsd.myApp就为项目名称,进入myApp这个文件夹:[plain]viewplaincopyprint?cdmyAppe.添加android平台:[plain]viewplaincopyprint?ionicplatformaddandroidf.生成androidapk:[plain]viewplaincopyprint?ionicbuildandroidg.在android模拟器或真机中模拟:[plain]viewplaincopyprint?ionicemulateandroid其中f和g可以合并为：[plain]viewplaincopyprint?ionicrunandroid即生成apk，并在模拟器或真机中模拟。4.更新ionic等a.更新cordova及ionic包[plain]viewplaincopyprint?npmupdate-gcordovaionicb.更新已建ionic项目中的js类库，命令行中先进入项目所在目录，然后运行：[plain]viewplaincopyprint?ioniclibupdate5.展现ionic项目结果（显示在ios和android上的样式）[plain]viewplaincopyprint?ionicserve--lab6.查看ionic版本（当前最新版本为1.2.13）[plain]viewplaincopyprint?ionic-v",2015/9/15
188,ZigBee爆安全漏洞引发物联网安全危机？且看资深人物深度解析,马习,http://180.168.156.212:2262/wecenter/?/article/9104,"对于ZigBee技术，至今全球尚未出现一起破解先例。其安全性源于其系统性的设计：采用AES加密(高级加密系统)，严密程度相当于银行卡加密技术的12倍；其次，Zigbee采用蜂巢结构组网，每个设备均能通过多个方向与网关通信，网络稳定性高；另外，其网络容量理论节点为65300个，足够满足家庭网络覆盖需求，即便是智能小区、智能楼宇等仍能全面覆盖；最后，Zigbee具备双向通讯的能力，不仅能发送命令到设备，同时设备也会把执行状态反馈回来，这对终端使用体验至关重要，尤其是安防设备，倘若你点击了关门，却不知道门是否真的已经锁上，将会带来多大的安全隐患；此外，Zigbee采用了极低功耗设计，可以全电池供电，理论上一节电池能使用10年以上，节能环保。Z-stack对Zigbee提供了全面的支持，功能之强大，性能稳定、安全性高，说到安全性是我们今天的主题。CC2530硬件支持128bit的AES加密算法，在协议栈中为了避开相同设备的干扰，和防止被其他设备监听，我们就采用这个技术将数据加密来提高数据的安全性。AES（TheAdvancedEncryptionStandard）是美国国家标准与技术研究所用于加密电子数据的规范。它被预期能成为人们公认的加密包括金融、电信和政府数字信息的方法。AES是一个新的可以用于保护电子数据的加密算法。明确地说，AES是一个迭代的、对称密钥分组的密码，它可以使用128、192和256位密钥，并且用128位（16字节）分组加密和解密数据。与公共密钥密码使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据。通过分组密码返回的加密数据的位数与输入数据相同。迭代加密使用一个循环结构，在该循环中重复置换（permutations）和替换(substitutions）输入数据。在Z-stack中采用的是128bit的加密，首先需要一个128bit的key，这个KEY不同，加密出来的内容也不同在Z-stack中是通过DEFAULT_KEY=""{0x01,0x03,0x05,0x07,0x09,0x0B,0x0D,0x0F,0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0D}""这种方式来定义的。在Z-stack中已经在协议栈中实现了这个加密算法，如果需要使用直接开启这个服务就可以了，下面我们主要将Z-stack的加密算法的开启。Z-stack1.4.3加密算法的功能开启方法：1.将f8wConfig.cfg文件中设置为-DSECURE=1，这句话的意思是SECURE=1，这个变量在协议栈中作为if语句的条件使用，条件为真的语句中就是开启加密算法的函数。所以要使用第一步是要将这个参数设置为1。2.将ZGlobals.c中的uint8zgPreConfigKeys=FLASE;修改为uint8zgPreConfigKeys=TRUE。3.准备一个key，这个可以在函数nwk_global.c中修改：如果使用了加密算法后，网络中所有的设备都需要开启这个算法，而且各个设备中的key必须相同。否则后果是很严重的，这会导致你的网络不能正常通讯，因为没有加密的数据或者相同key加密，这些数据网络是不认识的，根本就不会传到网络层。加密算法开启以后，如果你需要修改代码，就必须改变你的key，或者是擦除一次你的flash，否则会出现不可逾期的错误，而且没有规律。通常的做法是擦除flash一次，这样可以保证和整个网络的key相同。除此之外，还加入了一个加密入网白名单机制，通过将入网设备的Mac地址加密后生成key可以在运行时通过串口协议控制节点的入网许可，同时也限制了网内设备的生产厂家必须是经过协调器开发者认证的，否则不可能得到合法的key。通过以上的论证，我真的认为黑客想进入系统是很难的！在这个时代，放眼全球，“无线取代有线”已是大势所趋，如今人们只需置身于WiFi环境，或者打开设备的蓝牙功能，彼此间就能轻松的进行数据传输。另一方面，无线技术的不断发展，也为家庭物联网领域带来了全新的发展机遇，而家庭自动化(智能家居)更是成为了先进无线技术的竞技场。谈及无线技术，多数人最先想到的可能会是WiFi、蓝牙，但实际上，目前在智能家居行业中，较为主流的无线技术一共有四种：WiFi、蓝牙、Zwave和ZigBee。其实，智能化家居这个概念早在十几年前就出现了，1998年比尔盖茨就为自己建造过一座智能化的豪宅。早期的智能家居是有线的，这在很大程度上，限制了其自身的发展：首先是布线问题，需要开墙破洞，使得多数已装修好的房子不愿加入进来；其次，将线布好埋于墙体内，检修维护非常不便，一旦出现问题，意味着要再次开墙破洞；最后，就是造价不菲，以至于早期的智能家居只适合高端人群，而非平民消费品。无线解决方案为家居自动化带来了曙光，剪掉了这些繁琐的线，就减去了很多麻烦。就目前而言，无线智能家居根据所使用的技术不同，主要分为蓝牙、Wi-Fi、Zwave和ZigBee四种，无线技术让人们得以实现对家居的远程控制。经过这么一番技术性的解析后，真是让人更加坚定Zigbee是安全的！当然，“采用ZigBee协议的智能家居设备存在严重漏洞”客观上并没有错，只是这其中的问题出在制造厂商，并不能说ZigBee存在安全漏洞！",2015/9/15
189,Hibernate主键生成方式,赵本,http://180.168.156.212:2262/wecenter/?/article/9103,"语法：<generatorclass=""类型""/>1.assigned:主键由外部程序负责生成，无需Hibernate参与。----如果要由程序代码来指定主键,就采有这种.2.increment:对long，short或int的数据列生成自动增长主键。increment主键生成方式的特点是与底层数据库无关性，大部分数据库如Mysql，MSSQL和ORACLE等都支持increament生成方式。此方式的实现机制为在当前应用实例中维持一个变量，以保存着当前的最大值，之后每次需要生成主键的时候将此值加1作为主键。increment方式的不足之处是当多个线程并发对数据库表进行写操作时，可能出现相同的主键值，发生主键重复的冲突，因此多线程并发操作时，不应该使用此方法。3.identity:如果数据列的类型是long，short或int，可使用主键生成器生成自动增长Hibernate主键。与底层数据库有关，要求数据库支持identify,如MySQL中是auto_increment,SQLServer中是Identify.支持的数据库有MySQL,SQLServer,DB2,Sybase和HypersonicSQL.(好像不支持oracle)无需Hibernate和用户的干涉，使用较为方便，但不便于在不同的数据库之间移植程序。identity的优点是不会发生increment方式的并发错做问题。数据库涉及到的表要设置自动增长。4.sequence:在ORACLE等数据库中使用sequence生成主键。sequence的特点是于数据库的相关性，seqhio要求底层能支持sequence，列如Oracle。5.hilo:通过hi/lo算法生成主键，需要一个表来保存额外的主键信息。这样生成的标识符只在特定的数据库是唯一的，在使用JTA（Java分布式事务）获得链接或用户自定义提供的链接中，不要使用这种生成器。hilo方式需要维护表信息，因此对数据的影响的要率会造成一定影响。6.seqhio:与hilo类似，通过hi/lo算法实现的主键生成机制，只是主键历史状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。如果数据列的类型是long，short或int可使用该主键生成器。7.native:由Hibernate根据不同的数据库方言，自行判断采用identity、hilo、sequence其中一种作为Hibernate主键生成方式，native的优点是与底层性无关，便于不同数据库之间的移植，由Hibernate根据不同数据库选择主键的生成方式。在oracle中需要创建叫Hibernate_sequence名字的sequence，如果设置了Hibernate.hbm2ddl.auto属性，不需要手动建立序列，前提是数据库帐号必须有CreateSequence这种高级权限。mysql等数据库则不用建立sequence。8.uuid.hex:采用基于128位的算法生成唯一值，并编制成32位长度的唯一字符串作为主键值，uuid.hex的优点是支持大部分数据库，缺点就是要占用较大的存储空间。对于并发Insert要求较高的系统，推荐采用uuid.hex作为主键生成机制。9.uuid.string:使用UUID算法，UUID被编码为一个16个字符长的任意ASCII字符组成的字符串。不能在PostgreSQL数据库中使用。uuid.string同uuid.hex类似，需要占很大的存储空间。10.foreign:使用外部表的字段作为Hibernate主键。一般而言，利用uuid.hex方式生成Hibernate主键将提供最好的性能和数据库平台适应性。另外由于常用的数据库，如Oracle、DB2、SQLServer、MySql等，都提供了易用的主键生成机制（Auto-Increase字段或者Sequence）。我们可以在数据库提供的主键生成机制上，采用generator-class=native的主键生成方式。不过值得注意的是，一些数据库提供的主键生成机制在效率上未必最佳，大量并发insert数据时可能会引起表之间的互锁。数据库提供的主键生成机制，往往是通过在一个内部表中保存当前主键状态（如对于自增型主键而言，此内部表中就维护着当前的最大值和递增量），之后每次插入数据会读取这个最大值，然后加上递增量作为新记录的主键，之后再把这个新的最大值更新回内部表中，这样，一次Insert操作可能导致数据库内部多次表读写操作，同时伴随的还有数据的加锁解锁操作，这对性能产生了较大影响。因此，对于并发Insert要求较高的系统，推荐采用uuid.hex作为主键生成机制。",2015/9/15
190,Spring注解,赵本,http://180.168.156.212:2262/wecenter/?/article/9102,"?@Controller?@Service?@Autowired?@RequestMapping?@RequestParam?@ModelAttribute?@Cacheable?@CacheFlush?@Resource?@PostConstruct?@PreDestroy?@Repository?@Component（不推荐使用）?@Scope?@SessionAttributes?@InitBinder?@Required?@Qualifier@Controller?例如@ControllerpublicclassSoftCreateControllerextendsSimpleBaseController{}?或者@Controller(""softCreateController"")?说明@Controller负责注册一个bean到spring上下文中，bean的ID默认为类名称开头字母小写@Service?例如@ServicepublicclassSoftCreateServiceImplimplementsISoftCreateService{}?或者@Service(""softCreateServiceImpl"")?说明@Service负责注册一个bean到spring上下文中，bean的ID默认为类名称开头字母小写@Autowired?例如@AutowiredprivateISoftPMServicesoftPMService;?或者@Autowired(required=false)privateISoftPMServicesoftPMService=newSoftPMServiceImpl();?说明@Autowired根据bean类型从spring上线文中进行查找，注册类型必须唯一，否则报异常。与@Resource的区别在于，@Resource允许通过bean名称或bean类型两种方式进行查找@Autowired(required=false)表示，如果spring上下文中没有找到该类型的bean时，才会使用newSoftPMServiceImpl();@Autowired标注作用于Map类型时，如果Map的key为String类型，则Spring会将容器中所有类型符合Map的value对应的类型的Bean增加进来，用Bean的id或name作为Map的key。@Autowired还有一个作用就是，如果将其标注在BeanFactory类型、ApplicationContext类型、ResourceLoader类型、ApplicationEventPublisher类型、MessageSource类型上，那么Spring会自动注入这些实现类的实例，不需要额外的操作。@RequestMapping?类@Controller@RequestMapping(""/bbtForum.do"")publicclassBbtForumController{@RequestMapping(params=""method=listBoardTopic"")publicStringlistBoardTopic(inttopicId,Useruser){}}?方法@RequestMapping(""/softpg/downSoftPg.do"")@RequestMapping(value=""/softpg/ajaxLoadSoftId.do"",method=POST)@RequestMapping(value=""/osu/product/detail.do"",params={""modify=false""},method=POST)?说明@RequestMapping可以声明到类或方法上?参数绑定说明如果我们使用以下的URL请求： 将ModelMap中属性名为currUser的属性@SessionAttributes({""attr1"",""attr2""})@SessionAttributes(types=User.class)@SessionAttributes(types={User.class,Dept.class})@SessionAttributes(types={User.class,Dept.class},value={""attr1"",""attr2""})@InitBinder?说明如果希望某个属性编辑器仅作用于特定的Controller，可以在Controller中定义一个标注@InitBinder注解的方法，可以在该方法中向Controller了注册若干个属性编辑器?例如@InitBinderpublicvoidinitBinder(WebDataBinderbinder){SimpleDateFormatdateFormat=newSimpleDateFormat(""yyyy-MM-dd"");dateFormat.setLenient(false);binder.registerCustomEditor(Date.class,newCustomDateEditor(dateFormat,false));}@Required?例如@requiredpublicsetName(Stringname){}?说明@required负责检查一个bean在初始化时其声明的set方法是否被执行，当某个被标注了@Required的Setter方法没有被调用，则Spring在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。@Required注解只能标注在Setter方法之上。因为依赖注入的本质是检查Setter方法是否被调用了，而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非setXxxx()类型的方法则被忽略。@Qualifier?例如@Autowired@Qualifier(""softService"")privateISoftPMServicesoftPMService;?说明使用@Autowired时，如果找到多个同一类型的bean，则会抛异常，此时可以使用@Qualifier(""beanName"")，明确指定bean的名称进行注入，此时与@Resource指定name属性作用相同。",2015/9/15
191,JAVA代码优化小例子,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9101,"1、为'vectors'和'hashtables'定义初始大小jvm为vector扩充大小的时候需要重新创建一个更大的数组，将原原先数组中的内容复制过来，最后，原先的数组再被回收。可见vector容量的扩大是一个颇费时间的事。通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。例子：importjava.util.vector;publicclassdic{publicvoidaddobjects(object[]o){//iflength>10,vectorneedstoexpandfor(inti=0;i<o.length;i++){v.add(o);//capacitybeforeitcanaddmoreelements.}}publicvectorv=newvector();//noinitialcapacity.}更正：自己设定初始大小。publicvectorv=newvector(20);publichashtablehash=newhashtable(10);2、在finally块中关闭stream程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。例子：importjava.io.*;publicclasscs{publicstaticvoidmain(stringargs[]){cscs=newcs();cs.method();}publicvoidmethod(){try{fileinputstreamfis=newfileinputstream(""cs.java"");intcount=0;while(fis.read()!=-1)count++;system.out.println(count);fis.close();}catch(filenotfoundexceptione1){}catch(ioexceptione2){}}}更正：在最后一个catch后添加一个finally块finally{fis.close();}3、使用'system.arraycopy()'代替通过来循环复制数组'system.arraycopy()'要比通过循环来复制数组快的多。例子：publicclassirb{voidmethod(){int[]array1=newint[100];for(inti=0;i<array1.length;i++){array1[i]=i;}int[]array2=newint[100];for(inti=0;i<array2.length;i++){array2[i]=array1[i];//violation}}}更正：publicclassirb{voidmethod(){int[]array1=newint[100];for(inti=0;i<array1.length;i++){array1[i]=i;}int[]array2=newint[100];system.arraycopy(array1,0,array2,0,100);}}4、在字符串相加的时候，使用''代替""""，如果该字符串只有一个字符的话例子：publicclassstr{publicvoidmethod(strings){stringstring=s+""d""//violation.string=""abc""+""d""//violation.}}更正：将一个字符的字符串替换成''publicclassstr{publicvoidmethod(strings){stringstring=s+'d'string=""abc""+'d'}}5、不要在循环体中实例化变量在循环体中实例化临时变量将会增加内存消耗例子：importjava.util.vector;publicclassloop{voidmethod(vectorv){for(inti=0;i<v.size();i++){objecto=newobject();o=v.elementat(i);}}}更正：在循环体外定义变量，并反复使用importjava.util.vector;publicclassloop{voidmethod(vectorv){objecto;for(inti=0;i<v.size();i++){o=v.elementat(i);}}}6、确定stringbuffer的容量stringbuffer的构造器会创建一个默认大小(通常是16)的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再丢弃旧的数组。在大多数情况下，你可以在创建stringbuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。例子：publicclassrsbc{voidmethod(){stringbufferbuffer=newstringbuffer();//violationbuffer.append(""hello"");}}更正：为stringbuffer提供大小。publicclassrsbc{voidmethod(){stringbufferbuffer=newstringbuffer(max);buffer.append(""hello"");}privatefinalintmax=100;}7、通常把大循环放在里面,把小循环放在外面for(intj=0;j<1000000;j++){for（inti=0;i<10;i++）{System.out.println(“HelloWord!!!!”);}}改成for（inti=0;i<10;i++）{for(intj=0;j<1000000;j++){System.out.println(“HelloWord!!!!”);}}",2015/9/8
192,Java常见内存溢出(OutOfMemoryError),马玉荣,http://180.168.156.212:2262/wecenter/?/article/9100,"在解决java内存溢出问题之前，需要对jvm（java虚拟机）的内存管理有一定的认识。jvm管理的内存大致包括三种不同类型的内存区域：PermanentGenerationspace（永久保存区域）、Heapspace(堆区域)、JavaStacks(Java栈）。其中永久保存区域主要存放Class（类）和Meta的信息，Class第一次被Load的时候被放入PermGenspace区域，Class需要存储的内容主要包括方法和静态属性。堆区域用来存放Class的实例（即对象），对象需要存储的内容主要是非静态属性。每次用new创建一个对象实例后，对象实例存储在堆区域中，这部分空间也被jvm的垃圾回收机制管理。而Java栈跟大多数编程语言包括汇编语言的栈功能相似，主要基本类型变量以及方法的输入输出参数。Java程序的每个线程中都有一个独立的堆栈。容易发生内存溢出问题的内存空间包括：PermanentGenerationspace和Heapspace。OutOfMemoryError：PermGenspace----PermGenspace溢出PermGenspace的全称是PermanentGenerationspace，是指内存的永久保存区域。原因：程序中使用了大量的jar或class，使java虚拟机装载类的空间不够，与PermanentGenerationspace有关。解决这类问题有以下两种方法：增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。针对tomcat6.0，在catalina.sh或catalina.bat文件中一系列环境变量名说明结束处（大约在70行左右）增加一行：JAVA_OPTS=""-XX:PermSize=64M-XX:MaxPermSize=128m""如果是windows服务器还可以在系统环境变量中设置2.清理应用程序中web-inf/lib下的jar，如果tomcat部署了多个应用，很多应用都使用了相同的jar，可以将共同的jar移到tomcat共同的lib下，减少类的重复加载。OutOfMemoryError：Javaheapspace----JVMHeap（堆）溢出原因是：java虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了，与Heapspace有关。在JVM中如果98％的时间是用于GC，且可用的Heapsize不足2％的时候将抛出此异常信息。解决这类问题有以下两种方法：1.检查程序，看是否有死循环或不必要地重复创建大量对象。找到原因后，修改程序和算法。2.增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。如：setJAVA_OPTS=-Xms256m-Xmx1024mjava.lang.StackOverflowError----栈溢出栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。调用构造函数的“层”太多了，以致于把栈区溢出了。通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要1K的空间(这个大约相当于在一个C函数内声明了256个int类型的变量)，那么栈区也不过是需要1MB的空间。通常栈的大小是1－2MB的。通常递归也不要递归的层次过多，很容易溢出。解决方法：修改程序",2015/9/8
193,国家出大数据纲要 三大任务助力经济转型,张二伟,http://180.168.156.212:2262/wecenter/?/article/9108,近日，国务院正式印发《促进大数据发展行动纲要》(以下简称《行动纲要》)。《行动纲要》指出，推动大数据发展和应用在未来5—10年逐步实现以下目标：打造精准治理、多方协作的社会治理新模式;建立运行平稳、安全高效的经济运行新机制;构建以人为本、惠及全民的民生服务新体系;开启大众创业、万众创新的创新驱动新格局;培育高端智能、新兴繁荣的产业发展新生态。推动大数据与云计算、物联网、移动互联网等新一代信息技术融合发展，探索大数据与传统产业协同发展的新业态、新模式，促进传统产业转型升级和新兴产业发展，培育新的经济增长点。形成一批满足大数据重大应用需求的产品、系统和解决方案，建立安全可信的大数据技术体系，大数据产品和服务达到国际先进水平，国内市场占有率显著提高。培育一批面向全球的骨干企业和特色鲜明的创新型中小企业。构建形成政产学研用多方联动、协调发展的大数据产业生态体系。《行动纲要》提到了三大重点任务和十项工程。三大重点任务包括加快政府数据开放共享，推动资源整合，提升治理能力;推动产业创新发展，培育新兴业态，助力经济转型;强化安全保障，提高管理水平，促进健康发展。十项工程包括政府数据资源共享开放工程、国家大数据资源统筹发展工程、政府治理大数据工程、公共服务大数据工程、工业和新兴产业大数据工程、现代农业大数据工程、万众创新大数据工程、大数据关键技术及产品研发与产业化工程、大数据产业支撑能力提升工程、网络和大数据安全保障工程。根据纲要，到2020年，我国将形成一批具有国际竞争力的大数据处理、分析、可视化软件和硬件支撑平台等产品;并且培育10家国际领先的大数据核心龙头企业，500家大数据应用、服务和产品制造企业。值得一提的是，在发展工业大数据方面，《行动纲要》指出，将推动大数据在工业研发设计、生产制造、经营管理、市场营销、售后服务等产品全生命周期、产业链全流程各环节的应用，分析感知用户需求，提升产品附加价值，打造智能工厂。建立面向不同行业、不同环节的工业大数据资源聚合和分析应用平台。抓住互联网跨界融合机遇，促进大数据、物联网、云计算和三维(3D)打印技术、个性化定制等在制造业全产业链集成运用，推动制造模式变革和工业转型升级。另外，在发展万众创新大数据方面，《行动纲要》表示，适应国家创新驱动发展战略，实施大数据创新行动计划，鼓励企业和公众发掘利用开放数据资源，激发创新创业活力，促进创新链和产业链深度融合，推动大数据发展与科研创新有机结合，形成大数据驱动型的科研创新模式，打通科技创新和经济社会发展之间的通道，推动万众创新、开放创新和联动创新。记者了解到，当前，运用大数据推动经济发展、完善社会治理、提升政府服务和监管能力正成为趋势，应用深度和广度正在不断加深扩大，但仍然面临基础研究和核心技术有待攻克等问题。对此，《行动纲要》表示将围绕数据科学理论体系、大数据计算系统与分析理论、大数据驱动的颠覆性应用模型探索等重大基础研究进行前瞻布局，开展数据科学研究，引导和鼓励在大数据理论、方法及关键应用技术等方面展开探索。采取政产学研用相结合的协同创新模式和基于开源社区的开放创新模式，加强海量数据存储、数据清洗、数据分析发掘、数据可视化、信息安全与隐私保护等领域关键技术攻关，形成安全可靠的大数据技术体系。支持自然语言理解、机器学习、深度学习等人工智能技术创新，提升数据分析处理能力、知识发现能力和辅助决策能力。,2015/9/6
194,编写高质量的代码，从命名入手,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9099,要写高质量的代码，不是一件容易的事，需要长年累月的锻炼，是一个量变到质变的过程，但要写好命名，只需要有比较好的英语语法基础和一种自我意识即可轻松达到。本博文将会结合本人的开发经验，总结出若干命名规则，这些命名规则纯属个人的使用习惯，不代表是一种理想的规则，在这里列举出来，供大家交流讨论。1.切忌使用没有任何意义的英语字母进行命名for(inti=0;i<10;i++){...}这是在很多教Java基本语法的书上常见的代码片断，作为教学材料，这样写无可厚非，但作为真正的代码编写，程序员必须要养成良好的习惯，不要使用这种没有任何含义的命名方式，这里可以使用“index”。2.切忌使用拼音，甚至是拼音首字母组合cishu=5;//循环的次数zzje=1000.00//转账金额笔者在做代码检查的时候，无数次遇到过这样的命名，使人哭笑不得3.要使用英文，而且要使用准确的英语，无论是拼写还是语法名词单数，必须使用单数英文，如Account、Customer。对于数组，列表等对象集合的命名，必须使用复数，而且最好按照英文的语法基础知识使用准确的复数形式，如List<Account>accounts、Set<Strategy>strategies。对于boolean值的属性，很多开发人员习惯使用isXXX，如isClose（是否关闭），但这里有两点建议：1）最好不要带“is”，因为JavaBean的规范，为属性生成get/set方法的时候，会用“get/set/is”，上面的例子，生成get/set方法就会变成“getIsClose/isIsClose/getIsClose”，非常别扭；2）由于boolean值通常反映“是否”，所以准确的用法，应该是是用“形容词”，上面的例子，最终应该被改为closed，那么get/set方法就是“getClosed/isColsed/setClosed”，非常符合英语阅读习惯。转载补充：推荐阅读《老码农教你学英语》、《老码农教你学英语：补充一些英语学习素材》。4.方法名的命名，需要使用“动宾结构短语”或“是动词+表语结构短语”笔者曾看到过千奇百怪的方法命名，有些使用名词，有些甚至是“名词+动词”，而且，如果宾语是一个对象集合，还是最好使用复数：createOrder(Orderorder)//goodorderCreate(Orderorder)//badremoveOrders(List<Order>orders)//goodremoveOrder(List<Order>order)//bad5.对于常见的“增删改查”方法，命名最好要谨慎：增加：最常见使用create和add，但最好根据英语的语义进行区分，这有助于理解，create代表创建，add代表增加。比如，要创建一个Student，用createStudent要比用addStudent好，为什么？想想如果有个类叫Clazz(班级，避开Java关键字），现在要把一个Student加入到一个Clazz，Clazz很容易就定义了一个addStudent（Studentstudent)的方法，那么就比较容易混淆。修改：常见的有alter、update、modify，个人觉得modify最准确。查询：对于获取单个对象，可以用get或load，但个人建议用get，解释请见第7点的说明，对于不分条件列举，用list，对于有条件查询，用search（最好不要用find，find在英文了强调结果，是“找到”的意思，你提供一个“查询”方法，不保证输入的条件总能“找到”结果）。删除：常见的有delete和remove，但删除建议用delete，因为remove有“移除”的意思，参考Clazz的例子就可以理解，从班级移除一个学生，会用removeStudent。6.宁愿方法名冗长，也不要使用让人费解的简写笔者曾经遇到一个方法，判断“支付账户是否与收款账户相同”，结果我看到一个这样的命名：checkIsOrderingAccCollAccSame(...)//很难理解，我马上把它改为：isOrderingAccountSameAsCollectionAccount(...)//虽然有点长，但非常容易阅读，而且这种情况总是出现得比较少。7.如果你在设计业务系统，最好不要使用技术化的术语去命名笔者曾经工作的公司曾经制订这样的命名规则，接口必须要以“I”开头，数据传输对象必须以“DTO”作为后缀，数据访问对象必须以“DAO”作为后缀，领域对象必须以“DO”作为后缀，我之所以不建议这种做法，是希望设计人员从一开始就引导开发人员，要从“业务”出发考虑问题，而不要从“技术”出发。所以，接口不需要非得以“I”开头，只要其实现类以“Impl”结尾即可（注：笔者认为接口是与细节无关的，与技术无关，但实现类是实现相关的，用技术化术语无可口非），而数据传输对象，其实无非就是保存一个对象的信息，因此可以用“**Info”，如CustomerInfo，领域对象本身就是业务的核心，所以还是以其真实名称出现，比如Account、Customer，至于“DAO”，这一个词来源于J2ee的设计模式，笔者在之前的项目使用“***Repository”命名，意味“***的仓库”，如AccountRepository.关于“Repository”这个词的命名，是来源于EricEvans的《Domain-DrivenDesign》一书的仓库概念，EricEvans对Repository的概念定义是：领域对象的概念性集合，个人认为这个命名非常的贴切，它让程序员完全从技术的思维中摆脱出来，站在业务的角度思考问题。说到这里，可能有人会反驳：像Spring、Hibernate这些优秀的框架，不是都在用“I”作为接口开头，用“DAO”来命名数据访问对象吗？没错！但千万别忽略了语义的上下文，Spring、Hibernate框架都是纯技术框架，我这里所说的场景是设计业务系统。8.成员变量不要重复类的名称例如，很多人喜欢在Account对象的成员变量中使用accountId，accountNumber等命名，其实没有必要，想想成员变量不会鼓孤立的存在，你引用accountId，必须是account.accountId，用account.id已经足够清晰了。“勿以善小而不为，勿以恶小而为之”、“细节决定成败”，有太多的名言告诉我们，要注重细节。一个优秀的程序员，必须要有坚实的基础，而对于命名规则这样容易掌握的基础，我们何不现行？,2015/8/30
195,Java 日志管理最佳实践,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9098,"日志记录是应用程序运行中必不可少的一部分。具有良好格式和完备信息的日志记录可以在程序出现问题时帮助开发人员迅速地定位错误的根源。对于开发人员来说，在程序中使用日志API记录日志并不复杂，不过遵循一些最佳实践可以更好的利用日志。本文介绍了在Java程序中记录日志的最佳实践，同时也介绍了如何使用开源软件对日志进行聚合和分析。概述对于现在的应用程序来说，日志的重要性是不言而喻的。很难想象没有任何日志记录功能的应用程序运行在生产环境中。日志所能提供的功能是多种多样的，包括记录程序运行时产生的错误信息、状态信息、调试信息和执行时间信息等。在生产环境中，日志是查找问题来源的重要依据。应用程序运行时的产生的各种信息，都应该通过日志API来进行记录。很多开发人员习惯于使用System.out.println、System.err.println以及异常对象的printStrackTrace方法来输出相关信息。这些使用方式虽然简便，但是所产生的信息在出现问题时并不能提供有效的帮助。这些使用方式都应该改为使用日志API。使用日志API并没有增加很多复杂度，但是所提供的好处是显著的。尽管记录日志是应用开发中并不可少的功能，在JDK的最初版本中并不包含日志记录相关的API和实现。相关的API（java.util.logging包，JUL）和实现，直到JDK1.4才被加入。因此在日志记录这一个领域，社区贡献了很多开源的实现。其中比较流行的包括log4j及其后继者logback。除了真正的日志记录实现之外，还有一类与日志记录相关的封装API，如ApacheCommonsLogging和SLF4J。这类库的作用是在日志记录实现的基础上提供一个封装的API层次，对日志记录API的使用者提供一个统一的接口，使得可以自由切换不同的日志记录实现。比如从JDK的默认日志记录实现JUL切换到log4j。这类封装API库在框架的实现中比较常用，因为需要考虑到框架使用者的不同需求。在实际的项目开发中则使用得比较少，因为很少有项目会在开发中切换不同的日志记录实现。本文对于这两类库都会进行具体的介绍。记录日志只是有效地利用日志的第一步，更重要的是如何对程序运行时产生的日志进行处理和分析。典型的情景包括当日志中包含满足特定条件的记录时，触发相应的通知机制，比如邮件或短信通知；还可以在程序运行出现错误时，快速地定位潜在的问题源。这样的处理和分析的能力对于实际系统的维护尤其重要。当运行系统中包含的组件过多时，日志对于错误的诊断就显得格外重要。本文首先介绍关于日志API的基本内容。Java日志API从功能上来说，日志API本身所需求的功能非常简单，只需要能够记录一段文本即可。API的使用者在需要进行记录时，根据当前的上下文信息构造出相应的文本信息，调用API完成记录。一般来说，日志API由下面几个部分组成：记录器（Logger）：日志API的使用者通过记录器来发出日志记录请求，并提供日志的内容。在记录日志时，需要指定日志的严重性级别。格式化器（Formatter）：对记录器所记录的文本进行格式化，并添加额外的元数据。处理器（Handler）：把经过格式化之后的日志记录输出到不同的地方。常见的日志输出目标包括控制台、文件和数据库等。记录器当程序中需要记录日志时，首先需要获取一个日志记录器对象。一般的日志记录API都提供相应的工厂方法来创建记录器对象。每个记录器对象都是有名称的。一般的做法是使用当前的Java类的名称或所在包的名称作为记录器对象的名称。记录器的名称通常是具有层次结构的，与Java包的层次结构相对应。比如Java类“com.myapp.web.IndexController”中使用的日志记录器的名称一般是“com.myapp.web.IndexController”或“com.myapp.web”。除了使用类名或包名之外，还可以根据日志记录所对应的功能来进行划分，从而选择不同的名称。比如用“security”作为所有与安全相关的日志记录器的名称。这样的命名方式对于某些横切的功能比较实用。开发人员一般习惯于使用当前的类名作为日志记录器的名称，这样可以快速在日志记录中定位到产生日志的Java类。使用有意义的其他名称在很多情况下也是一个不错的选择。在通过日志记录器对象记录日志时，需要指定日志的严重性级别。根据每个记录器对象的不同配置，低于某个级别的日志消息可能不会被记录下来。该级别是日志API的使用者根据日志记录中所包含的信息来自行决定的。不同的日志记录API所定义的级别也不尽相同。日志记录封装API也会定义自己的级别并映射到底层实现中相对应的实际级别。比如JDK标准的日志API使用的级别包括OFF、SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST和ALL等，Log4j使用的级别则包括OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE和ALL等。一般情况下，使用得比较多的级别是FATAL、ERROR、WARN、INFO、DEBUG和TRACE等。这6个级别所对应的情况也有所不同：FATAL：导致程序提前结束的严重错误。ERROR：运行时异常以及预期之外的错误。WARN：预期之外的运行时状况，不一定是错误的情况。INFO：运行时产生的事件。DEBUG：与程序运行时的流程相关的详细信息。TRACE：更加具体的详细信息。在这6个级别中，以ERROR、WARN、INFO和DEBUG作为常用。日志记录API的使用者通过记录器来记录日志消息。日志消息在记录下来之后只能以文本的形式保存。不过有的实现（如Log4j）允许在记录日志时使用任何Java对象。非String类型的对象会被转换成String类型。由于日志记录通常在出现异常时使用，记录器在记录消息时可以把产生的异常（Throwable类的对象）也记录下来。每个记录器对象都有一个运行时对应的严重性级别。该级别可以通过配置文件或代码的方式来进行设置。如果没有显式指定严重性级别，则会根据记录器名称的层次结构关系往上进行查找，直到找到一个设置了严重性级别的名称为止。比如名称为“com.myapp.web.IndexController”的记录器对象，如果没有显式指定其严重性级别，则会依次查找是否有为名称“com.myapp.web”、“com.myapp”和“com”指定的严重性级别。如果仍然没有找到，则使用根记录器配置的值。通过记录器对象来记录日志时，只是发出一个日志记录请求。该请求是否会完成取决于请求和记录器对象的严重性级别。记录器使用者产生的低于记录器对象严重性级别的日志消息不会被记录下来。这样的记录请求会被忽略。除了基于严重性级别的过滤方式之外，日志记录框架还支持其他自定义的过滤方式。比如JUL可以通过实现java.util.logging.Filter接口的方式来进行过滤。Log4j可以通过继承org.apache.log4j.spi.Filter类的方式来过滤。格式化器实际记录的日志中除了使用记录器对象时提供的消息之外，还包括一些元数据。这些元数据由日志记录框架来提供。常用的信息包括记录器的名称、时间戳、线程名等。格式化器用来确定所有这些信息在日志记录中的展示方式。不同的日志记录实现提供各自默认的格式化方式和自定义支持。JUL中通过继承java.util.logging.Formatter类来自定义格式化的方式，并提供了两个标准实现SimpleFormatter类和XMLFormatter类。清单1中给出了JUL中自定义格式化器的实现方式，只需要继承自Formatter类并实现format方法即可。参数LogRecord类的对象中包含了日志记录中的全部信息。清单1.JUL中自定义格式化器的实现publicclassCustomFormatterextendsFormatter{publicStringformat(LogRecordrecord){returnString.format(""<%s>[%s]:%s"",newDate(record.getMillis()),record.getLoggerName(),record.getMessage());}}对于自定义的格式化器类，需要在JUL的配置文件中进行指定，如清单2所示。清单2.在JUL配置文件中指定自定义的格式化器类java.util.logging.ConsoleHandler.formatter=logging.jul.CustomFormatterLog4j在格式化器的实现上要简单一些，由org.apache.log4j.PatternLayout类来负责完成日志记录的格式化。在自定义时不需要创建新的Java类，而是通过配置文件指定所需的格式化模式。在格式化模式中，不同的占位符表示不同类型的信息。比如“%c”表示记录器的名称，“%d”表示日期，“%m”表示日志的消息文本，“%p”表示严重性级别，“%t”表示线程的名称。清单3给出了Log4j配置文件中日志记录的自定义方式。清单3.Log4j中日志记录的自定义方式log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-ddHH:mm:ss}[%p]%c-%m%n日志处理器日志记录经过格式化之后，由不同的处理器来进行处理。不同的处理器有各自不同的处理方式。比如控制台处理器会把日志输出到控制台中，文件处理器把日志写入到文件中。除了这些之外，还有写入到数据库、通过邮件发送、写入到JMS队列等各种不同的处理方式。日志处理器也可以配置所处理日志信息的最低严重性级别。低于该级别的日志不会被处理。这样可以控制所处理的日志记录数量。比如控制台处理器的级别一般设置为INFO，而文件处理器则一般设置为DEBUG。日志记录框架一般提供了比较多的日志处理器实现。开发人员也可以创建自定义的实现。Java日志封装API除了JUL和log4j这样的日志记录库之外，还有一类库用来封装不同的日志记录库。这样的封装库中一开始以ApacheCommonsLogging框架最为流行，现在比较流行的是SLF4J。这样封装库的API都比较简单，只是在日志记录库的API基础上做了一层简单的封装，屏蔽不同实现之间的区别。由于日志记录实现所提供的API大致上比较相似，封装库的作用更多的是达到语法上的一致性。在ApacheCommonsLogging库中，核心的API是org.apache.commons.logging.LogFactory类和org.apache.commons.logging.Log接口。LogFactory类提供了工厂方法用来创建Log接口的实现对象。比如LogFactory.getLog可以根据Java类或名称来创建Log接口的实现对象。Log接口中为6个不同的严重性级别分别定义了一组方法。比如对DEBUG级别，定义了isDebugEnabled()、debug(Objectmessage)和debug(Objectmessage,Throwablet)三个方法。从这个层次来说，Log接口简化了对于日志记录器的使用。SLF4J库的使用方式与ApacheCommonsLogging库比较类似。SLF4J库中核心的API是提供工厂方法的org.slf4j.LoggerFactory类和记录日志的org.slf4j.Logger接口。通过LoggerFactory类的getLogger方法来获取日志记录器对象。与ApacheCommonsLogging库中的Log接口类似，Logger接口中的方法也是按照不同的严重性级别来进行分组的。Logger接口中有同样isDebugEnabled方法。不过Logger接口中发出日志记录请求的debug等方法使用String类型来表示消息，同时可以使用包含参数的消息，如清单4所示。清单4.SLF4J的使用方式publicclassSlf4jBasic{privatestaticfinalLoggerLOGGER=LoggerFactory.getLogger(Slf4jBasic.class);publicvoidlogBasic(){if(LOGGER.isInfoEnabled()){LOGGER.info(""Mylogmessagefor%s"",""Alex"");}}}MDCMDC（MappedDiagnosticContext，映射调试上下文）是log4j和logback提供的一种方便在多线程条件下记录日志的功能。某些应用程序采用多线程的方式来处理多个用户的请求。在一个用户的使用过程中，可能有多个不同的线程来进行处理。典型的例子是Web应用服务器。当用户访问某个页面时，应用服务器可能会创建一个新的线程来处理该请求，也可能从线程池中复用已有的线程。在一个用户的会话存续期间，可能有多个线程处理过该用户的请求。这使得比较难以区分不同用户所对应的日志。当需要追踪某个用户在系统中的相关日志记录时，就会变得很麻烦。一种解决的办法是采用自定义的日志格式，把用户的信息采用某种方式编码在日志记录中。这种方式的问题在于要求在每个使用日志记录器的类中，都可以访问到用户相关的信息。这样才可能在记录日志时使用。这样的条件通常是比较难以满足的。MDC的作用是解决这个问题。MDC可以看成是一个与当前线程绑定的哈希表，可以往其中添加键值对。MDC中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的MDC的内容。当需要记录日志时，只需要从MDC中获取所需的信息即可。MDC的内容则由程序在适当的时候保存进去。对于一个Web应用来说，通常是在请求被处理的最开始保存这些数据。清单5中给出了MDC的使用示例。清单5.MDC使用示例publicclassMdcSample{privatestaticfinalLoggerLOGGER=Logger.getLogger(""mdc"");publicvoidlog(){MDC.put(""username"",""Alex"");if(LOGGER.isInfoEnabled()){LOGGER.info(""Thisisamessage."");}}}清单5中，在记录日志前，首先在MDC中保存了名称为“username”的数据。其中包含的数据可以在格式化日志记录时直接引用，如清单6所示，“%X{username}”表示引用MDC中“username”的值。清单6.使用MDC中记录的数据log4j.appender.stdout.layout.ConversionPattern=%X{username}%d{yyyy-MM-ddHH:mm:ss}[%p]%c-%m%n日志记录最佳实践下面主要介绍一些在记录日志时的比较好的实践。检查日志是否可以被记录当日志记录器收到一个日志记录请求时，如果请求的严重性级别低于记录器对象的实际有效级别，则该请求会被忽略。在日志记录方法的实现中会首先进行这样的检查。不过推荐的做法是在调用API进行记录之前，首先进行相应的检查，这样可以避免不必要的性能问题，如清单7所示。清单7.检查日志是否可以被记录if(LOGGER.isDebugEnabled()){LOGGER.debug(""Thisisamessage."");}清单7中的做法的作用在于避免了构造日志记录消息所带来的开销。日志消息中通常包含与当前上下文相关的信息。为了获取这些信息并构造相应的消息文本，不可避免会产生额外的开销。尤其对于DEBUG和TRACE级别的日志消息来说，它们所出现的频率很高，累加起来的开销比较大。因此在记录INFO、DEBUG和TRACE级别的日志时，首先进行相应的检查是一个好的实践。而WARN及其以上级别的日志则一般不需要进行检查。日志中包含充分的信息日志中所包含的信息应该是充分的。在记录日志消息时应该尽可能多的包含当前上下文中的各种信息，以方便在遇到问题时可以快速的获取到所需的信息。比如在网上支付功能中，与支付相关的日志应该完整的包含当前用户、订单以及支付方式等全部信息。一种比较常见的做法是把相关的日志记录分散在由不同日志记录器所记录的日志中。当出现问题之后，需要手工查找并匹配相关的日志来定位问题，所花费的时间和精力会更多。因此，应该尽可能在一条日志记录中包含足够多的信息。使用合适的日志记录器名称一般的日志记录实践是使用当前Java类的全名作为其使用的日志记录器的名称。这样做可以得到一个与Java类和包的层次结构相对应的日志记录器的层次结构。可以很方便的按照不同的模块来设置相应的日志记录级别。不过对于某些全局的或是横切的功能，如安全和性能等，则推荐使用功能相关的名称。比如程序中可能包含用来提供性能剖析信息的日志记录。对于这样的日志记录，应该使用同一名称的日志记录器，如类似“performance”或“performance.web”。这样当需要启用和禁用性能剖析时，只需要配置这些名称的记录器即可。使用半结构化的日志消息在介绍日志记录API中的格式化器时提到过，日志记录中除了基本的日志消息之外，还包括由日志框架提供的其他元数据。这些数据按照给定的格式出现在日志记录中。这些半结构化的格式使得可以通过工具提取日志记录中的相关信息进行分析。在使用日志API进行记录时，对于日志消息本身，也推荐使用半结构化的方式来组织。比如一个电子商务的网站，当用户登录之后，该用户所产生的不同操作所对应的日志记录中都可以包含该用户的用户名，并以固定的格式出现在日志记录中，如清单8所示。清单8.使用半结构化的日志消息[user1]用户登录成功。[user1]用户成功购买产品A。[user2]订单003付款失败。当需要通过日志记录来排查某个用户所遇到的问题时，只需要通过正则表达就可以很快地查询到用户相关的日志记录。日志聚合与分析在程序中正确的地方输出合适的日志消息，只是合理使用日志的第一步。日志记录的真正作用在于当有问题发生时，能够帮助开发人员很快的定位问题所在。不过一个实用的系统通常由很多个不同的部分组成。这其中包括所开发的程序本身，也包括所依赖的第三方应用程序。以一个典型的电子商务网站为例，除了程序本身，还包括所依赖的底层操作系统、应用服务器、数据库、HTTP服务器和代理服务器和缓存等。当一个问题发生时，真正的原因可能来自程序本身，也可能来自所依赖的第三方程序。这就意味着开发人员可能需要检查不同服务器上不同应用程序的日志来确定真正的原因。日志聚合的作用就在于可以把来自不同服务器上不同应用程序产生的日志聚合起来，存放在单一的服务器上，方便进行搜索和分析。在日志聚合方面，已经有不少成熟的开源软件可以很好的满足需求。本文中要介绍的是logstash，一个流行的事件和日志管理开源软件。logstash采用了一种简单的处理模式：输入->过滤器->输出。logstash可以作为代理程序安装到每台需要收集日志的机器上。logstash提供了非常多的插件来处理不同类型的数据输入。典型的包括控制台、文件和syslog等；对于输入的数据，可以使用过滤器来进行处理。典型的处理方式是把日志消息转换成结构化的字段；过滤之后的结果可以被输出到不同的目的地，比如ElasticSearch、文件、电子邮件和数据库等。Logstash在使用起来很简单。从官方网站下载jar包并运行即可。在运行时需要指定一个配置文件。配置文件中定义了输入、过滤器和输出的相关配置。清单9给出了一个简单的logstash配置文件的示例。清单9.logstash配置文件示例input{file{path=>[""/var/log/*.log"",""/var/log/messages"",""/var/log/syslog""]type=>'syslog'}}output{stdout{debug=>truedebug_format=>""json""}}清单9中定义了logstash收集日志时的输入（input）和输出（output）的相关配置。输入类型是文件（file）。每种类型输入都有相应的配置。对于文件来说，需要配置的是文件的路径。对每种类型的输入，都需要指定一个类型（type）。该类型用来区分来自不同输入的记录。代码中使用的输出是控制台。配置文件完成之后，通过“java-jarlogstash-1.1.13-flatjar.jaragent-flogstash-simple.conf”就可以启动logstash。在日志分析中，比较重要的是结构化的信息。而日志信息通常只是一段文本，其中的不同字段表示不同的含义。不同的应用程序产生的日志的格式并不相同。在分析时需要关注的是其中包含的不同字段。比如Apache服务器会产生与用户访问请求相关的日志。在日志中包含了访问者的各种信息，包括IP地址、时间、HTTP状态码、响应内容的长度和UserAgent字符串等信息。在logstash收集到日志信息之后，可以根据一定的规则把日志信息中包含的数据提取出来并命名。logstash提供了grok插件可以完成这样的功能。grok基于正则表达式来工作，同时提供了非常多的常用类型数据的提取模式，如清单10所示。清单10.使用grok提取日志记录中的内容//Apache访问日志49.50.214.136GET/index.html2001150""Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/537.17(KHTML,likeGecko)Chrome/24.0.1312.57Safari/537.17""//grok提取模式%{IP:client}%{WORD:method}%{URIPATHPARAM:request}%{NUMBER:status}%{NUMBER:bytes}%{QS:useragent}在经过上面grok插件的提取之后，Apache访问日志被转换成包含字段client、method、request、status、bytes和useragent的格式化数据。可以根据这些字段来进行搜索。这对于分析问题和进行统计都是很有帮助的。当日志记录通过logstash进行收集和处理之后，通常会把这些日志记录保存到数据库中进行分析和处理。目前比较流行的方式是保存到ElasticSearch中，从而可以利用ElasticSearch提供的索引和搜索能力来分析日志。已经有不少的开源软件在ElasticSearch基础之上开发出相应的日志管理功能，可以很方便的进行搜索和分析。本文中介绍的是Graylog2。Graylog2由服务器和Web界面两部分组成。服务器负责接收日志记录并保存到ElasticSearch之中。Web界面则可以查看和搜索日志，并提供其他的辅助功能。logstash提供了插件gelf，可以把logstash收集和处理过的日志记录发送到Graylog2的服务器。这样就可以利用Graylog2的Web界面来进行查询和分析。只需要把清单9中的logstash的配置文件中的output部分改成清单11中所示即可。清单11.配置logstash输出到Graylog2output{gelf{host=>'127.0.0.1'}}在安装Graylog2时需要注意，一定要安装与Graylog2的版本相对应的版本的ElasticSearch，否则会出现日志记录无法保存到ElasticSearch的问题。本文中使用的是Graylog2服务器0.11.0版本和ElasticSearch0.20.4版本。除了Graylog2之外，另外一个开源软件Kibana也比较流行。Kibana可以看成是logstash和ElasticSearch的Web界面。Kibana提供了更加丰富的功能来显示和分析日志记录。与代码清单中的logstash的配置相似，只需要把输出改为elasticsearch就可以了。Kibana可以自动读取ElasticSearch中包含的日志记录并显示。小结日志记录是应用程序开发中的重要一环。不过这一环比较容易被开发人员忽视，因为它所产生的影响在程序运行和维护时。对于一个生产系统来说，日志记录的重要性是不言而喻的。本文首先以java.util.logging包和log4j为例介绍了Java日志API的主要组成部分和使用方式，同时也介绍了ApacheCommonsLogging和SLF4J两种日志封装API。本文也给出了一些记录日志时应该采用的最佳实践。最后介绍了如何使用开源工具对日志进行聚合和分析。通过本文，开发人员可以了解如何在开发中有效的使用日志。",2015/8/30
196,AS3 PerspectiveProjection,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9097,"利用PerspectiveProjection类，可以轻松分配或修改显示对象及其所有子级的透视转换。对于更加复杂的或自定义的透视转换，请使用Matrix3D类。PerspectiveProjection类提供了基本的三维演示属性，而Matrix3D类提供了针对显示对象的三维演示的更细化的控制。投影是一种用于在二维空间内表示三维对象的方式，例如，投影到计算机屏幕上的立方体。透视投影使用视见平截头体（四棱锥）来建模并将三维世界及其对象投影到屏幕上。随着视见平截头体远离视点原点，它会变得越来越宽。视点原点可以是面向屏幕的摄像头或观察者的眼睛。投影透视会在深度和距离上产生三维错觉，其中接近屏幕的对象比远离屏幕的对象要大得多。默认的PerspectiveProjection对象是基于视野和舞台的高宽比（尺寸）为root对象的透视转换定义的框架。投影中心（即消失点）将设置为舞台中心，这意味着当三维显示对象沿z轴后移时，这些对象会朝着舞台中心消失。默认视点位于正向z轴向下的点(0,0)。y轴朝下指向屏幕底部。可以访问root显示对象的透视投影设置，并通过root对象的DisplayObject.transform属性来更改perspectiveProjection属性的视野和投影中心属性。也可以通过父级透视投影为显示对象设置不同的透视投影设置。首先，创建一个PerspectiveProjection对象并将设置其fieldOfView和projectionCenter属性。紧接着，使用DisplayObject.transform属性将PerspectiveProjection对象分配给父级显示对象。然后，指定的投影矩阵和转换将应用于显示对象的所有三维子级。",2015/8/27
197,MonoBehaviour生命周期,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9096,"最先执行的方法是Awake，这是生命周期的开始，用于进行激活时的初始化代码，一般可以在这个地方将当前脚本禁用:this.enable=false，如果这样做了，则会直接跳转到OnDisable方法执行一次，然后其它的任何方法，都将不再被执行。如果当前脚本处于可用状态，则正常的执行顺序是继续向下执行OnEnable，当然我们可以在另外一个脚本中实现这个脚本组件的启动：this.enab=true;再向下执行，会进行一个判断，如果Start方法还没有被执行，则会被执行一次，如果已经被执行了，则不会再被执行。这是个什么意思呢？我们可以在某个脚本中将组件禁用this.enable=false，再启用时会转到OnEnable处执行，这时继续向下走，发现Start执行过了，将不再被执行。比如说：第一次启用时，将怪物的初始位置定在了(0,0,0)点，然后怪物可能会发生了位置的变换，后来被禁用了，再次启用时，不会让怪物又回到初始的(0,0,0)位置。继续向后执行，就是FixUpdate了，然后是Update，再然后是LateUpdate，如果后面写了Reset，则会又回到Update，在这4个事件间可以进行循环流动。再向后执行，就进入了渲染模块（Rendering），非常重要的一个方法就是OnGUI，用于绘制图形界面。当然，如果你使用了NGUI，这个生命周期的事情你就不用考虑了。再向后，就是卸载模块（TearDown），这里主要有两个方法OnDisable与OnDestroy。当被禁用(enable=false)时，会执行OnDisable方法，但是这个时候，脚本并不会被销毁，在这个状态下，可以重新回到OnEnable状态（enable=true）。当手动销毁或附属的游戏对象被销毁时，OnDestroy才会被执行，当前脚本的生命周期结束。",2015/8/24
198,颜色喜好统计,康廷,http://180.168.156.212:2262/wecenter/?/article/9095,,2015/8/6
199,Coral toolbar 使用指南,李海波,http://180.168.156.212:2262/wecenter/?/article/9094,如附件。平台研发部-李海波-经验分享-20150727-f.zip,2015/8/3
200,Java并发教程,陆开奇,http://180.168.156.212:2262/wecenter/?/article/9093,"计算机的使用者一直以为他们的计算机可以同时做很多事情。他们认为当其他的应用程序在下载文件，管理打印队列或者缓冲音频的时候他们可以继续在文字处理程序上工作。甚至对于单个应用程序，他们任然期待它能在在同一时间做很多事情。举个例子，一个流媒体播放程序必须能同时完成以下工作：从网络上读取数字音频，解压缩数字音频，管理播放和更新程序显示。甚至文字处理器也应该能在忙于重新格式化文本和刷新显示的情况下同时响应键盘和鼠标事件。这样的软件就被称为并发软件。通过Java语言和Java类库对于基础并发的支持，Java平台具有完全（fromthegroundup）支持并发编程的能力。从JDK5.0起，Java平台还引入了高级并发APIs。这个课程不仅涵盖了Java平台基础并发内容，还对高级并发APIs有一定的阐述。目录[-]进程和线程线程对象同步活跃度保护块（GuardedBlocks）不可变对象高级并发对象进程和线程（本部分原文链接，译文链接，译者：bjsuo，校对：郑旭东）在并发编程中，有两个基本的执行单元：进程和线程。在java语言中，并发编程最关心的是线程，然而，进程也是非常重要的。即使在只有单一的执行核心的计算机系统中，也有许多活动的进程和线程。因此，在任何给定的时刻，只有一个线程在实际执行。处理器的处理时间是通过操作系统的时间片在进程和线程中共享的。现在具有多处理器或有多个执行内核的多处理器的计算机系统越来越普遍，这大大增强了系统并发执行的进程和线程的吞吐量–但在不没有多个处理器或执行内核的简单的系统中，并发任然是可能的。进程进程具有一个独立的执行环境。通常情况下，进程拥有一个完整的、私有的基本运行资源集合。特别地，每个进程都有自己的内存空间。进程往往被看作是程序或应用的代名词，然而，用户看到的一个单独的应用程序实际上可能是一组相互协作的进程集合。为了便于进程之间的通信，大多数操作系统都支持进程间通信（IPC），如pipes和sockets。IPC不仅支持同一系统上的通信，也支持不同的系统。Java虚拟机的大多数实现是单进程的。Java应用可以使用的ProcessBuilder对象创建额外的进程，多进程应用超出了本课的范围。线程线程有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。线程是在进程中存在的—每个进程最少有一个线程。线程共享进程的资源，包括内存和打开的文件。这样提高了效率，但潜在的问题就是线程间的通信。多线程的执行是Java平台的一个基本特征。每个应用都至少有一个线程–或几个，如果算上“系统”线程的话，比如内存管理和信号处理等。但是从程序员的角度来看，启动的只有一个线程，叫主线程。这个线程有能力创建额外的线程，我们将在下一节演示。线程对象（本部分原文链接，译文链接，译者：郑旭东）在Java中，每个线程都是Thread类的实例。并发应用中一般有两种不同的线程创建策略。直接控制线程的创建和管理，每当应用程序需要执行一个异步任务的时候就为其创建一个线程将线程的管理从应用程序中抽象出来作为执行器，应用程序将任务传递给执行器，有执行器负责执行。这一节，我们将讨论Thread对象，有关Executors将在高级并发对象一节中讨论。定义并启动一个线程应用程序在创建一个线程实例时，必须提供需要在线程中运行的代码。有两种方式去做到这一点：提供一个Runnable对象。Runnable对象仅包含一个run()方法，在这个方法中定义的代码将在会线程中执行。将Runnable对象传递给Thread类的构造函数即可，如下面这个HelloRunnable的例子：Java代码publicclassHelloRunnableimplementsRunnable{publicvoidrun(){System.out.println(""Hellofromathread!"");}publicstaticvoidmain(Stringargs[]){(newThread(newHelloRunnable())).start();}}继承Thread类。Thread类自身已实现了Runnable接口，但它的run()方法中并没有定义任何代码。应用程序可以继承与Thread类，并复写run()方法。如例子HelloThreadJava代码publicclassHelloThreadextendsThread{publicvoidrun(){System.out.println(""Hellofromathread!"");}publicstaticvoidmain(Stringargs[]){(newHelloThread()).start();}}需要注意的是，上述两个例子都需要调用Thread.start()方法来启动一个新的线程。哪一种方式是我们应该使用的？相对来说，第一种更加通用，因为Runnable对象可以继承于其他类（Java只支持单继承，当一个类继承与Thread类后，就无法继承与其他类）。第二种方法更易于在简单的应用程序中使用，但它的局限就是：你的任务类必须是Thread的子类。这个课程更加聚焦于第一种将Runnable任务和Thread类分离的方式。不仅仅是因为这种方式更加灵活，更因为它更适合后面将要介绍的高级线程管理API。Thread类定义了一些对线程管理十分有用的的方法。在这些方法中，有一些静态方法可以给当前线程调用，它们可以提供一些有关线程的信息，或者影响线程的状态。而其他一些方法可以由其他线程进行调用，用于管理线程和Thread对象。我们将在下面的章节中，深入探讨这些内容。使用Sleep方法暂停一个线程使用Thread.sleep()方法可以暂停当前线程一段时间。这是一种使处理器时间可以被其他线程或者运用程序使用的有效方式。sleep()方法还可以用于调整线程执行节奏（见下面的例子）和等待其他有执行时间需求的线程（这个例子将在下一节演示）。在Thread中有两个不同的sleep()方法，一个使用毫秒表示休眠的时间，而另一个是用纳秒。由于操作系统的限制休眠时间并不能保证十分精确。休眠周期可以被interrups所终止，我们将在后面看到这样的例子。不管在任何情况下，我们都不应该假定调用了sleep()方法就可以将一个线程暂停一个十分精确的时间周期。SleepMessages程序为我们展示了使用sleep()方法每四秒打印一个信息的例子Java代码publicclassSleepMessages{publicstaticvoidmain(Stringargs[])throwsInterruptedException{StringimportantInfo[]={""Mareseatoats"",""Doeseatoats"",""Littlelambseativy"",""Akidwilleativytoo""};for(inti=0;i<importantInfo.length;i++){//Pausefor4secondsThread.sleep(4000);//PrintamessageSystem.out.println(importantInfo[i]);}}}main()方法声明了它有可能抛出InterruptedException。当其他线程中断当前线程时，sleep()方法就会抛出该异常。由于这个应用程序并没有定义其他的线程，所以并不用关心如何处理该异常。中断（Interrupts）中断是给线程的一个指示，告诉它应该停止正在做的事并去做其他事情。一个线程究竟要怎么响应中断请求取决于程序员，不过让其终止是很普遍的做法。这是本文重点强调的用法。一个线程通过调用对被中断线程的Thread对象的interrupt()方法，发送中断信号。为了让中断机制正常工作，被中断的线程必须支持它自己的中断（即要自己处理中断）中断支持线程如何支持自身的中断？这取决于它当前正在做什么。如果线程正在频繁调用会抛InterruptedException异常的方法，在捕获异常之后，它只是从run()方法中返回。例如，假设在SleepMessages的例子中，关键的消息循环在线程的Runnable对象的run方法中，代码可能会被修改成下面这样以支持中断：Java代码for(inti=0;i<importantInfo.length;i++){//Pausefor4secondstry{Thread.sleep(4000);}catch(InterruptedExceptione){//We'vebeeninterrupted:nomoremessages.return;}//PrintamessageSystem.out.println(importantInfo[i]);}许多会抛InterruptedException异常的方法(如sleep()），被设计成接收到中断后取消它们当前的操作，并在立即返回。如果一个线程长时间运行而不调用会抛InterruptedException异常的方法会怎样？那它必须周期性地调用Thread.interrupted()方法，该方法在接收到中断请求后返回true。例如：Java代码for(inti=0;i<inputs.length;i++){heavyCrunch(inputs[i]);if(Thread.interrupted()){//We'vebeeninterrupted:nomorecrunching.return;}}在这个简单的例子中，代码只是检测中断，并在收到中断后退出线程。在更复杂的应用中，抛出一个InterruptedException异常可能更有意义。Java代码if(Thread.interrupted()){thrownewInterruptedException();}这使得中断处理代码能集中在catch语句中。中断状态标记中断机制通过使用称为中断状态的内部标记来实现。调用Thread.interrupt()设置这个标记。当线程通过调用静态方法Thread.interrupted()检测中断时，中断状态会被清除。非静态的isInterrupted()方法被线程用来检测其他线程的中断状态，不改变中断状态标记。按照惯例，任何通过抛出一个InterruptedException异常退出的方法，当抛该异常时会清除中断状态。不过，通过其他的线程调用interrupt()方法，中断状态总是有可能会立即被重新设置。JoinsJoin()方法可以让一个线程等待另一个线程执行完成。若t是一个正在执行的Thread对象，Java代码t.join();将会使当前线程暂停执行并等待t执行完成。重载的join()方法可以让开发者自定义等待周期。然而，和sleep()方法一样join()方法依赖于操作系统的时间处理机制，你不能假定join()方法将会精确的等待你所定义的时长。如同sleep()方法，join()方法响应中断并在中断时抛出InterruptedException。一个简单的线程例子下面这个简单的例子将会把这一节的一些概念放到一起演示。SimpleThreads程序有两个线程组成，第一个是主线程，它从创建了一个线程并等待它执行完成。如果MessageLoop线程执行了太长时间，主线程将会将其中断。MessageLoop现场将会打印一系列的信息。如果中断在它打印完所有信息前发生，它将会打印一个特定的消息并退出。Java代码publicclassSimpleThreads{//Displayamessage,precededby//thenameofthecurrentthreadstaticvoidthreadMessage(Stringmessage){StringthreadName=Thread.currentThread().getName();System.out.format(""%s:%s%n"",threadName,message);}privatestaticclassMessageLoopimplementsRunnable{publicvoidrun(){StringimportantInfo[]={""Mareseatoats"",""Doeseatoats"",""Littlelambseativy"",""Akidwilleativytoo""};try{for(inti=0;i<importantInfo.length;i++){//Pausefor4secondsThread.sleep(4000);//PrintamessagethreadMessage(importantInfo[i]);}}catch(InterruptedExceptione){threadMessage(""Iwasn'tdone!"");}}}publicstaticvoidmain(Stringargs[])throwsInterruptedException{//Delay,inmillisecondsbefore//weinterruptMessageLoop//thread(defaultonehour).longpatience=1000*60*60;//Ifcommandlineargument//present,givespatience//inseconds.if(args.length>0){try{patience=Long.parseLong(args[0])*1000;}catch(NumberFormatExceptione){System.err.println(""Argumentmustbeaninteger."");System.exit(1);}}threadMessage(""StartingMessageLoopthread"");longstartTime=System.currentTimeMillis();Threadt=newThread(newMessageLoop());t.start();threadMessage(""WaitingforMessageLoopthreadtofinish"");//loopuntilMessageLoop//threadexitswhile(t.isAlive()){threadMessage(""Stillwaiting..."");//Waitmaximumof1second//forMessageLoopthread//tofinish.t.join(1000);if(((System.currentTimeMillis()-startTime)>patience)&&t.isAlive()){threadMessage(""Tiredofwaiting!"");t.interrupt();//Shouldn'tbelongnow//--waitindefinitelyt.join();}}threadMessage(""Finally!"");}}同步（本部分原文链接，译文链接，译者：蘑菇街-小宝，Greenster，李任校对：丁一，郑旭东，李任）线程间的通信主要是通过共享域和引用相同的对象。这种通信方式非常高效，不过可能会引发两种错误：线程干扰和内存一致性错误。防止这些错误发生的方法是同步。不过，同步会引起线程竞争，当两个或多个线程试图同时访问相同的资源，随之就导致Java运行时环境执行其中一个或多个线程比原先慢很多，甚至执行被挂起，这就出现了线程竞争。线程饥饿和活锁都属于线程竞争的范畴。关于线程竞争的更多信息可参考活跃度一节。本节内容包括以下这些主题：线程干扰讨论了当多个线程访问共享数据时错误是怎么发生的。内存一致性错误讨论了不一致的共享内存视图导致的错误。同步方法讨论了一种能有效防止线程干扰和内存一致性错误的常见做法。内部锁和同步讨论了更通用的同步方法，以及同步是如何基于内部锁实现的。原子访问讨论了不能被其他线程干扰的操作的总体思路。1.线程干扰下面这个简单的Counter类：Java代码classCounter{privateintc=0;publicvoidincrement(){c++;}publicvoiddecrement(){c--;}publicintvalue(){returnc;}}Counter类被设计成：每次调用increment()方法，c的值加1；每次调用decrement()方法，c的值减1。如果当同一个Counter对象被多个线程引用，线程间的干扰可能会使结果同我们预期的不一致。当两个运行在不同的线程中却作用在相同的数据上的操作交替执行时，就发生了线程干扰。这意味着这两个操作都由多个步骤组成，而步骤间的顺序产生了重叠。Counter类实例的操作会交替执行，这看起来似乎不太可能，因为c上的这两个操作都是单一而简单的语句。然而，即使一个简单的语句也会被虚拟机转换成多个步骤。我们不去深究虚拟机内部的详细执行步骤——理解c++这个单一的语句会被分解成3个步骤就足够了：获取当前c的值；对获取到的值加1；把递增后的值写回到c；语句c–也可以按同样的方式分解，除了第二步的操作是递减而不是递增。假设线程A调用increment()的同时线程B调用decrement().如果c的初始值为0，线程A和B之间的交替执行顺序可能是下面这样：线程A：获取c；线程B：获取c；线程A：对获取的值加1，结果为1；线程B：对获取的值减1，结果为-1；线程A：结果写回到c,c现在是1；线程B：结果写回到c,c现在是-1；线程A的结果因为被线程B覆盖而丢失了。这个交替执行的结果只是其中一种可能性。在不同的环境下，可能是线程B的结果丢失了，也可能是不会出任何问题。由于结果是不可预知的，所以线程干扰的bug很难检测和修复。2.内存一致性错误当不同的线程对相同的数据产生不一致的视图时会发生内存一致性错误。内存一致性错误的原因比较复杂，也超出了本教程的范围。不过幸运的是，一个程序员并不需要对这些原因有详细的了解。所需要的是避免它们的策略。避免内存一致性错误的关键是理解happens-before关系。这种关系只是确保一个特定语句的写内存操作对另外一个特定的语句可见。要说明这个问题，请参考下面的例子。假设定义和初始化了一个简单int字段：Java代码intcounter=0;这个counter字段被A，B两个线程共享。假设线程A对counter执行递增:Java代码counter++;然后，很快的，线程B输出counter:Java代码System.out.println(counter);如果这两个语句已经在同一个线程中被执行过，那么输出的值应该是“1”。不过如果这两个语句在不同的线程中分开执行，那输出的值很可能是“0”，因为无法保证线程A对counter的改动对线程B是可见的——除非我们在这两个语句之间已经建立了happens-before关系。有许多操作会建立happens-before关系。其中一个是同步，我们将在下面的章节中看到。我们已经见过两个建立happens-before关系的操作。当一条语句调用Thread.start方法时，和该语句有happens-before关系的每一条语句，跟新线程执行的每一条语句同样有happens-before关系。创建新线程之前的代码的执行结果对线新线程是可见的。当一个线程终止并且当导致另一个线程中Thread.join返回时，被终止的线程执行的所有语句和在join返回成功之后的所有语句间有happens-before关系。线程中代码的执行结果对执行join操作的线程是可见的。要查看建立happens-before关系的操作列表，请参阅java.util.concurrent包的摘要页面。3.同步方法Java编程语言提供两种同步方式：同步方法和同步语句。相对较复杂的同步语句将在下一节中介绍。本节主要关注同步方法。要让一个方法成为同步方法，只需要在方法声明中加上synchronized关键字：Java代码publicclassSynchronizedCounter{privateintc=0;publicsynchronizedvoidincrement(){c++;}publicsynchronizedvoiddecrement(){c--;}publicsynchronizedintvalue(){returnc;}}如果count是SynchronizedCounter类的实例，那么让这些方法成为同步方法有两个作用:首先，相同对象上的同步方法的两次调用，它们要交替执行是不可能的。当一个线程正在执行对象的同步方法时，所有其他调用该对象同步方法的线程会被阻塞（挂起执行）,直到第一个线程处理完该对象。其次，当一个同步方法退出时，它会自动跟该对象同步方法的任意后续调用建立起一种happens-before关系。这确保对象状态的改变对所有线程是可见的。注意构造方法不能是同步的——构造方法加synchronized关键字会报语法错误。同步的构造方法没有意义，因为当这个对象被创建的时候，只有创建对象的线程能访问它。警告：当创建的对象会被多个线程共享时必须非常小心，对象的引用不要过早“暴露”出去。比如，假设你要维护一个叫instances的List，它包含类的每一个实例对象。你可能会尝试在构造方法中加这样一行：Java代码instances.add(this);不过其他线程就能够在对象构造完成之前使用instances访问对象。同步(synchronized)方法使用一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，对象域上的所有读写操作都是通过synchronized方法来完成的。（一个重要的例外：final域，在对象被创建后不可修改,能被非synchronized方法安全的读取）。synchronized同步策略很有效，不过会引起活跃度问题，我们将在本节后面看到。4.内部锁与同步同步机制的建立是基于其内部一个叫内部锁或者监视锁的实体。（在JavaAPI规范中通常被称为监视器。）内部锁在同步机制中起到两方面的作用：对一个对象的排他性访问；建立一种happens-before关系，而这种关系正是可见性问题的关键所在。每个对象都有一个与之关联的内部锁。通常当一个线程需要排他性的访问一个对象的域时，首先需要请求该对象的内部锁，当访问结束时释放内部锁。在线程获得内部锁到释放内部锁的这段时间里，我们说线程拥有这个内部锁。那么当一个线程拥有一个内部锁时，其他线程将无法获得该内部锁。其他线程如果去尝试获得该内部锁，则会被阻塞。当线程释放一个内部锁时，该操作和对该锁的后续请求间将建立happens-before关系。5.同步方法中的锁当线程调用一个同步方法时，它会自动请求该方法所在对象的内部锁。当方法返回结束时则自动释放该内部锁，即使退出是由于发生了未捕获的异常，内部锁也会被释放。你可能会问调用一个静态的同步方法会如何，由于静态方法是和类（而不是对象）相关的，所以线程会请求类对象(ClassObject)的内部锁。因此用来控制类的静态域访问的锁不同于控制对象访问的锁。6.同步块另外一种同步的方法是使用同步块。和同步方法不同，同步块必须指定所请求的是哪个对象的内部锁：Java代码publicvoidaddName(Stringname){synchronized(this){lastName=name;nameCount++;}nameList.add(name);}在上面的例子中，addName方法需要使lastName和nameCount的更改保持同步，而且要避免同步调用该对象的其他方法。（在同步代码中调用其他方法会产生Liveness一节所描述的问题。）如果不使用同步块，那么必须要定义一个额外的非同步方法，而这个方法仅仅是用来调用nameList.add。使用同步块对于更细粒度的同步很有帮助。例如类MsLunch有两个实例域c1和c2，他们并不会同时使用（译者注：即c1和c2是彼此无关的两个域），所有对这两个域的更新都需要同步，但是完全不需要防止c1的修改和c2的修改相互之间干扰（这样做只会产生不必要的阻塞而降低了并发性）。这种情况下不必使用同步方法，可以使用和this对象相关的锁。这里我们创建了两个“锁”对象（译者注：起到加锁效果的普通对象lock1和lock2）。Java代码publicclassMsLunch{privatelongc1=0;privatelongc2=0;privateObjectlock1=newObject();privateObjectlock2=newObject();publicvoidinc1(){synchronized(lock1){c1++;}}publicvoidinc2(){synchronized(lock2){c2++;}}}使用这种方法时要特别小心，需要十分确定c1和c2是彼此无关的域。7.可重入同步还记得吗，一个线程不能获得其他线程所拥有的锁。但是它可以获得自己已经拥有的锁。允许一个线程多次获得同一个锁实现了可重入同步。这里描述了一种同步代码的场景，直接的或间接地，调用了一个也拥有同步代码的方法，且两边的代码使用的是同一把锁。如果没有这种可重入的同步机制，同步代码则需要采取许多额外的预防措施以防止线程阻塞自己。8.原子访问在编程过程中，原子操作是指所有操作都同时发生。原子操作不能被中途打断：要么全做，要么不做。原子操作在完成前不会有看得见的副作用。我们发现像c++这样的增量表达式，并没有描述原子操作。即使是非常简单的表达式也能够定义成能被分解为其他操作的复杂操作。然而，有些操作你可以定义为原子的：对引用变量和大部分基本类型变量（除long和double之外）的读写是原子的。对所有声明为volatile的变量（包括long和double变量）的读写是原子的。原子操作不会交错，于是可以放心使用，不必担心线程干扰。然而，这并不能完全消除原子操作上的同步，因为内存一致性错误仍可能发生。使用volatile变量可以降低内存一致性错误的风险，因为对volatile变量的任意写操作，对于后续在该变量上的读操作建立了happens-before关系。这意味着volatile变量的修改对于其他线程总是可见的。更重要的是，这同时也意味着当一个线程读取一个volatile变量时，它不仅能看到该变量最新的修改，而且也能看到致使该改变发生的代码的副效应。使用简单的原子变量访问比通过同步代码来访问更高效，但是需要程序员更加谨慎以避免内存一致性错误。至于这额外的付出是否值得，得看应用的大小和复杂度。java.util.concurrent包中的一些类提供了一些不依赖同步机制的原子方法。我们将在高级并发对象这一节中讨论它们。活跃度（本部分原文地址，译文地址，译者：李任，郑旭东校对：蘑菇街-小宝）一个并发应用程序能及时执行的能力称为活跃性。本节将介绍最常见的活跃性问题：死锁（deadlock），以及另外两个活跃性问题：饥饿（starvation）和活锁（livelock）。1.死锁死锁描述了这样一种情景，两个或多个线程永久阻塞，互相等待对方释放资源。下面是一个例子。Alphone和Gaston是朋友，都很讲究礼节。礼节有一个严格的规矩，当你向一个朋友鞠躬时，你必须保持鞠躬的姿势，直到你的朋友有机会回鞠给你。不幸的是，这个规矩没有算上两个朋友相互同时鞠躬的可能。下面的应用例子，DeadLock，模拟了这个可能性。Java代码staticclassFriend{privatefinalStringname;publicFriend(Stringname){this.name=name;}publicStringgetName(){returnthis.name;}publicsynchronizedvoidbow(Friendbower){System.out.format(""%s:%s""+""hasbowedtome!%n"",this.name,bower.getName());bower.bowBack(this);}publicsynchronizedvoidbowBack(Friendbower){System.out.format(""%s:%s""+""hasbowedbacktome!%n"",this.name,bower.getName());}}publicstaticvoidmain(String[]args){finalFriendalphonse=newFriend(""Alphonse"");finalFriendgaston=newFriend(""Gaston"");newThread(newRunnable(){publicvoidrun(){alphonse.bow(gaston);}}).start();newThread(newRunnable(){publicvoidrun(){gaston.bow(alphonse);}}).start();}}当DeadLock运行后，两个线程极有可能阻塞，当它们尝试调用bowBack方法时。没有哪个阻塞会结束，因为每个线程都在等待另一个线程退出bow方法。2.饥饿和活锁饥饿和活锁并不如死锁一般普遍，但它仍然是每个并发程序设计者可能会遇到的问题。饥饿饥饿是指当一个线程不能正常的访问共享资源并且不能正常执行的情况。这通常在共享资源被其他“贪心”的线程长期时发生。举个例子，假设一个对象提供了一个同步方法，这个方法通常需要执行很长一段时间才返回。如果一个线程经常调用这个方法，那么其他需要同步的访问这个对象的线程就经常会被阻塞。活锁一个线程通常会有会响应其他线程的活动。如果其他线程也会响应另一个线程的活动，那么就有可能发生活锁。同死锁一样，发生活锁的线程无法继续执行。然而线程并没有阻塞——他们在忙于响应对方无法恢复工作。这就相当于两个在走廊相遇的人：Alphonse向他自己的左边靠想让Gaston过去，而Gaston向他的右边靠想让Alphonse过去。可见他们阻塞了对方。Alphonse向他的右边靠，而Gaston向他的左边靠，他们还是阻塞了对方。保护块（GuardedBlocks）（本部分原文连接，译文连接，译者：Greester，校对：郑旭东）多线程之间经常需要协同工作，最常见的方式是使用GuardedBlocks，它循环检查一个条件（通常初始值为true），直到条件发生变化才跳出循环继续执行。在使用GuardedBlocks时有以下几个步骤需要注意：假设guardedJoy()方法必须要等待另一线程为共享变量joy设值才能继续执行。那么理论上可以用一个简单的条件循环来实现，但在等待过程中guardedJoy方法不停的检查循环条件实际上是一种资源浪费。Java代码publicvoidguardedJoy(){//Simpleloopguard.Wastes//processortime.Don'tdothis!while(!joy){}System.out.println(""Joyhasbeenachieved!"");}更加高效的方法是调用Object.wait将当前线程挂起，直到有另一线程发起事件通知（尽管通知的事件不一定是当前线程等待的事件）。Java代码publicsynchronizedvoidguardedJoy(){//Thisguardonlyloopsonceforeachspecialevent,whichmaynot//betheeventwe'rewaitingfor.while(!joy){try{wait();}catch(InterruptedExceptione){}}System.out.println(""Joyandefficiencyhavebeenachieved!"");}注意：一定要在循环里面调用wait方法，不要想当然的认为线程唤醒后循环条件一定发生了改变。和其他可以暂停线程执行的方法一样，wait方法会抛出InterruptedException，在上面的例子中，因为我们关心的是joy的值，所以忽略了InterruptedException。为什么guardedJoy是synchronized方法？假设d是用来调用wait的对象，当一个线程调用d.wait，它必须要拥有d的内部锁（否则会抛出异常），获得d的内部锁的最简单方法是在一个synchronized方法里面调用wait。当一个线程调用wait方法时，它释放锁并挂起。然后另一个线程请求并获得这个锁并调用Object.notifyAll通知所有等待该锁的线程。Java代码publicsynchronizednotifyJoy(){joy=true;notifyAll();}当第二个线程释放这个该锁后，第一个线程再次请求该锁，从wait方法返回并继续执行。注意：还有另外一个通知方法，notify()，它只会唤醒一个线程。但由于它并不允许指定哪一个线程被唤醒，所以一般只在大规模并发应用（即系统有大量相似任务的线程）中使用。因为对于大规模并发应用，我们其实并不关心哪一个线程被唤醒。现在我们使用Guardedblocks创建一个生产者/消费者应用。这类应用需要在两个线程之间共享数据：生产者生产数据，消费者使用数据。两个线程通过共享对象通信。在这里，线程协同工作的关键是：生产者发布数据之前，消费者不能够去读取数据；消费者没有读取旧数据前，生产者不能发布新数据。在下面的例子中，数据通过Drop对象共享的一系列文本消息：Java代码publicclassDrop{//Messagesentfromproducer//toconsumer.privateStringmessage;//Trueifconsumershouldwait//forproducertosendmessage,//falseifproducershouldwaitfor//consumertoretrievemessage.privatebooleanempty=true;publicsynchronizedStringtake(){//Waituntilmessageis//available.while(empty){try{wait();}catch(InterruptedExceptione){}}//Togglestatus.empty=true;//Notifyproducerthat//statushaschanged.notifyAll();returnmessage;}publicsynchronizedvoidput(Stringmessage){//Waituntilmessagehas//beenretrieved.while(!empty){try{wait();}catch(InterruptedExceptione){}}//Togglestatus.empty=false;//Storemessage.this.message=message;//Notifyconsumerthatstatus//haschanged.notifyAll();}}Producer是生产者线程，发送一组消息，字符串DONE表示所有消息都已经发送完成。为了模拟现实情况，生产者线程还会在消息发送时随机的暂停。Java代码importjava.util.Random;publicclassProducerimplementsRunnable{privateDropdrop;publicProducer(Dropdrop){this.drop=drop;}publicvoidrun(){StringimportantInfo[]={""Mareseatoats"",""Doeseatoats"",""Littlelambseativy"",""Akidwilleativytoo""};Randomrandom=newRandom();for(inti=0;i&lt;importantInfo.length;i++){drop.put(importantInfo[i]);try{Thread.sleep(random.nextInt(5000));}catch(InterruptedExceptione){}}drop.put(""DONE"");}}Consumer是消费者线程，读取消息并打印出来，直到读取到字符串DONE为止。消费者线程在消息读取时也会随机的暂停。Java代码importjava.util.Random;publicclassConsumerimplementsRunnable{privateDropdrop;publicConsumer(Dropdrop){this.drop=drop;}publicvoidrun(){Randomrandom=newRandom();for(Stringmessage=drop.take();!message.equals(""DONE"");message=drop.take()){System.out.format(""MESSAGERECEIVED:%s%n"",message);try{Thread.sleep(random.nextInt(5000));}catch(InterruptedExceptione){}}}}ProducerConsumerExample是主线程，它启动生产者线程和消费者线程。Java代码publicclassProducerConsumerExample{publicstaticvoidmain(String[]args){Dropdrop=newDrop();(newThread(newProducer(drop))).start();(newThread(newConsumer(drop))).start();}}注意：Drop类是用来演示GuardedBlocks如何工作的。为了避免重新发明轮子，当你尝试创建自己的共享数据对象时，请查看JavaCollectionsFramework中已有的数据结构。如需更多信息，请参考QuestionsandExercises。不可变对象（本部分原文链接，译文链接，译者：Greenster，校对：郑旭东）一个对象如果在创建后不能被修改，那么就称为不可变对象。在并发编程中，一种被普遍认可的原则就是：尽可能的使用不可变对象来创建简单、可靠的代码。在并发编程中，不可变对象特别有用。由于创建后不能被修改，所以不会出现由于线程干扰产生的错误或是内存一致性错误。但是程序员们通常并不热衷于使用不可变对象，因为他们担心每次创建新对象的开销。实际上这种开销常常被过分高估，而且使用不可变对象所带来的一些效率提升也抵消了这种开销。例如：使用不可变对象降低了垃圾回收所产生的额外开销，也减少了用来确保使用可变对象不出现并发错误的一些额外代码。接下来看一个可变对象的类，然后转化为一个不可变对象的类。通过这个例子说明转化的原则以及使用不可变对象的好处。一个同步类的例子SynchronizedRGB是表示颜色的类，每一个对象代表一种颜色，使用三个整形数表示颜色的三基色，字符串表示颜色名称。Java代码publicclassSynchronizedRGB{//Valuesmustbebetween0and255.privateintred;privateintgreen;privateintblue;privateStringname;privatevoidcheck(intred,intgreen,intblue){if(red<0||red>255||green<0||green>255||blue<0||blue>255){thrownewIllegalArgumentException();}}publicSynchronizedRGB(intred,intgreen,intblue,Stringname){check(red,green,blue);this.red=red;this.green=green;this.blue=blue;this.name=name;}publicvoidset(intred,intgreen,intblue,Stringname){check(red,green,blue);synchronized(this){this.red=red;this.green=green;this.blue=blue;this.name=name;}}publicsynchronizedintgetRGB(){return((red<<16)|(green<<8)|blue);}publicsynchronizedStringgetName(){returnname;}publicsynchronizedvoidinvert(){red=255-red;green=255-green;blue=255-blue;name=""Inverseof""+name;}}使用SynchronizedRGB时需要小心，避免其处于不一致的状态。例如一个线程执行了以下代码：Java代码SynchronizedRGBcolor=newSynchronizedRGB(0,0,0,""PitchBlack"");...intmyColorInt=color.getRGB();//Statement1StringmyColorName=color.getName();//Statement2如果有另外一个线程在Statement1之后、Statement2之前调用了color.set方法，那么myColorInt的值和myColorName的值就会不匹配。为了避免出现这样的结果，必须要像下面这样把这两条语句绑定到一块执行：Java代码synchronized(color){intmyColorInt=color.getRGB();StringmyColorName=color.getName();}这种不一致的问题只可能发生在可变对象上。定义不可变对象的策略以下的一些规则是创建不可变对象的简单策略。并非所有不可变类都完全遵守这些规则，不过这不是编写这些类的程序员们粗心大意造成的，很可能的是他们有充分的理由确保这些对象在创建后不会被修改。但这需要非常复杂细致的分析，并不适用于初学者。不要提供setter方法。（包括修改字段的方法和修改字段引用对象的方法）将类的所有字段定义为final、private的。不允许子类重写方法。简单的办法是将类声明为final，更好的方法是将构造函数声明为私有的，通过工厂方法创建对象。如果类的字段是对可变对象的引用，不允许修改被引用对象。·不提供修改可变对象的方法。·不共享可变对象的引用。当一个引用被当做参数传递给构造函数，而这个引用指向的是一个外部的可变对象时，一定不要保存这个引用。如果必须要保存，那么创建可变对象的拷贝，然后保存拷贝对象的引用。同样如果需要返回内部的可变对象时，不要返回可变对象本身，而是返回其拷贝。将这一策略应用到SynchronizedRGB有以下几步：SynchronizedRGB类有两个setter方法。第一个set方法只是简单的为字段设值（译者注：删掉即可），第二个invert方法修改为创建一个新对象，而不是在原有对象上修改。所有的字段都已经是私有的，加上final即可。将类声明为final的只有一个字段是对象引用，并且被引用的对象也是不可变对象。经过以上这些修改后，我们得到了ImmutableRGB：Java代码finalpublicclassImmutableRGB{//Valuesmustbebetween0and255.finalprivateintred;finalprivateintgreen;finalprivateintblue;finalprivateStringname;privatevoidcheck(intred,intgreen,intblue){if(red<0||red>255||green<0||green>255||blue<0||blue>255){thrownewIllegalArgumentException();}}publicImmutableRGB(intred,intgreen,intblue,Stringname){check(red,green,blue);this.red=red;this.green=green;this.blue=blue;this.name=name;}publicintgetRGB(){return((red<<16)|(green<<8)|blue);}publicStringgetName(){returnname;}publicImmutableRGBinvert(){returnnewImmutableRGB(255-red,255-green,255-blue,""Inverseof""+name);}}高级并发对象（本部分原文链接，译文链接，译者：李任）目前为止，该教程重点讲述了最初作为Java平台一部分的低级别API。这些API对于非常基本的任务来说已经足够，但是对于更高级的任务就需要更高级的API。特别是针对充分利用了当今多处理器和多核系统的大规模并发应用程序。本节，我们将着眼于Java5.0新增的一些高级并发特征。大多数特征已经在新的java.util.concurrent包中实现。Java集合框架中也定义了新的并发数据结构。锁对象提供了可以简化许多并发应用的锁的惯用法。Executors为加载和管理线程定义了高级API。Executors的实现由java.util.concurrent包提供，提供了适合大规模应用的线程池管理。并发集合简化了大型数据集合管理，且极大的减少了同步的需求。原子变量有减小同步粒度和避免内存一致性错误的特征。并发随机数（JDK7）提供了高效的多线程生成伪随机数的方法。1.锁对象同步代码依赖于一种简单的可重入锁。这种锁使用简单，但也有诸多限制。java.util.concurrent.locks包提供了更复杂的锁。我们不会详细考察这个包，但会重点关注其最基本的接口，锁。锁对象作用非常类似同步代码使用的隐式锁。如同隐式锁，每次只有一个线程可以获得锁对象。通过关联Condition对象，锁对象也支持wait/notify机制。锁对象之于隐式锁最大的优势在于，它们有能力收回获得锁的尝试。如果当前锁对象不可用，或者锁请求超时（如果超时时间已指定），tryLock方法会收回获取锁的请求。如果在锁获取前，另一个线程发送了一个中断，lockInterruptibly方法也会收回获取锁的请求。让我们使用锁对象来解决我们在活跃度中见到的死锁问题。Alphonse和Gaston已经把自己训练成能注意到朋友何时要鞠躬。我们通过要求Friend对象在双方鞠躬前必须先获得锁来模拟这次改善。下面是改善后模型的源代码，Safelock。为了展示其用途广泛，我们假设Alphonse和Gaston对于他们新发现的稳定鞠躬的能力是如此入迷，以至于他们无法不相互鞠躬。Java代码importjava.util.concurrent.locks.Lock;importjava.util.concurrent.locks.ReentrantLock;importjava.util.Random;publicclassSafelock{staticclassFriend{privatefinalStringname;privatefinalLocklock=newReentrantLock();publicFriend(Stringname){this.name=name;}publicStringgetName(){returnthis.name;}publicbooleanimpendingBow(Friendbower){BooleanmyLock=false;BooleanyourLock=false;try{myLock=lock.tryLock();yourLock=bower.lock.tryLock();}finally{if(!(myLock&&yourLock)){if(myLock){lock.unlock();}if(yourLock){bower.lock.unlock();}}}returnmyLock&&yourLock;}publicvoidbow(Friendbower){if(impendingBow(bower)){try{System.out.format(""%s:%shas""+""bowedtome!%n"",this.name,bower.getName());bower.bowBack(this);}finally{lock.unlock();bower.lock.unlock();}}else{System.out.format(""%s:%sstarted""+""tobowtome,butsawthat""+""Iwasalreadybowingto""+""him.%n"",this.name,bower.getName());}}publicvoidbowBack(Friendbower){System.out.format(""%s:%shas""+""bowedbacktome!%n"",this.name,bower.getName());}}staticclassBowLoopimplementsRunnable{privateFriendbower;privateFriendbowee;publicBowLoop(Friendbower,Friendbowee){this.bower=bower;this.bowee=bowee;}publicvoidrun(){Randomrandom=newRandom();for(;;){try{Thread.sleep(random.nextInt(10));}catch(InterruptedExceptione){}bowee.bow(bower);}}}publicstaticvoidmain(String[]args){finalFriendalphonse=newFriend(""Alphonse"");finalFriendgaston=newFriend(""Gaston"");newThread(newBowLoop(alphonse,gaston)).start();newThread(newBowLoop(gaston,alphonse)).start();}}2.执行器（Executors）在之前所有的例子中，Thread对象表示的线程和Runnable对象表示的线程所执行的任务之间是紧耦合的。这对于小型应用程序来说没问题，但对于大规模并发应用来说，合理的做法是将线程的创建与管理和程序的其他部分分离开。封装这些功能的对象就是执行器，接下来的部分将讲详细描述执行器。执行器接口定义了三种类型的执行器对象。线程池是最常见的一种执行器的实现。Fork/Join是JDK7中引入的并发框架。3.Executor接口java.util.concurrent中包括三个Executor接口：Executor，一个运行新任务的简单接口。ExecutorService，扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法。ScheduledExecutorService，扩展了ExecutorService。支持Future和定期执行任务。通常来说，指向Executor对象的变量应被声明为以上三种接口之一，而不是具体的实现类。Executor接口Executor接口只有一个execute方法，用来替代通常创建（启动）线程的方法。例如：r是一个Runnable对象，e是一个Executor对象。可以使用Java代码e.execute(r);来代替Java代码(newThread(r)).start();但execute方法没有定义具体的实现方式。对于不同的Executor实现，execute方法可能是创建一个新线程并立即启动，但更有可能是使用已有的工作线程运行r，或者将r放入到队列中等待可用的工作线程。（我们将在线程池一节中描述工作线程。）ExecutorService接口ExecutorService接口在提供了execute方法的同时，新加了更加通用的submit方法。submit方法除了和execute方法一样可以接受Runnable对象作为参数，还可以接受Callable对象作为参数。使用Callable对象可以能使任务返还执行的结果。通过submit方法返回的Future对象可以读取Callable任务的执行结果，或是管理Callable任务和Runnable任务的状态。ExecutorService也提供了批量运行Callable任务的方法。最后，ExecutorService还提供了一些关闭执行器的方法。如果需要支持即时关闭，执行器所执行的任务需要正确处理中断。ScheduledExecutorService接口ScheduledExecutorService扩展ExecutorService接口并添加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate方法和scheduleWithFixedDelay方法。4.线程池在java.util.concurrent包中多数的执行器实现都使用了由工作线程组成的线程池，工作线程独立于所它所执行的Runnable任务和Callable任务，并且常用来执行多个任务。使用工作线程可以使创建线程的开销最小化。在大规模并发应用中，创建大量的Thread对象会占用占用大量系统内存，分配和回收这些对象会产生很大的开销。一种最常见的线程池是固定大小的线程池。这种线程池始终有一定数量的线程在运行，如果一个线程由于某种原因终止运行了，线程池会自动创建一个新的线程来代替它。需要执行的任务通过一个内部队列提交给线程，当没有更多的工作线程可以用来执行任务时，队列保存额外的任务。使用固定大小的线程池一个很重要的好处是可以实现优雅退化。例如一个Web服务器，每一个HTTP请求都是由一个单独的线程来处理的，如果为每一个HTTP都创建一个新线程，那么当系统的开销超出其能力时，会突然地对所有请求都停止响应。如果限制Web服务器可以创建的线程数量，那么它就不必立即处理所有收到的请求，而是在有能力处理请求时才处理。创建一个使用线程池的执行器最简单的方法是调用java.util.concurrent.Executors的newFixedThreadPool方法。Executors类还提供了下列一下方法：newCachedThreadPool方法创建了一个可扩展的线程池。适合用来启动很多短任务的应用程序。newSingleThreadExecutor方法创建了每次执行一个任务的执行器。还有一些创建ScheduledExecutorService执行器的方法。如果上面的方法都不满足需要，可以尝试java.util.concurrent.ThreadPoolExecutor或者java.util.concurrent.ScheduledThreadPoolExecutor。5.Fork/Jointfork/join框架是ExecutorService接口的一种具体实现，目的是为了帮助你更好地利用多处理器带来的好处。它是为那些能够被递归地拆解成子任务的工作类型量身设计的。其目的在于能够使用所有可用的运算能力来提升你的应用的性能。类似于ExecutorService接口的其他实现，fork/join框架会将任务分发给线程池中的工作线程。fork/join框架的独特之处在与它使用工作窃取(work-stealing)算法。完成自己的工作而处于空闲的工作线程能够从其他仍然处于忙碌(busy)状态的工作线程处窃取等待执行的任务。fork/join框架的核心是ForkJoinPool类，它是对AbstractExecutorService类的扩展。ForkJoinPool实现了工作偷取算法，并可以执行ForkJoinTask任务。基本使用方法使用fork/join框架的第一步是编写执行一部分工作的代码。你的代码结构看起来应该与下面所示的伪代码类似：Java代码if(当前这个任务工作量足够小)直接完成这个任务else将这个任务或这部分工作分解成两个部分分别触发(invoke)这两个子任务的执行，并等待结果你需要将这段代码包裹在一个ForkJoinTask的子类中。不过，通常情况下会使用一种更为具体的的类型，或者是RecursiveTask(会返回一个结果)，或者是RecursiveAction。当你的ForkJoinTask子类准备好了，创建一个代表所有需要完成工作的对象，然后将其作为参数传递给一个ForkJoinPool实例的invoke()方法即可。要清晰，先模糊想要了解fork/join框架的基本工作原理，接下来的这个例子会有所帮助。假设你想要模糊一张图片。原始的source图片由一个整数的数组表示，每个整数表示一个像素点的颜色数值。与source图片相同，模糊之后的destination图片也由一个整数数组表示。对图片的模糊操作是通过对source数组中的每一个像素点进行处理完成的。处理的过程是这样的：将每个像素点的色值取出，与周围像素的色值（红、黄、蓝三个组成部分）放在一起取平均值，得到的结果被放入destination数组。因为一张图片会由一个很大的数组来表示，这个流程会花费一段较长的时间。如果使用fork/join框架来实现这个模糊算法，你就能够借助多处理器系统的并行处理能力。下面是上述算法结合fork/join框架的一种简单实现：Java代码publicclassForkBlurextendsRecursiveAction{privateint[]mSource;privateintmStart;privateintmLength;privateint[]mDestination;//Processingwindowsize;shouldbeodd.privateintmBlurWidth=15;publicForkBlur(int[]src,intstart,intlength,int[]dst){mSource=src;mStart=start;mLength=length;mDestination=dst;}protectedvoidcomputeDirectly(){intsidePixels=(mBlurWidth-1)/2;for(intindex=mStart;index&lt;mStart+mLength;index++){//Calculateaverage.floatrt=0,gt=0,bt=0;for(intmi=-sidePixels;mi&lt;=sidePixels;mi++){intmindex=Math.min(Math.max(mi+index,0),mSource.length-1);intpixel=mSource[mindex];rt+=(float)((pixel&amp;0x00ff0000)&gt;&gt;16)/mBlurWidth;gt+=(float)((pixel&amp;0x0000ff00)&gt;&gt;8)/mBlurWidth;bt+=(float)((pixel&amp;0x000000ff)&gt;&gt;0)/mBlurWidth;}//Reassembledestinationpixel.intdpixel=(0xff000000)|(((int)rt)&lt;&lt;16)|(((int)gt)&lt;&lt;8)|(((int)bt)&lt;&lt;0);mDestination[index]=dpixel;}}接下来你需要实现父类中的compute()方法，它会直接执行模糊处理，或者将当前的工作拆分成两个更小的任务。数组的长度可以作为一个简单的阀值来判断任务是应该直接完成还是应该被拆分。Java代码protectedstaticintsThreshold=100000;protectedvoidcompute(){if(mLength&lt;sThreshold){computeDirectly();return;}intsplit=mLength/2;invokeAll(newForkBlur(mSource,mStart,split,mDestination),newForkBlur(mSource,mStart+split,mLength-split,mDestination));}如果前面这个方法是在一个RecursiveAction的子类中，那么设置任务在ForkJoinPool中执行就再直观不过了。通常会包含以下一些步骤：(1)创建一个表示所有需要完成工作的任务。Java代码//sourceimagepixelsareinsrc//destinationimagepixelsareindstForkBlurfb=newForkBlur(src,0,src.length,dst);(2)创建将要用来执行任务的ForkJoinPool。Java代码ForkJoinPoolpool=newForkJoinPool();(3)执行任务。Java代码pool.invoke(fb);想要浏览完成的源代码，请查看ForkBlur，其中还包含一些创建destination图片文件的额外代码。标准实现除了能够使用fork/join框架来实现能够在多处理系统中被并行执行的定制化算法（如前文中的ForkBlur.java例子），在JavaSE中一些比较常用的功能点也已经使用fork/join框架来实现了。在JavaSE8中，java.util.Arrays类的一系列parallelSort()方法就使用了fork/join来实现。这些方法与sort()系列方法很类似，但是通过使用fork/join框架，借助了并发来完成相关工作。在多处理器系统中，对大数组的并行排序会比串行排序更快。这些方法究竟是如何运用fork/join框架并不在本教程的讨论范围内。想要了解更多的信息，请参见JavaAPI文档。其他采用了fork/join框架的方法还包括java.util.streams包中的一些方法，此包是作为JavaSE8发行版中ProjectLambda的一部分。想要了解更多信息，请参见LambdaExpressions一节。6.并发集合java.util.concurrent包囊括了Java集合框架的一些附加类。它们也最容易按照集合类所提供的接口来进行分类：BlockingQueue定义了一个先进先出的数据结构，当你尝试往满队列中添加元素，或者从空队列中获取元素时，将会阻塞或者超时。ConcurrentMap是java.util.Map的子接口，定义了一些有用的原子操作。移除或者替换键值对的操作只有当key存在时才能进行，而新增操作只有当key不存在时。使这些操作原子化，可以避免同步。ConcurrentMap的标准实现是ConcurrentHashMap，它是HashMap的并发模式。ConcurrentNavigableMap是ConcurrentMap的子接口，支持近似匹配。ConcurrentNavigableMap的标准实现是ConcurrentSkipListMap，它是TreeMap的并发模式。所有这些集合，通过在集合里新增对象和访问或移除对象的操作之间，定义一个happens-before的关系，来帮助程序员避免内存一致性错误。7.原子变量java.util.concurrent.atomic包定义了对单一变量进行原子操作的类。所有的类都提供了get和set方法，可以使用它们像读写volatile变量一样读写原子类。就是说，同一变量上的一个set操作对于任意后续的get操作存在happens-before关系。原子的compareAndSet方法也有内存一致性特点，就像应用到整型原子变量中的简单原子算法。为了看看这个包如何使用，让我们返回到最初用于演示线程干扰的Counter类：Java代码classCounter{privateintc=0;publicvoidincrement(){c++;}publicvoiddecrement(){c--;}publicintvalue(){returnc;}}使用同步是一种使Counter类变得线程安全的方法，如SynchronizedCounter：Java代码classSynchronizedCounter{privateintc=0;publicsynchronizedvoidincrement(){c++;}publicsynchronizedvoiddecrement(){c--;}publicsynchronizedintvalue(){returnc;}}对于这个简单的类，同步是一种可接受的解决方案。但是对于更复杂的类，我们可能想要避免不必要同步所带来的活跃度影响。将int替换为AtomicInteger允许我们在不进行同步的情况下阻止线程干扰，如AtomicCounter：Java代码importjava.util.concurrent.atomic.AtomicInteger;classAtomicCounter{privateAtomicIntegerc=newAtomicInteger(0);publicvoidincrement(){c.incrementAndGet();}publicvoiddecrement(){c.decrementAndGet();}publicintvalue(){returnc.get();}8.并发随机数在JDK7中，java.util.concurrent包含了一个相当便利的类，ThreadLocalRandom，当应用程序期望在多个线程或ForkJoinTasks中使用随机数时。对于并发访问，使用TheadLocalRandom代替Math.random()可以减少竞争，从而获得更好的性能。你只需调用ThreadLocalRandom.current()，然后调用它的其中一个方法去获取一个随机数即可。下面是一个例子：Java代码intr=ThreadLocalRandom.current().nextInt(4,77);",2015/7/31
201,通过jacob操作office,陆开奇,http://180.168.156.212:2262/wecenter/?/article/9092,"简介：jacob（javacombridge，javacom桥）分为两个部分，jacob.jar,jacob.dll，使用时两个东西的版本要一致，而且还分32位和64位，它的位数和jdk的位数有关，与操作系统的位数无关。它的原理是通过java的jni功能，调用系统组件dll，通过这个com桥来操作com组件，最终完成对office文档的操作。环境配置：1、在工程中引入jar包2、将dll文件放到系统的path变量中，或者直接放到jdk/bin、jre/bin、system32/system64下面都放一份，总能找得到，版本要急着对应好。常用类以及方法ComThread：com组件管理，用来初始化com线程，释放线程，所以会在操作office之前使用，操作完成再使用。ActiveXComponent：创建office的一个应用，比如你操作的是word还是excelDispatch：调度处理类，封装了一些操作来操作office，里面所有的可操作对象基本都是这种类型，所以jacob是一种链式操作模式，就像StringBuilder对象，调用append()方法之后返回的还是StringBuilder对象Variant：封装参数数据类型，因为操作office是的一些方法参数，可能是字符串类型，可能是数字类型，虽然都是1，但是不能通过，可以通过Variant来进行转换通用的参数类型，newVariant(1),newVariant(""1""),Dispatch的几种静态方法：这些方法就是要用来操作office的。?call()方法：调用COM对象的方法，返回Variant类型值。?invoke()方法：和call方法作用相同，但是不返回值。?get()方法：获取COM对象属性，返回variant类型值。?put()方法：设置COM对象属性。例1、Word转pdf/***word文件格式转换**@paramsourceFilePath(输入路径)*@paramdestFilePath(输出路径)*@paramformat(转pdf参数为17)*/privatestaticvoidconvert(StringsourceFilePath,StringdestFilePath,intformat){//初始化com的线程ComThread.InitSTA();ActiveXComponentapp=null;Dispatchdoc=null;try{logger.debug(""启动word..."");app=newActiveXComponent(""Word.Application"");app.setProperty(""Visible"",newVariant(false));Dispatchdocs=app.getProperty(""Documents"").toDispatch();//打开word文档logger.debug(""打开文档...:""+sourceFilePath);doc=Dispatch.invoke(docs,""Open"",Dispatch.Method,newObject[]{sourceFilePath,newVariant(false),newVariant(true)/*ReadOnly*/,newVariant(false),newVariant("""")/*password*/,newVariant(""""),newVariant(true)/*Revert*/,newVariant(""""),newVariant(""""),newVariant(0)/*Format*/,newVariant(0)/*Encoding*/,newVariant(false)/*Visible*/,newVariant(false)/*OpenAndRepair*/,newVariant(0),newVariant(true)/*NoEncodingDialog*/},newint[1]).toDispatch();logger.debug(""转换...：""+destFilePath);Filetofile=newFile(destFilePath);if(tofile.exists()){tofile.delete();}Dispatch.call(doc,""SaveAs"",destFilePath,format);}catch(Throwablee){////异常时调用，很关键//ComThread.doCoUninitialize();thrownewRuntimeException(""转换失败"",e);}finally{if(doc!=null){try{logger.debug(""关闭文档..."");Dispatch.call(doc,""Close"",newVariant(false));}catch(Throwablee){logger.error(""关闭文档失败"",e);}}try{try{if(app!=null){logger.debug(""退出word..."");//app.invoke(""Quit"",newVariant[]{});app.invoke(""Quit"",newVariant(0),newVariant(0),newVariant(false));}}catch(Throwablee){logger.error(""退出word失败"",e);}//如果没有这句话,winword.exe进程将不会关闭//关闭com的线程ComThread.Release();logger.debug(""转换完毕"");}catch(Exceptione){logger.error(""退出word失败"",e);}}}例2、判断是否装了office，及获得office版本号:ActiveXComponentapp=null;try{app=newActiveXComponent(""Word.Application"");//启动wordStringversion=""0"";if(Util.notNull(app)){version=app.getProperty(""version"").toString();}System.out.println(version);}catch(Exceptione){//e.printStackTrace();}finally{try{if(app!=null){//app.invoke(""Quit"",newVariant[]{});app.invoke(""Quit"",newVariant(0),newVariant(0),newVariant(false));}}catch(Throwablee){//logger.error(""退出word失败"",e);}}Office版本号：office2013版本号——15office2010版本号——14office2007版本号——12office2003版本号——11",2015/7/31
202,JAVA中的反射机制,王四云,http://180.168.156.212:2262/wecenter/?/article/9091,"JAVA反射机制是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法；对任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能就是java语言的反射机制。Java反射机制主要提供了一下功能：在程序运行时：a判断任意一个对象所属的类；b构造任意一个类的对象；c判断任意一个类所具有的成员变量和方法；d调用任意一个对象的方法。反射机制的作用：1．反编译：.class-->.java2．通过反射机制访问java对象的属性，方法，构造方法等；常用的反射机制中的类如下所示：java.lang.Class;java.lang.reflect.Constructor;java.lang.reflect.Field;java.lang.reflect.Method;java.lang.reflect.Modifier;很多反射中的方法，属性等操作可以从这四个类中查询。Java中，无论生成某个类的多少个对象，这些对象都会对应于同一个Class对象。反射机制的实现：（1）反射机制获取Class对象有三种方法：1.通过Object类的getClass()方法。例如：Classc1=newString("""").getClass();2.通过Class类的静态方法——forName()来实现：Classc2=Class.forName(""MyObject"");3.如果T是一个已定义的类型的话，在java中，它的.class文件名：T.class就代表了与其匹配的Class对象，例如：Classc3=Manager.class;Classc4=int.class;Classc5=Double[].class;注意：当一个class被加载，或当加载器（classloader）的defineClass()被JVM调用，JVM便自动产生一个Classobject。不能通过“修改Java标准库源码”来观察Classobject的实际生成时机，因为Class并没有publicconstructor。（2）创建对象：获取类以后我们来创建它的对象，利用newInstance：该方法可以根据某个Class对象产生其对应类的实例。需要强调的是，它调用的是此类的默认构造方法。例如：MyObjectx=newMyObject();MyObjecty=x.getClass().newInstance();（3）运行时复制对象ReflectTester类有一个copy(Objectobject)方法，这个方法能够创建一个和参数object同样类型的对象，然后把object对象中的所有属性拷贝到新建的对象中，并将它返回。ReflectTester类的copy(Objectobject)方法依次执行以下步骤：a.获得对象的类型：ClassclassType=object.getClass();System.out.println(""Class:""+classType.getName())；b.通过默认构造方法创建一个新对象：ObjectobjectCopy=classType.getConstructor(newClass[]{}).newInstance(newObject[]{});先调用Class类的getConstructor()方法获得一个Constructor对象，它代表默认的构造方法，然后调用Constructor对象的newInstance()方法构造一个实例。c.获得对象的所有属性：Fieldfields[]=classType.getDeclaredFields();Class类的getDeclaredFields()方法返回类的所有属性，包括public、protected、默认和private访问级别的属性。d.获得每个属性相应的getXXX()和setXXX()方法，然后执行这些方法，把原来对象的属性拷贝到新的对象中。（4）用反射机制调用对象的方法publicclassInvokeTester{publicintadd(intparam1,intparam2){returnparam1+param2;}publicStringecho(Stringmsg){return""echo:""+msg;}publicstaticvoidmain(String[]args)throwsException{Class<?>classType=InvokeTester.class;ObjectinvokeTester=classType.newInstance();//获取InvokeTester类的add()方法MethodaddMethod=classType.getMethod(""add"",newClass[]{int.class,int.class});//调用invokeTester对象上的add()方法Objectresult=addMethod.invoke(invokeTester,newObject[]{newInteger(100),newInteger(200)});System.out.println((Integer)result);//获取InvokeTester类的echo()方法MethodechoMethod=classType.getMethod(""echo"",newClass[]{String.class});//调用invokeTester对象的echo()方法result=echoMethod.invoke(invokeTester,newObject[]{""Hello""});System.out.println((String)result);}}在例程InvokeTester类的main()方法中，运用反射机制调用一个InvokeTester对象的add()和echo()方法。add()方法的两个参数均为int类型，获得表示add()方法的Method对象的代码如下：MethodaddMethod=classType.getMethod(""add"",newClass[]{int.class,int.class});Method类的invoke(Objectobj,Objectargs[])方法接收的参数必须为对象，如果参数为基本类型数据，必须转换为相应的包装类型的对象。invoke()方法的返回值总是对象，如果实际被调用的方法的返回类型是基本类型数据，那么invoke()方法会把它转换为相应的包装类型的对象，再将其返回。在上述例子中，尽管InvokeTester类的add()方法的两个参数以及返回值都是int类型，调用addMethod对象的invoke()方法时，只能传递Integer类型的参数，并且invoke()方法的返回类型也是Integer类型，Integer类是int基本类型的包装类。",2015/7/31
203,浅谈Java中的Set、List、Map的区别,王四云,http://180.168.156.212:2262/wecenter/?/article/9090,"在软件开发过程中，经常会用到Set、List、Map类型进行数据存储，它们之间的区别有哪些呢？以下是对三者之间的总结：就学习经验，浅谈Java中的Set,List,Map的区别，对JAVA的集合的理解是相对于数组：数组是大小固定的，并且同一个数组只能存放类型一样的数据（基本类型/引用类型），JAVA集合可以存储和操作数目不固定的一组数据。所有的JAVA集合都位于java.util包中！JAVA集合只能存放引用类型的的数据，不能存放基本数据类型。JAVA集合主要分为三种类型：1.Set(集)2.List(列表)3.Map(映射)Collection接口：Collection是最基本的集合接口，声明了适用于JAVA集合（只包括Set和List）的通用方法。Set和List都继承了Conllection,MapCollection接口的方法：booleanadd(Objecto)：向集合中加入一个对象的引用voidclear()：删除集合中所有的对象，即不再持有这些对象的引用booleanisEmpty()：判断集合是否为空booleancontains(Objecto)：判断集合中是否持有特定对象的引用Iterartoriterator()：返回一个Iterator对象，可以用来遍历集合中的元素booleanremove(Objecto)：从集合中删除一个对象的引用intsize()：返回集合中元素的数目Object[]toArray()：返回一个数组，该数组中包括集合中的所有元素关于：Iterator()和toArray()方法都用于集合的所有的元素，前者返回一个Iterator对象，后者返回一个包含集合中所有元素的数组。Iterator接口声明了如下方法：hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回truenext()：返回下一个元素remove()：从集合中删除上一个有next()方法返回的元素。Set(集合)：Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。Set接口主要实现了两个实现类：HashSet：HashSet类按照哈希算法来存取集合中的对象，存取速度比较快TreeSet：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。Set的用法：存放的是对象的引用，没有重复对象。eg:Setset=newHashSet();Strings1=newString(""hello"");Strings2=s1;Strings3=newString(""world"");set.add(s1);set.add(s2);set.add(s3);System.out.println(set.size());//打印集合中对象的数目为2。Set的add()方法是如何判断对象是否已经存放在集合中？eg:booleanisExists=false;Iteratoriterator=set.iterator();while(it.hasNext()){StringoldStr=it.next();if(newStr.equals(oldStr)){isExists=true;}}List(列表)：List的特征是其元素以线性方式存储，集合中可以存放重复对象。List接口主要实现类包括：ArrayList():代表长度可以改变得数组。可以对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢。LinkedList():在实现中采用链表数据结构。插入和删除速度快，访问速度慢。对于List的随机访问来说，就是只随机来检索位于特定位置的元素。List的get(intindex)方法放回集合中由参数index指定的索引位置的对象，下标从“0”开始。最基本的两种检索集合中的所有对象的方法：1：for循环和get()方法：for(inti=0;i<list.size();i++){System.out.println(list.get(i));}2：使用迭代器（Iterator）:Iteratorit=list.iterator();while(it.hashNext){System.out.println(it.next);}Map(映射):Map是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象。Map没有继承于Collection接口从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。Map的常用方法：1添加，删除操作：Objectput(Objectkey,Objectvalue)：向集合中加入元素Objectremove(Objectkey)：删除与KEY相关的元素voidputAll(Mapt)：将来自特定映像的所有元素添加给该映像voidclear()：从映像中删除所有映射2查询操作：Objectget(Objectkey)：获得与关键字key相关的值。Map集合中的键对象不允许重复，也就说，任意两个键对象通过equals()方法比较的结果都是false.，但是可以将任意多个键独享映射到同一个值对象上。Conllections：集合实用类。Conllections提供了供JAVA集合实用的静态方法总结：JAVA集合的基本用法，都归纳了，上面这些是平常最常用的JAVA集合，具体的其他的，还要参考JDK帮助文档了，呵呵关于Map的应用，还有很多，具体就是这个，Conllections提供了很多List/Map实用的方法，对平常开发非常有用。booleancontainsKey(Objectkey)：判断映像中是否存在关键字keybooleancontainsValue(Objectvalue)：判断映像中是否存在值valueintsize()：返回当前映像中映射的数量booleanisEmpty()：判断映像中是否有任何映射List按对象进入的顺序保存对象，不做排序或编辑操作。Set对每个对象只接受一次，并使用自己内部的排序方法(通常，你只关心某个元素是否属于Set,而不关心它的顺序--否则应该使用List)。Map同样对每个元素保存一份，但这是基于""键""的，Map也有内置的排序，因而不关心元素添加的顺序。如果添加元素的顺序对你很重要，应该使用LinkedHashSet或者LinkedHashMap.List的功能方法实际上有两种Lis：一种是基本的ArrayList,其优点在于随机访问元素，另一种是更强大的LinkedList,它并不是为快速随机访问设计的，而是具有一套更通用的方法。List：次序是List最重要的特点：它保证维护元素特定的顺序。List为Collection添加了许多方法，使得能够向List中间插入与移除元素(这只推荐LinkedList使用。)一个List可以生成ListIterator,使用它可以从两个方向遍历List,也可以从List中间插入和移除元素。ArrayList：由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。ListIterator只应该用来由后向前遍历ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。LinkedList：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。(使用ArrayList代替。)还具有下列方法：addFirst(),addLast(),getFirst(),getLast(),removeFirst()和removeLast(),这些方法(没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。Set的功能方法Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection,只是行为不同。(这是继承与多态思想的典型应用：表现不同的行为。)Set不保存重复的元素(至于如何判断元素相同则较为负责)Set:存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。TreeSet：保存次序的Set,底层为树结构。使用它可以从Set中提取有序的序列。LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。Map的功能方法方法put(Objectkey,Objectvalue)添加一个“值”(想要得东西)和与“值”相关联的“键”(key)(使用它来查找)。方法get(Objectkey)返回与给定“键”相关联的“值”。可以用containsKey()和containsValue()测试Map中是否包含某个“键”或“值”。标准的Java类库中包含了几种不同的Map：HashMap,TreeMap,LinkedHashMap,WeakHashMap,IdentityHashMap。它们都有同样的基本接口Map，但是行为、效率、排序策略、保存对象的生命周期和判定“键”等价的策略等各不相同。执行效率是Map的一个大问题。看看get()要做哪些事，就会明白为什么在ArrayList中搜索“键”是相当慢的。而这正是HashMap提高速度的地方。HashMap使用了特殊的值，称为“散列码”(hashcode)，来取代对键的缓慢搜索。“散列码”是“相对唯一”用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。所有Java对象都能产生散列码，因为hashCode()是定义在基类Object中的方法。HashMap就是使用对象的hashCode()进行快速查询的。此方法能够显着提高性能。Map:维护“键值对”的关联性，使你可以通过“键”查找“值”HashMap：Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子loadfactor，以调整容器的性能。LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。TreeMap：基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。WeakHashMao：弱键(weakkey)Map，Map中使用的对象也被允许释放:这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。IdentifyHashMap：:使用==代替equals()对“键”作比较的hashmap。专为解决特殊问题而设计。",2015/7/31
204,Visitor设计模式,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9089,"我猜想许多人都知道访问者设计模式，这种模式在“四人帮”的那本可复用面向对象软件基础的书被描述过。这个模式自身其实一点也不复杂（和以往的其他设计模式一样）。如上图所示：我知道这个模式很久了，但是我至今都不需要它。Java通过本地方式处理多态：方法被调用时是基于调用这个方法的对象运行时的类型，而是不是基于调用对象编译时的类型。interfaceAnimal{voideat();}publicclassDogimplementsAnimal{publicvoideat(){System.out.println(""Gnawsbones"");}}Animala=newDog();a.eats();//Prints""Gnawsbones""然而，以上的方式对于参数类型却无法有效的运行。publicclassFeeder{publicvoidfeed(Dogd){d.eat();}publicvoidfeed(Catc){c.eat();}}Feederfeeder=newFeeder();Objecto=newDog();feeder.feed(o);//Cannotcompile!这个问题被称之为双重派发，因为它既要求被调用的方法既基于调用方法的实例，同时也基于方法的参数类型。而对于参数类型而言，Java不是基于本地化方式来处理。为了能够编译通过，下面的代码是必须的：if(oinstanceofDog){feeder.feed((Dog)o);}elseif(oinstanceofCat){feeder.feed((Cat)o);}else{thrownewRuntimeException(""Invalidtype"");}随着更多重载方法的出现，情况也会变得更加复杂——方法中出现更多的参数，复杂度也会呈指数级别提高。在维护阶段，添加更多的重载的方法需要阅读所有代码，如果程序填充了太多不必要的代码需就要去更新它。多个参数通过嵌套多个if来实现，这对于维护会变得更加糟糕。访问者模式是一种优雅的方式来解决以上同样的效果，不使用多if，而使用Animal类中的一个单独的方法来作为解决的代价。publicinterfaceAnimal{voideat();voidaccept(Visitorv);}publicclassCat{publicvoideat(){...}publicvoidaccept(Visitorv){v.visit(this);}}publicclassDog{publicvoideat(){...}publicvoidaccept(Visitorv){v.visit(this);}}publicclassFeederVisitor{publicvoidvisit(Catc){newFeeder().feed(c);}publicvoidvisit(Dogd){newFeeder().feed(d);}}好处：没有逻辑的评价出现只是在Animal和FeederVisitor之间建立依赖,FeederVisitor中只限于visit方法按照推论，当添加新的Animal子类的时候，Feeder类可以保持不变当添加一个新的Animal子类的时候，FeederVisitor类实现一个额外的方法去处理它即可其他的横切逻辑也可以遵循相同的模式，比如：一个来教动物新把戏的训练特征对于一些简单的例子使用如此长的代码似乎有杀鸡用宰牛刀的感觉。然而，我的经验教会了我像上面简单的填充代码，当随着项目的发展业务逻辑变负责是致命的。",2015/7/31
205,spring-test单元测试,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9088,spring-test单元测试spring单元测试.html2.png1.png,2015/7/31
206,as3使用滤镜为文字描边,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9087,效果图:使用GlowFilter类可以对显示对象应用发光效果。有多个用于发光样式的选项，包括内侧发光或外侧发光以及挖空模式。在投影滤镜的distance和angle属性设置为0时，发光滤镜与投影滤镜极为相似。您可以将滤镜应用于任何显示对象（即，从DisplayObject类继承的对象），例如MovieClip、SimpleButton、TextField和Video对象，以及BitmapData对象。GlowFilter相关参数：alpha:Number颜色的Alpha透明度值。blurX:Number水平模糊量。blurY:Number垂直模糊量。color:uint光晕颜色。inner:Boolean指定发光是否为内侧发光。knockout:Boolean指定对象是否具有挖空效果。quality:int应用滤镜的次数。strength:Number印记或跨页的强度。,2015/7/31
207,Java 修改Windows注册表，以实现开机自启动应用程序。,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9086,"使用Java修改Windows注册表，使用最基本的就是cmd命令。事例和运行结果如下所示：packageday01;importjava.io.IOException;/*1，regadd将新的子项或项添加到注册表中语法：regaddKeyName[/vEntryName|/ve][/tDataType][/sseparator][/dvalue][/f]参数KeyName指定子项的完全路径。对于远程计算机，请在\\ComputerName\PathToSubkey中的子项路径前包含计算机名称。忽略ComputerName会导致默认对本地计算机进行操作。以相应的子目录树开始路径。有效子目录树为HKLM、HKCU、HKCR、HKU以及HKCC。远程机器上只有HKLM和HKU。值说明HKCR：HKEY_CLASSES_ROOTHKCU：HKEY_CURRENT_USERHKLM：HKEY_LOCAL_MACHINEHKU：HKEY_USERSHKCC：HKEY_CURRENT_CONFIG/vEntryName指定要添加到指定子项下的项名称。/ve指定添加到注册表中的项为空值。/tDataType指定项值的数据类型。DataType可以是以下几种类型：REG_SZREG_MULTI_SZREG_DWORD_BIG_ENDIANREG_DWORDREG_BINARYREG_DWORD_LITTLE_ENDIANREG_LINKREG_FULL_RESOURCE_DESCRIPTORREG_EXPAND_SZ/sseparator指定用于分隔多个数据实例的字符。当REG_MULTI_SZ指定为数据类型且需要列出多个项时，请使用该参数。如果没有指定，将使用默认分隔符为""\0""。/dvalue指定新注册表项的值。/f不用询问信息而直接添加子项或项。/?在命令提示符显示帮助。注释该操作不能添加子树。该版本的Reg在添加子项时无需请求确认。下表列出了regadd操作的返回值。值说明0成功1失败*/publicclassTest00{/***Reg参数说明*/v所选项之下要添加或删除的值名*/tRegKey数据类型（reg_sz字符串）*/d要分配给添加的注册表ValueName的数据*/f不用提示就强行删除*/publicstaticvoidchangeStart(booleanisStartAtLogon)throwsIOException{StringregKey=""HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"";StringmyAppName=""mgtest"";StringexePath=""\""D:\\ProgramFiles(x86)\\love\\HelloWorld.exe\"""";Runtime.getRuntime().exec(""reg""+(isStartAtLogon?""add"":""delete"")+regKey+""/v""+myAppName+(isStartAtLogon?""/treg_sz/d""+exePath:""/f""));}publicstaticvoidmain(String[]args)throwsIOException{try{changeStart(true);}catch(IOExceptione){//changeStart(false);e.printStackTrace();}}}",2015/7/28
208,Oracle 中使用的%TYPE和%ROWTYPE类型的变量和复合变量,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9085,"游标(cursor)可以被看作指向结果集(asetofrows)中一行的指针(pointer)。在oracle数据库中可以使用显示或隐式两种游标。隐式游标：在执行一个sql语句时,oracle服务器将自动创建一个隐式游标,这个游标是内存中处理该语句的工作区域，其中存储了执行SQL语句的结果.通过游标的属性可获得sql语句执行的结果以及游标状态信息。游标的主要属性如下：%found布尔属性如果sql语句至少影响一行则为true否则为false%notfound布尔属性与%found相反。%isopen布尔属性游标是否打开打开为true否则为false%rowcount数字属性返回受sql语句影响的行数怎么来使用这些属性呢?则可以通过“sql属性名“来查看结果//%rowcount用来检查受影响的行SQL>declare2emp_rowemp%rowtype;3begin4select*intoemp_rowfromempwhereempno=7369;5dbms_output.put_line(sql%rowcount);6end;7/1//返回的结果为1//%found用来检查是否影响到了行SQL>begin2updateempsetsal=2000whereempno=7369;3ifsql%foundthen4dbms_output.put_line('更新记录成功影响了'||sql%rowcount||'行');5else6dbms_output.put_line('未更新记录');7endif;8end;9/更新记录成功影响了1行//%notfound//%isopen一以上两个的使用方式参考%found进行理解。另外一种隐式游标cursorforloop可用于处理sql语句的结果集SQL>begin23forrecin(select*fromemp)loop4dbms_output.put_line(rec.empno||'/'||rec.ename||'/'||rec.job||'/'||rec.mgr||'/'||rec.hiredate||'/'||rec.sal||'/'||rec.comm||'/'||rec.deptno);5endloop;6end;7/显示游标是在PL/SQL程序中使用包含select语句来声明的游标。如果需要处理从数据库中检索的一组记录,则可以使用显示游标.使用显示游标处理数据需要四个步骤：声明游标,打开游标，检索数据，关闭游标。1、声明游标声明游标就是通过定义游标的名称,游标的特性来声明游标,以及打开游标后就可调用查询语句,声明的语法如下：Cursorcursor_name[parameter[,parameter]….][returnreturn_type]isselect_statement;Parameter作为游标的输入参数,它可以让用户在打开游标式,向游标传递值；语法如下：Parameter_name[in]datatype[{:=|default}expression]\举例：declarecursoremp_cursor(pnoinnumber(4)default7369)isselect*fromempwhereempno=pno;2、打开游标就是指执行声明游标时指定的查询语句。打开的方式只需使用open打开语法：Opencursor_name(参数);如果没有指定参数就采用默认值执行select语句3、检索数据检索数据就是从检索到的结果集中获取数据保存到变量中,以便变量进行处理。使用fetch语句找出结果集中的单行,并从中提取单个值传递给主变量。语法如下：Fetchcursor_nameinto[variable_list[record_variable]]变量用于存储检索的数据4、关闭游标关闭游标使得用户不能再从查询结果中检索数据。使用完游标后应该关闭游标释放select语句的查询结果。语法：Close游标名称综上所述综合案例如下：SQL>declare2cursoremp_cursor(pnoinnumberdefault7369)//声明游标3isselect*fromempwhereempno=pno;45emp_rowemp%rowtype;//声明变量6begin7openemp_cursor(7934);//打开游标8fetchemp_cursorintoemp_row;//检索数据结果为一行9dbms_output.put_line(emp_row.ename);//输出检索结果1011closeemp_cursor;//关闭游标12end;13/游标for循环依次读取结果集中的行,当for循环开始时,游标会自动打开(不需要使用open方法开启),每循环读取一次,系统自动读取当前数据(不需要使用fetch),当退出for循环时,游标也会自动关闭(不需要使用close方法)。SQL>declare2cursoremp_cursor(pnoinnumberdefault7369)//声明游标3isselect*fromempwhereempno=pno;45begin6foremp_rowinemp_cursor(7934)loop//for循环开始时自动打开游标并且自动获取数据自动关闭7dbms_output.put_line(emp_row.ename);8endloop;9end;10/游标变量游标变量也可以处理多行查询结果集。游标变量的定义包括两个步骤：1、定义cursor类型的指针语法：Typeref_cursor_nameisrefcursor[returnreturn_type]举例：Typevar_cursor_nameisrefcursor;2、定义refcursor类型的变量v_rcvar_cursor_name;综合写法如下：Typevar_cursor_nameisrefcursor;v_rcvar_cursor_name;上面的综合声明的游标变量称为弱的refcursor类型,因为它没有指明游标返回的结果,因此它可以指向任何一个具有多列的select查询结果.相对于上面还有一种称为:强refcursor类型.声明方式如下：TypevarcursorNameisrefcursorreturnemp%rowtype;//指明了返回的结果VcnvarcursorName;//声明一个强的refcursor类型的变量使用游标变量与游标使用方式一样,也需要声明,打开,检索，关闭游标变量。综合案例如下：SQL>declare23typeemp_cnameisrefcursorreturnemp%rowtype;//声明游标变量第一步45ecnameemp_cname;//声明游标变量第二步67emp_rowemp%rowtype;//声明用于保存检索数据的变量89begin10dbms_output.put_line('开始');11openecnameforselect*fromempwhereempno=7934;//打开游标变量12loop13fetchecnameintoemp_row;//查询结果赋值给保存的变量14exitwhenecname%notfound;//退出条件15dbms_output.put_line(emp_row.ename);//输出结果16endloop;//退出循环17closeecname;//关闭游标变量18dbms_output.put_line('结束');19end;20/开始MILLER结束//复杂的案例SQL>declare23typeemp_cnameisrefcursorreturnemp%rowtype;45ecnameemp_cname;67emp_rowemp%rowtype;89begin10dbms_output.put_line('开始');11openecnameforselect*fromemp;12loop13fetchecnameintoemp_row;14exitwhenecname%notfound;15dbms_output.put_line(emp_row.ename);16endloop;17closeecname;18dbms_output.put_line('结束');19end;20/开始SMITHALLENWARDJONESMARTINBLAKECLARKSCOTTKINGTURNERADAMSJAMESFORDMILLER",2015/7/28
209,在windows 8 中不用再重装Wotalk了，设置其兼容性为window 7好了,康廷,http://180.168.156.212:2262/wecenter/?/article/9084,我在windows8中安装我们的wotalk聊天交流工具时，发现重启后没法使用，要再重装一次Wotalk。我发现了一个解决方法：就是在wotalk的快捷键上设置其兼容性为window7就正常使用了，不用再重装了。,2015/7/27
210,css兼容问题大全,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9083,兼容性一直都是个令人头痛的问题，下面简单总结火狐与IE的兼容性问题！！！css兼容问题大全.txt,2015/7/21
211,较常用的头部meta信息,李海波,http://180.168.156.212:2262/wecenter/?/article/9082,"<!--字体编码--><metacharset=""utf-8""/><!--关键字--><metaname=""keywords""content=""""/><!--说明--><metaname=""description""content=""""/><!--作者--><metaname=""author""content=""""/><!--设置文档宽度、是否缩放--><metaname=""viewport""content=""width=device-width,initial-scale=1.0,user-scalable=no""/><!--优先使用IE最新版本或chrome--><metahttp-equiv=""X-UA-Compatible""content=""IE=edge,chrome=1""/><!--360读取到这个标签立即钱换到极速模式--><metaname=""renderer""content=""webkit""/><!--禁止百度转码--><metahttp-equiv=""Cache-Control""content=""no-siteapp""/><!--UC强制竖屏--><metaname=""screen-orientation""content=""portrait""/><!--QQ强制竖屏--><metaname=""x5-orientation""content=""portrait""/><!--UC强制全屏--><metaname=""full-scerrn""content=""yes""/><!--QQ强制全屏--><metaname=""x5-fullscreen""content=""ture""/><!--QQ应用模式--><metaname=""x5-page-mode""content=""app""/><!--UC应用模式--><metaname=""browsermode""content=""application""><!--windowphone点亮无高光--><metaname=""msapplication-tap-highlight""content=""no""/><!--安卓设备不自动识别邮件地址--><metaname=""format-detection""name=""email=no""/><!--iOS设备--><!--添加到主屏幕的标题--><metaname=""apple-mobile-web-app-title""content=""标题""/><!--是否启用webApp全屏--><metaname=""apple-mobile-web-app-capable""content=""yes""/><!--设置状态栏的背景颜色，启用webapp模式时生效--><metaname=""apple-mobile-web-app-status-bar-style""content=""black-translucent/black/default""/><!--半透明/黑色/默认白色--><!--禁止数字识别为电话号码--><metaname=""format-detection""content=""telephone=no""/><!--iOS图标iPhone/iTouch默认是57*57iPad，72*72，可以没有，但推荐有RetinaiPhone/RetinaiTouch，114*114,可以没有，但推荐有RetinaiPad,144*144,可以没有，但推荐有iPhone6plus是180*180，iPhone6是120*120--><linkrel=""apple--touch-icon-precomposed""sizes=""width*height""href=""xxx.png""/><!--iOS启动画面--><!--iPad启动是不包含状态栏的--><!--标准分辨率：1、竖屏(768*1004)；2、横屏(1024*748)Retina:1、竖屏(1536*2008)；2、横屏(2048*1496)--><!--iPhone/iTouch启动是包含状态栏的--><!--标准分辨率(320*480)、Retina(640*960)、iPhone5/iTouch5(640*1136)--><linkrel=""apple-touch-startup-image""sizes=""width*height""href=""xxx.png""/><!--iPhone6对应的图片大小是750×1294，iPhone6Plus对应的是1242×2148--><linkrel=""apple-touch-startup-image""href=""xxx.png""media=""(device-width:375px)""><linkrel=""apple-touch-startup-image""href=""xxx.png""media=""(device-width:414px)""><!--智能添加广告条--><metaname=""apple-itunes-app""content=""app-id=myappstoreID,affiliate-data=myaffiliatedata,app-argument=myurl""/>",2015/7/21
212,flexpaper的二次开发总结,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9081,"我的项目名称为FlexPaper,修改flexPaper.mxml如下：<?xmlversion=""1.0""encoding=""utf-8""?><mx:Applicationxmlns:mx="" 文件中开头已经定义一个获取flex对象的方法window.$FlexPaper=window[""$FlexPaper""]=function(){if(window['flexpaper'])returnwindow['flexpaper'];elsewindow['flexpaper']=window.FlexPaperViewer_Instance.getApi();returnwindow['flexpaper'];};那么我们就可以这样用了：varpdf=$FlexPaper();pdf.loadSwf(encodeURI(swf));到此，先记下这些，后面继续研究。",2015/7/9
213,MATERIAL DESIGN的设计思想,康廷,http://180.168.156.212:2262/wecenter/?/article/9080,MATERIALDESIGN的设计思想Materialdesign这套设计风格非常鲜明，带有浓郁的Google式严谨和理性哲学Materialdesign的设计规范细致入微，需要消化好一阵子。越读越感受到它的妙处，假如每个细节都严格遵照Materialdesign的思想来设计，哪怕你不是设计人员，你的产品也一定不会难用和难看。当然，作为设计师，要求就更高了。设计文档本身，就提供了一种很好的方式，帮你从各个角度思考和构建自己产品的规范。但在这之前，先要好好整理一下学习笔记。要打破规矩，必先掌握规矩。一、核心思想Materialdesign的核心思想，就是把物理世界的体验带进屏幕。去掉现实中的杂质和随机性，保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果。Materialdesign是最重视跨平台体验的一套设计语言。由于规范严格细致，保证它在各个平台使用体验高度一致。不过目前还只有Google自家的服务这么做，毕竟其他平台有自己的规范与风格。三、动画Materialdesign重视动画效果，它反复强调一点：动画不只是装饰，它有含义，能表达元素、界面之间的关系，具备功能上的作用。转场效果通过过渡动画，表达界面之间的空间与层级关系，并且跨界面传递信息。细节动画通过图标的变化和一些细节来达到令人愉悦的效果。五、图标桌面图标桌面图标尺寸是48dpX48dp。桌面图标建议模仿现实中的折纸效果，通过扁平色彩表现空间和光影。注意避免以下问题：不要给彩色元素加投影层叠不要超过两层十、设置界面设置和帮助反馈通常放在侧边抽屉中。如果没有侧边抽屉，则放在Appbar的下拉菜单底部。设置界面只能包含设置项，诸如关于、反馈之类的界面，入口应该放在其他地方。设置项使用通栏分隔线来分组。7项以下不必分组。如果某项独立一组，考虑把它放在顶部（重要）或放在底部的“其他”一栏中（不重要）。设置项较多时尝试合并，比如把两个相关的勾选项合并成一个多选项。设置项非常多时，使用子界面。转载自： /comprehen...te%23,2015/7/6
214,产品经理的三部曲：当前版本、下个版本、需求池,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/9079,相信大家看过不少关于产品的文章和书籍，道长看过不少，很多不错，不过要说系统的用到工作中，是比较散的，今天跟大家聊的是产品经理做事情的三部曲。在我的工作过程中，我永远都用重点和预期，不会出现没有事儿做或者开发没事干的情况，对公司负责，对团队成员的成长也负责。第一步：当前版本当前版本即是正在开发中的版本，当前版本进行的过程中，产品经理需要关心和做的事儿至少有这三点：第一是开发有没有碰到难点，以及碰到的难点的解决方案，是能解决还是妥协掉体验还是就实现不了，这种情况在创业公司团队还是有发生的，我们跟牛逼的开发团队是不能比的，很多问题都是在开发的过程中才会体现出来，这个时候产品经理就需要有很好的问题处理能力了;第二是已经完成的需求点的关心，安排给测试尽快测，产品经理自己也需要去亲自用，看开发的结果跟需求是否有出入，视情况处理;第三是写下个版本的需求。第二步：下个版本下个版本的规划并且落实到需求文档，功能点需要根据产品情况和规划来做，需要区分功能优先级和功能性质。先说说优先级，按照“四象限法”来进行归类，像重大问题修复、重要体验优化、重要的新功能这种优先级肯定是最高的;功能性质是新增和改进，这个做好沟通和准备，新功能有可能会涉及到调研或者人力成本增加，另外要考虑，新功能会带来的影响，比如对用户的影响和运营新功能的方法这些，需要更运营团队沟通和预先有方案。第三步：需求池需求池是存放跟产品有关的未来可能会做的功能点子的地方，拿我们的产品来举例，在道长的需求池里面，会在现有“展览、发现、我的”三个帧上面增加一个帧，暂且叫“碎片”，这帧是未来给用户带来跟艺术相关的内容，呈现方式是文字、图片和视频，内容形式包括艺术家/策展人/批评家/达人专访。我对需求池的建议有两点，第一是不必考虑能不能做或者是做了没用什么的这样的限制，先不必设置伪命题，只要是觉得OK的，都先列出来;第二点是最好用xmind来做，每个点子是属于哪一个模块的，如果是已经做了，标记出来，这样方便检查和对比。以上就是道长的三部曲，走起来很有节奏，你仔细思考会发现，这三步是一个闭环，本篇文章主要想表达做事的方法，不讨论做事的细节，好了，祝天下还在加班的产品经理幸福安康。,2015/7/6
215,oracle 导出空表的解决办法,胡增辉,http://180.168.156.212:2262/wecenter/?/article/9078,1、Oracle11g默认对空表不分配segment，故使用exp导出Oracle11g数据库时，空表不会导出。2、设置deferred_segment_creation参数为FALSE后，无论是空表还是非空表，都分配segment。在sqlplus中，执行如下命令：SQL>altersystemsetdeferred_segment_creation=false;查看：SQL>showparameterdeferred_segment_creation;该值设置后只对后面新增的表产生作用，对之前建立的空表不起作用。3、可以使用手工为空表分配Extent的方式，来解决导出之前建立的空表的问题。说明如下：3.1使用ALLOCATEEXTENT的说明使用ALLOCATEEXTENT可以为数据库对象分配Extent。其语法如下：-----------ALLOCATEEXTENT{SIZEinteger[K|M]|DATAFILE'filename'|INSTANCEinteger}-----------可以针对数据表、索引、物化视图等手工分配Extent。ALLOCATEEXTENT使用样例:ALLOCATEEXTENTALLOCATEEXTENT(SIZEinteger[K|M])ALLOCATEEXTENT(DATAFILE'filename')ALLOCATEEXTENT(INSTANCEinteger)ALLOCATEEXTENT(SIZEinteger[K|M]DATAFILE'filename')ALLOCATEEXTENT(SIZEinteger[K|M]INSTANCEinteger)针对数据表操作的完整语法如下：-----------ALTERTABLE[schema.]table_nameALLOCATEEXTENT[({SIZEinteger[K|M]|DATAFILE'filename'|INSTANCEinteger})]-----------故，需要构建如下样子简单的SQL命令：-----------altertableaTabelNameallocateextent-----------3.2构建对空表分配空间的SQL命令，查询当前用户下的所有空表（一个用户最好对应一个默认表空间）。命令如下：-----------SQL>selecttable_namefromuser_tableswhereNUM_ROWS=0;-----------根据上述查询，可以构建针对空表分配空间的命令语句，如下：-----------SQL>Select'altertable'||table_name||'allocateextent;'fromuser_tableswherenum_rows=0-----------批量输出上述生成的SQL语句，建立C:\createsql.sql，其内容如下：-----------setheadingoff;setechooff;setfeedbackoff;settermouton;spoolC:\allocate.sql;Select'altertable'||table_name||'allocateextent;'fromuser_tableswherenum_rows=0;spooloff;-----------执行C:\createsql.sql，命令如下：-----------SQL>@C:\createsql.sql;-----------执行完毕后，得到C:\allocate.sql文件。打开该文件会看到，已经得到对所有空表分配空间的命令SQL语句。3.3执行SQL命令，对空表分配空间：执行C:\allocate.sql，命令如下：-----------SQL>@C:\allocate.sql;-----------执行完毕，表已更改。3.4此时执行exp命令，即可把包括空表在内的所有表，正常导出。另外：Oracle11g中，对密码是大小写敏感的，即密码中的字母是区分大小写的。在Oracle10g中及以前，密码中的字母大小写无所谓。,2015/7/6
216,搞定网页重设计的7个必要环节,康廷,http://180.168.156.212:2262/wecenter/?/article/9077,网站更新迭代重新设计恐怕是许多网站必经的环节，如何做好网页重设计也是许多设计师和产品人需要考量的事情。今天的这篇文章就是著名电商平台Shopify针对旗下企业服务平台ShopifyPlus重设计改版的一些经验总结，希望能给大家带来一些启示~~~ShopifyPlus是Shopify的企业版电子商务托管平台，自从2014年2月发布之后，至今只做过一次更新迭代，也正是在这种情况下，我提出了对网站进行重设计的建议。在这长达一年的时间里，我们对于自己的客户有更加深入的了解，也清楚地认识到老品牌和旧设计已经不再适应现在的情况了。不同的公司和不同的团队，对于重设计有着不同的需求和考量，自然也就有着不同的流程。我们并未遵循某种特定流程，但是在迭代过程中，我们做好了下面7件环节，最终得到了我们想要的结果。1、访谈我对我们的决策团队的每一个成员进行了一对一的面谈，借此明确他们心中的ShopifyPlus到底是什么。为了接近真实，每次访谈我都会作笔记并且录音，随后繁复回放，仔细研究。访谈之后，通常能从中获取灵感——从那里能了解关于产品的各种细节。这样一来，无论是产品未来的愿景、目标、品牌指南、项目原则还是网站文案，都比较容易确认。作为一个网站而言，更好的传达信息，才能真正让用户感到惊喜。2、项目简介在真正开始深入开发之前，我们需要写一份项目简介，确保每个参与者的信息和进度保持一致。我们会根据项目的实际情况，随时对简介内容进行调整和修改，实时更新。通常，项目简介会回答以下问题：?我们正在试图达到什么目的？?我们如何确认这个项目是成功的？?我们需要做什么事情？?我们为什么需要这样做？?哪些事情是非做不可的？?我们为谁在做这些事情？?他们如何了解这些事情？?项目团队中包含哪些人？?我们的最后期限是什么时候？3、竞品分析我们还需要仔细审视我们的对手。为此我们列出了竞争对手的列表，并开始了解在电子商务领域以外我们的产品如何服务于目标客户的。我们会对比我们和对手之间的优势、劣势，我们碰到的机遇，独有的特色，以及需要规避的问题。4、信息架构合理可靠的信息架构能够有效地将内容组织起来，让信息更容易被用户获取并理解。在进行网页设计的时候，用结构化的示意图来呈现整个网站各屏之间的关系，能够使你从更高的层面上来把握整个网站。于是，我先用结构示意图画出老版本网站的各屏关系。在更新升级之前，我充分屏幕了其中的内容、目标和流量分布，并提出了建议。结构示意图帮助我们界定项目实施的范畴，就像一份详尽的核对清单，让我们在组织内容、设计界面、编写代码的时候更为清晰明了。5、线框图在重设计过程中，我会使用线框图来勾勒整体，帮我思考问题，打通思路。有人喜欢在将想法涂鸦在餐巾纸之上，有人喜欢面对面分享想法，还有人喜欢将想法落实于草稿在线分享。线框图的好处在于，你可以快速、便捷地填充不同的内容。仅落实于文档的思路不够具象，粗略的草稿不够规整，线框图能较好规避这些问题，不同类型的内容整齐地排列在一起，你可以清晰掌控布局，模块与模块之间的关系。高精度的ShopifyPlus重设计线框图6、启发板我们会在启发版（Inspirationboard）上展现新品牌的视觉设计，展现它可能的样子，这也是我从团队获取支持的一种方式。同时我们还会使用Pinterest，为了防止我们在单个画板中泥足深陷，我们创造了多个画板，为导航、动效、排版等不同领域，有针对性地搜集案例，获取灵感。当我有想法的时候，会在AI中进行勾勒，它们通常都是文字、图像和色彩的结合体，看起来形同广告。随后，相同相近的设计元素会出现在我们的草稿中，不过其中各元素的位置和外观，会有所不同，并且有许多不同的版本。ShopifyPlus的启发板在启发板上对ShopifyPlus品牌进行探索7、视觉稿和原型很多人并不在意印在纸上的线框图和视觉稿。的确，直接在屏幕上看看还挺不错，但是直接查看落实于纸面上的线框图、视觉稿和原型效果更好。另外，我在线框图绘制阶段就开始制作可交互的视觉稿（原型？），并且拿这些东西同客户进行沟通交流，一直到它们最终被落实为代码和实际的从程序。ShopifyPlus的InVision项目页面为ShopifyPlus搜集反馈转载自： ,2015/7/3
217,组件库4.0中组件的参数问题？,刘冬1,http://180.168.156.212:2262/wecenter/?/article/9076,组件库4.0中大部分组件的参数都是JSON对象，能否同时支持JSON格式的字符串呢？这样是不是更方便？在组件中eval一下是否就可以呢？,2015/6/30
218,深入理解java回收机制,孙荟博,http://180.168.156.212:2262/wecenter/?/article/9075,深入理解java回收机制java垃圾回收机制.docx,2015/6/30
219,Eclipse Mars 正式版发布，列数 10 大特点,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9074,"代号Mars的Eclipse4.5版本发布了，这一版本在Linux工具中结合了额外的Docker工具，更好地支持Maven和Gradle（包括对嵌入工具的更新），提升了Java8的特性，并通过EclipseMarketplace支持对Java9早期访问。主要更新内容有以下几个方面：新JavaIDE特性，包括对嵌套的项目层次视图，可自定义perspectives，并提升了文本搜索的速度。集成的工具，用于建立和维护Docker容器，可在LinuxTools项目获取.Oomph项目现在能够跨工作区记录和分享个人偏好设置。Gradle新的集成，使得更加容易管理Gradle构建，通过Buildship项目。提升对Maven支持，包括支持Maven3.3.3,提升Maven原型整合和在pom编辑器中的自动完成。自动错误报告，让Eclipse用户可以直接报告错误到Eclipse项目。新的Thym项目提供了使用ApacheCordova创建跨平台移动应用的工具。下面，是一篇对EclipseMars的分析文章：EclipseMars来了！在过去的十天里，我一直在细数最令我兴奋的十个EclipseMars的特点。想了解最新特性的详细信息，请查看以下链接：10.MacApplicationLayout9.PlatformImprovements8.UIMonitoring7.C/C++Launching6.e4Tools5.JDTImprovements4.DockerTools3.GitFlowinEclipse2.EclipseAutomaticErrorReporting今年EclipseMars将完全提供一个下载和使用IDE新的方法。不用单独下载每个包，Oomph的Eclipse安装包可以提你想要的安装包。你可以通过“bundlepool”在安装程序之间分享Eclipse插件。这就意味着如果你安装了其他的包，所有常见的位就会被共享。一旦Eclipse启动，你可以通过走完EclipseWelcomeQuestionnaire流程来按你的喜好设置Eclipse。除了提供IDE给你，Oomph还能安装你的工作空间。这就是说可以从Git中复制项目，配置你的目标平台，初始化项目设置等等。一旦Eclipse启动，选择File->Import->Oomph->Projects进入Workspace。几个Eclipse项目已经配置好并且可以一键安装。Oomph甚至提供工具帮你创作自己的安装文件。Oomph的Eclipse安装器可以让安装，配置，分享Eclipse项目变得更容易。如果你是名使用者，你能从简单的安装过程中受益。如果你是位贡献者，你也能轻松设置你的工作空间；如果你是提交者，你可以创建配置文件，帮助他人获取你的项目。",2015/6/29
220,HTML5 Page Visibility API,孙荟博,http://180.168.156.212:2262/wecenter/?/article/9073,PageVisibilityAPIPageVisibilityAPI.docx,2015/6/29
221,js中setInterval与setTimeout用法,何文,http://180.168.156.212:2262/wecenter/?/article/9072,"setTimeout定义和用法:setTimeout()方法用于在指定的毫秒数后调用函数或计算表达式。语法:setTimeout(code,millisec)code（必需）：要调用的函数后要执行的JavaScript代码串。millisec（必需）：在执行代码前需等待的毫秒数。提示：setTimeout()只执行code一次。如果要多次调用，请使用setInterval()或者让code自身再次调用setTimeout()。两种调用函数的写法：functionpage_list(){alert(""shihuan"");}window.setTimeout(page_list,5000);//表示延时5秒执行page_list()函数window.setTimeout(""page_list()"",30000);//表示延时30秒执行page_list()函数带参数方法使用setTimeout要注意，setTimeout(""函数名(""+参数+"")"",毫秒数)，这里的参数只能是字符串形式的，而不能传递一个对象，网上很多朋友也在问此类问题，我在此说明下，以下我举几个个简单的例子：网上查找下“带参数setTimeout”，很多朋友写了很多方法来实现使用setTimeout带对象的方法循环，例如：<scriptlanguage=""javascript"">var__sto=setTimeout;window.setTimeout=function(callback,timeout,param){varargs=Array.prototype.slice.call(arguments,2);var_cb=function(){callback.apply(null,args);}__sto(_cb,timeout);}//测试代码functionshihuan(a){alert(a);}functionyushibo(a,b,c){alert(a+b+c);}vara=newObject();window.setTimeout(shihuan,1000,a);window.setTimeout(yushibo,2000,a,6,7);</script>此例中，setTimeout用法，setTimeout(回调函数,时间,参数1,...,参数n)。--------------------------------------------------------------------------------------------------定义和用法setInterval()方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval()方法会不停地调用函数，直到clearInterval()被调用或窗口被关闭。由setInterval()返回的ID值可用作clearInterval()方法的参数。语法setInterval(code,millisec[,""lang""])参数描述code必需。要调用的函数或要执行的代码串。millisec必须。周期性执行或调用code之间的时间间隔，以毫秒计。返回值一个可以传递给Window.clearInterval()从而取消对code的周期性执行的值。例子：<html><body><form><inputtype=""text""id=""clock""size=""35""/><scriptlanguage=javascript>varint=self.setInterval(""clock()"",50)functionclock(){vart=newDate()document.getElementByIdx_x_x_x_x_x(""clock"").value=t}</script></form><buttononclick=""int=window.clearInterval(int)"">Stopinterval</button></body></html>--------------------------------------------------------------------------------------------------clearTimeout()和clearInterval()：JS里设定延时：使用SetInterval和设定延时函数setTimeout很类似。setTimeout运用在延迟一段时间，再进行某项操作。setTimeout(""function"",time)设置一个超时对象setInterval(""function"",time)//设置一个超时对象SetInterval为自动重复，setTimeout不会重复。clearTimeout(对象)清除已设置的setTimeout对象clearInterval(对象)清除已设置的setInterval对象一、什么叫做JavaScript的计时事件使用JavaScript可以实现代码的延时执行，也就是说当一个函数被调用时不立即执行某些代码，而是等一段指定的时间后再执行，这就叫做计时事件。二、JavaScript的计时事件的函数setTimeout()//-在指定时间后执行代码clearTimeout()//-取消setTimeout()注意:setTimeout()和clearTimeout()都是HTMLDOM的Window对象的函数。三、setTimeout详解vart=setTimeout(""javascript语句"",时间参数)注：时间参数单位为毫秒示例：vart=setTimeout(""alert('3seconds!')"",3000)如果js语句带变量，则必须用+号将变量连接起来，如：vart=setTimeout（""document.getElementByIdx_x_x_x_x_x(""+menuid+"").style.display='none'"",3000)四、clearTimeout详解语法：clearTimeout(setTimeout的变量名)示例：clearTimeout(t)//其中t为前面设置的setTimeout的变量使用clearTimeout可以随时停止计时。五、应用技巧建议将setTimeout单独设置为一个函数。如：functiondelayRun(code,time){vart=setTimeout(code,time);}这样，在需要让某段代码延时执行的时候，只需在这段代码前加入这个函数就可以了。如：onmouseover=delayRun(""setTab(0,0)"",500)其中setTab是一个自定义的函数。如果以后不想让setTab延时执行，则去掉语句中的delayRun相关的代码即可，改为：onmouseover=setTab(0,0)就可以了。这种写法避免每一个需要延时的地方都写一段setTimeout的代码，只需要直接调用就可以了，很方便。也节省了代码的量。",2015/6/29
222,JS无需确认直接关闭当前窗口,何文,http://180.168.156.212:2262/wecenter/?/article/9071,"if(""shihuan""==""shihuan""){alert(""一个IP地址只允许打开一个浏览器访问本系统!"");window.opener=null;window.open('','_self');window.close();}--------------------------------------------------------------------------------------------------适用于Chrome，IE6，Safari等几种浏览器的关闭方法：varopened=window.open('about:blank','_self');opened.opener=null;opened.close();--------------------------------------------------------------------------------------------------JS关闭窗口或JS关闭页面的几种代码//JS关闭窗口或JS关闭页面的几种代码JS定时自动关闭窗口<scriptlanguage=""javascript""><!--functionclosewin(){self.opener=null;self.close();}functionclock(){i=i-1document.title=""本窗口将在""+i+""秒后自动关闭!"";if(i>0)setTimeout(""clock();"",1000);elseclosewin();}vari=10clock();//--></script>第二种：点击链接没有提示的JS关闭窗口<ahref=""javascript:self.close()"">关闭窗口</a>第三种：窗口没有提示自动关闭的js代码<scriptlanguage=javascript><!--this.window.opener=null;window.close();//--></script>IE6-7JS关闭窗口不提示的方法方法一：js代码functionCloseWin()//这个不会提示是否关闭浏览器{window.opener=null;//window.opener=top;window.open("""",""_self"");window.close();}方法二：open.htmljs代码functionopen_complex_self(){varobj_window=window.open('close.html','_self');obj_window.opener=window;obj_window.focus();}close.htmljs代码window.close();另附：//普通带提示关闭functioncloseie(){window.close();}//关闭IE6不提示functioncloseie6(){window.opener=null;window.close();}//关闭IE7不提示functioncloseie7(){window.open('','_top');window.top.close();}",2015/6/29
223,Java获取客户端IP地址,何文,http://180.168.156.212:2262/wecenter/?/article/9070,"在JSP里，获取客户端的IP地址的方法是：request.getRemoteAddr（），这种方法在大部分情况下都是有效的。但是在通过了Apache，Squid等反向代理软件就不能获取到客户端的真实IP地址了。如果使用了反向代理软件，将 p时，则能返回客户端的真实IP地址，写了个方法去验证。原因出在了Squid上。squid.conf的配制文件forwarded_for项默认是为on，如果forwarded_for设成了off则：X-Forwarded-For：unknown于是可得出获得客户端真实IP地址的方法二：Java代码：publicStringgetIpAddr(HttpServletRequestrequest){Stringip=request.getHeader(""x-forwarded-for"");if(ip==null||ip.length()==0||""unknown"".equalsIgnoreCase(ip)){ip=request.getHeader(""Proxy-Client-IP"");}if(ip==null||ip.length()==0||""unknown"".equalsIgnoreCase(ip)){ip=request.getHeader(""WL-Proxy-Client-IP"");}if(ip==null||ip.length()==0||""unknown"".equalsIgnoreCase(ip)){ip=request.getRemoteAddr();}returnip;}可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串Ip值，究竟哪个才是真正的用户端的真实IP呢？答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。如：X-Forwarded-For：192.168.1.110，192.168.1.120，192.168.1.130，192.168.1.100用户真实IP为：192.168.1.110最近做一个安全系统，需要对用户的ip和mac地址进行验证，这里用到获取客户端ip和mac地址的两个方法，留存。1.获取客户端ip地址(这个必须从客户端传到后台)：jsp页面下，很简单，request.getRemoteAddr();因为系统的VIew层是用JSF来实现的，因此页面上没法直接获得类似request，在bean里做了个强制转换Java代码：publicStringgetMyIP(){try{FacesContextfc=FacesContext.getCurrentInstance();HttpServletRequestrequest=(HttpServletRequest)fc.getExternalContext().getRequest();returnrequest.getRemoteAddr();}catch(Exceptione){e.printStackTrace();}return"""";}2.获取客户端mac地址调用window的命令，在后台Bean里实现通过ip来获取mac地址。方法如下：Java代码：publicStringgetMACAddress(Stringip){Stringstr="""";StringmacAddress="""";try{Processp=Runtime.getRuntime().exec(""nbtstat-A""+ip);InputStreamReaderir=newInputStreamReader(p.getInputStream());LineNumberReaderinput=newLineNumberReader(ir);for(inti=1;i<100;i++){str=input.readLine();if(str!=null){if(str.indexOf(""MACAddress"")>1){macAddress=str.substring(str.indexOf(""MACAddress"")+14,str.length());break;}}}}catch(IOExceptione){e.printStackTrace(System.out);}returnmacAddress;}补充：关于获取IP地址的方式，最近在linux下有一个教训，如果单纯通过InetAddress来获取IP地址，就会出现在不同的机器上IP地址不同的问题。InetAddress.getLocalHost().getAddress()实际上是根据hostname来获取IP地址的。linux系统在刚刚装完默认的hostname是localhost，所以通过上面代码获取到的本机ip就是127.0.0.1,相对应，比如我的hostname就是rjlin.atsig.com返回的ip地址确是atsig.com的地址。暂时采用下面代码来处理，当然还不够灵活：Java代码：publicstaticbyte[]getIp()throwsUnknownHostException{byte[]b=InetAddress.getLocalHost().getAddress();EnumerationallNetInterfaces=null;try{allNetInterfaces=NetworkInterface.getNetworkInterfaces();}catch(SocketExceptione){e.printStackTrace();}InetAddressip=null;NetworkInterfacenetInterface=null;while(allNetInterfaces.hasMoreElements()){netInterface=(NetworkInterface)allNetInterfaces.nextElement();if(netInterface.getName().trim().equals(""eth0"")){Enumerationaddresses=netInterface.getInetAddresses();while(addresses.hasMoreElements()){ip=(InetAddress)addresses.nextElement();}break;}}if(ip!=null&&ipinstanceofInet4Address){returnb=ip.getAddress();}returnb;}",2015/6/29
224,Oracle11g导出空表,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9069,Oracle11g导出空表Oracle11g导出空表.md,2015/6/29
225,ECharts使用心得,何文,http://180.168.156.212:2262/wecenter/?/article/9068,"Echarts图标统计ECharts，缩写来自EnterpriseCharts，商业级数据图表，一个纯Javascript的图表库，可以流畅的运行在PC和移动设备上，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari等），提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。js文件夹：下载了ECharts之后，解压缩，如解压后的根目录是echarts-2.0.4，则到echarts-2.0.4\doc\example\www路径下，把里面的js文件夹直接复制粘贴到项目的WebRoot建一个jsp文件，在开头引入js<scriptsrc=""${componentPath}/js/vote/esl.js""></script>3、为ECharts准备一个具备大小（宽高）的div<divid=""mainBar""style=""height:500px;border:1pxsolid#ccc;padding:10px;""></div>4、为模块加载器配置echarts的路径，从当前页面链接到echarts.js，定义所需图表路径require.config({paths:{echarts:'./echarts/echarts','echarts/chart/map':'./echarts/echarts-map'}});5、动态加载echarts然后在回调函数中开始使用，注意保持按需加载结构定义图表路径require(['echarts','echarts/chart/map'],6、创建ECharts图表方法myChart.setOption({tooltip:{trigger:'item',formatter:""{a}<br/>{b}:{c}({d}%)""},legend:{orient:'vertical',x:'left',data:label},calculable:true,series:[{name:'投票统计',type:'pie',radius:'55%',center:['50%','60%'],itemStyle:{normal:{label:{show:true,formatter:'{c}:{b}({d}%)'},labelLine:{show:true}}},data:(function(){varres=[];varlen=label.length;for(vari=0;i<len;i++){res.push({value:value[i],name:label[i]});}returnres;})()}]},true);Title:标题，每个图表最多仅有一个标题控件，每个标题控件可设主副标题Tooltip:提示框，鼠标悬浮交互时的信息提示Legend:图例，每个图表最多仅有一个图例Toolbox:工具箱，每个图表最多仅有一个工具箱xAxis:横轴通常为类目型，但条形图时则横轴为数值型，散点图时则横纵均为数值型yAxis:纵轴通常为数值型，但条形图时则纵轴为类目型series:sereis的数据:用于设置图表数据之用。series是一个对象嵌套的结构；对象内包含对象",2015/6/29
226,JFinal 2.0 发布，JAVA 极速 WEB+ORM 框架,陆开奇,http://180.168.156.212:2262/wecenter/?/article/9067,"JFinal2.0继续专注于极速开发，将极速进行到底!从控制层到业务层再到Model层，以及未来的在View层一直极速下去！以下是本次版本升级的主要功能：一、极速化业务层AOP支持JFinal2.0对业务层AOP提供了极速化支持，成为本星球第一个支持极速加特效的MVC+ORM+AOP框架，只需Duang.duang(target)即可添加特效，以下是代码示例：publicvoidpay(){Serviceservice=Duang.duang(Service.class,Tx.class);service.justDoIt(para);}只需要通过Duang.duang(target,interceptors)即可为任意目标组件极速添加特效。当然，还有更多愉快的用法，例如：publicclassOrderService{@Before(Tx.class)//拦截器与控制层完全一样的用法publicvoidjustDoIt(){}}以上是JFinal粉丝们一直钟爱的控制层拦截器用法，现在此用法可用于业务层，除此之外，还提供了拦截器注入用法，可以在无侵入target的同时为其添加特效，target可以完全不知道AOP的存在：publicvoidaction(){//在controller中可直接用enhance()enhance(target,interceptors).justDoIt();//在其它地方可使用Enhancer.enhance()Enhancer.enhance(target,interceptors).justDoIt();}JFinal2.0全程AOP支持，并没有引入IOC容器，从而也不需要引入与IOC容器相配套的一坨坨XML，不需要花费精力去码XML，即可愉快地玩耍。在SSH时代到处是一坨坨的XML累到死，然而并没有什么卵用！二、极速化redis支持publicvoidplay(){Redis.use().put(key,value);Redis.use().get(key);}代码量依然少到极致，但又不失功能的完备，hash、set、zset、list的API保持了redis原有的命名，使学习成本降至最低。RedisPlugin可同时支持多个redis实例，只需要指定cacheName即可：Redis.use(""jfinalWeb"").put(key,value)三、极速化ActiveRecord复合主键支持publicvoidplay(){//映射时指定多主键,用逗号分隔arp.addMapping(tableName,""id1,id2,idn"",modelClass);//使用方式，传入多主键即可model.findById(id1,id2,idn);model.deleteById(id1,id2,idn);}支持任意多个复合主键，不局限于两个主键，JFinal会自动进行复合主键数量判断，避免主键数量不符时出错。四、极速化Model多数据源多table支持当不同数据源中的相同表结构的table需要共享同一个Model时，本特性非常有用，用法依然极速：publicvoidplay(){//从主数据源中取数据并保存到另一数据源model.findById(id).use(""otherDataSource"").save();}此特性用于多数据源的多table共享同一个Model的情况，如果Model唯一对应某个数据源的某个table，数据源的切换是自动且透明的。本功能实现仅用了6行代码，JFinal架构可扩展性就是这么碉堡。五：极速化i18n支持publicvoidplay(){ResresEn=I18n.use(""en_US"");StringmsgEn=resEn.get(""msg"");StringmsgEnFormat=resEn.format(""msg"",""james"",newDate());ResresZh=I18n.use(""zh_CN"");StringmsgZh=resZh.get(""msg"");StringmsgZhFormat=resZh.format(""msg"",""詹波"",newDate());}立足于实践，对i18n进行了全面增强，更加极速的用法详见JFinal手册。有朋友在说，JFinal2.0加了这么多特效，还让不让SSH们有心思继续堆XML了啊？没办法，以下还有更多特效继续冲击：JFinal2.0changelog：1：极速化业务层AOP支持2：极速化redis支持3：极速化ActiveRecord复合主键支持4：极速化Model多数据源多table支持5：极速化i18n支持6：ActionInvocation更名为Invocation7：ClearInterceptor更名为Clear，并增强功能，支持移除指定的拦截器，删掉ClearyLayer8：添加Model.findFirstByCache(...)、Db.findFirstByCache(...)，方便对单个对象进行缓存，省时省力省代码9：Model.findById带Stringcolumns参数的方法更名为findByIdLoadColumns10：删除Db.findById带Stringcolumns的方法，可用Db.findFirst代替11：改进Validator，添加系列方法支持urlPara验证。添加setDatePattern(...)方法可指定Date的pattern12：Db.batch(...)系列方法添加事务及嵌套事务支持13：添加Config.isInTransaction()方法14：EncryptionKit更名为HashKit，并添加盐值生成方法generateSalt()15：改进Tx拦截器，放行ActionException，便于renderError正确响应errorcode16：添加Sqls工具类，用于加载和使用外部sql文件，例如：User.dao.find(Sqls.get(""findAll""));17：ActiveRecord添加SqlServerDialect支持SqlServer数据库18：添加Controller.getParaValuesToLong(String)方法19：添加OreillyCos.setFileRenamePolicy(...)支持自定义上传文件重名时的更名策略20：改进ActionMapping，在actionKey重复时终止启动而非输出警告，优化Action映射，进一步提升系统启动速度21：TableBuilder重构，进一步减少代码量、提升性能，提高可读性22：添加com.jfinal.ext.kit.ElResolverListener支持weblogic等容器注册EL增强23：CacheInterceptor添加JsonRender支持24：去掉了Render类中所有方法的final关键字，更加便于扩展自定义render25：添加PathKit.setRootClassPath(...)方法，便于在如Resin这类容器下无法自动探测class目录时使用26：JsonKit、JsonRender默认转换深度增大到15层27：添加DbKit.removeConfig(...)方法，便于动态管理多数源28：改进JettyServer在启动过程中允许抛出异常终止启动并退出JVM29：改进ActionException在renderError(...)时支持viewPath30：移除SpringPlugin31：改进PropKit，对多线程更加严格，让PropKit的重度使用者以及有代码洁癖工程师更加顺爽32：改进Controller，urlPara转换错误由500error改为404error33：添加Controller.checkUrlPara(...)系列方法，支持严格url，避免出现多余urlPara34：Tx拦截器开放getConfigWithTxConfig()方法，方便扩展自定义事务拦截器35：改进OneConnectionPerThread支持事务以及嵌套拦截36：TxByActionMethods更名为TxByMethods，可用于拦截控制层于业务层37：删除Controller、Constants中与i18n有关代码",2015/6/25
227,oracle分区详解,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9066,"此文从以下几个方面来整理关于分区表的概念及操作:1.表空间及分区表的概念2.表分区的具体作用3.表分区的优缺点4.表分区的几种类型及操作方法5.对表分区的维护性操作.(1.)表空间及分区表的概念表空间：是一个或多个数据文件的集合，所有的数据对象都存放在指定的表空间中，但主要存放的是表，所以称作表空间。分区表：当表中的数据量不断增大，查询数据的速度就会变慢，应用程序的性能就会下降，这时就应该考虑对表进行分区。表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间(物理文件上)，这样查询数据时，不至于每次都扫描整张表。(2).表分区的具体作用Oracle的表分区功能通过改善可管理性、性能和可用性，从而为各式应用程序带来了极大的好处。通常，分区可以使某些查询以及维护操作的性能大大提高。此外,分区还可以极大简化常见的管理任务，分区是构建千兆字节数据系统或超高可用性系统的关键工具。分区功能能够将表、索引或索引组织表进一步细分为段，这些数据库对象的段叫做分区。每个分区有自己的名称，还可以选择自己的存储特性。从数据库管理员的角度来看，一个分区后的对象具有多个段，这些段既可进行集体管理，也可单独管理，这就使数据库管理员在管理分区后的对象时有相当大的灵活性。但是，从应用程序的角度来看，分区后的表与非分区表完全相同，使用SQLDML命令访问分区后的表时，无需任何修改。什么时候使用分区表：1、表的大小超过2GB。2、表中包含历史数据，新的数据被增加都新的分区中。(3).表分区的优缺点表分区有以下优点：1、改善查询性能：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度。2、增强可用性：如果表的某个分区出现故障，表在其他分区的数据仍然可用；3、维护方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可；4、均衡I/O：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能。缺点：分区表相关：已经存在的表没有方法可以直接转化为分区表。不过Oracle提供了在线重定义表的功能。(4).表分区的几种类型及操作方法一.范围分区：范围分区将数据基于范围映射到每一个分区，这个范围是你在创建分区时指定的分区键决定的。这种分区方式是最为常用的，并且分区键经常采用日期。举个例子：你可能会将销售数据按照月份进行分区。当使用范围分区时，请考虑以下几个规则：1、每一个分区都必须有一个VALUESLESSTHEN子句，它指定了一个不包括在该分区中的上限值。分区键的任何值等于或者大于这个上限值的记录都会被加入到下一个高一些的分区中。2、所有分区，除了第一个，都会有一个隐式的下限值，这个值就是此分区的前一个分区的上限值。3、在最高的分区中，MAXVALUE被定义。MAXVALUE代表了一个不确定的值。这个值高于其它分区中的任何分区键的值，也可以理解为高于任何分区中指定的VALUELESSTHEN的值，同时包括空值。例一：假设有一个CUSTOMER表，表中有数据200000行，我们将此表通过CUSTOMER_ID进行分区，每个分区存储100000行，我们将每个分区保存到单独的表空间中，这样数据文件就可以跨越多个物理磁盘。下面是创建表和分区的代码，如下：CREATETABLECUSTOMER(CUSTOMER_IDNUMBERNOTNULLPRIMARYKEY,FIRST_NAMEVARCHAR2(30)NOTNULL,LAST_NAMEVARCHAR2(30)NOTNULL,PHONEVARCHAR2(15)NOTNULL,EMAILVARCHAR2(80),STATUSCHAR(1))PARTITIONBYRANGE(CUSTOMER_ID)(PARTITIONCUS_PART1VALUESLESSTHAN(100000)TABLESPACECUS_TS01,PARTITIONCUS_PART2VALUESLESSTHAN(200000)TABLESPACECUS_TS02)例二：按时间划分CREATETABLEORDER_ACTIVITIES(ORDER_IDNUMBER(7)NOTNULL,ORDER_DATEDATE,TOTAL_AMOUNTNUMBER,CUSTOTMER_IDNUMBER(7),PAIDCHAR(1))PARTITIONBYRANGE(ORDER_DATE)(PARTITIONORD_ACT_PART01VALUESLESSTHAN(TO_DATE('01-MAY-2003','DD-MON-YYYY'))TABLESPACEORD_TS01,PARTITIONORD_ACT_PART02VALUESLESSTHAN(TO_DATE('01-JUN-2003','DD-MON-YYYY'))TABLESPACEORD_TS02,PARTITIONORD_ACT_PART02VALUESLESSTHAN(TO_DATE('01-JUL-2003','DD-MON-YYYY'))TABLESPACEORD_TS03)例三：MAXVALUECREATETABLERangeTable(iddINTPRIMARYKEY,iNAMEVARCHAR(10),gradeINT)PARTITIONBYRANGE(grade)(PARTITIONpart1VALUESLESSTHEN(1000)TABLESPACEPart1_tb,PARTITIONpart2VALUESLESSTHEN(MAXVALUE)TABLESPACEPart2_tb);二.列表分区：该分区的特点是某列的值只有几个，基于这样的特点我们可以采用列表分区。例一CREATETABLEPROBLEM_TICKETS(PROBLEM_IDNUMBER(7)NOTNULLPRIMARYKEY,DESCRIPTIONVARCHAR2(2000),CUSTOMER_IDNUMBER(7)NOTNULL,DATE_ENTEREDDATENOTNULL,STATUSVARCHAR2(20))PARTITIONBYLIST(STATUS)(PARTITIONPROB_ACTIVEVALUES('ACTIVE')TABLESPACEPROB_TS01,PARTITIONPROB_INACTIVEVALUES('INACTIVE')TABLESPACEPROB_TS02例二CREATETABLEListTable(idINTPRIMARYKEY,nameVARCHAR(20),areaVARCHAR(10))PARTITIONBYLIST(area)(PARTITIONpart1VALUES('guangdong','beijing')TABLESPACEPart1_tb,PARTITIONpart2VALUES('shanghai','nanjing')TABLESPACEPart2_tb);)三.散列分区：这类分区是在列值上使用散列算法，以确定将行放入哪个分区中。当列的值没有合适的条件时，建议使用散列分区。散列分区为通过指定分区编号来均匀分布数据的一种分区类型，因为通过在I/O设备上进行散列分区，使得这些分区大小一致。例一：CREATETABLEHASH_TABLE(COLNUMBER(8),INFVARCHAR2(100))PARTITIONBYHASH(COL)(PARTITIONPART01TABLESPACEHASH_TS01,PARTITIONPART02TABLESPACEHASH_TS02,PARTITIONPART03TABLESPACEHASH_TS03)简写：CREATETABLEemp(empnoNUMBER(4),enameVARCHAR2(30),salNUMBER)PARTITIONBYHASH(empno)PARTITIONS8STOREIN(emp1,emp2,emp3,emp4,emp5,emp6,emp7,emp8);hash分区最主要的机制是根据hash算法来计算具体某条纪录应该插入到哪个分区中,hash算法中最重要的是hash函数，Oracle中如果你要使用hash分区，只需指定分区的数量即可。建议分区的数量采用2的n次方，这样可以使得各个分区间数据分布更加均匀。四.组合范围散列分区这种分区是基于范围分区和列表分区，表首先按某列进行范围分区，然后再按某列进行列表分区，分区之中的分区被称为子分区。CREATETABLESALES(PRODUCT_IDVARCHAR2(5),SALES_DATEDATE,SALES_COSTNUMBER(10),STATUSVARCHAR2(20))PARTITIONBYRANGE(SALES_DATE)SUBPARTITIONBYLIST(STATUS)(PARTITIONP1VALUESLESSTHAN(TO_DATE('2003-01-01','YYYY-MM-DD'))TABLESPACErptfact2009(SUBPARTITIONP1SUB1VALUES('ACTIVE')TABLESPACErptfact2009,SUBPARTITIONP1SUB2VALUES('INACTIVE')TABLESPACErptfact2009),PARTITIONP2VALUESLESSTHAN(TO_DATE('2003-03-01','YYYY-MM-DD'))TABLESPACErptfact2009(SUBPARTITIONP2SUB1VALUES('ACTIVE')TABLESPACErptfact2009,SUBPARTITIONP2SUB2VALUES('INACTIVE')TABLESPACErptfact2009))五.复合范围散列分区：这种分区是基于范围分区和散列分区，表首先按某列进行范围分区，然后再按某列进行散列分区。createtabledinya_test(transaction_idnumberprimarykey,item_idnumber(8)notnull,item_descriptionvarchar2(300),transaction_datedate)partitionbyrange(transaction_date)subpartitionbyhash(transaction_id)subpartitions3storein(dinya_space01,dinya_space02,dinya_space03)(partitionpart_01valueslessthan(to_date(‘2006-01-01’,’yyyy-mm-dd’)),partitionpart_02valueslessthan(to_date(‘2010-01-01’,’yyyy-mm-dd’)),partitionpart_03valueslessthan(maxvalue));(5).有关表分区的一些维护性操作：一、添加分区以下代码给SALES表添加了一个P3分区ALTERTABLESALESADDPARTITIONP3VALUESLESSTHAN(TO_DATE('2003-06-01','YYYY-MM-DD'));注意：以上添加的分区界限应该高于最后一个分区界限。以下代码给SALES表的P3分区添加了一个P3SUB1子分区ALTERTABLESALESMODIFYPARTITIONP3ADDSUBPARTITIONP3SUB1VALUES('COMPLETE');二、删除分区以下代码删除了P3表分区：ALTERTABLESALESDROPPARTITIONP3;在以下代码删除了P4SUB1子分区：ALTERTABLESALESDROPSUBPARTITIONP4SUB1;注意：如果删除的分区是表中唯一的分区，那么此分区将不能被删除，要想删除此分区，必须删除表。三、截断分区截断某个分区是指删除某个分区中的数据，并不会删除分区，也不会删除其它分区中的数据。当表中即使只有一个分区时，也可以截断该分区。通过以下代码截断分区：ALTERTABLESALESTRUNCATEPARTITIONP2;通过以下代码截断子分区：ALTERTABLESALESTRUNCATESUBPARTITIONP2SUB2;四、合并分区合并分区是将相邻的分区合并成一个分区，结果分区将采用较高分区的界限，值得注意的是，不能将分区合并到界限较低的分区。以下代码实现了P1P2分区的合并：ALTERTABLESALESMERGEPARTITIONSP1,P2INTOPARTITIONP2;五、拆分分区拆分分区将一个分区拆分两个新分区，拆分后原来分区不再存在。注意不能对HASH类型的分区进行拆分。ALTERTABLESALESSBLITPARTITIONP2AT(TO_DATE('2003-02-01','YYYY-MM-DD'))INTO(PARTITIONP21,PARTITIONP22);六、接合分区(coalesca)结合分区是将散列分区中的数据接合到其它分区中，当散列分区中的数据比较大时，可以增加散列分区，然后进行接合，值得注意的是，接合分区只能用于散列分区中。通过以下代码进行接合分区：ALTERTABLESALESCOALESCAPARTITION;七、重命名表分区以下代码将P21更改为P2ALTERTABLESALESRENAMEPARTITIONP21TOP2;八、相关查询跨分区查询selectsum(*)from(selectcount(*)cnfromt_table_SSPARTITION(P200709_1)unionallselectcount(*)cnfromt_table_SSPARTITION(P200709_2));查询表上有多少分区SELECT*FROMuseR_TAB_PARTITIONSWHERETABLE_NAME='tableName'查询索引信息selectobject_name,object_type,tablespace_name,sum(value)fromv$segment_statisticswherestatistic_nameIN('physicalreads','physicalwrite','logicalreads')andobject_type='INDEX'groupbyobject_name,object_type,tablespace_nameorderby4desc--显示数据库所有分区表的信息：select*fromDBA_PART_TABLES--显示当前用户可访问的所有分区表信息:select*fromALL_PART_TABLES--显示当前用户所有分区表的信息：select*fromUSER_PART_TABLES--显示表分区信息显示数据库所有分区表的详细分区信息：select*fromDBA_TAB_PARTITIONS--显示当前用户可访问的所有分区表的详细分区信息：select*fromALL_TAB_PARTITIONS--显示当前用户所有分区表的详细分区信息：select*fromUSER_TAB_PARTITIONS--显示子分区信息显示数据库所有组合分区表的子分区信息：select*fromDBA_TAB_SUBPARTITIONS--显示当前用户可访问的所有组合分区表的子分区信息：select*fromALL_TAB_SUBPARTITIONS--显示当前用户所有组合分区表的子分区信息：select*fromUSER_TAB_SUBPARTITIONS--显示分区列显示数据库所有分区表的分区列信息：select*fromDBA_PART_KEY_COLUMNS--显示当前用户可访问的所有分区表的分区列信息：select*fromALL_PART_KEY_COLUMNS--显示当前用户所有分区表的分区列信息：select*fromUSER_PART_KEY_COLUMNS--显示子分区列显示数据库所有分区表的子分区列信息：select*fromDBA_SUBPART_KEY_COLUMNS--显示当前用户可访问的所有分区表的子分区列信息：select*fromALL_SUBPART_KEY_COLUMNS--显示当前用户所有分区表的子分区列信息：select*fromUSER_SUBPART_KEY_COLUMNS--怎样查询出oracle数据库中所有的的分区表select*fromuser_tablesawherea.partitioned='YES'--删除一个表的数据是truncatetabletable_name;--删除分区表一个分区的数据是altertabletable_nametruncatepartitionp5;",2015/6/25
228,Oracle to MySQL,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9065,"1.java实体的移植主键生成策略有JPA提供与Hibernate提供之分JPA提供的四种标准用法为TABLE,SEQUENCE,IDENTITY,AUTO.TABLE：使用一个特定的数据库表格来保存主键。SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。IDENTITY：主键由数据库自动生成（主要是自动增长型）AUTO：主键由程序控制。这里如果是mysql数据库一般使用Identity，Oracle使用Sequence。当使用Auto时，如果使用Oracle且配置了Sequence则使用Sequence，Mysql则使用Identity。主键生成策略应该配置为Auto并配置Squeuence，Oracle转mysql则不会有问题。2.DDL的问题Orcale里可以写createorreplacetableTable_nameMysql需要变换为DropTableTable_nameifexiststable_namecreatetabletable_name3.Mysql需要对自增主键添加auto_incrementOracle中一般会先建立表然后通过altertable设置表的主键，这时需要注意，我们需要将主键定义在createtable语句中进行。4.Mysql引擎的选择Mysql5.*默认为Innodb，支持事物以及行锁表锁，所以应选择Innodb，但是对于使用空间数据的情况需要使用MyISAM，因为Innodb不支持空间数据5.数据类型的转换下表是数据类型映射的表MySQLDataTypeOracleDataTypeBIGINTNUMBER(19,0)BITRAWBLOBBLOB,RAWCHARCHARDATEDATEDATETIMEDATEDECIMALFLOAT(24)DOUBLEFLOAT(24)DOUBLEPRECISIONFLOAT(24)ENUMVARCHAR2FLOATFLOATINTNUMBER(10,0)INTEGERNUMBER(10,0)LONGBLOBBLOB,RAWLONGTEXTCLOB,RAWMEDIUMBLOBBLOB,RAWMEDIUMINTNUMBER(7,0)MEDIUMTEXTCLOB,RAWNUMERICNUMBERREALFLOAT(24)SETVARCHAR2SMALLINTNUMBER(5,0)TEXTVARCHAR2,CLOBTIMEDATETIMESTAMPDATETINYBLOBRAWTINYINTNUMBER(3,0)TINYTEXTVARCHAR2VARCHARVARCHAR2,CLOBYEARNUMBER主要关注date,number,varchar2的转换。其中需要注意varchar2的转换，因为在oracle中varchar2表示存储的字节数，与编码有关，而mysql中varchar则没有，mysql中varchar(30)表示存储30个字符，所以此处需要注意。至于date因为不需要支持微妙，所以我使用timestamp储存了。6.常用的系统函数变化to_date-->char_to_dateto_char-->date_to_char||-->concat7.hql中需要注意，避免使用原始sql尽量使用hql，尤其是日期处理。对于空串的处理，在oracle中varchar2下传入空串则oracle作为null处理，所以你搜索空串是无结果的但是mysql中是有空串的.mysql中需要为子查询设置别名要么也会报错。分页查询，mysql中没有rownum，可以使用limit实现，建议使用hql。8.注意切换hibernate方言9.触发器与存储过程oracle的触发器比较高端，对于行触发器支持到按照某列改变触发，而mysql只支持行触发。oracle中可以判断当前操作类型update，delete还是insert，mysql只能分开写了。变量声明的语法也不相同，需要注意（会详细写一篇）10。获取当前使用的数据库我的方法比较屌丝根据Hibernate方言判断使用哪种11.一些语法上的限制1）.Everyderivedtablemusthaveitsownalias遇到这个问题驱动表需要有一个别名，比如selectsum(money)sumfrom(select*fromguestlimit0,10)t;2）deletefromdecode_resourcerewherere.decode_resource_id=1这个地方原因未知，delete中不可以表的别名？去掉re即可",2015/6/25
229,MySQL监控、性能分析,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9064,"MySQL越来越被更多企业接受，随着企业发展，MySQL存储数据日益膨胀，MySQL的性能分析、监控预警、容量扩展议题越来越多。“工欲善其事，必先利其器”，那么我们如何在进行MySQL性能分析、监控预警、容量扩展问题上得到更好的解决方案，就要利用各种工具来对MySQL各种指标进行分析。本文是读书笔记，下面提及的工具，读者可能都用过，或打算准备是使用。MySQL服务器的发布包没有包含那些能完成许多常见任务的工具，例如监控服务器的工具、比较服务器间数据的工具。我们把这些工具分成以下几类：界面、监控、分析和辅助工具。带界面的工具1、MySQL可视化工具这些工具都可以免费使用:a、MySQL查询浏览器（MySQLQueryBrowser）：这个不用说了…b、MySQL管理员（MySQLAdministrator）：功能集中在服务器管理上，所以它最适合DBA使用，而不是开发人员和分析人员。它可以帮助DBA把创建备份、创建用户并分配权限、显示服务器日志和状态信息等过程进行自动化处理。它还包括了一些基本的监控功能，例如图形化的状态变量显示，但是它没有下文里会提到的交互式监控工具那么灵活。c、MySQL迁移工具箱（MySQLMigrationTookit）：可以帮你把数据从别的数据库系统迁移到MySQL里。d、MySQL工作台（MySQLWorkbench）：MySQL的建模工具。2、SQLyogSQLyog是最常用的MySQL可视化工具，只能用于win下。3、phpMyAdminphpMyAdmin是一款很流行的管理工具，它基于Web界面来管理MySQL服务器。有很多支持者，但反对者也不少。监控工具MySQL监控是一个很大复杂的任务，不同的应用有着不同的需求。“监控”是大家滥用的术语之一，承载了几重意思。我们讲到的监控工具被分为非互动的和互动的两类。非互动监控常常就是一个自动化系统，它接收系统的测量值，如果有超出安全范围的，就通过发出警告提醒管理员。互动监控工具可以让你实时地观测服务器。你可能对监控工具在其他方面的差别也很感兴趣，例如被动监控和主动监控，后者会发送报警信息并作出初步反应（就像Nagios一样）；或者你可能正在寻找这样一工具：它可以创建一个信息仓库，而不仅仅是显示当前的统计信息。有许多监控系统不是专为监控MySQL而设计的，它们就是一个通用系统，里面设计了一个周期性的任务，定时去检查各类资源的状态，例如像服务器、路由器、以及各种软件（包括MySQL）。它们常常会提供一个插件架构，同时有一个预订的MySQL插件可供使用。这样的一些系统能够记录监控对象的状态，并通过web界面用图形化的形式表示出来。当监控对象出现问题，或者状态值超过安全范围时，它们还能发送报警信息，或者执行一个初始化的动作。a、非交互性工具1、Nagios监控界流行一句话：只要用顺了Nagios，你就永远不会再想到其它监控系统。对于Nagios本blog会持续推出相关文章，现在只是引用Nagios官方的介绍：Nagios是一款用于系统和网络监控的应用程序。它可以在你设定的条件下对主机和服务进行监控，在状态变差和变好的时候给出告警信息。Nagios最初被设计为在Linux系统之上运行，然而它同样可以在类Unix的系统之上运行。Nagios更进一步的特征包括：监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）；监控主机资源（处理器负荷、磁盘利用率等）；简单地插件设计使得用户可以方便地扩展自己服务的检测方法；并行服务检查机制；具备定义网络分层结构的能力，用”parent”主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态；当服务或主机问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）；具备定义事件句柄功能，它可以在主机或服务的事件发生时获取更多问题定位；自动的日志回滚；可以支持并实现对主机的冗余监控；可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等；下面是可代替Nagios的工具：i、ZenossZenoss是用Python编写的，拥有基于浏览器的用户界面，并使用了Ajax使操作更加快捷而富有效率。它将监控、报警、趋势显示、图表显示和记录历史数据等功能合成在一个统一的工具里，它还能在网上自动发现资源，在默认情况下，Zenoss使用SNMP从远程机器上收集数据，但它也可以使用SSH，并且支持Nagios插件。ii、HypericHQHypericHQ是一款基于Java的监控系统，它的目标跟其他同类别的软件不太一样，它要成为企业级的监控系统。跟Zenoss一样，它也能自动发现资源，支持Nagios插件，但是它的逻辑组织和架构很不一样，显得有点庞大。至于它是不是合适你的需求，那要看你的参数设置和监控的方式了。iii、OpenNMSOpenNMS是由Java编写的，拥有一个活跃的开发者社区。它具备了常规的功能，例如监控和报警，也加入了图表和趋势显示的功能。它的目标是高性能、伸缩性、自动化以及良好的兼容性。跟Hyperic一样，它也企图成为一款企业级的监控软件，可以用于大型的关键系统上。iv、GroundworkOpenSourceGroundworkOpenSource实际上是基于Nagios的，它把Nagios和其他几个工具集成为一个系统，并安上一个统一的门户界面。描述它的最好方法可能就是：如果你对Nagios、Cacti及其他工具很熟悉，并且能够花大量的时间把它们无缝地集成在一起的话，你也能在家庭作坊里做一个出来。v、ZabbixZabbix是一个开源监控系统，在许多方面跟Nagios很相像，但是也有一些关键的不同点。例如：它把所有配置信息和其他数据都存放在一个数据库里，而不是放在配置文件里；它比Nagios存储了更多类型的数据，这样可以生成更好的趋势图和历史报告。它的网络图表和可视化功能也优于Nagios。很多使用它的人发现它更易配置，更具有兼容性。说起来它也能比Nagios少，它的报警功能也不够高级。2、MySQL监控和建议服务MySQL自己的监控方案就是设计用来监控MySQL实例的，但也能够监控主机的一些关键方面。这个工具不是开源的，需要MySQL企业订阅费。3、MONyogMONyog是一个轻量级的无代理的监控系统，它跟以上那些工具有着不同实现方法：它的底层是一个JavaScript引擎，所有配置都是通过JavaScrpt对象模型来完成的。它被设计为在桌面系统上运行，运行时它会在一个闲置的端口上打开一个HTTP监听器。这样，你就可以把你的浏览器指向这个端口，查看MySQL服务器的信息了，这信息都是结合了Javascript和Flash来表示的。MONyog实际上有交互式和非交互式两种类型，因此，你可以把两种类型的监控功能都尝试着用用看。4、基于RRDTool的系统严格地说，RRDTool不算是一个监控系统，但是，它很重要，有必要在此提到一下。很多组织里都是使用几种脚本或程序–这些一般都是自制的–从服务器那里读取信息，然后再保存到循环数据库（Round-robindatabase，RRD）文件里。在许多要获取记录生成图表的环境下，RRD文件是一个很合适的解决方案。它们能聚合输入的数据，如果输入数据值没有按期在随后提交进行时，还能在随后插入这些丢失的数据。它们还都带有强大的图表工具，能够生成漂亮的与众不同的图表。现在已经有一些基于RRDTOOL的系统可供使用了。a、MutiRouterTrafficGrapher，或者叫MRTG就是一款典型的基于RRDTOOL的系统。它真正的设计初衷是记录网络数据流，但是它也被扩展用来记录和图表化表示其他一些东西。b、Munin是一个能为你采集数据的系统，将它放入RRDTool后，就会根据数据生成不同粒度的图表。它能从配置信息里生成静态的HTML文件，这样你就可以轻松地浏览，查看趋势情况。c、Cacti是另外一个常用的图表和趋势显示系统。它的工作方式是：从系统里获取数据，然后保存在RRD文件里，然后用PHPWeb界面的形式，使用RRDTool把数据以图表的形式展示出来。这个显示界面也是配置和管理界面（配置信息存储在一个MySQL服务器里）。它是模板驱动的，因此，你可以自己定义模板，并放到你的系统里使用。d、Cricket是一个用Perl编写的跟Cacti类似的系统，使用的是基于文件的配置系统。Ganglia也跟Cacti类似，但它的设计初衷是永远监控群集和系统网络，因此，你可以查看到由许多服务器信息聚合得到的结果，也可以按照你的意愿，查看单独某台服务器的信息。（Cacti和Cricket无法显示聚合数据。）以上这些系统都可以被用作MySQL系统信息的收集、记录、图表化数据和报告，它们在用途方面差异较小，都具备了不同程度的兼容性。但是，它们缺乏真正意义上的兼容性，比如当某些东西出错时，它要能够有针对性地发送报警信息给某些人。它们中的一些甚至没有“错误”的概念。所以，有些人把这一点看作是此类系统的一大缺点，觉得最好还是把记录、图表化表示、报警这几项功能都独立开来。事实上，Munin特地设计了使用Nagios来作为它的报警系统。然而，对于其他几个来说，这的确是缺点。另外还有一个缺点就是安装和配置这样一个系统，使其能完全满足你需求，须投入很多时间和努力，不过，这一点也并不是这样。最后，RRD文件无法让你使用SQL或其他标准方法来查询它里面的数据。而且，在默认情况下，它永远会以一种恰好的粒度来存储数据，许多MySQL管理员就不愿意接受这种限制，转而选择一个关系数据库来存储这些历史数据。b、交互性工具交互性工具就是那些在你需要时就可以启动起来，并以视图显示的形式不断获取最新服务器状态的软件。innotopinnotop是一个通过文本模式显示MySQL和InnoDB的监测工具。它有很多特点，快速的配置的，易于使用等。它吸取了MYTOP的精华这使它变得更加强大。innotop是用PERL语言写成的，这是它能更加灵活的使用在各种操作平台之上，它能详细的的监控出当前MYSQL和INNODB运行的状态，以便维护人员根据结果合理的优化MYSQL，让MYSQL更稳定更高效的运行。安装INNOTOP工具非常的简单，既然是由PERL写的，当然需要PERL环境和相关的工具包。在安装之前先要确定你的系统安装了Time::HiRes,Term::ReadKey,DBI,DBD::mysql这四个包。安装可以把包下载下来通过编译安装完成也可以用PERL模块安装方式来完成。mtop是一个显示MySQL服务器查询状态的监视器。功能包括显示完成的查询进程，显示查询优化的信息及杀死一个查询。附加功能包括服务器性能统计，配置信息和调整技巧提示。mytopmytop就是類似top的MySQL監察工具。執行mytop後，它會每隔幾秒更新一次，而且也可以針對性地監察某一個資料庫。分析工具分析工具可以帮你自动化那些单调乏味的工作，如监测服务器，找出还可以优化和调优的功能区域。这些工具可以作为解决性能问题的良好开端。a、HackMySQL工具（这个很出名，可惜已停止更新）1、Mysqlreport2、Mysqlslab、Maatkit分析工具一系列命令行工具的集合。MySQL的辅助工具MySQL里有几个工具是为了消除MySQL提供的功能与它自带的命令行工具之间的隔阂。a、MySQLProxyb、Dormando的MySQL代理MySQL监控、性能分析——工具篇",2015/6/25
230,有一个国产数据库——成都欧冠虚谷数据库,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9063, /index.asp吹得也是相当得牛叉啊，不知道实际情况怎么样。虚谷数据库管理系统构筑中国信息长城保障国家信息安全时间：2011-12-229:54:20点击:3068次虚谷之路成都欧冠信息技术有限责任公司是四川唯一一家具有自主知识产权和核心竞争力的基础软件公司，公司自2002年开始从事大型的数据库管理系统的研发。目前，公司所开发的数据库管理系统虚谷DBMS已在一些重要部门开始使用，该产品得到了各级政府的高度重视和大力支持，并被四川省列为重大战略产品之一。中国人需不需要搞自己的数据库系统？毫无争论，有无数无可辩驳的理由，需要我们拥有自己的数据库系统。但在“中国人有没有这个技术能力”“搞出来的东西有没有市场”这些方面可能很多人将无法回答。在现有条件的限制下，能不能搞出有实用性的、高性能的、能与国外产品媲美的、能被市场接受的数据库系统，我们认为是能的，这也是我们的目标。虚谷的亮剑精神u改变：决心改变我国数据库主要依赖国外产品、受它人约束、存在潜在攻击风险的局面u突破：突破数据库管理系统核心技术u开发：开发出能够与国外主流数据库产品相抗衡的、具有完全自主知识产权的数据库管理系统u面向：面向我国信息安全这一敏感领域，为国家信息化建设提供安全保障要改变我国在数据库行业目前的局面，走技术创新，发展具有自主产权的核心技术软件产品应是我国数据库行业的必由之路，发展国产大型数据库管理系统也是保障国家信息安全的必由之路，无论此路有多艰辛，行走在此路上的风险和牺牲有多大，此路都值得一走，中国人应该有这个血性和勇气，中国政府也应该有这个血性和勇气！虚谷DBMS总体架构虚谷数据库作为通用系统软件，具有开放的构架，强大的功能，优良的性能。产品借鉴和改进了国外数据库产品的结构，设计了自己先进产品技术架构。采用C/Server和B/S结合的混合体系结构、支持采用UNIX／LINIX／WINDOWS系统结构的应用软件系统。网络侦听线程：侦听网络连接请求，创建会话，由于本系统不为每个会话创建服务线程，因而网络侦听线程还要负责侦听会话上请求的开始部分内容。一旦侦听到会话上有请求，请求将被打包成一个任务放入任务池，任意一个闲置的服务线程皆可处理它。服务线程：服务线程是系统中数据最多的一类线程，与其它类型线程不同的是，此类线程的运行的程序不固定，它们执行的程序由任务结构上的方法函数决定，而任务的种类林林总总，并且随版本升级还会不断增加。一个请求本身就是一个任务，请求被分析规划后将会生成一个或多个任务，这些任务对于服务线程来说如同一个个的“工件”，它们被服务线程逐个处理最后生成结果集。缓冲区维护线程：维护自由缓冲区个数，在系统空闲时，调动操作系统异步IO或磁盘IO线程将已写脏的缓冲块写回磁盘。磁盘IO线程：当不启用操作系统提供的异步IO功能时，系统启动此类线程，此类线程的个数可配置，通常应与物理磁盘数相同或相近。它们模拟操作系统的异步IO功能。日志线程：以异步方式将日志缓冲区中的数据写入磁盘。日志归档线程：将日志转移到归档目录或设备中。数据同步线程：当多个数据库实例间有数据同步项时，该线程将按设置定期检查有无数据需要相互传送和处理，从而实现不同数据库中的数据同步。后台杂项事务处理线程：定时执行一些杂项事务，如：检查定时批处理脚本文件有无新的批处理任务需要在某一时刻执行，检查系统是否需要启动一个checkpoint过程等。各个线程总是运行在一个独立的任务环境下，在本系统中，每个任务皆有一个独立的任务环境，它们有自己的内存上下文，一个线程在执行一个任务时，称作任务与线程的绑定，一个任务在执行完毕后整体释放，但线程并不终止，线程要么闲置要么执行别的任务。系统中有的任务永不终止，如：磁盘IO任务作为一个任务将永不终止，而有的任务生命期很短，如：一个select语句生成的任务，在执行完查询后立即消亡。虚谷DBMS系统-性能指标(1)支持大数据量，实现TB级数据量管理；(2)单台服务器最大同时在线连接数达到10000个；(3)一个安装实例中可以创建32768个用户数据库；(4)一个用户数据库允许创建多达32768个表空间；(5)一个表空间可包含32768个文件；(6)一个数据库内允许创建多达20亿个表；(7)一个表中的字段数最大可达2048个；(8)一个表中允许容纳多达20亿条记录；(9)一个常规记录的最大长度可达64K字节；(10)一个表中允许同时存在多个大对象字段，各大对象字段的数据尺度皆可达2G；(11)一个表可分成2048个分区表，每个分区表允许再次分成512个子分区表；(12)实现完全行级封锁，不因封锁对象数增加而提高封锁级别；(13)最低事务隔离级别为读已提交（即：永远无脏读），并保证在此级别下读操作不会被阻塞；8(14)在同等硬件配置、同等数据量的情况下，在线事务处理能力指标tpmc值达到或超过国外大型数据库的水平。虚谷DBMS系统–安全性指标(1)审计功能，可对指定用户、指定操作过程等进行跟踪记载；(2)系统安全级别达到B1级，逐步达到B2级；(3)支持数据加密，数据加密采用按块即时加解密方式，不依赖外部加密软件或加密文件系统，启动数据加密功能不影响系统性能；(4)支持网络加密，使用伪噪声发生器产生加密流，具有速度快，强度高等优点，且加密过程勿需操作系统的SSL层支持；(5)能抵御目前已知的网络攻击手段虚谷DBMS系统–稳定性、扩展性、可管理性指标指标(1)稳定性：可用性99.8%，支持7x24，具有完善的容错和容灾能力，因本软件故障引起的停机时间全年不超过1天。(2)高可扩展性：支持多种可扩展计算机体系结构，加速比和伸缩比接近线性。(3)可管理性：实用、易用、智能。交互式SQL、基于WEB的集成管理、全中文的操作管理界面和性能监测、优化工具等。虚谷DBMS系统的总体特点虚谷DBMS产品从功能、性能、安全、可管理等方面可与国外大型数据库媲美，是一个高性价比的、大型的、完全自主知识产权的国产数据库管理系统，系统设计基于标准的数据库理论，吸取国外大型数据库的优点，同时为了提高系统性能和安全性、提高系统的可管理性和实用性，在系统设计和技术开发上进行了创新，具有自身的设计和技术特色。（1）完全自主知识产权，虚谷DBMS是具有完全自主知识产权的国产大型高性能数据库管理系统，我公司拥有产品的全部源代码和完全的自主版权，从根本上保证了系统的安全性，系统的升级换代，同时有利于与其它应用系统集成，并可以根据具体需求定制和提供及时有效的服务。（2）核心技术应达到国际水平，核心技术体现在整个数据库系统的架构上、硬件资源的合理调度与充分运用上、快速有效的优化与执行机制上等多个方面；（3）设计上借鉴了Oracle及DB2的一些特点，同时又与它们的实现方式截然不同，比如数据存贮机制、任务调度等。在许多关键性部分的算法设计上，都要求其性能与最好的数据库系统看齐；（4）功能上全面实现SQL92标准，支持对数据表进行分区，支持多级事务嵌套、支持全文检索、多数据类型、“数据刀片”、JAVA支持、具备数据库镜像、联邦数据库、远程数据库同步与复制及完善的容灾能力、支持ODBC、JDBC、ADO、DBI等驱动程序标准；（5）性能上支持大数据量，实现TB级数据量管理、实现完全行级封锁、在线事务处理能力指标tpmc值达到ORACLE9的水平；（6）系统安全级别达到B1级，具备审计、支持数据加密；（7）稳定性与扩展性方面可用性99.8%，支持7x24，具有完善的容错和容灾能力、支持多种可扩展计算机体系结构和较强的可管理能力。虚谷DBMS系统–高性能虚谷DBMS拥有在多个测试项目中大大超过Oracle的性能。为实现高性能，虚谷DBMS在提高执行效率、减少系统固有开销以及提高并发度方面采取了极为重要的措施（1）为提高执行效率、减少系统固有开销，虚谷DBMS采用如下措施单线程管理所有网络连接请求；线程池、任务池，会话、事务与线程的动态绑定；资源非平均分配与自适应运用策略；数据引用与拷贝的自适应转换，尽可能避免数据拷贝；自建应用程序级锁管理器，速度快且极少使用系统级资源；SQL引擎采用执行节点动态组装技术，几乎为C语言级执行速度;一体化的存贮过程运行环境与SQL引擎环境，存贮过程引擎使用虚拟机技术；内存复用、多种多级别内存管理器与松散内存释放策略相结合。（2）为提高并发度，虚谷DBMS采用如下措施表级以上对象的封锁绝大多数是共享型封锁；采用基于事务号的多版本与行级锁相结合的方案，无需加锁即可实现无阻塞的读操作，且可保证无脏读；采用行级锁转嫁算法实现无限制的行级封锁，不随锁定行数的增加而升级锁级别，也不随行锁定行数的增加而增大锁表负担；各个操作过程均采用高并发设计。虚谷DBMS系统–高稳定性虚谷DBMS采用以下措施提高其稳定性(1)多级别错误隔离技术，尽量减少故障对其它事务及系统核心单元的影响；(2)多种多级别内存管理器将不同用途，不同生命期的内存对象进行隔离，极大缩小内存存取错误的影响面，并防止长期运行后内存映像的零散化；(3)变量、参量采用统一格式，并具有自动伸缩和释放内存的能力，辅以不同生命期内存的总清功能，有效地杜绝了内存的泄漏；(4)具有完善的灾难恢复措施，故障发生后能将系统恢复到故障发生前一刻的状态，并保证已提交的事务生效，未提交事务完全回滚虚谷DBMS系统–高安全性虚谷DBMS采用以下措施提高其安全性（1）自主权限控制与强制安全控制相结合，安全级别为B1级；（2）完善的审计功能；（3）内建的数据文件加密功能；（4）内建的网络传输加密功能，结合标准网络传输协议的SSL层功能，可实现传输过程的双重加密；（5）完全自主知识产权，绝无恶意留下的后门。虚谷数据库管理器（XGManager）虚谷数据库V3.0的界面大体上分4个区：菜单栏、对象浏览器、工作区和SQL语句返回区。其中SQL语句返回区包含错误信息和已执行SQL语句两个部分，这样就大大方便了查找在操作出现的问题。实例组：一个控制台下面可以有多个实例组，每个实例组下面又可以连接多个实例。数据库：虚谷数据库中数据库分为系统库和用户库，创建系统库是建立连接后做的第一件事情。模式：模式是数据库中存储数据的一个逻辑表示，是一系列数据结构和数据对象的集合，既可以是数据库的全局逻辑描述也可是数据库的局部逻辑描述。虚谷迁移工具（XGMigrator）虚谷迁移工具目前基本实现了主流数据库的所有数据类型到虚谷数据库的迁移。在V3.0版本中，增加了从TEXT文件到虚谷和虚谷到TEXT文件的迁移。这就大大的方便了不同数据库间的数据迁移。虚谷数据迁移使用的是ODBC接口，这使得数据库迁移的工作变得简单方便。安全管理工具(XGSecurity)用于安全管理员在每个数据库中定义多种安全策略，并将之赋予用户等数据库对象。为了实现数据的强制访问控制，安全管理员需要在每个数据库中定义多种安全策略，每个安全策略中可以定义多种安全级别和范围，用来表示现实中的不同安全特征。将这些安全策略应用于表和用户上，就给用户、表和元组都指定了安全标记(label)。数据库就是通过比较用户、表、以及元组之间的安全标记来确定用户是否可以操作表或元组。u一个策略中最多可以定义10000个等级，等级ID的取值范围为1-10000。u每个等级名称都要对应一个等级ID，ID越小表示安全等级别越低。u一个策略中最多可以定义48个范围，范围没有等级高低之分，也没有大小之分。u在同一个策略中，等级ID不可重复，等级名不可重名，范围名也不可重名。安全审计工具（XGAuditor）数据库的创建者作为DBO（DatabaseOwner）拥有设置和取消数据库对象的审计策略，查看和分析数据库对象的审计记录，创建和删除数据库审计员的权限。由DBO创建的具有审计角色和权限的用户，具备审计功能，可以对指定用户、指定操作过程等进行跟踪记载。虚谷DBMS的安全体系统创新性地研究和设计了三权分治、四级权限的安全体系，除开数据及通讯加密部分，主要包括：用户管理及权限认证子系统、审计子系统、强制安全子系统，用户管理及权限认证子系统的核心工作是定义用户和授权，审计子系统的核心工作是对数据库的操作行为进行监控，强制安全子系统的核心工作是制定系统主客体的密级。为了达到真正安全的目的，系统不能允许有任何用户凌驾于审计和强制安全体系之上，因此，系统采用了三权分治策略，即：DBA、系统审计管理员、系统安全管理员须由不同用户充当，这样就防止了具有对象操作权限的用户通过修改审计设置或安全策略设置而躲过系统的审计监视或违反强制安全策略存取数据。虚谷DBMS与国外主流数据库系统的技术比较比较项目OracleDB2SQLserverInformixMysql虚谷DBMS运行平台跨平台跨平台windows跨平台跨平台跨平台进(线)程多进程+多线程多进程+多线程多线程多进程多线程多线程调度策略进程池进程池线程池不详每连接一线程线程池任务内并发YesYes不祥不详noYes存贮模式表空间表空间少量文件少量文件每表或索引对应一文件表空间缓冲管理有有有有无有锁粒度记录级记录级随锁定个数增加升级至块级或表级记录级随锁定个数增加升级至块级或表级记录级随锁定个数增加升级至块级或表级表级记录级锁类型S、XS、U、X、IXS、U、X、IXS、U、X、IXS、XS、X事务支持YesYesYesYesNoYes允许脏读NoYesYesYesYesNo数据类型内建内建内建内建+数据刀片内建内建+数据刀片空间数据支持yesYesnoYesnoyes全文索引yesYesyes不详yesYes表分区yesYesyes不详noYes磁盘IO方式预读、异步、直接预读、异步、直接预读、异步、直接不详标准IO预读、异步、直接、模拟异步Sql92实现程度完全完全完全完全入门级中常用少量遗漏游标支持Oracle方式Sql92兼容Sql92兼容Sql92兼容无Sql92兼容通过游标更改yesYesyesYesnoYesRowId支持yesYesNo不祥noyes集群模式HA、SDHA、SN、SDHA、SNHAHAHA、SD、SN（实现中）基于目前的虚谷DBMS核心系统架构，我们将进一步完善大型、高性能、高安全、高可靠和完全自主知识产权的虚谷数据库管理系统，研究和开发广泛支持的标准程序接口，功能强大的数据库管理、审计、检测与控制和数据备份、恢复、迁移等相关工具，达到目前主流商用数据库的一些技术和应用水平，从架构、实现技术和方法上进行创新，推动整个数据库管理系统的产品化和实用化，满足以数据高效存贮、安全管理和快速检索等为需求的中高端应用需求。同时进行数据库系统的产业化工作，并借鉴了国外大型数据库的技术和功能，提出和解决提高数据库的性能的许多关键技术和算法，优化系统的内存管理、事务管理、进程管理等核心功能，研究和架构三权分治、四级权限的安全体系，优化和实现系统安全，提高系统安全性和稳定性；实现系统对多平台支持，研制集成管理工具集，提升系统可用性，研制和扩展面向行业的特定功能等，提供数据定义、数据操作功能、数据库的运行管理、数据库的建立和维护功能。满足以海量数据的高效存贮、安全管理和快速检索等为需求的中高端应用需求，为国家、行业和地方重大信息化应用提供支撑：u突破数据库管理系统核心技术，优化虚谷DBMS，继续提升系统性能；u在对多操作系统支持、SQL92标准支持、标准接口支持、管理与应用工具集等方面全面实现支持大规模中高端应用的产品化；u进行国家第三方安全机构的认证，提供B1级安全要求的所有功能，通过TPC-C和TPC-H测试；u推动数据库及其应用软件产业化：与国产操作系统、中间件、以及应用软件等共同形成我国自主的软件产业；u面向制造业信息化、电子政务、信息安全工程等实施数据库应用工程，为国民经济信息化提供支撑，为国家信息安全提供保障，实现虚谷DBMS的产业化。,2015/6/24
231,H.265,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9062,"H.265是ITU-TVCEG继H.264之后所制定的新的视频编码标准。H.265标准围绕着现有的视频编码标准H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。具体的研究内容包括:提高压缩效率、提高鲁棒性和错误恢复能力、减少实时的时延、减少信道获取时间和随机接入时延、降低复杂度等。H264由于算法优化，可以低于1Mbps的速度实现标清数字图像传送;H265则可以实现利用1~2Mbps的传输速度传送720P(分辨率1280*720)普通高清音视频传送。2012年8月，爱立信公司推出了首款H.265编解码器，而在仅仅六个月之后，国际电联(ITU)就正式批准通过了HEVC/H.265标准，标准全称为高效视频编码(HighEfficiencyVideoCoding)，相较于之前的H.264标准有了相当大的改善，中国华为公司拥有最多的核心专利，是该标准的主导者。H.265旨在在有限带宽下传输更高质量的网络视频，仅需原先的一半带宽即可播放相同质量的视频。这也意味着，我们的智能手机、平板机等移动设备将能够直接在线播放1080p的全高清视频。H.265标准也同时支持4K(4096×2160)和8K(8192×4320)超高清视频。可以说，H.265标准让网络视频跟上了显示屏""高分辨率化""的脚步。可能在几个月内，你就能看到支持H.265解码的设备上市了(如智能手机、显卡等)。H.264统治了过去的五年，而未来的五年甚至十年，H.265很可能将会成为主流。H.263可以2~4Mbps的传输速度实现标准清晰度广播级数字电视(符合CCIR601、CCIR656标准要求的720*576);而H.264由于算法优化，可以低于2Mbps的速度实现标清数字图像传送;H.265HighProfile可实现低于1.5Mbps的传输带宽下，实现1080p全高清视频传输。除了在编解码效率上的提升外，在对网络的适应性方面H.265也有显著提升，可很好运行在Internet等复杂网络条件下。在运动预测方面，下一代算法将不再沿袭""宏块""的画面分割方法，而可能采用面向对象的方法，直接辨别画面中的运动主体。在变换方面，下一代算法可能不再沿袭基于傅立叶变换的算法族，有很多文章在讨论，其中提请大家注意所谓的""超完备变换""，主要特点是:其MxN的变换矩阵中，M大于N，甚至远大于N，变换后得到的向量虽然比较大，但其中的0元素很多，经过后面的熵编码压缩后，就能得到压缩率较高的信息流。关于运算量，H.264的压缩效率比MPEG-2提高了1倍多，其代价是计算量提高了至少4倍，导致高清编码需要100GOPS的峰值计算能力。尽管如此，仍有可能使用2013年的主流IC工艺和普通设计技术，设计出达到上述能力的专用硬件电路，且使其批量生产成本维持在原有水平。5年(或许更久)以后，新的技术被接受为标准，其压缩效率应该比H.264至少提高1倍，估计对于计算量的需求仍然会增加4倍以上。随着半导体技术的快速进步，相信届时实现新技术的专用芯片的批量生产成本应该不会有显著提高。因此，500GOPS，或许是新一代技术对于计算能力的需求上限。H.265/HEVC的编码架构大致上和H.264/AVC的架构相似，主要也包含，帧内预测(intraprediction)、帧间预测(interprediction)、转换(transform)、量化(quantization)、去区块滤波器(deblockingfilter)、熵编码(entropycoding)等模块，但在HEVC编码架构中，整体被分为了三个基本单位，分别是:编码单位(codingunit,CU)、预测单位(predictunit,PU)和转换单位(transformunit,TU)。比起H.264/AVC，H.265/HEVC提供了更多不同的工具来降低码率，以编码单位来说，H.264中每个宏块(macroblock/MB)大小都是固定的16x16像素，而H.265的编码单位可以选择从最小的8x8到最大的64x64。以下图为例，信息量不多的区域(颜色变化不明显，比如车体的红色部分和地面的灰色部分)划分的宏块较大，编码后的码字较少，而细节多的地方(轮胎)划分的宏块就相应的小和多一些，编码后的码字较多，这样就相当于对图像进行了有重点的编码，从而降低了整体的码率，编码效率就相应提高了。同时，H.265的帧内预测模式支持33种方向(H.264只支持8种)，并且提供了更好的运动补偿处理和矢量预测方法。反复的质量比较测试已经表明，在相同的图象质量下，相比于H.264，通过H.265编码的视频大小将减少大约39-44%。由于质量控制的测定方法不同，这个数据也会有相应的变化。通过主观视觉测试得出的数据显示，在码率减少51-74%的情况下，H.265编码视频的质量还能与H.264编码视频近似甚至更好，其本质上说是比预期的信噪比(PSNR)要好。这些主观视觉测试的评判标准覆盖了许多学科，包括心理学和人眼视觉特性等，视频样本非常广泛，虽然它们不能作为最终结论，但这也是非常鼓舞人心的结果。H.264与H.265编码视频的主观视觉测试对比，我们可以看到后者的码率比前者大大减少了截止2013年的HEVC标准共有三种模式:Main、Main10、MainStillPicture。Main模式支持8bit色深(即红绿蓝三色各有256个色度，共1670万色)，Main10模式支持10bit色深，将会用于超高清电视(UHDTV)上。前两者都将色度采样格式限制为4:2:0。预期将在2014年对标准有所扩展，将会支持4:2:2和4:4:4采样格式(即提供了更高的色彩还原度)，和多视图编码(例如3D立体视频编码)。事实上，H.265和H.264标准在各种功能上有一些重叠，例如，H.264标准中的Hi10P部分就支持10bit色深的视频。另一个H.264的部分(Hi444PP)还可以支持4:4:4色度抽样和14bit色深。在这种情况下，H.265和H.264的区别就体现在前者可以使用更少的带宽来提供同样的功能，其代价就是设备计算能力:H.265编码的视频需要更多的计算能力来解码。已经有支持H.265解码的芯片发布了--博通公司在2013年1月初的CES大展上发布了一款BrahmaBCM7445芯片，它是一个采用28纳米工艺的四核处理器，可以同时转码四个1080P视频数据流，或解析分辨率为4096×2160的H.265编码超高清视频。截止2013年，有线电视和数字电视广播主要采用仍旧是MPEG-2标准。好消息是，H.265标准的出台最终可以说服广播电视公司放弃垂垂老矣的MPEG-2，因为同样的内容，H.265可以减少70-80%的带宽消耗。这就可以在现有带宽条件下轻松支持全高清1080p广播。但是另一方面，电视广播公司又很少有想要创新的理由，因为大多数有线电视公司在他们的目标市场中面临的竞争实在是有限。出于节省带宽的目的，反而是卫星电视公司可能将会率先采用H.265标准。从长远角度看，H.265标准将会成为超高清电视(UHDTV)的4K和8K分辨率的选择，但这也会带来其它问题，比如2013年还极少有原生4K分辨率的视频内容。H.265标准的完成意味着内容拥有者在2013年已经有了一个对应的理论标准，但是他们在2013年还没有一个统一的方式来传送内容。标清(SD)、高清(HD)和8K分辨率超高清(UHD)视频大小对比图蓝光光盘协会(TheBlu-rayDiscAssociation)正在研究在蓝光光盘标准中支持4K分辨率视频的方法，但是这可没那么简单。理论上H.264在扩展后就可以拥有这个功能，但是到那时码率问题又会浮出水面。一个H.264编码的4K蓝光电影需要的存储空间远大于相同内容的H.265版本，其大小可高达100G以上，而现有的播放器也不支持100-128GB的高容量可刻录可擦写光盘(BDXL)。到目前为止，仍然没有一个妥善解决方案，可以将4K分辨率视频加入已有的蓝光标准中并且不破坏其兼容性。虽然更新到H.265标准并不需要对光盘制造工艺进行改进，但却需要制造全新的播放器才能将新的蓝光光盘播放出来，虽然截止2013年的有些播放器可以播放高密度光盘，但那也需要进行设备检查升级才行。另一个大问题就是游戏主机对H.265标准的支持。索尼的PS2和PS3主机推动了DVD和蓝光标准的发展，而即将发布的PS4理论上很可能将支持4K分辨率的内容，但4K分辨率的视频该怎样传送，通过哪些标准进行支持?这仍然还在讨论中。目前看来，对于H.265/HEVC标准，我们仍需持谨慎乐观态度。但有一点是肯定的:H.265标准在同等的内容质量上会显著减少带宽消耗，有了H.265，高清1080P电视广播和4K视频的网络播放将不在困难，但前提是索尼或者其它媒体巨头能想出办法来传送这些内容。同时，如果移动设备要采用H.265标准，那么其在解码视频时对电量的高消耗也是各大厂商需要解决的问题。",2015/6/19
232,red5自定义视频流目录(修改默认的streams/目录为其它),庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9061,"本文介绍了使用bean对自己的项目进行配置,更换默认的视频播放目录和视频录制目录.在0.6版的时候,我们可以直接在red5-web.properties中写入playbackPath=mypath/来进行目录定义,但是在0.7以后的版本,这样写已经不起作用了.因此到网上查了一下,找到了这篇文章.发出来供大家参考RED5中文件名的产生控制RED5使用scope服务来对其本身的一些功能进行控制.其中一个scope服务是IStreamFilenameGenerator,它用来产生点播VOD流或录制流的的文件名.我们可以通过自定义该scope来达到改变默认视频目录的目的.自己的IStreamFilenameGenerator想要自定义视频目录的路径,我们必须implements一个自己的文件产生器,代码如下:importorg.red5.server.api.IScope;importorg.red5.server.api.stream.IStreamFilenameGenerator;publicclassCustomFilenameGeneratorimplementsIStreamFilenameGenerator{/**Paththatwillstorerecordedvideos.*/publicStringrecordPath=""recordedStreams/"";/**PaththatcontainsVODstreams.*/publicStringplaybackPath=""videoStreams/"";publicStringgenerateFilename(IScopescope,Stringname,GenerationTypetype){//Generatefilenamewithoutanextension.returngenerateFilename(scope,name,null,type);}publicStringgenerateFilename(IScopescope,Stringname,Stringextension,GenerationTypetype){Stringfilename;if(type==GenerationType.RECORD)filename=recordPath+name;elsefilename=playbackPath+name;if(extension!=null)//Addextensionfilename+=extension;returnfilename;}}上述代码所构成的文件发生器,将产生类似recordedStreams/red5RecordDemo1234.flv的视频录制文件以及将videoStreams作为VOD点播的默认目录修改配置文件另我们的文件管理器生效下一步,我们自定义的文件产生器必须通过配置文件来生效,这样才能对我们的应用产生影响.修改你的项目中WEB-INFO/red5-web.xml<beanid=""streamFilenameGenerator""class=""path.to.your.CustomFilenameGenerator""/>请注意,实际上你的CustomFilenameGenerator肯定是在其他的包中,因此这里我们用path.to.your来表示.你需要用实际的路径来代替它,例如com.D5Power.CustomFilenameGenerator.这样一来,你就可以通过我们编写的CustomFilenameGenerator来控制你想要的视频播放目录和录制目录了,但是对于一个项目来说,这样似乎很麻烦,我们要修改目录的时候总是要去修改源代码,并重新进行编译.我们需要象原来的0.6版程序一样,只通过配置文件就可以进行配置.这样更方便一些.那么,对我们的代码做一些修改吧.向CustomFilenameGenerator中增加以下两个方法publicvoidsetRecordPath(Stringpath){recordPath=path;}publicvoidsetPlaybackPath(Stringpath){playbackPath=path;}接下来,把我们的bean的配置代码改成下面这样<beanid=""streamFilenameGenerator""class=""path.to.your.CustomFilenameGenerator""><propertyname=""recordPath""value=""recordedStreams/""/><propertyname=""playbackPath""value=""videoStreams/""/></bean>当然,你还可以把这两个变量的声明移到你的应用中WEB-INF/red5-web.properties文件中,于是上述代码变成了:<beanid=""streamFilenameGenerator""class=""path.to.your.CustomFilenameGenerator""><propertyname=""recordPath""value=""${recordPath}""/><propertyname=""playbackPath""value=""${playbackPath}""/></bean>而在red5-web.properties中多出以下两个变量的声明就可以了recordPath=recordedStreams/playbackPath=videoStreams/D5附:其实我们也从这个例子中看到了RED5中一些参数的获取原理.我们也可以通过类似的方法进行mysql等资料的配置.",2015/6/19
233,Oracle 10g/11g 导入导出整理,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9060,"Oracle10g/11g基本导入导出命令：exp用户名/用户密码@服务名file=保存路径.dmpbuffer=8192filesize=10000mfeedback=1000imp用户名/用户密码@服务名file=文件所在路径.dmpfull=y一般来说,指定用户下数据导出(包括触发器,存储过程等)在10g中就可以完全导出(导入)。另外还有导出指定表,指定函数等可以参考Oracle的官方文档(安装后EM界面上貌似就有,也可以到官网上去找)。总体来说10g的导入导出还比较方便。说明：1、exp/imp命令使用时,只要能够连接数据库,那么就可以在服务端(远端)使用。2、Oracle11g基本导入导出命令与Oracle10g相同,需要注意的是11g导出有时空表不会导出,问题参考 3、在不同版本导入时,高版本可以兼容低版本的导出文件,但是需要注意表空间名称、索引、版本号等问题。使用expdp/impdp导出/导入文件：使用expdp命令时,需要指定转储的文件夹。1、基本导出方法：CREATEORREPLACEDIRECTORYtest_dir(directory别名)AS'/u01/app/oracle/oradata/'(此处为硬盘上路径);GRANTREAD,WRITEONDIRECTORYtest_dir(directory别名)TOscott(指定用户名)/public(所有用户);expdpscott/scott@orcldirectory=test_dirDUMPFILE=xx.dmpschemas=scott(用户名)logfile=expdpScott.logversion=10.2.0.1.0(导入数据版本号,同版本内可选参数)2、并行导出：expdpscott/scott@orcldirectory=test_dirparallel=4DUMPFILE=xx_%U.dmpschemas=scott(用户名)logfile=expdpScott.logversion=10.2.0.1.0其中,parallel为并行导出参数。可以指定导出时使用的线程数。_%U为通配符,导出后形式为XX01.dmp;xx02.dmp等。说明：1、expdp/impdp为服务器端命令,所以此时导出时只能在服务器端使用(若在远端导出请往下看)2、到出前请确认作为转储文件夹在硬盘中存在且路径正确3、version使用时,如果是从11g导入的数据要导入到10g中,那么请指定10g的版本号4、导入命令请参考文档(见最后的参考资料b.中)远端使用expdp命令导出：使用远端导出时,请确认远端电脑中安装有oracle客户端并且能够连接到服务端。同时也要相应的建立转储文件夹,且DIRECTORY要建立在本地CREATEDATABASELINKremote_scott(dblink别名)CONNECTTOSCOTT(要连接到用户名)IDENTIFIEDBYtiger(要连接的用户密码)USING'DEV'(远端数据库服务名);expdptest/test@db10g(本地数据库用户)tables=SCOTT.EMP(远端)network_link=REMOTE_SCOTT(dblink名称)directory=TEST_DIRdumpfile=EMP.dmplogfile=exp.log思路就是在本地库与远端建立DB_Link。上面语句中tables=SCOTT.EMP(远端)只是导出的一张表(导出用户下所有表)。",2015/6/19
234,javascript常用代码大全,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9059,从网上发现的，里面好多总结得方法挺实用的！！！javascript常用代码大全.doc,2015/6/19
235,新OA的首页将要改版了，您希望改进哪些地方？,康廷,http://180.168.156.212:2262/wecenter/?/article/9057,新OA的首页最近将要改版了，您希望改进哪些地方？在你使用OA首页的过程中，觉得哪里不舒服？哪里需要改进，需要增加什么？减去什么板块。都可以反映给我们。我们尽力在新OA中改进。,2015/6/18
236,关于OCR识别的探索,孙传金,http://180.168.156.212:2262/wecenter/?/article/9056,"最近在灵器工具集中的格式转换软件2.0性能测试中ocr识别的效率与格式转换软件1.0的差别有20倍之大，因此本章将针对如何提高ocr识别进行阐述。在以下介绍中，格式转换软件2.0简称2.0；格式转换软件1.0简称1.0。2.0中ocr使用的是Google的tesseract，而1.0版本使用的微软office中带的工具MicrosoftOfficeDocumentImaging工具（简称MODI），那么为什么会有如此大的差别呢？为了更直观表现二者的差别，使用相同的tif文件进行识别，数据如下：文件1：Tesseract：耗时46秒753MODI：耗时03秒642文件2：Tesseract：耗时29秒938MODI：耗时03秒246以上两个实例充分说明了两者的识别时间差距。为了能够更好的与现有的相同集成，因此采用了jacob1.18M2的com访问jar包，具体JAVA实例代码：importcom.jacob.activeX.*;importcom.jacob.com.*;importcom.jacob.*;privatestaticStringdoOCR_MODI(StringfilePath){System.out.println(""进入modi.document识别模块"");StringBuildersb=newStringBuilder();ActiveXComponentwordApp=newActiveXComponent(""MODI.Document"");Dispatch.call(wordApp,""Create"",newVariant(filePath));Dispatch.call(wordApp,""OCR"",newVariant[]{newVariant(2052)});Dispatchimage,layout;Dispatchimages=wordApp.getProperty(""images"").toDispatch();inttotal=Dispatch.call(images,""count"").toInt();System.out.println(""total=>""+total);for(inti=0;i<total;i++){image=Dispatch.call(wordApp,""images"",newVariant(i)).toDispatch();layout=Dispatch.call(image,""layout"").toDispatch();sb.append(Dispatch.call(layout,""Text"").toString());}returnsb.toString();}MODI独立工具安装.zipOCRImages.zip",2015/6/17
237,近期彩码调研结果,王国栋,http://180.168.156.212:2262/wecenter/?/article/9058,近期调研的上海彩链公司和中食安彩色三维码，反编译后发现两家解码内核完全一致，可以猜测加密原理也一致。两家公司的产品都申请了专利，并且彩码的母公司colorzip也在中国申请了多项图形、图像方面的专利，如果我们后续采用近似方案，可能会有问题。图片附件为彩码解码处理流程。ppt为彩码大概介绍。参考了大量colorzip、colormobi的专利文档。挑了几篇比较有用的，如下（要翻墙）： /viewer...C.pdf彩码调研结果回报交流6月5日.pptx彩链调用分析.bmp,2015/6/16
238,设计相关 ： Top Web Design Trends for 2015,王链玮,http://180.168.156.212:2262/wecenter/?/article/9055,老外推荐的集中流行设计，中文翻译版本TopWebDesignTrendsfor2015.docx,2015/6/16
239,2015年计算机职称考试信息,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/9054, ,2015/6/11
240,javascript的函数节流,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/9053,javascript的函数节流浅谈javascript的函数节流.docx,2015/6/5
241,Access-Control-Allow-Origin解决Ajax跨域问题,何文,http://180.168.156.212:2262/wecenter/?/article/9052,"今天一个Ajax跨域问题，纠结我半天，记录之。<html><head><title>title</title><scriptsrc="" ""></script><script>$.ajax({url:"" /gpsApi.php?lat=22.502412986242&lng=113.93832783228"",type:'GET',dataType:'JSONP',success:function(data){$('body').append(""Name:""+data);}});</script></head><body>测试Ajax跨域问题</body></html>二，server端加上header设为Access-Control-Allow-Origin：*header(""Access-Control-Allow-Origin:*"");#跨域处理问题就解决了。",2015/6/4
242,jquery选择器问题,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/9051,jquery选择器问题以及达梦数据库查询空字符串问题总结经验共享-毛璀玲[201505].doc,2015/6/4
243,终于有人把O2O、C2C、B2B、B2C的区别讲透了,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/9050,"一.O2O、C2C、B2B、B2C的区别在哪里？o2o是onlinetooffline分为四种运营模式1.onlinetooffline是线上交易到线下消费体验2.offlinetoonline是线下营销到线上交易3.offlinetoonlinetooffline是线下营销到线上交易再到线下消费体验4.onlinetoofflinetoonline是线上交易或营销到线下消费体验再到线上消费体验比如:保险直购O2O,苏宁易购O2O,大众点评O2O等c2c是consumertoconsumer就是个人对个人的，比如淘宝的小店铺。b2c是businesstoconsumer是商家对个人，这个就很多了卓越、当当、京东等等都是。b2cc2c很重要的一点是都运用了物流。b2b是businesstobusiness是企业间的，比如阿里巴巴。举例通俗说明一下就是：C2C就是我卖东西你来买B2C就是我成立个公司卖东西，你来买O2O就是我成立个公司卖东西，你来买，但是要你自己来拿B2B就是你也成立了公司，买我公司的东西二.电子商务知识口诀B2B有三宝：企业、中介、沟通好B2C有三宝：品牌、渠道、销售好C2C有三宝：你开、我买、支付宝O2O有三宝：线上、线下、一起搞LBS有三宝：签到、优惠、位置找NFC有三宝：近场、支付、安全好SEO有三宝：内容、外链、权重屌EDM有三宝：内容、受众、分析好CPA有三宝：行动、转化、站长恼CPS有三宝：佣金、销量、效果好CPC有三宝：点击、引导、作弊少CPM有三宝：展示、千人、不可靠PHP有三宝：开放、高效、成本少从事电子商务，以上都要知晓电子商务模式B2B(经济组织对经济组织)B2C(经济组织对消费者)B2B2C(企业对企业对消费者)C2B(T)(消费者集合竞价-团购)C2C(消费者对消费者)B2F(企业对家庭)O2O(网上与网下相结合)SaaS(软件服务)PaaS(平台服务)IaaS(基础服务)M-B(移动电子商务)B2G(政府采购)G2B(政府抛售)B2M(面向市场营销的电子商务企业)M2C(生产厂商对消费者)SoLoMo(社交+本地化+移动)ABC(代理商-商家-消费者)BAB(企业-联盟-企业)P2C(生活服务平台)P2P(点对点、渠道对渠道)SNS-EC(社会化网络电子商务)B2S(分享式商务，或体验式商务)",2015/6/4
244,我们成功了吗?IT国产化这条路走到哪儿了,王链玮,http://180.168.156.212:2262/wecenter/?/article/9049, ,2015/6/3
245,为什么越来越多的手机不能换电池？,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9047,自苹果公司推出iPhone系列手机之后，越来越多的安卓手机厂商也开始不学好，不但不支持内存卡拓展，还开始学苹果不能更换电池的设计。不可更换电池虽然能保证了机身的一体化，但也容易引发一系列的问题，给用户造成很大的不便。在批斗这个脑残设计之前，我们不妨来看看手机不能换电池的好处。手机不能换电池的好处如下：1、让机身更紧凑，手机设计更精美频繁更换电池会使外壳松动，一体成型也是出于更好的外观，可以很好的提升机器的整体性和手感，.给人外观上的享受。智能手机行内有个不成文的规定，不超过10mm左右的标准，超过10mm，那么它的工业设计就会被人嘲笑。不更换电池更体现设计水平。2、出于商业目的，也更容易保修一体机更加不容易送保，出的问题少。可更换电池方面容易被不良商家更换导致出的问题大大增加。而且防止用户自己使用其他电池造成对手机的伤害。假如手机采用可更换电池的设计，用户买第二块手机的时候买原装电池的比较少，大多数都买其他品牌的电板，与其自己的电板买不掉，还不如不做电板，搞个内置的电池，让做电板的厂商干瞪眼去吧！3、不会有因为电池触点松动引起重启众所周知，手机可更换电池，我们就会频繁开启后盖，更换电池的过程会导致电池金属触点氧化，由于电池和机身接触不良，很容易就引起手机莫名其妙的关机和重启。既然手机不换电池有这么多好处，那为什么很多人都反感手机不可更换电池的设计。我们不妨来看看，不可更换电池到底有什么不好呢？手机不能更换电池的的弊端：1、电池寿命到期后，隐性成本高所以现在的手机，不能换电池缺点就是，电池寿命到了后，更换麻烦，成本高。很多时候，手机电池不耐用了，意味着你这部手机基本上就报废了，不管你是苹果、索尼还是HTC，不管你多少钱买的，电池不耐用了等于逼着你换手机。2、边充电边用手机，存在安全隐患你知道边冲边放电是有多危险吗？前段时间，曾经有媒体报答过，边冲边放电引起的电池爆炸事故。两块电池就什么问题没有。内置电池用一段时间就坏了，容量急剧下降，到最后充满电只能用半小时的时候，高兴去吧。还有，有的电池越充越鼓，特别的危险用户却不知道，真正出问题的时候你也高兴去吧！3、不能换电池远没有可以换电池方有多少人能接受需要用手机的时候却要一手拿着移动电源，一手拿着手机在街上打电话是有多不方便，而可更换电池，一块用完了下一块已经冲好，换个电池，原地满血复活多方便！小结：不能更换电池的手机除非电池容量很大，至少2500毫安以上能达到3000毫安最好否则低于2000毫安的手机我还真没信心买配置再强也不愿意买为了续航牺牲了体验真心划不来。现如今，越来越多的手机厂商逐渐加入了不能换电池的行列中。相比之下，三星可换电池的设计就显得良心多了。而容量达到2500mAh的三星i9220，都能换电池。它的后续版本Note2就是3100mAh，还是能换电池。当然，三星手机售价也是一如既往的贵。再来看看哪些不能换电池的：iPhone4S，1420mAh。HTCOneX，1800mAh。简直都是要逆天。所以说为了保修方便、为了美观都是厂商为不可换电池的找的借口。小编吐槽：手机不能换电池我们忍了，最不能忍受的就是，有的手机可以拆后盖却不能换电池。比如小米4和锤子手机。,2015/6/1
246,Java 8 默认方法和多继承,孙荟博,http://180.168.156.212:2262/wecenter/?/article/9046,"以前经常谈论的Java对比c++的一个优势是Java中没有多继承的问题。因为Java中子类只能继承(extends)单个父类，尽管可以实现(implements)多个接口，但是接口中只有抽象方法，方法体是空的，没有具体的方法实现，不会有方法冲突的问题。这些都是久远的说法了，自从今年Java8发布后，接口中也可以定义方法了(defaultmethod)。之所以打破以前的设计在接口中增加具体的方法，是为了既有的成千上万的Java类库的类增加新的功能，且不必对这些类重新进行设计。比如，只需在Collection接口中增加defaultStream<E>stream(),相应的Set和List接口以及它们的子类都包含此的方法，不必为每个子类都重新copy这个方法。这是一个折衷的设计，带来的问题就是为Java引入了多继承的问题。我们知道，接口可以继承接口，类可以继承类和实现接口。一旦继承的类和实现的接口中有相同签名的方法，会出现什么样的状况呢？本文将探讨各种情况的多继承，以便能清楚的理解Java多继承的规则。接口继承多个父接口假定有三个接口InterfaceA,InterfaceB,InterfaceC,继承关系如下：123456789+---------------++------------+|InterfaceA||InterfaceB|+-----------^---++---^--------+||||||+-+------------+--+|InterfaceC|+------------+A,B拥有相同签名的默认方法defaultStringsay(Stringname),如果接口C没有override这个方法，则编译出错。12345678910111213interfaceA{defaultStringsay(Stringname){return""hello""+name;}}interfaceB{defaultStringsay(Stringname){return""hi""+name;}}interfaceCextendsA,B{}错误信息：123456C:\Lambda\src>javac-J-Duser.country=UScom\colobu\lambda\chapter3\MultipleInheritance1.javacom\colobu\lambda\chapter3\MultipleInheritance1.java:17:error:interfaceCinheritsunrelateddefaultsforsay(String)fromtypesAandBstaticinterfaceCextendsA,B{^1error我们可以在子接口C中覆盖override这个方法,这样编译就不会出错了：12345interfaceCextendsA,B{defaultStringsay(Stringname){return""greet""+name;}}注意方法签名不包括方法的返回值，也就是仅仅返回值不同的两个方法的签名也是相同的。下面的代码编译不会出错，因为A和B的默认方法不同，C隐式继承了两个默认方法。12345678910111213interfaceA{defaultvoidsay(intname){}}interfaceB{defaultvoidsay(Stringname){}}interfaceCextendsA,B{}但是有的情况下即使是不同签名的方法也是很难分辨的：123456789101112131415161718192021interfaceA{defaultvoidsay(inta){System.out.println(""A"");}}interfaceB{defaultvoidsay(shorta){System.out.println(""B"");}}interfaceCextendsA,B{}staticclassDimplementsC{}publicstaticvoidmain(String[]args){Dd=newD();bytea=1;d.say(a);//B}Java会选择最适合的方法，请参看Java规范15.12.2.5接口多层继承下面看一下多层继承的问题。继承关系如下图，A2继承A1,C继承A2。123456789101112131415+---------------+|InterfaceA1|+--------+------+|||+--------+------+|InterfaceA2|+-------+-------+|||+-------+--------+|InterfaceC|+----------------+基于我们以前对类继承的认识，很容易知道C会继承A2的默认方法，包括直接定义的默认方法，覆盖的默认方法，以及隐式继承于A1接口的默认方法。123456789101112131415161718192021interfaceA{defaultvoidsay(inta){System.out.println(""A"");}defaultvoidrun(){System.out.println(""A.run"");}}interfaceBextendsA{defaultvoidsay(inta){System.out.println(""B"");}defaultvoidplay(){System.out.println(""B.play"");}}interfaceCextendsA,B{}多层多继承上面一个例子还是单继承的例子，如果如下图的多继承呢？123456789101112131415161718192021222324252627282923456789101112131415+---------------+|InterfaceA1|+--------+------+|||+--------+------++---------------+|InterfaceA2||InterfaceB|+-------+-------++---------+-----+|+---------+---------^||||+-------+-------++|InterfaceC|+----------------+如果A2和B拥有相同签名的方法，这和第一个例子一样。如果不想编译出错，可以覆盖父接口的默认方法，还可以调用指定父接口的默认方法：1234567891011121314151617181920interfaceA1{defaultvoidsay(inta){System.out.println(""A1"");}}interfaceA2extendsA1{}interfaceB{defaultvoidsay(inta){System.out.println(""B"");}}interfaceCextendsA2,B{defaultvoidsay(inta){B.super.say(a);}}更复杂的多层多继承12345678910111213+--------------+|InterfaceA1|+------+------++|^+-------+||+-------+-------+||InterfaceA2||+------------+--+|^--++|||+--+------+-----+|InterfaceC|+---------------+接口A2继承A1，接口C继承A2和A1。代码如下，1234567891011121314151617181920interfaceA1{defaultvoidsay(){System.out.println(""A1"");}}interfaceA2extendsA1{defaultvoidsay(){System.out.println(""A2"");}}interfaceCextendsA2,A1{}staticclassDimplementsC{}publicstaticvoidmain(String[]args){Dd=newD();d.say();}以上代码不会编译出错，运行输出A2。可以看到接口C会隐式继承子接口的方法，也就是子接口A2的默认方法。类继承如果继承关系类型全部是类，那么由于类依然是单继承的，不会有多继承的问题。类和接口混杂我们把第一个例子中的其中一个接口换成类，会出现什么现象呢。12345678+-------------++-----------+|InterfaceA||ClassB|+-----------+-++-----+-----+^-++--+-----^||+---+----+-+|ClassC|+----------+以下代码不会编译出错：1234567891011121314151617interfaceA{defaultvoidsay(){System.out.println(""A"");}}staticclassB{publicvoidsay(){System.out.println(""B"");}}staticclassCextendsBimplementsA{}publicstaticvoidmain(String[]args){Cc=newC();c.say();//B}结果输出B。可以看出，子类优先继承父类的方法，如果父类没有相同签名的方法，才继承接口的默认方法。结论更复杂的继承关系可以简化成以上的继承关系。根据以上的例子，可以得出以下的结论：类优先于接口。如果一个子类继承的父类和接口有相同的方法实现。那么子类继承父类的方法子类型中的方法优先于父类型中的方法。如果以上条件都不满足，则必须显示覆盖/实现其方法，或者声明成abstract。",2015/5/31
247,Oracle中sequence的缓存问题,孙荟博,http://180.168.156.212:2262/wecenter/?/article/9045,Oracle中的sequence缓存问题Oracle中sequence的缓存问题.docx,2015/5/31
248,JAVA NIO详解,姚锡铭,http://180.168.156.212:2262/wecenter/?/article/9044,"JavaNIO（NewIO）是从Java1.4版本开始引入的一个新的IOAPI，可以替代标准的JavaIOAPI。本系列教程将有助于你学习和理解JavaNIO。JavaNIO提供了与标准IO不同的IO工作方式：ChannelsandBuffers（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。AsynchronousIO（异步IO）：JavaNIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。Selectors（选择器）：JavaNIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。下面就来详细介绍JavaNIO的相关知识。目录1.JavaNIO概述2.JavaNIOvs.IO3.通道（Channel）4.缓冲区（Buffer）5.分散（Scatter）/聚集（Gather）6.通道之间的数据传输7.选择器（Selector）8.文件通道9.Socket通道10.ServerSocket通道11.Datagram通道12.管道（Pipe）JavaNIO概述JavaNIO由以下几个核心部分组成：ChannelsBuffersSelectors虽然JavaNIO中除此之外还有很多类和组件，但在我看来，Channel，Buffer和Selector构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。Channel和Buffer基本上，所有的IO在NIO中都从一个Channel开始。Channel有点象流。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。这里有个图示：Channel和Buffer有好几种类型。下面是JAVANIO中的一些主要Channel的实现：FileChannelDatagramChannelSocketChannelServerSocketChannel正如你所看到的，这些通道涵盖了UDP和TCP网络IO，以及文件IO。与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。以下是JavaNIO里关键的Buffer实现：ByteBufferCharBufferDoubleBufferFloatBufferIntBufferLongBufferShortBuffer这些Buffer覆盖了你能通过IO发送的基本数据类型：byte,short,int,long,float,double和char。JavaNIO还有个Mappedyteuffer，用于表示内存映射文件，我也不打算在概述中说明。SelectorSelector允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。这是在一个单线程中使用一个Selector处理3个Channel的图示：要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。JavaNIOvs.IO当学习了JavaNIO和IO的API后，一个问题马上涌入脑海：引用我应该何时使用IO，何时使用NIO呢？在本文中，我会尽量清晰地解析JavaNIO和IO的差异、它们的使用场景，以及它们如何影响您的代码设计。JavaNIO和IO的主要区别下表总结了JavaNIO和IO之间的主要差别，我会更详细地描述表中每部分的差异。IONIOStreamorientedBufferorientedBlockingIONonblockingIOSelectors面向流与面向缓冲JavaNIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。JavaIO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。JavaNIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。阻塞与非阻塞IOJavaIO的各种流是阻塞的。这意味着，当一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。JavaNIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。选择器（Selectors）JavaNIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。NIO和IO如何影响应用程序的设计无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面：对NIO或IO类的API调用。数据处理。用来处理数据的线程数。API调用当然，使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理。数据处理使用纯粹的NIO设计相较IO设计，数据处理也受到影响。在IO设计中，我们从InputStream或Reader逐字节读取数据。假设你正在处理一基于行的文本数据流，例如：代码Name:AnnaAge:25Email:anna@mailserver.comPhone:1234567890该文本行的流可以这样处理：Java代码InputStreaminput=…;//gettheInputStreamfromtheclientsocketBufferedReaderreader=newBufferedReader(newInputStreamReader(input));StringnameLine=reader.readLine();StringageLine=reader.readLine();StringemailLine=reader.readLine();StringphoneLine=reader.readLine();请注意处理状态由程序执行多久决定。换句话说，一旦reader.readLine()方法返回，你就知道肯定文本行就已读完，readline()阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个readline()调用返回的时候，你知道这行包含年龄等。正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：从一个阻塞的流中读数据而一个NIO的实现会有所不同，下面是一个简单的例子：Java代码ByteBufferbuffer=ByteBuffer.allocate(48);intbytesRead=inChannel.read(buffer);注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。假设第一次read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：Java代码ByteBufferbuffer=ByteBuffer.allocate(48);intbytesRead=inChannel.read(buffer);while(!bufferFull(bytesRead)){bytesRead=inChannel.read(buffer);}bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。bufferFull()方法扫描缓冲区，但必须保持在bufferFull（）方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：从一个通道里读数据，直到所有的数据都读到缓冲区里总结NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：单线程管理多个连接如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：一个典型的IO服务器设计：一个连接通过一个线程处理通道（Channel）JavaNIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。通道可以异步地读写。通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示：Channel的实现这些是JavaNIO中最重要的通道的实现：FileChannel：从文件中读写数据。DatagramChannel：能通过UDP读写网络中的数据。SocketChannel：能通过TCP读写网络中的数据。ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。基本的Channel示例下面是一个使用FileChannel读取数据到Buffer中的示例：Java代码RandomAccessFileaFile=newRandomAccessFile(""data/nio-data.txt"",""rw"");FileChannelinChannel=aFile.getChannel();ByteBufferbuf=ByteBuffer.allocate(48);intbytesRead=inChannel.read(buf);while(bytesRead!=-1){System.out.println(""Read""+bytesRead);buf.flip();while(buf.hasRemaining()){System.out.print((char)buf.get());}buf.clear();bytesRead=inChannel.read(buf);}aFile.close();注意buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。缓冲区（Buffer）JavaNIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIOBuffer对象，并提供了一组方法，用来方便的访问该块内存。Buffer的基本用法使用Buffer读写数据一般遵循以下四个步骤：写入数据到Buffer调用flip()方法从Buffer中读取数据调用clear()方法或者compact()方法当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。下面是一个使用Buffer的例子：Java代码RandomAccessFileaFile=newRandomAccessFile(""data/nio-data.txt"",""rw"");FileChannelinChannel=aFile.getChannel();//createbufferwithcapacityof48bytesByteBufferbuf=ByteBuffer.allocate(48);intbytesRead=inChannel.read(buf);//readintobuffer.while(bytesRead!=-1){buf.flip();//makebufferreadyforreadwhile(buf.hasRemaining()){System.out.print((char)buf.get());//read1byteatatime}buf.clear();//makebufferreadyforwritingbytesRead=inChannel.read(buf);}aFile.close();Buffer的capacity,position和limit缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIOBuffer对象，并提供了一组方法，用来方便的访问该块内存。为了理解Buffer的工作原理，需要熟悉它的三个属性：capacitypositionlimitposition和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。这里有一个关于capacity，position和limit在读写模式中的说明，详细的解释在插图后面。capacity作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。position当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后，position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity–1。当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。limit在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时，limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）Buffer的类型JavaNIO有以下Buffer类型：ByteBufferMappedByteBufferCharBufferDoubleBufferFloatBufferIntBufferLongBufferShortBuffer如你所见，这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float或double类型来操作缓冲区中的字节。MappedByteBuffer有些特别，在涉及它的专门章节中再讲。Buffer的分配要想获得一个Buffer对象首先要进行分配。每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。Java代码ByteBufferbuf=ByteBuffer.allocate(48);这是分配一个可存储1024个字符的CharBuffer：Java代码CharBufferbuf=CharBuffer.allocate(1024);向Buffer中写数据写数据到Buffer有两种方式：从Channel写到Buffer。通过Buffer的put()方法写到Buffer里。从Channel写到Buffer的例子Java代码intbytesRead=inChannel.read(buf);//readintobuffer.通过put方法写Buffer的例子：Java代码buf.put(127);put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如，写到一个指定的位置，或者把一个字节数组写入到Buffer。更多Buffer实现的细节参考JavaDoc。flip()方法flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等——现在能读取多少个byte、char等。从Buffer中读取数据从Buffer中读取数据有两种方式：从Buffer读取数据到Channel。使用get()方法从Buffer中读取数据。从Buffer读取数据到Channel的例子：Java代码//readfrombufferintochannel.intbytesWritten=inChannel.write(buf);使用get()方法从Buffer中读取数据的例子Java代码byteaByte=buf.get();get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。rewind()方法Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。clear()与compact()方法一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。如果调用的是clear()方法，position将被设回0，limit被设置成capacity的值。换句话说，Buffer被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。mark()与reset()方法通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：Java代码buffer.mark();//callbuffer.get()acoupleoftimes,e.g.duringparsing.buffer.reset();//setpositionbacktomark.equals()与compareTo()方法可以使用equals()和compareTo()方法两个Buffer。equals()当满足下列条件时，表示两个Buffer相等：有相同的类型（byte、char、int等）。Buffer中剩余的byte、char等的个数相等。Buffer中所有剩余的byte、char等都相同。如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。compareTo()方法compareTo()方法比较两个Buffer的剩余元素(byte、char等)，如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：第一个不相等的元素小于另一个Buffer中对应的元素。所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。（译注：剩余元素是从position到limit之间的元素）分散（Scatter）/聚集（Gather）JavaNIO开始支持scatter/gather，scatter/gather用于描述从Channel（译者注：Channel在中文经常翻译为通道）中读取或者写入到Channel的操作。分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel将多个Buffer中的数据“聚集（gather）”后发送到Channel。scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。ScatteringReadsScatteringReads是指数据从一个channel读取到多个buffer中。如下图描述：代码示例如下：Java代码ByteBufferheader=ByteBuffer.allocate(128);ByteBufferbody=ByteBuffer.allocate(1024);ByteBuffer[]bufferArray={header,body};channel.read(bufferArray);注意buffer首先被插入到数组，然后再将数组作为channel.read()的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。ScatteringReads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如128byte），ScatteringReads才能正常工作。GatheringWritesGatheringWrites是指数据从多个buffer写入到同一个channel。如下图描述：代码示例如下：Java代码ByteBufferheader=ByteBuffer.allocate(128);ByteBufferbody=ByteBuffer.allocate(1024);//writedataintobuffersByteBuffer[]bufferArray={header,body};channel.write(bufferArray);buffers数组是write()方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与ScatteringReads相反，GatheringWrites能较好的处理动态消息。通道之间的数据传输在JavaNIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel（译者注：channel中文常译作通道）传输到另外一个channel。transferFrom()FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子：Java代码RandomAccessFilefromFile=newRandomAccessFile(""fromFile.txt"",""rw"");FileChannelfromChannel=fromFile.getChannel();RandomAccessFiletoFile=newRandomAccessFile(""toFile.txt"",""rw"");FileChanneltoChannel=toFile.getChannel();longposition=0;longcount=fromChannel.size();toChannel.transferFrom(position,count,fromChannel);方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于count个字节，则所传输的字节数要小于请求的字节数。此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。transferTo()transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子：Java代码RandomAccessFilefromFile=newRandomAccessFile(""fromFile.txt"",""rw"");FileChannelfromChannel=fromFile.getChannel();RandomAccessFiletoFile=newRandomAccessFile(""toFile.txt"",""rw"");FileChanneltoChannel=toFile.getChannel();longposition=0;longcount=fromChannel.size();fromChannel.transferTo(position,count,toChannel);是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。选择器（Selector）Selector（选择器）是JavaNIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。(1)为什么使用Selector?仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。下面是单线程使用一个Selector处理3个channel的示例图：(2)Selector的创建通过调用Selector.open()方法创建一个Selector，如下：Java代码Selectorselector=Selector.open();(3)向Selector注册通道为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：Java代码channel.configureBlocking(false);SelectionKeykey=channel.register(selector,Selectionkey.OP_READ);与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：ConnectAcceptReadWrite通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个serversocketchannel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。这四种事件用SelectionKey的四个常量来表示：SelectionKey.OP_CONNECTSelectionKey.OP_ACCEPTSelectionKey.OP_READSelectionKey.OP_WRITE如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：Java代码intinterestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE;在下面还会继续提到interest集合。(4)SelectionKey在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：interest集合ready集合ChannelSelector附加的对象（可选）下面我会描述这些属性。interest集合就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：Java代码intinterestSet=selectionKey.interestOps();booleanisInterestedInAccept=(interestSet&SelectionKey.OP_ACCEPT)==SelectionKey.OP_ACCEPT；booleanisInterestedInConnect=interestSet&SelectionKey.OP_CONNECT;booleanisInterestedInRead=interestSet&SelectionKey.OP_READ;booleanisInterestedInWrite=interestSet&SelectionKey.OP_WRITE;可以看到，用“位与”操作interest集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest集合中。ready集合ready集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个readyset。Selection将在下一小节进行解释。可以这样访问ready集合：intreadySet=selectionKey.readyOps();可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：Java代码selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable();Channel+Selector从SelectionKey访问Channel和Selector很简单。如下：Java代码Channelchannel=selectionKey.channel();Selectorselector=selectionKey.selector();附加的对象可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：Java代码selectionKey.attach(theObject);ObjectattachedObj=selectionKey.attachment();还可以在用register()方法向Selector注册Channel的时候附加对象。如：Java代码SelectionKeykey=channel.register(selector,SelectionKey.OP_READ,theObject);(5)通过Selector选择通道一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。下面是select()方法：intselect()intselect(longtimeout)intselectNow()select()阻塞到至少有一个通道在你注册的事件上就绪了。select(longtimeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。selectNow()不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。selectedKeys()一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selectedkeyset）”中的就绪通道。如下所示：Java代码SetselectedKeys=selector.selectedKeys();当像Selector注册Channel时，Channel.register()方法会返回一个SelectionKey对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。可以遍历这个已选择的键集合来访问就绪的通道。如下：Java代码SetselectedKeys=selector.selectedKeys();IteratorkeyIterator=selectedKeys.iterator();while(keyIterator.hasNext()){SelectionKeykey=keyIterator.next();if(key.isAcceptable()){//aconnectionwasacceptedbyaServerSocketChannel.}elseif(key.isConnectable()){//aconnectionwasestablishedwitharemoteserver.}elseif(key.isReadable()){//achannelisreadyforreading}elseif(key.isWritable()){//achannelisreadyforwriting}keyIterator.<tuihighlightclass=""tuihighlight""><ahref=""javascript:;""style=""display:inline;float:none;position:inherit;cursor:pointer;color:#7962D5;text-decoration:underline;""onclick=""returnfalse;"">remove</a></tuihighlight>();}这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。(6)wakeUp()某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wakeup）”。(7)close()用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。(8)完整的示例这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。Java代码Selectorselector=Selector.open();channel.configureBlocking(false);SelectionKeykey=channel.register(selector,SelectionKey.OP_READ);while(true){intreadyChannels=selector.select();if(readyChannels==0)continue;SetselectedKeys=selector.selectedKeys();IteratorkeyIterator=selectedKeys.iterator();while(keyIterator.hasNext()){SelectionKeykey=keyIterator.next();if(key.isAcceptable()){//aconnectionwasacceptedbyaServerSocketChannel.}elseif(key.isConnectable()){//aconnectionwasestablishedwitharemoteserver.}elseif(key.isReadable()){//achannelisreadyforreading}elseif(key.isWritable()){//achannelisreadyforwriting}keyIterator.<tuihighlightclass=""tuihighlight""><ahref=""javascript:;""style=""display:inline;float:none;position:inherit;cursor:pointer;color:#7962D5;text-decoration:underline;""onclick=""returnfalse;"">remove</a></tuihighlight>();}}文件通道JavaNIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。打开FileChannel在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：Java代码RandomAccessFileaFile=newRandomAccessFile(""data/nio-data.txt"",""rw"");FileChannelinChannel=aFile.getChannel();从FileChannel读取数据调用多个read()方法之一从FileChannel中读取数据。如：Java代码ByteBufferbuf=ByteBuffer.allocate(48);intbytesRead=inChannel.read(buf);首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。向FileChannel写数据使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：Java代码StringnewData=""NewStringtowritetofile...""+System.currentTimeMillis();ByteBufferbuf=ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()){channel.write(buf);}注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。关闭FileChannel用完FileChannel后必须将其关闭。如：Java代码channel.close();FileChannel的position方法有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。也可以通过调用position(longpos)方法设置FileChannel的当前位置。这里有两个例子：Java代码longpos=channel.position();channel.position(pos+123);如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1——文件结束标志。如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。FileChannel的size方法FileChannel实例的size()方法将返回该实例所关联文件的大小。如：Java代码longfileSize=channel.size();FileChannel的truncate方法可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：Java代码channel.truncate(1024);这个例子截取文件的前1024个字节。FileChannel的force方法FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。下面的例子同时将文件数据和元数据强制写到磁盘上：Java代码channel.force(true);Socket通道JavaNIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：打开一个SocketChannel并连接到互联网上的某台服务器。一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。打开SocketChannel下面是SocketChannel的打开方式：Java代码SocketChannelsocketChannel=SocketChannel.open();socketChannel.connect(newInetSocketAddress("" "",80));当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：Java代码intbytesRead=channel.read(buf);intbytesWritten=channel.write(but);管道（Pipe）JavaNIO管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。这里是Pipe原理的图示：创建管道通过Pipe.open()方法打开管道。例如：Java代码Pipepipe=Pipe.open();向管道写数据要向管道写数据，需要访问sink通道。像这样：Java代码Pipe.SinkChannelsinkChannel=pipe.sink();通过调用SinkChannel的write()方法，将数据写入SinkChannel,像这样：Java代码StringnewData=""NewStringtowritetofile...""+System.currentTimeMillis();ByteBufferbuf=ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()){<b>sinkChannel.write(buf);</b>}",2015/5/29
249,装饰者设计模式,陆开奇,http://180.168.156.212:2262/wecenter/?/article/9043,"装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象.以下情况使用Decorator模式1.需要扩展一个类的功能，或给一个类添加附加职责。2.需要动态的给一个对象添加功能，这些功能可以再动态的撤销。3.需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。4.当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。看了上面文字性的叙述头都晕了，下面以实例来讲解。我们都知道买奶茶可以添加各种配料，如下 /images/magplus.gif),pointer;""title=""点击查看原始大小图片""width=""700""/>这里只有了4种配料即可生成那么多种奶茶，如果我们用一个奶茶子类来存储该种奶茶的价格（价格为奶茶原价加上添加各个配料的前的和）和名称，则会派生出很多对应的子类，如果再为奶茶添加巧克力，布丁等配料，则又会添加许多子类，可以想象，每增加一种配料，对应的子类会增加很多。会导致类爆炸，也不好管理对应的子类。这里就可以使用装饰者模式来解决该问题。1.定义被装饰者的对象接口Java代码packagecom.longpo.decorator;/***被装饰者的对象接口**/publicinterfaceDrink{//奶茶名字publicStringname();//奶茶价格publicfloatprice();}2.具体被装饰者的对象：奶茶Java代码packagecom.longpo.decorator;/***具体的被装饰者对象：奶茶**/publicclassMikeTeaimplementsDrink{@OverridepublicStringname(){return""奶茶"";}@Overridepublicfloatprice(){return1f;//奶茶原价1元}}3.定义装饰者的父类Java代码packagecom.longpo.decorator;/***装饰者的父类*/publicabstractclassDecoratorimplementsDrink{publicDrinkdrink;//要装饰的对象publicDecorator(Drinkdrink){this.drink=drink;}@OverridepublicStringname(){returndrink.name();}@Overridepublicfloatprice(){returndrink.price();}}4.定义装饰者类：即配料配料1：椰果类Java代码packagecom.longpo.decorator;/***具体的装饰对象：椰果*/publicclassCoconutextendsDecorator{publicCoconut(Drinkdrink){super(drink);}@OverridepublicStringname(){return""椰果""+super.name();}@Overridepublicfloatprice(){returnsuper.price()+0.8f;//椰果8毛}}配料2：珍珠类Java代码packagecom.longpo.decorator;/***具体的装饰对象：珍珠*/publicclassPearlextendsDecorator{publicPearl(Drinkdrink){super(drink);}@OverridepublicStringname(){return""珍珠""+super.name();}@Overridepublicfloatprice(){returnsuper.price()+0.5f;//珍珠5毛}}配料3：果条类Java代码packagecom.longpo.decorator;/***具体的装饰对象：果条*/publicclassFruitextendsDecorator{publicFruit(Drinkdrink){super(drink);}@OverridepublicStringname(){return""果条""+super.name();}@Overridepublicfloatprice(){returnsuper.price()+0.5f;//果条5毛}}配料4：红豆Java代码packagecom.longpo.decorator;/***具体的装饰对象：红豆*/publicclassRedBeanextendsDecorator{publicRedBean(Drinkdrink){super(drink);}@OverridepublicStringname(){return""红豆""+super.name();}@Overridepublicfloatprice(){returnsuper.price()+1f;//红豆1元}}这样我们就写好了装饰者模式了，下面来测试一下装饰者模式Java代码packagecom.longpo.decorator;publicclassDecoratorTest{publicstaticvoidmain(String[]args){//首先弄杯奶茶Drinkdrink=newMikeTea();//奶茶里添加椰果Coconutcoconut=newCoconut(drink);//再添加红豆RedBeanredBean=newRedBean(coconut);System.out.println(""第一杯奶茶为:""+redBean.name()+""价格为:""+redBean.price());//再弄杯奶茶Drinkdrink1=newMikeTea();//奶茶里添加果条Fruitfruit=newFruit(drink1);//再添加椰果Coconutcoconut1=newCoconut(fruit);//再添加红豆RedBeanredBean1=newRedBean(coconut1);//在添加珍珠Pearlpearl=newPearl(redBean1);System.out.println(""-----------------------------"");System.out.println(""第而杯奶茶为:""+pearl.name()+""价格为:""+pearl.price());}}运行结果：使用类装饰者模式，没添加一种配料我们主需要多添加一个配料的具体装饰者对象类就可以了。通过上面的实际例子，已经发现了装饰者模式的好用之处了。学习了解装饰者设计模式是很有必要的，最常用的java的IO就使用了装饰者模式。",2015/5/29
250,Eclipse和DOS下运行程序的差异(主要涉及user.dir和classpath的问题),陆开奇,http://180.168.156.212:2262/wecenter/?/article/9042,"遇到过很多人，甚至工作了几年的人，经常搞不清classpath，写了一个小程序,Eclipse能运行的程序，在DOS下就经常运行不了了，一般都是报这样的异常：java.lang.ClassNotFoundException。群里一旦有人问起，一帮人看都不看，一般都由以下几种说法：1.设置了环境变量没？这种几率还真小,安装了jdk基本上毫无疑问都会设置环境变量.2.java文件的问题.这个完全就是在胡扯了3.先把java文件编译一下.这个都在eclipse能运行了.已经都编译好了，无需再多此一举。4.classpath路径有问题.这个还真要稍微注意一下.如果是jdk5.0及以后的版本,那么classpath是完全可以不用设置的.现在大部分人应该都不会再使用jdk1.4或者更老的版本了吧.所以这个概率也很小.5.把环境变量重新设置一下.这个？？？6.这个问题太多了，百度去吧.我想这么说的人估计自己也搞不清楚。很多人都习惯了Eclipse，怎么在DOS下编译和运行还真不熟悉.首先说明一下,上面的程序是带有包名的,很好解决,只要进入到项目的bin目录下,运行java报名.类名即可.下面的程序稍微有点区别.也涉及到相对路径的问题.项目结构如下：IDEAndDosTest.java的代码如下(不要去揪程序的规范)：Java代码publicstaticvoidmain(String[]args)throwsIOException{FileInputStreamin=newFileInputStream(""src/iotest/test.txt"");intdata;while((data=in.read())!=-1){System.out.print(data+"""");}in.close();}很简单,就是读取一个文件,打印字节.在Eclipse下运行当然是没有任何问题的.在DOS下运行，进入到的目录是bin.这时候运行发现,报异常了：Java代码Exceptioninthread""main""java.io.FileNotFoundException:src\iotest\test.txt(系统找不到指定的路径。)异常也很明显,文件路径不对,没错,路径当然不对了.既然现在在bin目录下,那么肯定相对应bin目录了.这时需要搞清楚的就是两个系统属性""user.dir""和""java.class.path"".GetClassPathAndUserDir类的代码很简单：Java代码System.out.println(System.getProperty(""user.dir""));System.out.println(System.getProperty(""java.class.path""));在Eclipse下运行,结果是：Java代码user.dir=磁盘路径\Testjava.class.path=磁盘路径\Test\bin在DOS下运行(目录是bin),结果是：Java代码user.dir=磁盘路径\Test\binjava.class.path=.//其实就是磁盘路径\Test\bin从以上的结果其实已经可以看出结果了。问题主要集中在""user.dir"".其实解决上面的问题也很简单.换种方式,DOS下进入项目的目录,也就是现在在Test目录下.运行Java代码java-cpbiniotest.IDEAndDosTestOK.没有任何问题.其实这个时候user.dir已经发生了变化.其实GetClassPathAndUserDir这个类在不同的目录下运行结果是有些差异的比如，现在在Test目录下运行，结果是：Java代码user.dir=磁盘路径\Testjava.class.path=bin来个更好玩的,直接在E盘下运行，结果是：Java代码user.dir=E:\java.classpath=E:\Java\workspace\framework_workspace\Test\bin可以发现java.classpath是不变的，而user.dir是不断变化的.不过要是在E盘下运行IDEAndDosTest，一样还是会报java.io.FileNotFoundException从上面的结果也可以看出了""user.dir"",可以简单的说就是当前用户的目录.把IDEAndDosTest.java稍作修改：Java代码FileInputStreamin=newFileInputStream(""iotest/test.txt"");这个时候在DOS下(bin目录),运行时没有任何的,在Eclipse运行会报java.io.FileNotFoundException不过只要我们稍作修改就能让其运行正常：做如下的修改运行也就完全没问题了.既然这两种方式都这么麻烦,那有没有什么好的替换方式呢？当然有了：Java代码InputStreamin=IDETest.class.getResourceAsStream(""test.txt"");//当前类的同目录下或者Java代码InputStreamin=IDEAndDosTest.class.getClassLoader().getResourceAsStream(""iotest/test.txt"");//classpath目录现在不管你怎么运行,都没有问题了(当然了你要指定好classpath)其实也可以看出了如果要用绝对路径,千万别涉及到""user.dir""的问题,最好相对于你的classpath而言。",2015/5/29
251,java代码操作cmd命令,姚锡铭,http://180.168.156.212:2262/wecenter/?/article/9041,"用JAVA代码实现执行CMD命令的方法!Runtimert=Runtime.getRuntime();Processp=rt.exec(String[]cmdarray);或者Processp=rt.exec(Stringcmd);cmd命令格式为""cmd.exe/cipconfig/all""对像p为进程,在给p赋值以前,必须保证p为空if(p!=null){p.destory();p=null;}java的Runtime.getRuntime().exec(commandStr)可以调用执行cmd指令。cmd/cdir是执行完dir命令后关闭命令窗口。cmd/kdir是执行完dir命令后不关闭命令窗口。cmd/cstartdir会打开一个新窗口后执行dir指令，原窗口会关闭。cmd/kstartdir会打开一个新窗口后执行dir指令，原窗口不会关闭。可以用cmd/?查看帮助信息。★CMD命令★1.gpedit.msc-----组策略2.sndrec32-------录音机3.Nslookup-------IP地址侦测器4.explorer-------打开资源管理器5.logoff---------注销命令6.tsshutdn-------60秒倒计时关机命令7.lusrmgr.msc----本机用户和组8.services.msc---本地服务设置9.oobe/msoobe/a----检查XP是否激活10.notepad--------打开记事本11.cleanmgr-------垃圾整理12.netstartmessenger----开始信使服务13.compmgmt.msc---计算机管理14.netstopmessenger-----停止信使服务15.conf-----------启动netmeeting16.dvdplay--------DVD播放器17.charmap--------启动字符映射表18.diskmgmt.msc---磁盘管理实用程序19.calc-----------启动计算器20.dfrg.msc-------磁盘碎片整理程序21.chkdsk.exe-----Chkdsk磁盘检查22.devmgmt.msc---设备管理器23.regsvr32/u*.dll----停止dll文件运行24.drwtsn32------系统医生25.rononce-p----15秒关机26.dxdiag---------检查DirectX信息27.regedt32-------注册表编辑器28.Msconfig.exe---系统配置实用程序29.rsop.msc-------组策略结果集30.mem.exe--------显示内存使用情况31.regedit.exe----注册表32.winchat--------XP自带局域网聊天33.progman--------程序管理器34.winmsd---------系统信息35.perfmon.msc----计算机性能监测程序2.36.winver---------检查Windows版本37.sfc/scannow-----扫描错误并复原38.taskmgr-----任务管理器（2000／xp／200339.winver---------检查Windows版本40.wmimgmt.msc----打开windows管理体系结构(WMI)41.wupdmgr--------windows更新程序42.wscript--------windows脚本宿主设置43.write----------写字板44.winmsd---------系统信息45.wiaacmgr-------扫描仪和照相机向导46.winchat--------XP自带局域网聊天47.mem.exe--------显示内存使用情况48.Msconfig.exe---系统配置实用程序49.mplayer2-------简易widnowsmediaplayer50.mspaint--------画图板51.mstsc----------远程桌面连接52.mplayer2-------媒体播放机53.magnify--------放大镜实用程序54.mmc------------打开控制台55.mobsync--------同步命令56.dxdiag---------检查DirectX信息57.drwtsn32------系统医生58.devmgmt.msc---设备管理器59.dfrg.msc-------磁盘碎片整理程序60.diskmgmt.msc---磁盘管理实用程序61.dcomcnfg-------打开系统组件服务62.ddeshare-------打开DDE共享设置63.dvdplay--------DVD播放器64.netstopmessenger-----停止信使服务65.netstartmessenger----开始信使服务66.notepad--------打开记事本67.nslookup-------网络管理的工具向导68.ntbackup-------系统备份和还原69.narrator-------屏幕“讲述人”70.ntmsmgr.msc----移动存储管理器71.ntmsoprq.msc---移动存储管理员操作请求72.netstat-an----(TC)命令检查接口73.syncapp--------创建一个公文包74.sysedit--------系统配置编辑器75.sigverif-------文件签名验证程序76.sndrec32-------录音机77.shrpubw--------创建共享文件夹78.secpol.msc-----本地安全策略79.syskey---------系统加密，一旦加密就不能解开，保护windowsxp系统的双重密码80.services.msc---本地服务设置81.Sndvol32-------音量控制程序82.sfc.exe--------系统文件检查器83.sfc/scannow---windows文件保护84.tsshutdn-------60秒倒计时关机命令3.84.tsshutdn-------60秒倒计时关机命令85.tourstart------xp简介（安装完成后出现的漫游xp程序）86.taskmgr--------任务管理器87.eventvwr-------事件查看器88.eudcedit-------造字程序89.explorer-------打开资源管理器90.packager-------对象包装程序91.perfmon.msc----计算机性能监测程序92.progman--------程序管理器93.regedit.exe----注册表94.rsop.msc-------组策略结果集95.regedt32-------注册表编辑器96.rononce-p----15秒关机97.regsvr32/u*.dll----停止dll文件运行98.regsvr32/uzipfldr.dll------取消ZIP支持99.cmd.exe--------CMD命令提示符100.chkdsk.exe-----Chkdsk磁盘检查101.certmgr.msc----证书管理实用程序102.calc-----------启动计算器103.charmap--------启动字符映射表104.cliconfg-------SQLSERVER客户端网络实用程序105.Clipbrd--------剪贴板查看器106.conf-----------启动netmeeting107.compmgmt.msc---计算机管理108.cleanmgr-------垃圾整理109.ciadv.msc------索引服务程序110.osk------------打开屏幕键盘111.odbcad32-------ODBC数据源管理器112.oobe/msoobe/a----检查XP是否激活113.lusrmgr.msc----本机用户和组114.logoff---------注销命令115.iexpress-------木马捆绑工具，系统自带116.Nslookup-------IP地址侦测器117.fsmgmt.msc-----共享文件夹管理器118.utilman--------辅助工具管理器119.gpedit.msc-----组策略120.explorer-------打开资源管理器javac其实执行了只是没有输出执行结果因为你没有输出执行结果的部分如果你执行Runtime.getRuntime.exec(""cmd"");也看不到结果因为它不是在java程序中执行的而是在操作系统上执行的你可以这样Runtime.getRuntime.exec(""cmd/cstartjavac"");就可以看到一个命令行窗",2015/5/29
252,未来的 Web：九个不可思议的 WebGL 应用试验,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9040,WebGL技术允许把JavaScript和OpenGLES2.0结合在一起，通过增加OpenGLES2.0的一个JavaScript绑定，WebGL可以为HTML5Canvas元素提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。今天，本文向大家展示8个惊艳的WebGL应用实验。1.PearlBoy如果你需要片刻来放松心情，那么来试玩一下PearlBoy吧。这个精美的演示操作很简单，控制船上小男孩在美丽的海上夕阳的背景下划船前进或者潜入水底，探寻神秘的海底世界。效果演示2.PittsDemoPittsdemo是另一个精彩的3D飞行游戏，像其它我已经展示的游戏演示一样，这个游戏的物理引擎也是让人难以置信的。你可以滚动，减慢，加速！效果演示3.ChromeWorldMaze《Chrome世界迷宫》是Chrome最前沿的实验项目之一。玩转世界迷宫的时候，用你的桌面设备作为显示屏和手机（安装了Chrome浏览器）作为控制器。你可以使用任何网站作为迷宫，赶紧体验一下吧！效果演示4.OpticFlow《光流》演示使用的设备的摄像头来检测移动，并再运动路径周围发散一系列的光点。运动越多，动画圆点越多。终极玩法，在摄像头前面的摇摆运动，以获得最佳体验。效果演示5.RollIt这是一款经典的滚雪球游戏，和《Chrome迷宫》游戏一样，也是桌面屏幕作为显示器，移动设备作为控制器。摆动手动的移动设备，板上的球就能滚动了，赶紧试一下！效果演示6.IronbaneMMOIronbane是一个3D平台游戏，在你移动的的时候回自动切换的角度。不可思议的平滑动画和响应能力，Ironbane是HTML5游戏经典案例之一。效果演示7.CubeSlam有人想尝试和一只孤独的熊玩挡板打砖块游戏吗？Cubeslam给你这个机会，当然也可以和朋友玩，只要发给他们一个用于同步的链接就可以了。效果演示8.WebCamMesh这个令人惊叹的演示也是应用了摄像头，创建动态，充满质感的脉动形态的用户图像，多么令人难以置信的流畅和迷人的杰作。效果演示9.Pixelate像素化是另一种基于摄像头的演示，跟踪用户的动作，并以绿色的像素点显示对象的轮廓。此演示甚至能模仿声音（在Mac上，尝试增加和减少音量可以实现）。效果演示WebGL还可以用于更强大的图形创作和动画。上述几个演示项目都是令人印象深刻的游戏，代表着HTML5游戏的未来！,2015/5/27
253,10个调试技巧,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9039,摘要：调试不仅可以查找到应用程序缺陷所在，还可以解决缺陷。对于Java程序员来说，他们不仅要学会如何在Eclipse里面开发像样的程序，更需要学会如何调试程序。本文介绍了Java程序员必知的10个调试技巧，保证让你受益匪浅！调试可以帮助识别和解决应用程序缺陷，在本文中，作者将使用大家常用的的开发工具Eclipse来调试Java应用程序。但这里介绍的调试方法基本都是通用的，也适用于NetBeansIDE，我们会把重点放在运行时上面。在开始之前，推荐大家去看看Eclipseshortcuts这篇文章，它将会给你带来很多方便。在本文中使用的是EclipseJuno版（Eclipse4.2），在开始前给大家提3点建议！1.不要使用System.out.println作为调试工具2.把所有涉及到的组件日志级别激活并使用3.使用日志分析器来读取日志0.条件断点如果你不知道如何添加断点，只需点击左边面板（行号前面）断点即被创建。在调试界面中，“断点”视图会把所有被创建的断点列出来。我们可以给它加一个布尔条件，也就是说，该断点会被激活并且如果布尔条件为真，就会执行该断点，否则将会跳过往下执行。1.异常断点在断点视图中，有一个J!标记按钮！我们可以使用该按钮来添加一个Java异常断点。例如，我们想让程序在遇到空指针异常（NullPointerException）时，仍然能继续调试，那么我们可以使用该按钮来添加一个异常断点！2.监视点这是一个非常好的功能，当选定的属性访问或修改程序时，程序会停止执行并允许进行调试。在Outline视图中选择一个类变量并从上下文菜单中选择切换监视点，属性监视点将会被创建，在断点（Breakpoints）视图中会把所有监视点用列表的形式显示出来。3.评估/检查按Ctrl+Shift+D或者Ctrl+Shift+I来显示选定变量或者表达式的值。我们也可以给一个变量或表达式添加永久观察点，当程序在调试时，这些观察点就会在表达式视图（Expressionview）中显示出来。4.修改变量值在调试过程中，我们可以修改变量值。先选好一个变量然后进入变量视图（Variablesview），根据变量类型在其对应的Value列里输入值即可。5.在Main函数里面停止执行在运行/调试设置中，编辑配置对话框中有“Main”这个选项卡，我们可以勾选“Stopinmain”这个复选框。如果选中，那么在调试一个基于main方法的Java程序时，程序会在main方法第一行位置便停止执行。6.环境变量并不是在系统属性中添加环境变量，我们可以在编辑配置对话框中很方便地进行添加。7.DroptoFrame这也是我最喜欢的一个功能。调试期间，可以重新跳到调用堆栈框架的开始处执行，并且变量值也会回到最初。根据回档调整堆栈的深度，这个功能的主要用途是所有变量状态可以快速回到方法开始执行时候的样子，然后你可以重新进行一遍一遍执行，这样就可以在你关注的地方进行多次调试，但是在执行过程中也会产生一些副作用，比如插入到数据库里面的数据是无法删除的！8.分布过滤当我们进入（F5）方法的时候，我们还可以访问其外部库（比如java.*），我们可能不需要这个库，就可以在Perference选项卡页面添加一个过滤器来排除这个包。9.进入、跳出和返回我把这个放在最后一点，在调试过程中，这些是必须要了解（最好掌握）的东西：F5——进入：移动到下一个步骤，如果当前行有一个方法调用，该控件将会跳转到被调用方法的第一行执行。F6——跳出：移动到下一行。如果在当前行有方法调用，那么会直接移动到下一行执行。不会进入被调用方法体里面。F7——返回：从当前方法中跳出，继续往下执行。F8——移动到下一个断点处执行。,2015/5/26
254,如何做单元测试,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9038,"序单元测试是一个非常好用的工具，是一个Java程序员修养的一部分。从04年开始，我就开始在项目实践中使用单元测试。十几年来，参与的项目基本上都或多或少的使用了单元测试，多的能有100%覆盖率的要求，少的也要覆盖主要代码，发现这个实践在提高软件质量和开发速度上还是很有好处的。在和朋友同事的交流中，发现有很多项目没有使用单元测试，也有很多程序员不会写单元测试，但是大家对这个都很有兴趣。所以我想把自己掌握的关于单元测试的技能（架构、设计和技术）和实施策略分享一下。当然，要是有那个企业愿意要求我去做相关的内训和咨询，我会很高兴的。单元测试这系列想讲讲几方面内容：1.如何项目中使用单元测试2.Java单元测试的技术3.一些实施单元测试的误区本文包括下面几部分的内容1.我所理解的单元测试的定义和分类2.实施单元测试的好处3.Java程序员单元测试工具库单元测试的定义和分类单元测试的定义指程序员编写的用于测试逻辑代码的代码。我的理解中单元测试分成以下两类：代码测试代码测试是指对代码的实现进行测试，不依赖于第三方环境，运行速度很快。举几个例子：测试aController对象的doGet方法正确的把参数P1和P2传递给了bService对象的query方法测试一个Dao类的get方法正确的把""selecta,bfromtwherel=5""传递给jdbcTemplate的query方法，并把查询结果返回。集成测试集成测试是指集成了第三方依赖之后的测试。它会依赖于第三方环境，运行速度相对代码测试慢。举几个例子：通过Http协议测试REST服务调用Dao类，测试它从数据库里面正确的获取到了数据实施单元测试的好处进行早期测试在软件工程中，大家都知道越早开始测试越好，越早开始测试就能越早发现缺陷，修改代价就越小。但是对于软件系统的测试需要你至少编写完一个可运行的最小化系统之后才能进行。在外人看到的可操作的界面出现之前，已经是开发人员好几天努力工作的汗水了。但是按照传统的工作方法，所有的这些努力，在界面没有出来之前，除了知道他们是可以编译通过的，无法进行任何测试。更甚的是，如果你的系统依赖于一个未实现的第三方系统，那么在那个第三方系统能正确响应你的请求之前，你的代码得不到任何有效的测试。但是使用单元测试技术，通过使用Stub和Mock技术，我们可以不用依赖界面，不用依赖第三方系统，就可以对代码进行测试处，甚至，你可以实现一个方法就测试一个方法，不用等整个功能都完成了再测试。可以放心的修改代码以及进行代码重构单元测试是可以自动化运行的，如果代码有良好的单元测试覆盖，在对代码进行重构和修改之后，我们可以用极短的时间（几分钟）对整个系统进行一下测试，测试全部通过，这个说明的修改对系统没有造成严重影响（这不能说明单元测试覆盖不到的地方也没有问题），于是你就可以安心的继续修改代码和重构代码。有助于提高代码质量和架构设计为了便于单元测试和代码覆盖，架构必然会在逻辑封装，解耦合，依赖注入，控制反转，对外接口封装等方面进行优化。举几个例子：把逻辑代码和界面代码都写在一起，会导致对逻辑代码的测试要包括对界面元素的解析。于是，“逻辑代码和界面代码的分离”成了停止单元测试之外的最小代价的解决方案在代码中实例化所依赖的对象，会加大隔离测试的难度，并且在所依赖的对象实现之前，无法进行测试。于是，依赖注入成了最佳的选择。可重复对代码进行验证编写良好的单元测试代码可以自动化运行，可以在所有的开发人员的环境里运行，可以在持续集成环境里运行，可以在每次代码修改提交后运行，项目的代码和功能在反复的收到测试。加快开发速度前期的小小投入，能够在整个项目周期中发挥作用，能够提高代码的质量，能够对代码进行早期测试，能够减少代码Bug，能够保证代码不会被其他代码破坏。修改Bug和调试的时间、相关的沟通时间被大幅度的减少。项目时间能更有保证。起到代码文档的作用对于一个方法或者一个对象的使用，有的时候光用注释很难说清楚。单元测试中对该方法/对象的使用提供了实例说明的作用，使我们更容易理解对其的使用。Java程序员单元测试工具库写单元测试也是需要掌握一些工具的，不过这些工具使用起来都比较简单，也和容易学习。在后面的文章中，我将会介绍其中的一部分我经常用到的。单元测试框架在Java世界中，有两个使用最多的单元测试框架，JUnit和TestNG。使用最多和支持最广泛的是JUnit。后面的文章中我将会给大家介绍一下它的使用。Mock工具Mock工具是进行代码测试所必须掌握的一个工具。目前流行的有Mockito,EasyMock和JMock这三种。我以前用过EasyMock和JMock，后来开始使用Mockito之后就停不下来了。后面的文章中会给大家介绍一下它的用法。其他工具通用型的我将会介绍Hamcrest，一个用于验证测试结果工具库。其他的有一些用于各种专门目的而使用的工具，这类工具有很多，比如SpringTest,用于对Spring程序进行集成测试的必需品，我将会在后面的文章中介绍SpringMVCTestFramework，一个用于SpringMVC编写的Web应用的工具，我将会在后面的文章中介绍DBUnit，这个也有很多人用，但是我基本上没用过，所以就不介绍了。有兴趣的可以自己去看看。rest-assured，JavaDSLforeasytestingofRESTservices，看起来很美，还没有用过，等我学习使用完觉得好用了再分享。",2015/5/26
255,AS3:一行代码让圆周运动不依赖于三角函数,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9048,"圆周运动，想在AS3里实现它，我们一般都这么写：varcenterX:Number=300;varcenterY:Number=200;varradius:Number=20;vardegree:Number=0;addEventListener(Event.ENTER_FRAME,enterFrameHandller);functionenterFrameHandler(event:Event):void{display.x=centerX+radius*Math.cos(degree*Math.PI/180);display.y=centerY+radius*Math.sin(degree*Math.PI/180);degree+=5;}其中centerX和centerY分别是圆心的x坐标和y坐标，radius为圆周的半径，degree是当前角度。代码中出现了cos和sin两个三角函数，那么，有没办法不通过这些三角函数来实现同样的效果呢？可以将一对极坐标转换为笛卡尔点坐标，只要一行代码，什么弦什么切的都可以一边凉快去了varpt:Point=Point.polar(radius,degree*Math.PI/180);display.x=centerX+pt.x;display.y=centerY+pt.y;",2015/5/25
256,八张图读懂未来“互联网+”的六大趋势,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/9037,虽然“互联网”一词在当下伴随着鼓吹与泡沫而炙手可热，但毋庸置疑的是，互联网将成为人类下一次飞跃的桥梁和动力。今天我们将以八张图分析一下互联网发展的未来趋势。虽然“互联网”一词在当下伴随着鼓吹与泡沫而炙手可热，但毋庸置疑的是，互联网将成为人类下一次飞跃的桥梁和动力毋庸置疑。钛媒体作者薄云借智用八张图互联网未来发展的六大趋势：连接与聚合、产业互联网化、产业金融化、个性化需求、O2O、智能工业。趋势一：连接与聚合趋势二：产业互联网化趋势三：产业金融化趋势四：个性化需求趋势五：O2O将成为服务互联网的主要方式趋势六：智慧工业时代,2015/5/22
257,基于jQuery图片弹出翻转特效代码,管俊,http://180.168.156.212:2262/wecenter/?/article/9036,"分享一款基于jQuery图片弹出翻转特效代码。这是一款基于jQuery+HTML5实现的，里面包含六款不同效果的鼠标点击图片弹出特效下载。效果图如下：在线预览源码下载实现的代码。html代码：<sectionclass=""main""><article><divclass=""imgContainer""><h5>效果一</h5><imgsrc=""images/chinaz.jpg""data-expander='{animation:""default""}'></div><divclass=""imgContainer""><h5>效果二</h5><imgsrc=""images/chinaz.jpg""data-expander='{animation:""diamond""}'></div><divclass=""imgContainer""><h5>效果三</h5><imgsrc=""images/chinaz.jpg""data-expander='{animation:""turn3d""}'></div><divclass=""imgContainer""><h5>效果四</h5><imgsrc=""images/chinaz.jpg""data-expander='{animation:""flip3d""}'></div><divclass=""imgContainer""><h5>效果五</h5><imgsrc=""images/chinaz.jpg""data-expander='{animation:""rotate""}'></div><divclass=""imgContainer""><h5>效果六</h5><imgsrc=""images/chinaz.jpg""data-expander='{animation:""fade""}'></div></article></section>js代码：varindex=0;vartimeout=setInterval(function(){if(index>10){window.clearInterval(timeout)}$(""article"").eq(index).addClass(""show"");index++},300);functionshowFoo(){$(""#fooId"").trigger(""expand"");}$(""#expandSettings"").on(""click"",function(){if($(""ul.settings"").hasClass(""open"")){$(""ul.settings"").removeClass(""open"");}else{$(""ul.settings"").addClass(""open"");}});",2015/5/21
258,Android系统查看wifi密码,管俊,http://180.168.156.212:2262/wecenter/?/article/9035,对于用户连接过的wifi，android系统把相关信息明文保存在/data/misc/wifi/wpa_supplicant.conf中，root之后可以查看，或者利用手机的备份功能进行备份，这样不用root也可以查看。,2015/5/21
259,Java 可变参数,管俊,http://180.168.156.212:2262/wecenter/?/article/9034,"java1.5增加了新特性：可变参数：适用于参数个数不确定，类型确定的情况，java把可变参数当做数组处理。注意：可变参数必须位于最后一项。当可变参数个数多余一个时，必将有一个不是最后一项，所以只支持有一个可变参数。因为参数个数不定，所以当其后边还有相同类型参数时，java无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。可变参数的特点：（1）、只能出现在参数列表的最后；（2）、...位于变量类型和变量名之间，前后有无空格都可以；（3）、调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中一数组的形式访问可变参数。publicclassVarable{publicstaticvoidmain(String[]args){System.out.println(add(2,3));System.out.println(add(2,3,5));}publicstaticintadd(intx,int...args){intsum=x;for(inti=0;i<args.length;i++){sum+=args[i];}returnsum;}}",2015/5/21
260,"用java实现新浪爬虫,代码完整剖析(仅针对当前SinaSignOn有效)",管俊,http://180.168.156.212:2262/wecenter/?/article/9033,"先来看我们的web.xml文件，如下1<!DOCTYPEweb-appPUBLIC2""-//SunMicrosystems,Inc.//DTDWebApplication2.3//EN""3"" **/headers.put(""Accept"",""text/html,application/xhtml+xml,*/*"");headers.put(""Referer"","" (v1.4.5)&_=""+System.currentTimeMillis());returnbuilder.toString();}//对用户名进行编码privateStringgetEncodedU(){if(username!=null&&username.length()>0){returnBase64Encoder.encode(EncodeUtils.encodeURL(username,""utf-8"").getBytes());}return"""";}//对密码进行编码privateStringgetEncryptedP(){//returnEncodeSuAndSp.getEncryptedP(password,servertime,nonce);Stringdata=servertime+""\t""+nonce+""\n""+password;StringspT=rsaCrypt(pubkey,""10001"",data);returnspT;}publicstaticStringrsaCrypt(Stringpubkey,StringexponentHex,Stringpwd,Stringservertime,Stringnonce){Stringdata=servertime+""\t""+nonce+""\n""+pwd;returnrsaCrypt(pubkey,exponentHex,data);}publicstaticStringrsaCrypt(Stringpubkey,StringexponentHex,Stringmessageg){KeyFactoryfactory=null;try{factory=KeyFactory.getInstance(""RSA"");}catch(NoSuchAlgorithmExceptione1){return"""";}BigIntegerpublicExponent=newBigInteger(pubkey,16);/*publicexponent*/BigIntegermodulus=newBigInteger(exponentHex,16);/*modulus*/RSAPublicKeySpecspec=newRSAPublicKeySpec(publicExponent,modulus);RSAPublicKeypub=null;try{pub=(RSAPublicKey)factory.generatePublic(spec);}catch(InvalidKeySpecExceptione1){return"""";}Cipherenc=null;byte[]encryptedContentKey=null;try{enc=Cipher.getInstance(""RSA"");enc.init(Cipher.ENCRYPT_MODE,pub);encryptedContentKey=enc.doFinal(messageg.getBytes());}catch(NoSuchAlgorithmExceptione1){System.out.println(e1.getMessage());return"""";}catch(NoSuchPaddingExceptione1){System.out.println(e1.getMessage());return"""";}catch(InvalidKeyExceptione1){System.out.println(e1.getMessage());return"""";}catch(IllegalBlockSizeExceptione1){System.out.println(e1.getMessage());return"""";}catch(BadPaddingExceptione1){System.out.println(e1.getMessage());return"""";}returnnewString(Hex.encodeHex(encryptedContentKey));}publicvoidsetUserid(Stringuserid){this.userid=userid;}publicStringgetUserid(){returnuserid;}publicvoidsetUserdomainname(Stringuserdomainname){this.userdomainname=userdomainname;}publicStringgetUserdomainname(){returnuserdomainname;}}Spider.sina类如下：1packagemain.java.sina.httpclient;2importjava.util.HashMap;3importjava.util.List;4importjava.util.Map;56importorg.apache.http.HttpResponse;7importorg.apache.http.cookie.Cookie;89importmain.java.sina.utils.Constant;10importmain.java.sina.utils.EncodeUtils;11importmain.java.sina.utils.HttpUtils;12importmain.java.sina.utils.Utils;1314publicclassSpiderSina{15privateLoginSinals;16privateMap<String,String>headers;17privatefinalintADDFOLLOWING=1;18privatefinalintCANCELFOLLOWING=2;19publicSpiderSina(LoginSinals){20this.ls=ls;21this.headers=newHashMap<String,String>();22headers.put(""Accept"",""text/html,application/xhtml+xml,*/*"");23headers.put(""Accept-Language"",""zh-cn"");24headers.put(""User-Agent"",""Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0;BOIE9;ZHCN"");25headers.put(""Connection"",""Keep-Alive"");26headers.put(""Cache-Control"",""no-cache"");27StringcookieValue=HttpUtils.setCookie2String(ls.getCookies());28headers.put(""Cookie"",cookieValue);29}36publicStringgetGroupCategory(){37Stringurl="" "");663this.headers.put(""Accept"",""*/*"");664this.headers.put(""Content-Type"",""application/x-www-form-urlencoded"");665this.headers.put(""X-Requested-With"",""XMLHttpRequest"");666HttpResponseresponse=HttpUtils.doGet(url,headers);667returnHttpUtils.getStringFromResponse(response);668}669}",2015/5/21
261,完整全面的Java资源库（包括构建、操作、代码分析、编译器、数据库、社区等等）,管俊,http://180.168.156.212:2262/wecenter/?/article/9032,"构建这里搜集了用来构建应用程序的工具。ApacheMaven：Maven使用声明进行构建并进行依赖管理，偏向于使用约定而不是配置进行构建。Maven优于ApacheAnt。后者采用了一种过程化的方式进行配置，所以维护起来相当困难。Gradle：Gradle采用增量构建。Gradle通过Groovy编程而不是传统的XML声明进行配置。Gradle可以很好地配合Maven进行依赖管理，并且把Ant脚本当作头等公民。字节码操作编程操作Java字节码的函数库。ASM：通用底层字节码操作及分析。Javassist：尝试简化字节码编辑。ByteBuddy：使用“流式API”进一步简化字节码生成。代码分析软件度量和质量评估工具。Checkstyle：对编程规范和标准进行静态分析。FindBugs：通过字节码静态分析找出潜在Bug。PMD：对源代码中不良编程习惯进行分析。SonarQube：通过插件集成其它分析组件，提供评估最终结果报告。Safe.ijiami：应用代码安全，一键检测漏洞，并最终提供分析报告，包括解决方案，强大的漏洞检测工具。编译器创建分析器、解释器和编译器的框架。ANTLR：功能完备的自顶向下分析复杂框架。JavaCC：相对ANTLR更具体，上手略为简单。支持语法语法超前预测（syntacticlookahead）。持续集成支持持续集成、测试和应用发布的工具。Bamboo：Atlassian的持续集成（CI）解决方案，包含很多其它产品。CircleCI：提供托管服务，可免费试用。Codeship：提供托管服务，提供有限免费计划。Go：ThoughtWork开源持续集成解决方案。Jenkins：提供基于服务器的部署服务。TeamCity：JetBrain持续集成方案，提供免费版。Travis：提供托管服务，常用于开源项目。数据库简化数据库交互的工具、库。Flyway：使用JavaAPI轻松完成数据库迁移。H2：小型SQL数据库，以内存操作著称。JDBI：便捷的JDBC抽象。jOOQ：基于SQLschema生成类型安全代码。Presto：针对大数据的分布式SQL查询引擎。Querydsl：针对Java的类型安全统一查询。日期和时间处理日期和时间的函数库。Joda-Time：Java8出现之前，它是日期、时间处理的标准函数库。Time4J：Java高级日期、时间函数库。依赖注入帮助代码实现控制反转模式的函数库。Dagger：编译期的注入框架，没有使用反射，主要用于Android开发。Guice：轻量级注入框架，功能强大可与Dagger媲美。开发库从基础层次上改进开发流程。AspectJ：面向切面编程扩展，与程序无缝连接。Auto：源代码生成器集合。DCEVM：通过修改JVM，在运行时可无限次重定义已加载的类。OpenJDK7、8已提供支持，详情可查看这个分支（fork）。JRebel：商用软件，无需重新部署可即时重新加载代码及配置。Lombok：代码生成器，旨在减少Java冗余代码。RxJava：使用JVM中可观察序列，创建异步、基于事件应用程序的函数库。SpringLoaded：另一个JVM类重载代理。vert.x：JVM多语言事件驱动应用框架。分布式应用用来开发分布式、具有容错性应用程序的函数库和框架。Akka：构建并发、分布式和具有容错功能的事件驱动应用程序所需的工具包和运行时。ApacheStorm：分布式实时计算系统。ApacheZooKeeper：为大型分布式系统，使用分布式配置、同步和命名注册提供协调服务。Hazelcast：分布式、高可扩展性内存网格。Hystrix：为分布式系统提供延迟和容错处理。JGroups：一组提供可靠消息传输的工具包，可用来创建集群。集群中的节点可互相发送消息。Quasar：为JVM提供轻量级线程和Actor。发布使用本机格式分发Java应用程序的工具。Bintray：对二进制发布进行版本控制，可与Maven或Gradle配合使用。IzPack：为跨平台部署建立授权工具。Launch4j：将JAR包装为小巧的Windows可执行文件。packr：将程序JAR、资源和JVM打包成Windows、Linux和MacOSX的本机文件。文档处理用来处理Office格式文档的函数库。ApachePOI：支持OOXML（XLSX、DOCX、PPTX）以及OLE2（XLS,DOCorPPT）格式的文档。jOpenDocument：处理OpenDocument格式文档。游戏开发游戏开发框架。jMonkeyEngine：支持现代3D开发的游戏引擎。libGDX：全面的跨平台高级开发框架。LWJGL：抽象了OpenGL、CL、AL等函数库的健壮框架。ijiami.cn：游戏开发全方位的加密安全解决方案，针对游戏app面临的一系列安全问题，提前加入安全解决措施，防患于未然。GUI用来创建现代图形用户界面的函数库。JavaFX：Swing的继承者。SceneBuilder：JavaFX虚拟布局工具。高性能与高性能计算有关的资源，包括集合以及很多具体功能的函数库。Disruptor：线程间消息函数库。fastutil：快速紧凑的Java类型安全集合。GSCollections：受Smalltalk启发的集合框架。hftc：Hashset和hashmap。HPPC：基本类型集合。Javolution：针对实时嵌入式系统的函数库。Trove：基本类型集合。IDE视图简化开发的集成开发环境。Eclipse：后台做了很多工作，以其丰富插件著称。IntelliJIDEA：支持很多JVM语言，为Android开发提供了很多不错的选项。其商业版本主要面向企业用户。NetBeans：集成了很多JavaSE和JavaEE特性，包括数据库访问、服务器、HTML5以及AngularJS。图像处理用来帮助创建、评估或操作图形的函数库。Picasso：Android下载图像和图像缓存函数库。ZXing：多种格式的一维、二维条形码处理函数库。JSON简化JSON处理的函数库。Gson：将Java对象序列化为JSON及反向操作。使用时提供了很好的性能。Jackson：与GSON类似，但如果需要频繁初始化Jackson库会带来性能问题。JVM和JDK目前的JVM、JDK实现。JDK9：JDK9早期访问版本。OpenJDK：开源实现。日志记录应用程序的日志函数库。ApacheLog4j2：对之前版本进行了完全重写。现在的版本具备一个强大的插件和配置架构。kibana：对日志进行分析并进行可视化。Logback：Log4j原班人马作品。被证明是一个强健的日志函数库，通过Groovy提供了很多有意思的配置选项。logstash：日志文件管理工具。SLF4J：日志抽象层，需要与某个具体日志框架配合使用。机器学习提供具体统计算法的工具。其算法可从数据中学习。ApacheHadoop：对商用硬件集群上大规模数据存储和处理的开源软件框架。ApacheMahout：专注协同过滤、聚类和分类的可扩展算法。ApacheSpark：开源数据分析集群计算框架。h2o：用作大数据统计的分析引擎。Weka：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。消息在客户端之间进行消息传递，确保协议独立性的工具。ApacheActiveMQ：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。ApacheKafka：高吞吐量分布式消息系统。JBossHornetQ：清晰、准确、模块化且方便嵌入的消息工具。JeroMQ：ZeroMQ的纯Java实现。其它其它资源。DesignPatterns：实现并解释了最常见的设计模式。Jimfs：内存文件系统。Lanterna：类似curses的简单console文本GUI函数库。LightAdmin：可插入式CRUDUI函数库，可用于快速应用开发。Metrics：创建自己的软件度量或者为支持框架添加度量信息，通过JMX或HTTP进行发布或者发送到数据库。OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用WebService进行扩展并将其关联到数据库。RoboVM：Java编写原生iOS应用。jingpin：代码编写的应用全面的竞品分析，用数据诠释应用的市场竞争性，包括下载量、评论、推广信息、版本更新等具体信息。自然语言处理用来专门处理文本的函数库。ApacheOpenNL：处理类似分词等常见任务的工具。CoreNLP：斯坦佛的CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。LingPipe：一组可以处理各种任务的工具集，支持POS标签、情感分析等。Mallet：统计学自然语言处理、文档分类、聚类、主题建模等。网络网络编程函数库。Netty：构建高性能网络应用程序开发框架。OkHttp：一个Android和Java应用的HTTP+SPDY客户端。ORM处理对象持久化的API。EclipseLink：支持许多持久化标准，JPA、JAXB、JCA和SDO。Hibernate：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。Ebean：支持快速数据访问和编码的ORM框架。PDF用来帮助创建PDF文件的资源。ApacheFOP：从XSL-FO创建PDF。ApachePDFBox：用来创建和操作PDF的工具集。DynamicReports：JasperReports的精简版。iText：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。JasperReports：一个复杂的报表引擎。REST框架用来创建RESTful服务的框架。Dropwizard：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。Jersey：JAX-RS参考实现。RESTEasy：经过JAX-RS规范完全认证的可移植实现。Retrofit：一个Java类型安全的REST客户端。Spark：受到Sinatra启发的JavaREST框架。Swagger：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTfulWebService。科学用于科学计算和分析的函数库。SCaVis：用于科学计算、数据分析和数据可视化环境。搜索文档索引引擎，用于搜索和分析。ApacheSolr：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTfulWeb接口和无schema的JSON文档。安全用于处理安全、认证、授权或会话管理的函数库。ApacheShiro：执行认证、授权、加密和会话管理。Cryptomator：在云上进行客户端跨平台透明加密。Keycloak：为浏览器应用和RESTfulWebService集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。PicketLink：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（UmbrellaProject）。SpringSecurity：专注认证、授权和多维度攻击防护框架。ijiami.cn：专业的移动应用安全智能服务，通过安全的加密解决方案，保证app开发者等的利益，有最全面最安全的加密服务。序列化用来高效处理序列化的函数库。FlatBuffers：序列化函数库，高效利用内存，无需解包和解析即可高效访问序列化数据。Kryo：快速和高效的对象图形序列化框架。MessagePack：一种高效的二进制序列化格式。服务器用来部署应用程序的服务器。ApacheTomcat：针对Servlet和JSP的应用服务器，健壮性好且适用性强。ApacheTomEE：Tomcat加JavaEE。GlassFish：JavaEE开源参考实现，由Oracle资助开发。Jetty：轻量级、小巧的应用服务器，通常会嵌入到项目中。WildFly：之前被称作JBoss，由RedHat开发。支持很多JavaEE功能。模版引擎对模板中表达式进行替换的工具。ApacheVelocity：提供HTML页面模板、email模板和通用开源代码生成器模板。FreeMarker：通用模板引擎，不需要任何重量级或自己使用的依赖关系。Handlebars.java：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semanticMustache）。JavaServerPages：通用网站模板，支持自定义标签库。Thymeleaf：旨在替换JSP，支持XML文件。测试测试内容从对象到接口，涵盖性能测试和基准测试工具。ApacheJMeter：功能性测试和性能评测。Arquillian：集成测试和功能行测试平台，集成JavaEE容器。AssertJ：支持流式断言提高测试的可读性。JMH：JVM微基准测试工具。JUnit：通用测试框架。Mockito：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。Selenium：为Web应用程序提供可移植软件测试框架。Selenide：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。TestNG：测试框架。VisualVM：提供可视化方式查看运行中的应用程序信息。工具类通用工具类函数库。ApacheCommons：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。Guava：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。javatuples：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。网络爬虫用于分析网站内容的函数库。ApacheNutch：可用于生产环境的高度可扩展、可伸缩的网络爬虫。Crawler4j：简单的轻量级爬虫。JSoup：刮取、解析、操作和清理HTML。Web框架用于处理Web应用程序不同层次间通讯的框架。ApacheTapestry：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。ApacheWicket：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。GoogleWebToolkit：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCPAPI、JUnit集成、国际化支持和GUI控件。Grails：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。Play：使用约定而非配置，支持代码热加载并在浏览器中显示错误。PrimeFaces：JSF框架，提供免费版和带技术支持的商业版。包含一些前端组件。SpringBoot：微框架，简化了Spring新程序的开发过程。Spring：旨在简化JavaEE的开发过程，提供依赖注入相关组件并支持面向切面编程。Vaadin：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。Ninja：Java全栈Web开发框架。非常稳固、快速和高效。Ratpack：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。资源社区活跃的讨论区。r/java：Java社区的Subreddit。stackoverflow：问答平台。有影响的书籍具有广泛影响且值得阅读的Java经典书籍。EffectiveJava(2ndEdition)JavaConcurrencyinPractice|Java并发编程实战ThinkinginJava|中文版播客可以一边编程一边听的东西。TheJavaPosseTwitter值得关注的帐号。AdamBien：自由职业者、作家、JavaONE明星演讲者、顾问、JavaChampion。AntonioGoncalves：JavaChampion、JUGLeader、DevoxxFrance、JavaEE6/7、JCP、作家。ArunGupta：JavaChampion、JavaONE明星演讲者、JUGLeader、Devoxx4Kids成员、RedHatter。BrunoBorges：Oracle产品经理、JavaJock。EdBurns：Oracle技术团队顾问。EugenParaschiv：Spring安全课程作者。JamesWeaver：Java、JavaFX、IoT开发者、作者和演讲者。JavaEE：JavaEETwitter官方账号。JavaMagazine：Java杂志官方账号。Java.net：Java.net官方账号。Java：JavaTwitter官方账号。JavinPaul：知名Java博客作者。LukasEder：DataGeekery（jOOQ）创始人兼CEO。MarioFusco：RedHatter、JUG协调、活跃讲师和作者。MarkReinhold：Oracle首席架构师、Java平台开发组。MartijnVerburg：LondonJUGco-leader、演讲者、作家、JavaChampion等。OpenJDK：OpenJDK官方账号。RezaRahman：JavaEE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。SimonMaple：JavaChampion、virtualJUG创始人、LJCleader、RebelLabs作者。StephenColebourne：JavaChampion、演讲者。TimBoudreau：作家、NetBeans大牛。TrishaGee：JavaChampion、演讲者。网站值得阅读的网站。GoogleJavaStyleInfoQJavaCodeGeeksJava.netJavalobbyJavaWorldRebelLabsTheJavaSpecialist’NewsletterTheServerSide.comThoughtsOnJavaImportNew（ImportNew专注Java技术）ijiami.cn",2015/5/21
262,SmartUpload实现文件上传,管俊,http://180.168.156.212:2262/wecenter/?/article/9031,"（一）SmartUpload组件简介SmartUpload组件专门用于实现文件上传及下载的免费组件（二）SmartUpload组件特点使用简单：编写少量代码，完成上传下载功能能够控制上传内容能够控制上传文件的大小、类型缺点：目前已停止更新服务（三）SmartUpload组件应用条件File类及方法SmartUpload类及方法文件上传的实现控制上传文件的类型控制上传文件的大小注意：㈠表单要求对于上传文件的FORM表单，有两个要求：1、METHOD应用POST，即METHOD=""POST""。2、增加属性：ENCTYPE=""multipart/form-data""案例：下面是一个用于上传文件的FORM表单的例子：表单页面indes.jsp<%@pagelanguage=""java""import=""java.util.*""pageEncoding=""UTF-8""%><%Stringpath=request.getContextPath();StringbasePath=request.getScheme()+""://""+request.getServerName()+"":""+request.getServerPort()+path+""/"";%><!DOCTYPEHTMLPUBLIC""-//W3C//DTDHTML4.01Transitional//EN""><html><head><basehref=""<%=basePath%>""><title>SmartUpload</title></head><body><formaction=""doupload.jsp""method=""post""enctype=""multipart/form-data"">姓名:<inputtype=""text""name=""username""/><br/>密码:<inputtype=""text""name=""pwd""/><br/>文件1:<inputtype=""file""name=""file1""/><br/>文件2:<inputtype=""file""name=""file2""/><br/>文件3:<inputtype=""file""name=""file3""/><br/>文件4:<inputtype=""file""name=""file4""/><br/>文件5:<inputtype=""file""name=""file5""/><br/>文件6:<inputtype=""file""name=""file6""/><br/>文件7:<inputtype=""file""name=""file7""/><br/><inputtype=""submit""/></form></body></html>处理表单页<%@pagelanguage=""java""import=""java.util.*""pageEncoding=""UTF-8""%><%@pageimport=""com.jspsmart.upload.SmartUpload""%><%@pageimport=""com.jspsmart.upload.File""%><%//----处理上传文件/*使用smartupload1、添加组件jar包至WEB-INF/lib包中2、设置form表单的提交类型为二进制类型*///创建smartupload组件SmartUploadsu=newSmartUpload();//初始化组件上下文su.initialize(pageContext);//设置编码su.setCharset(""utf-8"");try{//允许上传的文件类型//su.setAllowedFilesList(""doc"");//限制上传文件的类型//su.setDeniedFilesList(""bat"");//限制上传文件的大小//su.setMaxFileSize(2000);//上传文件su.upload();}catch(Exceptione){%><scripttype=""text/javascript"">alert(""不允许上传：bat,exe,jsp,html,htm,java,class文件类型"");location.href=""index.jsp"";</script><%}out.println(""上传""+su.save(""upload\\"")+""个文件成功!!!"");//得到表单项Stringname=su.getRequest().getParameter(""username"");Stringpwd=su.getRequest().getParameter(""pwd"");/*实现多文件上传*/for(inti=0;i<su.getFiles().getCount();i++){//获取单个文件Filefile=su.getFiles().getFile(i);//判断当前file是否选择了文件;如果没有则继续if(file.isMissing())continue;//设置上传服务器的位置Stringpath=""upload\\"";//得到上传文件的名称Stringfilename=file.getFileName();//上传文件的路径path=path+filename;//保存文件file.saveAs(path,SmartUpload.SAVE_VIRTUAL);out.println(""<tableborder=1>"");out.println(""<tr><td>姓名:</td><td>""+name+""</td></tr>"");out.println(""<tr><td>密码:</td><td>""+pwd+""</td></tr>"");out.println(""<tr><td>上传的文件名称（filename):</td><td>""+filename+""</td></tr>"");out.println(""<tr><td>上传的文件表单项名称（fliedname):</td><td>""+file.getFieldName()+""</td></tr>"");out.println(""<tr><td>上传的文件的大小（长度）（size):</td><td>""+file.getSize()+""</td></tr>"");out.println(""<tr><td>上传的文件的扩展名（ext):</td><td>""+file.getFileExt()+""</td></tr>"");out.println(""</table><br/>"");}%>",2015/5/21
263,[转]阿里巴巴二维码：给所有商品贴上，让你扫一扫知真假,路斌,http://180.168.156.212:2262/wecenter/?/article/9030,阿里也正在搭建自动生成二维码的商家共享平台。平台搭建完成后，商家只需提交企业以及品牌相关信息，在平台通过认证后，商家就可自动获取独一无二的商品二维码。阿里巴巴首席风险官邵晓锋认为，满天星计划能够给消费者一个安全、透明的购物环境。在货架上拿下一瓶水，打开之前先用手机扫一下瓶盖上的二维码……如果你身边有人这么做，他们很有可能不仅仅是在参与抽奖活动，而且也在查看这瓶水的水质。最近恒大冰泉出厂的一批产品都覆盖上了自己的身份证明，只要用手机扫描每瓶恒大冰泉瓶盖上的二维码，就可以看到这瓶水的水源地、泉眼以及唯一生产编号。而接下来，恒大市面上的粮油米面等产品也将加入这一计划，每件商品上都会标注一个唯一的二维码，通过手机扫码，便能够知道这件商品的身份信息——真伪验证码和产地溯源。这技术背后，是阿里巴巴的满天星计划。作为阿里巴巴的嫡系部队，恒大是首个加入阿里巴巴满天星计划的厂商。阿里巴巴也希望与各大厂商共享二维码技术，确保每件商品在生产过程中获得独一的二维码身份证，来从生产源头截断不良商家造假售假行为。目前，阿里也正在搭建自动生成二维码的商家共享平台。平台搭建完成后，商家只需提交企业以及品牌相关信息，在平台通过认证后，商家就可自动获取独一无二的商品二维码。阿里巴巴首席风险官邵晓锋认为，满天星计划能够给消费者一个安全、透明的购物环境。那么如何保证二维码的唯一性呢？满天星计划所采用的“码”，是通过个人秘钥数字签名加密、与线下离线SDK数据验证相结合的方式，从而确保每一件商品上的二维码都是独一无二的。如果有商家复制个别二维码进行造假售假，厂家在通过阿里大数据对二维码做出扫码次数判断，以及打假雷达自动追踪扫码地理位置后，也可迅速排查出假冒产品售假地址，从而截断线上线下的售假行为。阿里码上淘相关负责人则介绍，满天星计划主要是以“码”作为链接，为厂商提供从生产数据管理、产品溯源、防伪验真、产品说明、用户互动的一整套解决方案。恒大方面的数据显示，这批恒大冰泉上市不到10天时间，有10万人参与了扫码进行产品溯源。当然，扫码后可抽奖获取支付宝红包是消费者去验证一个个二维码的重要原因。到明年一月份，美妆品牌佰草集、韩后和自然堂也将推出商品二维码。到时候，一位购买韩后化妆品的用户，只需扫商品上的二维码，就可立即显示产品是“真”还是“假”。同时，二维码除了帮你辨别真伪，它还可以提供该产品的使用方法和搭配效果。而现在，恒大作为第一批“小白鼠”开始了这一计划。,2015/5/21
264,为现代JavaScript开发做好准备,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9029,"今天无论是在浏览器中还是在浏览器外，JavaScript世界正在经历翻天覆地地变化。如果我们谈论脚本加载、客户端的MVC框架、压缩器、AMD、Common.js还有Coffeescript……只会让你的脑子发昏。对于那些已经早就熟知这些技术的人而言，或许很难想象到现在为止还有很多JS开发者还不熟悉这些工具，甚至事实上，他们很可能现在还不想去尝试这些工具。这篇文章将会介绍一些很基础的JS知识，以及当开发者想要尝试Backbone.js和Ember.js之类的工具之前需要知道一些内容。当你理解了这篇文章中的大部分内容的时候，你会更有信心去学习其他高级JavaScript知识的时候。这篇文章是假设你曾经使用过JavaScript的，所以如果你从没有接触过它，也许你需要先了解下更基础的知识。现在我们开始吧！模块有多少人在一个文件中写的JS像下面的代码块一样？（注意：我可没有说内嵌在HTML文件中哦）:varsomeSharedValue=10;varmyFunction=function(){//dosomething}varanotherImportantFunction=function(){//domorestuff}如果你做到了这一点，那么很有可能你正在写这样的代码。我不是在给你下定义，因为在相当长的一段时间里我也曾这么写程序。事实上这段代码有很多毛病，不过我们会专注在讨论全局命名空间的污染问题上。这样的代码代码会把方法和变量都暴露在了全局中，我们需要将让这些数据与全局命名空间独立开来，我们将会采用模块模式（ModulePattern）来实现这个目的。模块中可以有很多不同的形式达到我们的目标，我会从最简单的方法开始说：立即调用的函数表达式（ImmediatelyInvokedFunctionExpression，简写为：IIFE）。名字听起来很高大上，不过它的实现其实很简单：(function(){//dosomework})();如果在此之前你从未接触过这种函数，可能现在你会觉得它很怪—怎么会有这么多括号！它是会立即执行的函数，你可以这么理解：一个函数被创建了后又立刻被调用。它应该是一个表达而不是一个语句：一个函数语句是一定要有一个名字的，但是大家也看到了，立即执行函数是没有名字的。在函数定义的外部还有一组括号，这一点也能很好地帮助我们在代码中轻易找到匿名函数的身影。现在我们知道要怎么写一个立即执行函数了，那就来聊聊为什么要使用它吧。在JS中我们都是在和各种作用域之中的函数打交道，所以如果我们想要创建一个作用域，就可以使用函数。匿名函数中的变量和方法的作用域仅仅在匿名函数中，就不会污染全局的命名空间，那么现在还需要考虑的一个问题是，我们要如何从外部取得那些在匿名函数作用域中的变量和方法呢？答案就是全局命名空间：将变量放入全局命名空间中，或者至少将作用变量与全局命名空间关联起来想要在立即执行函数外部调用方法，我们可以将window对象传入立即执行函数，再将函数或变量值赋值到这个对象上。为了保证这个window对象的引入不会造成什么混乱，我们可以将widow对象作为一个变量传入我们的立即执行函数中。当做函数传入参数的方法同样适用于第三方库，甚至undefined这样的值。现在我们的立即执行函数看起来是这样的：(function(window,$,undefined){//dosomework})(window,jQuery);正如你所看到的，我们将window和jQuery传入函数中（’$'符号表示的就是’jQuery’，把它用在这的原因是防止其他库也定义了’$'），但是这个函数其实是接收了3个参数。如果我们没有传入第三个参数，形参undefined的值会保持这个状态，而不会由于其他代码把全局的undefined改变了它也跟着改变。其实在函数内我们也是可以直接使用这些值，能这么做的原理是，JS的闭包会覆盖他们所处的上下文。对于这个话题，我曾写过一篇关于C#的文章以解释这个概念，这两者是互通的。现在我们有了一个会立即执行的方法，还有一个相对安全的执行上下文，其中还包含有window、$和undefined变量（这几个变量还是有可能在这个脚本被执行前就被重新赋值，不过现在的可能性要小的多了）。现在我们已经做得很好了：把我们的代码从全局环境下的一团混乱的局面中拯救了出来；降低了与其他在同一应用中使用的脚本的冲突可能性。任何我们想要从模块中获取的东西都可以通过window对象拿到。但是通常我不会直接将模块中的内容直接复制到window对象上，而是会用更有组织性地将模块中的内容。在大部分语言中，我们将这些容器称为“命名空间”，在JS中我们可以用“对象”的方式来模拟。命名空间如果我们想要声明一个命名空间，将一个函数放进这个空间中，代码可以写成这样：window.myApp=window.myApp||{};window.myApp.someFunction=function(){//sosomework};我们是在全局环境中创建了一个对象，它是用于查看另外的某个对象是否已经存在，如果已经存在了，那么我们就可以直接使用；不然就需要用’{}’来创建一个新的对象。接着，我们可以开始添加这个命名空间的内容，将各种函数放入这个空间中，就像上面的代码片段所做的那样，但是我们又不希望这些函数就随便的放在那里，而是希望将模块和命名空间联系在一起，就像下面这样：(function(myApp,$,undefined){//dosomework}(window.myApp=window.myApp||{},jQuery));还可以这么写：window.myApp=(function(myApp,$,undefined){//dosomeworkreturnmyApp;})(window.myApp||{},jQuery);现在，我们不再是将window传入我们的模块中，我们将一个和window对象联系在一起的命名空间传入模块中。之所以使用’||’的原因是我们可以重复使用同一个命名空间，而不是每次需要使用命名空间的时候我们又要重新创建一个。许多包含有命名空间方法的库会帮你创建好空间的，或者你可以使用一些想namespace.js这样的工具来构建嵌套的命名空间。由于在JS中，每一个在命名空间中的项你都不得不指定它的命名空间，所以通常我都尽量不会去创建深度嵌套的命名空间。如果你在MyApp.MyModule.MySubModule中创建了一个doSomething方法，你需要这么引用它：MyApp.MyModule.MySubModule.doSomething();每次你要调用它，或者你可以在你的模块中给这个命名空间一个别名：varMySubModule=MyApp.MyModule.MySubModule;这样定义以后，如果你想用doSomething这个方法可以用MySubModule.doSomething()来调用。不过这个方式其实是不必要的，除非你有非常非常多的代码，不然这么做只会将问题复杂化。揭秘模块模式在创建模块时你也常会看到另一种设计模式：揭秘模块模式（RevealingModulePattern）。它和模块模式有一些不同：所有定义在模块中的内容都是私有的，然后你可以把所有要暴露到模块外部的内容放在一个对象中，再返回这个对象。你可以这么做：varmyModule=(function($,undefined){varmyVar1='',myVar2='';varsomeFunction=function(){returnmyVar1+""""+myVar2;};return{getMyVar1:function(){returnmyVar1;},//myVar1publicgettersetMyVar1:function(val){myVar1=val;},//myVar1publicsettersomeFunction:someFunction//somefunctionmadepublic}})(jQuery);一次就建立一个模块，然后返回一个包含有需要公有化的模块片段的对象，同时模块中需要保持私有的变量也不会被暴露。myModule变量会包含有两个共有的项，不过其中Somefunction中的myVar2是从外部获取不到的。创建构造器（类）在JS中没有“类”这个概念，但是我们可以通过创建构造器来创建“对象”。假设现在我们要创建一系列Person对象，还需要传入姓、名和年龄，我们可以将构造器定义成下面这样（这部分代码应该放在模块之中）：varPerson=function(firstName,lastName,age){this.firstName=firstName;this.lastName=lastName;this.age=age;}Person.prototype.fullName=function(){returnthis.firstName+""""+this.lastName;};现在先看第一个函数，你会看到我们创建了一个Person构造器。我们用它来构造新的person对象。这个构造器需要3个传入参数，然后将这3个参数赋值到执行上下文中。我们也是通过这种方式获取到公有实例变量。这里也可以创建私有变量：将传入参数赋值到这个构造器中的局部变量。但是这么做以后，公有的方法就没法获取这些私有的变量了，所以你最好还是把它们都变成公有的。也可以把方法放在构造器中同时还能从外部获取到它，这样方法就能拿到构造器里的私有变量了，不过这么做的话又会出现一系列新的问题。第二个方法中我们使用了Person构造器的”原型”（prototype）。一个函数的原型就是一个对象，当你需要在某个实例上解析它所调用到的字段或者函数时你需要遍历这个函数上所有的实例。所以这几行代码所做的就是创建一个fullName方法的实例，然后所有的Person的实例都能直接调用到这方法，而不是对每个Person实例都添加一个fullName方法，造成方法的泛滥。我们也可以在构造器中用this.fullName=function(){…的方式定义fullName，但这样每一个Person实例都会有fullName方法的副本，这不是我们希望的。如果我们想要创建一个Person实例，我们可以这么做：varperson=newPerson(""Justin"",""Etheredge"");alert(person.fullName());我们也可以创建一个继承自Person的构造器：Spy构造器，我们会创建Spy的一个实例，不过只会声明一个方法：varSpy=function(firstName,lastName,age){this.firstName=firstName;this.lastName=lastName;this.age=age;};Spy.prototype=newPerson();Spy.prototype.spy=function(){alert(this.fullName()+""isspying."");}varmySpy=newSpy(""Mr."",""Spy"",50);mySpy.spy();正如你所看到的，我们创建了一个和Person很相似的构造器，但是它的原型是Person的一个实例。现在我们又添加上一些方法，使得Spy的实例又可以调用到Person的方法，同时还能直接取得Spy中的变量。这个方法比较复杂，不过一旦你明白怎么使用了，你的代码就会变得很优雅。结语看到这里，希望你已经学到了一些东西。不过这篇文章里并没有介绍多少关于“现代”JS的开发。这篇文章中涉及的还是旧知识，在过去几年里它们的使用面相当广。希望你看完这篇文章以后，找到了学习JS的正确的方向。现在可能你把代码放到了不同的模块不同的文件中（你应该做到这一点！），那么下一步你要开始着手研究如何将JS结合和压缩。如果你是使用Rails3的开发者，可以在assetpipeline上免费获取这些信息或者工具。如果你是.NET开发者，你可以看看SquishIt框架，我就是从这里开始的。如果你是ASP.NETMVC4的开发者，也有相关的资源。",2015/5/19
265,SWT封装Firefox后异常推出解决,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/9028,SWT封装Firefox后异常推出解决2015年4月经验共享-黄翔宇.docx,2015/5/19
266,前端js脚本执行错误收集,丁凯,http://180.168.156.212:2262/wecenter/?/article/9027,"前端js脚本执行错误收集一、背景项目开发完成以后，也经过了严格的测试。尽管如此，当你的项目完成向外发布以后，在用户的机器上还是会出现各种各样的问题(我们这里所指的是前端js脚本执行错误问题)，因为用户的浏览器是各种各样的、千差万别的！对于这种情况你如何进行收集js脚本的执行错误信息呢？没有一个监控系统，我们很难了解到发布出去的代码在用户机器上执行是否正确，所以需要建立前端代码性能相关的监控系统—js脚本执行错误收集。二、收集脚本执行错误functionerror(msg,url,line){varREPORT_URL=""xxx"";//收集上报数据的信息地址varurl=REPORT_URL+""?msg=""+msg+""&url=""+url+""&line=""+line+""&userAgent=""+navigator.userAgent+""&date=""+newDate;//组装错误上报信息内容URLvarimg=newImage;img.onload=img.onerror=function(){img=null;};img.src=url;//发送数据到后台}/***监听错误上报*msg错误信息*url发生错误的文件*line发生错误的行号*/window.onerror=function(msg,url,line){error(msg,url,line);}这样,通过管理后台系统，我们可以看到页面上每次错误的信息，通过这些信息我们可以很快定位并且解决问题。",2015/5/19
267,如何不借助H5在浏览中绘制矢量图形？,丁凯,http://180.168.156.212:2262/wecenter/?/article/9026,如何不借助H5在浏览中绘制矢量图形？见附件平台研发部经验共享[201504]_丁凯.ppt,2015/5/19
268,Redis客户端之Spring整合Jedis,管俊,http://180.168.156.212:2262/wecenter/?/article/9025,"1.下载相关jar包，并引入工程：jedis-2.4.2.jarcommons-pool2-2.0.jar2.将以下XML配置引入spring<beanid=""shardedJedisPool""class=""redis.clients.jedis.ShardedJedisPool""><constructor-argindex=""0""ref=""jedisPoolConfig""/><constructor-argindex=""1""><list><beanname=""slaver""class=""redis.clients.jedis.JedisShardInfo""><constructor-argindex=""0""value=""${redis.slaver.host}""/><constructor-argindex=""1""value=""${redis.slaver.port}""type=""int""/></bean><beanname=""master""class=""redis.clients.jedis.JedisShardInfo""><constructor-argindex=""0""value=""${redis.master.host}""/><constructor-argindex=""1""value=""${redis.master.port}""type=""int""/></bean></list></constructor-arg></bean><beanid=""jedisPoolConfig""class=""redis.clients.jedis.JedisPoolConfig""><propertyname=""maxTotal""value=""2048""/><propertyname=""maxIdle""value=""200""/><propertyname=""numTestsPerEvictionRun""value=""1024""/><propertyname=""timeBetweenEvictionRunsMillis""value=""30000""/><propertyname=""minEvictableIdleTimeMillis""value=""-1""/><propertyname=""softMinEvictableIdleTimeMillis""value=""10000""/><propertyname=""maxWaitMillis""value=""1500""/><propertyname=""testOnBorrow""value=""true""/><propertyname=""testWhileIdle""value=""true""/><propertyname=""testOnReturn""value=""false""/><propertyname=""jmxEnabled""value=""true""/><propertyname=""jmxNamePrefix""value=""youyuan""/><propertyname=""blockWhenExhausted""value=""false""/></bean>3.将shardedJedisPool注入相关的类中即可使用@ResourceprivateShardedJedisPoolshardedJedisPool;/***设置一个key的过期时间（单位：秒）*@paramkeykey值*@paramseconds多少秒后过期*@return1：设置了过期时间0：没有设置过期时间/不能设置过期时间*/publiclongexpire(Stringkey,intseconds){if(key==null||key.equals("""")){return0;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.expire(key,seconds);}catch(Exceptionex){logger.error(""EXPIREerror[key=""+key+""seconds=""+seconds+""]""+ex.getMessage(),ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return0;}/***设置一个key在某个时间点过期*@paramkeykey值*@paramunixTimestampunix时间戳，从1970-01-0100:00:00开始到现在的秒数*@return1：设置了过期时间0：没有设置过期时间/不能设置过期时间*/publiclongexpireAt(Stringkey,intunixTimestamp){if(key==null||key.equals("""")){return0;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.expireAt(key,unixTimestamp);}catch(Exceptionex){logger.error(""EXPIREerror[key=""+key+""unixTimestamp=""+unixTimestamp+""]""+ex.getMessage(),ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return0;}/***截断一个List*@paramkey列表key*@paramstart开始位置从0开始*@paramend结束位置*@return状态码*/publicStringtrimList(Stringkey,longstart,longend){if(key==null||key.equals("""")){return""-"";}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.ltrim(key,start,end);}catch(Exceptionex){logger.error(""LTRIM出错[key=""+key+""start=""+start+""end=""+end+""]""+ex.getMessage(),ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return""-"";}/***检查Set长度*@paramkey*@return*/publiclongcountSet(Stringkey){if(key==null){return0;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.scard(key);}catch(Exceptionex){logger.error(""countSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return0;}/***添加到Set中（同时设置过期时间）*@paramkeykey值*@paramseconds过期时间单位s*@paramvalue*@return*/publicbooleanaddSet(Stringkey,intseconds,String...value){booleanresult=addSet(key,value);if(result){longi=expire(key,seconds);returni==1;}returnfalse;}/***添加到Set中*@paramkey*@paramvalue*@return*/publicbooleanaddSet(Stringkey,String...value){if(key==null||value==null){returnfalse;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.sadd(key,value);returntrue;}catch(Exceptionex){logger.error(""setListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***@paramkey*@paramvalue*@return判断值是否包含在set中*/publicbooleancontainsInSet(Stringkey,Stringvalue){if(key==null||value==null){returnfalse;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.sismember(key,value);}catch(Exceptionex){logger.error(""setListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***获取Set*@paramkey*@return*/publicSet<String>getSet(Stringkey){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.smembers(key);}catch(Exceptionex){logger.error(""getListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}/***从set中删除value*@paramkey*@return*/publicbooleanremoveSetValue(Stringkey,String...value){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.srem(key,value);returntrue;}catch(Exceptionex){logger.error(""getListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***从list中删除value默认count1*@paramkey*@paramvalues值list*@return*/publicintremoveListValue(Stringkey,List<String>values){returnremoveListValue(key,1,values);}/***从list中删除value*@paramkey*@paramcount*@paramvalues值list*@return*/publicintremoveListValue(Stringkey,longcount,List<String>values){intresult=0;if(values!=null&&values.size()>0){for(Stringvalue:values){if(removeListValue(key,count,value)){result++;}}}returnresult;}/***从list中删除value*@paramkey*@paramcount要删除个数*@paramvalue*@return*/publicbooleanremoveListValue(Stringkey,longcount,Stringvalue){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.lrem(key,count,value);returntrue;}catch(Exceptionex){logger.error(""getListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***截取List*@paramkey*@paramstart起始位置*@paramend结束位置*@return*/publicList<String>rangeList(Stringkey,longstart,longend){if(key==null||key.equals("""")){returnnull;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.lrange(key,start,end);}catch(Exceptionex){logger.error(""rangeList出错[key=""+key+""start=""+start+""end=""+end+""]""+ex.getMessage(),ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}/***检查List长度*@paramkey*@return*/publiclongcountList(Stringkey){if(key==null){return0;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.llen(key);}catch(Exceptionex){logger.error(""countListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return0;}/***添加到List中（同时设置过期时间）*@paramkeykey值*@paramseconds过期时间单位s*@paramvalue*@return*/publicbooleanaddList(Stringkey,intseconds,String...value){booleanresult=addList(key,value);if(result){longi=expire(key,seconds);returni==1;}returnfalse;}/***添加到List*@paramkey*@paramvalue*@return*/publicbooleanaddList(Stringkey,String...value){if(key==null||value==null){returnfalse;}ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.lpush(key,value);returntrue;}catch(Exceptionex){logger.error(""setListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***添加到List(只新增)*@paramkey*@paramvalue*@return*/publicbooleanaddList(Stringkey,List<String>list){if(key==null||list==null||list.size()==0){returnfalse;}for(Stringvalue:list){addList(key,value);}returntrue;}/***获取List*@paramkey*@return*/publicList<String>getList(Stringkey){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.lrange(key,0,-1);}catch(Exceptionex){logger.error(""getListerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}/***设置HashSet对象**@paramdomain域名*@paramkey键值*@paramvalueJsonStringorStringvalue*@return*/publicbooleansetHSet(Stringdomain,Stringkey,Stringvalue){if(value==null)returnfalse;ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.hset(domain,key,value);returntrue;}catch(Exceptionex){logger.error(""setHSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***获得HashSet对象**@paramdomain域名*@paramkey键值*@returnJsonStringorStringvalue*/publicStringgetHSet(Stringdomain,Stringkey){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.hget(domain,key);}catch(Exceptionex){logger.error(""getHSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}/***删除HashSet对象**@paramdomain域名*@paramkey键值*@return删除的记录数*/publiclongdelHSet(Stringdomain,Stringkey){ShardedJedisshardedJedis=null;longcount=0;try{shardedJedis=shardedJedisPool.getResource();count=shardedJedis.hdel(domain,key);}catch(Exceptionex){logger.error(""delHSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returncount;}/***删除HashSet对象**@paramdomain域名*@paramkey键值*@return删除的记录数*/publiclongdelHSet(Stringdomain,String...key){ShardedJedisshardedJedis=null;longcount=0;try{shardedJedis=shardedJedisPool.getResource();count=shardedJedis.hdel(domain,key);}catch(Exceptionex){logger.error(""delHSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returncount;}/***判断key是否存在**@paramdomain域名*@paramkey键值*@return*/publicbooleanexistsHSet(Stringdomain,Stringkey){ShardedJedisshardedJedis=null;booleanisExist=false;try{shardedJedis=shardedJedisPool.getResource();isExist=shardedJedis.hexists(domain,key);}catch(Exceptionex){logger.error(""existsHSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnisExist;}/***全局扫描hset**@parammatchfield匹配模式*@return*/publicList<Map.Entry<String,String>>scanHSet(Stringdomain,Stringmatch){ShardedJedisshardedJedis=null;try{intcursor=0;shardedJedis=shardedJedisPool.getResource();ScanParamsscanParams=newScanParams();scanParams.match(match);Jedisjedis=shardedJedis.getShard(domain);ScanResult<Map.Entry<String,String>>scanResult;List<Map.Entry<String,String>>list=newArrayList<Map.Entry<String,String>>();do{scanResult=jedis.hscan(domain,String.valueOf(cursor),scanParams);list.addAll(scanResult.getResult());cursor=Integer.parseInt(scanResult.getStringCursor());}while(cursor>0);returnlist;}catch(Exceptionex){logger.error(""scanHSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}/***返回domain指定的哈希集中所有字段的value值**@paramdomain*@return*/publicList<String>hvals(Stringdomain){ShardedJedisshardedJedis=null;List<String>retList=null;try{shardedJedis=shardedJedisPool.getResource();retList=shardedJedis.hvals(domain);}catch(Exceptionex){logger.error(""hvalserror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnretList;}/***返回domain指定的哈希集中所有字段的key值**@paramdomain*@return*/publicSet<String>hkeys(Stringdomain){ShardedJedisshardedJedis=null;Set<String>retList=null;try{shardedJedis=shardedJedisPool.getResource();retList=shardedJedis.hkeys(domain);}catch(Exceptionex){logger.error(""hkeyserror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnretList;}/***返回domain指定的哈希key值总数**@paramdomain*@return*/publiclonglenHset(Stringdomain){ShardedJedisshardedJedis=null;longretList=0;try{shardedJedis=shardedJedisPool.getResource();retList=shardedJedis.hlen(domain);}catch(Exceptionex){logger.error(""hkeyserror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnretList;}/***设置排序集合**@paramkey*@paramscore*@paramvalue*@return*/publicbooleansetSortedSet(Stringkey,longscore,Stringvalue){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.zadd(key,score,value);returntrue;}catch(Exceptionex){logger.error(""setSortedSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***获得排序集合**@paramkey*@paramstartScore*@paramendScore*@paramorderByDesc*@return*/publicSet<String>getSoredSet(Stringkey,longstartScore,longendScore,booleanorderByDesc){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();if(orderByDesc){returnshardedJedis.zrevrangeByScore(key,endScore,startScore);}else{returnshardedJedis.zrangeByScore(key,startScore,endScore);}}catch(Exceptionex){logger.error(""getSoredSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}/***计算排序长度**@paramkey*@paramstartScore*@paramendScore*@return*/publiclongcountSoredSet(Stringkey,longstartScore,longendScore){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();Longcount=shardedJedis.zcount(key,startScore,endScore);returncount==null?0L:count;}catch(Exceptionex){logger.error(""countSoredSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return0L;}/***删除排序集合**@paramkey*@paramvalue*@return*/publicbooleandelSortedSet(Stringkey,Stringvalue){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();longcount=shardedJedis.zrem(key,value);returncount>0;}catch(Exceptionex){logger.error(""delSortedSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}/***获得排序集合**@paramkey*@paramstartRange*@paramendRange*@paramorderByDesc*@return*/publicSet<String>getSoredSetByRange(Stringkey,intstartRange,intendRange,booleanorderByDesc){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();if(orderByDesc){returnshardedJedis.zrevrange(key,startRange,endRange);}else{returnshardedJedis.zrange(key,startRange,endRange);}}catch(Exceptionex){logger.error(""getSoredSetByRangeerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}/***获得排序打分**@paramkey*@return*/publicDoublegetScore(Stringkey,Stringmember){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.zscore(key,member);}catch(Exceptionex){logger.error(""getSoredSeterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnnull;}publicbooleanset(Stringkey,Stringvalue,intsecond){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.setex(key,second,value);returntrue;}catch(Exceptionex){logger.error(""seterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}publicbooleanset(Stringkey,Stringvalue){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.set(key,value);returntrue;}catch(Exceptionex){logger.error(""seterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}publicStringget(Stringkey,StringdefaultValue){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.get(key)==null?defaultValue:shardedJedis.get(key);}catch(Exceptionex){logger.error(""geterror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returndefaultValue;}publicbooleandel(Stringkey){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();shardedJedis.del(key);returntrue;}catch(Exceptionex){logger.error(""delerror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}returnfalse;}publiclongincr(Stringkey){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.incr(key);}catch(Exceptionex){logger.error(""increrror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return0;}publiclongdecr(Stringkey){ShardedJedisshardedJedis=null;try{shardedJedis=shardedJedisPool.getResource();returnshardedJedis.decr(key);}catch(Exceptionex){logger.error(""increrror."",ex);returnBrokenResource(shardedJedis);}finally{returnResource(shardedJedis);}return0;}privatevoidreturnBrokenResource(ShardedJedisshardedJedis){try{shardedJedisPool.returnBrokenResource(shardedJedis);}catch(Exceptione){logger.error(""returnBrokenResourceerror."",e);}}privatevoidreturnResource(ShardedJedisshardedJedis){try{shardedJedisPool.returnResource(shardedJedis);}catch(Exceptione){logger.error(""returnResourceerror."",e);}}",2015/5/19
269,Java POI导出excel,何文,http://180.168.156.212:2262/wecenter/?/article/9024,"在web开发中，有一个经典的功能，就是数据的导入导出。特别是数据的导出，在生产管理或者财务系统中用的非常普遍，因为这些系统经常要做一些报表打印的工作。而数据导出的格式一般是EXCEL或者PDF，我这里就用两篇文章分别给大家介绍下。（注意，我们这里说的数据导出可不是数据库中的数据导出！么误会啦^_^）呵呵，首先我们来导出EXCEL格式的文件吧。现在主流的操作Excel文件的开源工具有很多,用得比较多的就是Apache的POI及JExcelAPI。这里我们用ApachePOI！我们先去Apache的大本营下载POI的jar包： students.xls"");wb.write(fout);fout.close();}catch(Exceptione){e.printStackTrace();}",2015/5/18
270,solrJ 调用solrcloud 示例,王国栋,http://180.168.156.212:2262/wecenter/?/article/9023,"solrj客户端调用solrcloud与调用传统solr单机有一点区别。增查索引可以参考下面代码，例子仅仅列出了最基本的API操作与大概逻辑。实际情况需要根据自己需求改写packagecom.cesgroup.solr;importjava.io.IOException;importjava.util.ArrayList;importjava.util.Collection;importjava.util.List;importorg.apache.solr.client.solrj.SolrQuery;importorg.apache.solr.client.solrj.SolrServerException;importorg.apache.solr.client.solrj.impl.CloudSolrClient;importorg.apache.solr.client.solrj.response.QueryResponse;importorg.apache.solr.common.SolrDocument;importorg.apache.solr.common.SolrDocumentList;importorg.apache.solr.common.SolrException;importorg.apache.solr.common.SolrInputDocument;importorg.apache.solr.common.cloud.ClusterState;importorg.apache.solr.common.cloud.ZkStateReader;importorg.slf4j.Logger;importorg.slf4j.LoggerFactory;/***solr增删改查工具。**@authorwang*/publicclassSolrUtil{privatestaticfinalLoggerLOG=LoggerFactory.getLogger(SolrUtil.class);///////////////////常量、属性/***失败重试次数。可以读取配置文件*/privatestaticfinalintMAX_RETRY_TIMES=5;/***客户端调用超时,ms。可以读取配置文件*/privatestaticfinalintZK_CLIENT_TIMEOUT=2000;/***solr服务器连接超时,ms。可以读取配置文件*/privatestaticfinalintZK_CONNECT_TIMEOUT=1000;/***ZK服务器地址，oversee监控节点或者所有zk节点。可以读取配置文件*/privatestaticfinalStringZK_SERVER=""localhost:2181,localhost:2182,localhost:2183"";/***默认collection，如果调用时不指定索引集，那么使用默认值，可以读取配置文件*/privatestaticfinalStringDEFAULT_COLLECTION=""collection1"";privatestaticvolatilebooleanisInstanced=false;privatestaticCloudSolrClientsolrClient;///////////////////方法区privatestaticSolrUtilsolrUtil;privateSolrUtil(){solrClient=newCloudSolrClient(ZK_SERVER);solrClient.setZkClientTimeout(ZK_CLIENT_TIMEOUT);solrClient.setZkConnectTimeout(ZK_CONNECT_TIMEOUT);solrClient.setDefaultCollection(DEFAULT_COLLECTION);}/***返回工具实例**@return*/publicstaticSolrUtilgetSolrUtil(){if(!isInstanced){synchronized(SolrUtil.class){if(solrUtil==null){solrUtil=newSolrUtil();isInstanced=true;}}}returnsolrUtil;}/***查询例子，可以自己扩展需要的方法参数和查询**@paramcollectionName*索引集名字*@paramqueryParam*查询参数*/publicstaticvoidsearch(StringcollectionName,StringqueryParam){SolrQueryquery=newSolrQuery(queryParam);QueryResponseresponse;try{response=solrClient.query(query);SolrDocumentListdocList=response.getResults();LOG.debug(""查询结果文档个数-{}"",docList.getNumFound());LOG.debug(""本次查询消耗时间-{}"",response.getQTime());for(SolrDocumentsolrDocument:docList){//组织自己需要的返回值//TODO}}catch(SolrServerException|IOExceptione){if(!shoudNotRetry(e)){//需要重试，调用重试代码。可能是重试队列。//TODO}}}/***添加索引示例，传入参数还可以是个map**@paramcollectionName*@paraminsertList*传入参数的形式可以按照需求改变*/publicstaticvoidaddIndex(StringcollectionName,List<Object>insertList){Collection<SolrInputDocument>docs=newArrayList<SolrInputDocument>(insertList.size());SolrInputDocumentdoc;for(Objecto:insertList){doc=newSolrInputDocument();doc.addField(""id"",2);doc.addField(""name"",""张三"");docs.add(doc);}try{solrClient.add(docs);}catch(SolrServerException|IOExceptione){if(!shoudNotRetry(e)){//需要重试，调用重试代码。可能是重试队列。//TODO}}}/***测试solr集群的可用性等状态信息*/privatestaticvoidtestServer(){ZkStateReaderzkStateReader=solrClient.getZkStateReader();ClusterStatecloudState=zkStateReader.getClusterState();//这里会打印存活节点、每个索引集状态等信息，可以根据需求自己接受并解析状态LOG.info(cloudState.toString());}/***测试当前异常是否需要重试**@paramt*@return*/privatestaticbooleanshoudNotRetry(Throwablet){if(tinstanceofError){returntrue;}if(tinstanceofIOException){returnfalse;}if(tinstanceofSolrException){SolrExceptionse=(SolrException)t;interrorCode=se.code();//无需重试的HTTP相应代码if(errorCode==404||errorCode==403||errorCode==503||errorCode==400){returntrue;}}returnfalse;}}",2015/5/18
271,jar转exe转换器,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9022,jar转exe转换器(jar2exe)是一款可以将jar文件转换成exe可执行文件的工具。采用Java开发的软件更加方便地执行和发布，避免了采用批处理文件进行启动带来的麻烦。jar2exe的工作原理就是使用JNI接口启动java虚拟机，并在此基础上提供其他高级的功能。软件可以生成：“控制台程序”，“Windows窗口程序”以及“WindowsNT服务程序”三种类型的可执行文件。jar转exe转换器(jar2exe)使用方法很简单，如下所示：1.输入jar文件的路径2.选择应用程序类型（控制台程序、Windows窗口程序或WindowsNT服务程序）3.输入启动类。输入带有main方法的类名4.输入要生成的Exe文件名5.大功告成，jar2exe使用就是这样简单。,2015/5/15
272,4月经验分享,李海波,http://180.168.156.212:2262/wecenter/?/article/9020,4月经验分享研发一部-李海波-经验分享-20150505.doc,2015/5/12
273,工时日志系统使用遇到的bug,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9021,1、新增日志-增加-点击项目编号下拉框，每次需要点几次，下拉框才出现内容，使用起来不方便。2、添加内容之后，点击保存，系统没有跳转到日志列表，而是到空白页,2015/5/11
274,中信自己的彩码，行还是不行？,杨安荣,http://180.168.156.212:2262/wecenter/?/article/9019,彩码，是为解决二维码的技术和应用瓶颈，而发展起来的新型条码技术产品，也是未来市场适用性最广的产品。 /link?url=KRoYA_8H5u5Pn46CFh5ExlMtvXlePrIbFo4bpuR3mdvjpvYMMv4hHjXlrLZEaoM1GjU46c7BdCWYcAoS7mNkwq预计在我司的包装类食品追溯项目中会有广阔的应用前景。有没有开源的彩码技术？我们自己设计算法，搞一个自主知识产权的彩码行不行？,2015/5/8
275,sql 语句的优化,马玉荣,http://180.168.156.212:2262/wecenter/?/article/9018,"1、避免使用“*”当你想在SELECT子句中列出所有的COLUMN时,使用动态SQL列引用‘*’是一个方便的方法.不幸的是,这是一个非常低效的方法.实际上,ORACLE在解析的过程中,会将‘*’依次转换成所有的列名,这个工作是通过查询数据字典完成的,这意味着将耗费更多的时间；2、避免使用耗费资源的操作带有DISTINCT,UNION,MINUS,INTERSECT,ORDERBY的SQL语句会启动SQL引擎执行耗费资源的排序(SORT)功能.DISTINCT需要一次排序操作,而其他的至少需要执行两次排序.例如,一个UNION查询,其中每个查询都带有GROUPBY子句,GROUPBY会触发嵌入排序(NESTEDSORT);这样,每个查询需要执行一次排序,然后在执行UNION时,又一个唯一排序(SORTUNIQUE)操作被执行而且它只能在前面的嵌入排序结束后才能开始执行.嵌入的排序的深度会大大影响查询的效率.通常,带有UNION,MINUS,INTERSECT的SQL语句都可以用其他方式重写.（1）用EXISTS替换DISTINCT，例如:低效:SELECTDISTINCTDEPT_NO,DEPT_NAMEFROMDEPTD,EMPEWHERED.DEPT_NO=E.DEPT_NO高效:SELECTDEPT_NO,DEPT_NAMEFROMDEPTDWHEREEXISTS(SELECT‘X’FROMEMPEWHEREE.DEPT_NO=D.DEPT_NO);（2）用UNION-ALL替换UNION(ifpossible)当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并,然后在输出最终结果前进行排序.低效：SELECTACCT_NUM,BALANCE_AMTFROMDEBIT_TRANSACTIONSWHERETRAN_DATE=’31-DEC-95’UNIONSELECTACCT_NUM,BALANCE_AMTFROMDEBIT_TRANSACTIONSWHERETRAN_DATE=’31-DEC-95’高效:SELECTACCT_NUM,BALANCE_AMTFROMDEBIT_TRANSACTIONSWHERETRAN_DATE=’31-DEC-95’UNIONALLSELECTACCT_NUM,BALANCE_AMTFROMDEBIT_TRANSACTIONSWHERETRAN_DATE=’31-DEC-95’3、避免在索引列上使用计算函数WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．举例:低效：SELECT…FROMDEPTWHERESAL*12>25000;高效:SELECT…FROMDEPTWHERESAL>25000/12;4、避免使用前置通配符WHERE子句中,如果索引列所对应的值的第一个字符由通配符(WILDCARD)开始,索引将不被采用.SELECTUSER_NO,USER_NAME,ADDRESSFROMUSER_FILESWHEREUSER_NOLIKE'%109204421';在这种情况下，ORACLE将使用全表扫描.在很多情况下可能无法避免这种情况，但是一定要心中有底，通配符如此使用会降低查询速度。然而当通配符出现在字符串其他位置时，优化器就能利用索引。在下面的查询中索引得到了使用：select*fromemployeewherelast_namelike'c%';5、避免在索引列上使用NOT通常，我们要避免在索引列上使用NOT,NOT会产生在和在索引列上使用函数相同的影响.当ORACLE遇到NOT,他就会停止使用索引转而执行全表扫描.举例:低效:(这里,不使用索引)SELECT…FROMDEPTWHEREDEPT_CODENOT=0;高效:(这里,使用了索引)SELECT…FROMDEPTWHEREDEPT_CODE>0;6、避免在索引列上使用ISNULL和ISNOTNULL避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录.对于复合索引，如果每个列都为空，索引中同样不存在此记录.如果至少有一个列不为空，则记录存在于索引中．如果唯一性索引建立在表的A列和B列上,并且表中存在一条记录的A,B值为(123,null),ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入).然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空.因此你可以插入1000条具有相同键值的记录,当然它们都是空!因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引.任何在where子句中使用isnull或isnotnull的语句优化器是不允许使用索引的。7、WHERE子句中的连接顺序ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,当在WHERE子句中有多个表联接时，WHERE子句中排在最后的表应当是返回行数可能最少的表，有过滤条件的子句应放在WHERE子句中的最后。n如：设从emp表查到的数据比较少或该表的过滤条件比较确定，能大大缩小查询范围，则将最具有选择性部分放在WHERE子句中的最后：select*fromempe,deptdwhered.deptno>10ande.deptno=30;n如果dept表返回的记录数较多的话，上面的查询语句会比下面的查询语句响应快得多。select*fromempe,deptdwheree.deptno=30andd.deptno>10;8、用>=替代>如果DEPTNO上有一个索引。高效:SELECT*ROMEMPHEREDEPTNO>=4低效:SELECT*ROMEMPHEREDEPTNO>39、通过使用>=、<=等，避免使用NOT命令例子：select*fromemployeewheresalary<>3000;对这个查询，可以改写为不使用NOT：select*fromemployeewheresalary<3000orsalary>3000;虽然这两种查询的结果一样，但是第二种查询方案会比第一种查询方案更快些。第二种查询允许Oracle对salary列使用索引，而第一种查询则不能使用索引。",2015/5/7
276,web前端高性能优化,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/9017,web前端优化：HTML、CSS、JavascriptWeb前端高性能优化.doc,2015/5/5
277,CSS - 文字隐藏方法,李海波,http://180.168.156.212:2262/wecenter/?/article/9016, /archives/82,2015/5/5
278,HTML页面性能调优,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/9015,HTML页面性能优化HTML性能优化.doc,2015/5/5
279,本地缓存的使用,姚锡铭,http://180.168.156.212:2262/wecenter/?/article/9014,"缓存对于提升系统性能效果显而易见，而且成本也比较低，深受程序员的青睐。最简单的用法就是定义一个集合类，存储一些对象信息，下次使用时不需要从别的地方重新获取，而是直接在本地集合类查询即可。常用的是基于k-v键值对Map系列示例：[html]viewplaincopyprint?/***类CollectionCache.java的实现描述：TODO类实现描述**@authoronlyone*/publicclassCollectionCache{//本地缓存privatestaticMap<String,Object>context=newHashMap<String,Object>();publicObjectgetObject(Stringkey){if(context.containsKey(key)){returncontext.get(key);}//模拟从其它地方获取一个value值Objecto=newObject();context.put(key,o);returno;}}这种用法的确可以带来很大便利，但是存在潜在风险。随着Map集合自增长，会占用大量内存，可能导致频繁FullGC或者内存溢出现象。因此对于集合的使用，一定要注意限制容量，避免出现内存消耗过多的问题。常用的解决方案就是通过计数或获取集合大小来实现控制，当到达集合限制数量后，将准备放入集合的对象采取其它策略，比如LRU最近最少使用原则，或者存储到本地磁盘。Google的开源软件Guava实现了一个不错的本地缓存器，可以有效解决上面的问题。主要特征：1、采用kv存储2、当缓存器溢出时，采用最近最少使用原则替换。3、过期规则基于最后读写时间。4、设置键值引用级别。5、元素移出通知。6、缓存访问统计。参数设置：1.大小的设置：CacheBuilder.maximumSize(long)CacheBuilder.weigher(Weigher)CacheBuilder.maxumumWeigher(long)2.时间：expireAfterAccess(long,TimeUnit)expireAfterWrite(long,TimeUnit)3.引用：CacheBuilder.weakKeys()CacheBuilder.weakValues()CacheBuilder.softValues()4.明确的删除：invalidate(key)invalidateAll(keys)invalidateAll()5.asMap，把缓存动作一个ConcurrentMap[html]viewplaincopyprint?importjava.util.concurrent.ExecutionException;importjava.util.concurrent.TimeUnit;importcom.google.common.cache.Cache;importcom.google.common.cache.CacheBuilder;/****类ContextCache.java的实现描述：TODO类实现描述*@authoronlyone*/publicclassContextCache{/***超时时间，默认不超时*/privatestaticlongexpiredTime=2;/***容量大小*/privatestaticlongsize=4;privatestaticCache<Object,Object>cache=null;static{//初始化Guava的LocalCacheCacheBuilder<Object,Object>builder=CacheBuilder.newBuilder().maximumSize(size).initialCapacity((int)(size/2));if(expiredTime>0){builder.expireAfterWrite(expiredTime,TimeUnit.SECONDS);}cache=builder.build();}publicstaticvoidmain(String[]args)throwsExecutionException{for(inti=1;i<=6;i++){cache.put(""b""+i,i);}System.out.println(""缓存的大小=""+cache.size());for(inti=1;i<=6;i++){System.out.println(""b""+i+""=""+cache.getIfPresent(""b""+i));}}}[html]viewplaincopyprint?缓存的大小=3b1=nullb2=2b3=nullb4=nullb5=5b6=6",2015/4/30
280,Tomcat性能优化,姚锡铭,http://180.168.156.212:2262/wecenter/?/article/9013,"web压力测试的实现原理都是通过发送大量的重复的页面请求来模拟多用户对被测系统的并发访问，以此达到产生压力的目地。产生压力的手段都是通过录制或编写压力脚本，这些脚本以多进程或多线程的方式在客户端运行，这样通过人为制造各种类型的压力，我们可以观察被测系统在各种压力情况下的反映，从而定位系统瓶颈，作为系统调优的基础。目前已经市场上的性能测试工具不下一百种，从单一的开放源码的免费小工具如Apache自带的web性能测试工具ApacheBenchmark、开源的Jmeter到大而全的商业性能测试软件如Mercury的LoadRunner等等。常用的软件测试工具网站： #LOAD对于tomcat的性能调整可以分为两块外部环境：调整非Tomcat组件，例如Tomcat运行的操作系统和运行Tomcat的java虚拟机。自身调整：修改Tomcat自身的参数，调整Tomcat配置文件中的参数。外部环境：1.JAVA虚拟机性能优化Tomcat本身不能直接在计算机上运行，需要依赖于硬件基础之上的操作系统和一个java虚拟机。你可以根据自己的需要选择不同的操作系统和对应的JDK的版本。首先为Java虚拟机设置使用的内存大小参数描述-Xms<size>JVM初始化堆的大小-Xmx<size>JVM堆的最大值这两个值的大小一般根据需要进行设置。初始化堆的大小执行了虚拟机在启动时向系统申请的内存的大小。一般而言，这个参数不重要。但是有的应用程序在大负载的情况下会急剧地占用更多的内存，此时这个参数就是显得非常重要，如果虚拟机启动时设置使用的内存比较小而在这种情况下有许多对象进行初始化，虚拟机就必须重复地增加内存来满足使用。由于这种原因，我们一般把-Xms和-Xmx设为一样大，而堆的最大值受限于系统使用的物理内存。一般使用数据量较大的应用程序会使用持久对象，内存使用有可能迅速地增长。当应用程序需要的内存超出堆的最大值时虚拟机就会提示内存溢出，并且导致应用服务崩溃。因此一般建议堆的最大值设置为可用内存的最大值的80%。linux系统下，在文件{tomcat_home}/bin/catalina.sh的前面，增加如下设置：JAVA_OPTS='-Xms【初始化内存大小】-Xmx【可以使用的最大内存】'例如：JAVA_OPTS='-Xms256m-Xmx512m'表示初始化内存为256MB，可以使用的最大内存为512MB。另外需要考虑的是Java提供的垃圾回收机制。虚拟机的堆大小决定了虚拟机花费在收集垃圾上的时间和频度。收集垃圾可以接受的速度与应用有关，应该通过分析实际的垃圾收集的时间和频率来调整。如果堆的大小很大，那么完全垃圾收集就会很慢，但是频度会降低。如果你把堆的大小和内存的需要一致，完全收集就很快，但是会更加频繁。调整堆大小的的目的是最小化垃圾收集的时间，以在特定的时间内最大化处理客户的请求。在基准测试的时候，为保证最好的性能，要把堆的大小设大，保证垃圾收集不在整个基准测试的过程中出现。2.Tomcat与其它web服务器整合使用虽然tomcat也可以作web服务器，但其处理静态html的速度比不上apache，且其作为web服务器的功能远不如apache，因此我们想把apache和tomcat集成起来，将html与jsp的功能部分进行明确分工，让tomcat只处理jsp部分，其它的图片、js等由apache,Nginx等web服务器处理，可以大大节省tomcat有限的工作“线程”。3.负载均衡在负载均衡的思路下，多台服务器为对称方式，每台服务器都具有同等的地位，可以单独对外提供服务而无须其他服务器的辅助。通过负载分担技术，将外部发送来的请求按一定规则分配到对称结构中的某一台服务器上，而接收到请求的服务器都独立回应客户机的请求。提供服务的一组服务器组成了一个应用服务器集群(cluster)，并对外提供一个统一的地址。当一个服务请求被发至该集群时，根据一定规则选择一台服务器，并将服务转向给该服务器处理。通过负载均衡技术，使应用服务超过了一台服务器上限时，可以利用多台服务器同时为大量用户提供服务。当某台服务器出现故障时，负载均衡服务器会自动进行检测并停止将服务请求分发至该服务器，而由其他工作正常的服务器继续提供服务，从而保证了服务的可靠性。负载均衡实现的方式大概有四种：第一是通过DNS，但只能实现简单的轮流分配，不能处理故障，第二如果是基于MSIIS，Windows2003server本身就带了负载均衡服务，第三是硬件方式，通过交换机的功能或专门的负载均衡设备可以实现，第四种是软件方式，通过一台负载均衡服务器进行，上面安装软件。使用ApacheHttpdServer做负载平衡器，Tomcat集群节点使用Tomcat就可以做到以上第四种方式。这种方式比较灵活，成本相对也较低。另外一个很大的优点就是可以根据应用的情况和服务器的情况采取一些策略。内部环境：1.调整线程数Tomcat使用线程池加快处理请求的速度。在Java中线程是程序运行的路径，多线程程序可以有效利用CPU，使cpu空闲时间保持最低，从而接受更多的请求。webserver允许的最大连接数还受制于操作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。在Tomcat5对这些参数进行了调整，请看下表：属性名描述maxThreadsTomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。acceptCount指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。connnectionTimeout网络连接超时，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。minSpareThreadsTomcat初始化时创建的线程数。maxSpareThreads一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。最好的方式是多设置几次并且进行测试，观察cpu、内存、io、gc、响应时间等指标情况。在不同的机器、操作系统或虚拟机组合的情况下可能会不同，而且不是所有人的web站点的流量都是一样的，因此没有一刀切的方案来确定线程数的值。2.为了防止恶意攻击，禁止某些机器访问Tomcat提供了两个参数供你配置：RemoteHostValve和RemoteAddrValve全局设置，对Tomcat下所有应用生效server.xml中添加下面一行，重启服务器即可：<ValveclassName=""org.apache.catalina.valves.RemoteAddrValve""allow=""192.168.1.*""deny=""""/>此行放在</Host>之前。例子： /blog/static/10076891420129231118360/补充：Tomcat与Web服务器Tomcat是提供一个支持Servlet和JSP运行的容器。Servlet和JSP能根据实时需要，产生动态网页内容。而对于Web服务器来说，Apache仅仅支持静态网页，对于支持动态网页就会显得无能为力；Tomcat则既能为动态网页服务，同时也能为静态网页提供支持。尽管它没有通常的Web服务器快、功能也不如Web服务器丰富，但是Tomcat逐渐为支持静态内容不断扩充。大多数的Web服务器都是用底层语言编写如C，利用了相应平台的特征，因此用纯Java编写的Tomcat执行速度不可能与它们相提并论。一般来说，大的站点都是将Tomcat与Apache的结合，Apache负责接受所有来自客户端的HTTP请求，然后将Servlets和JSP的请求转发给Tomcat来处理。Tomcat完成处理后，将响应传回给Apache，最后Apache将响应返回给客户端。",2015/4/30
281,jvm调优,姚锡铭,http://180.168.156.212:2262/wecenter/?/article/9012,"jvm性能调优的目地：1）控制jvm的堆栈大小。比如当你的程序年轻代对象在某个时间段产生的比较多的时候，就需要控制年轻代的堆大小。同时还要控制总的JVM大小避免内存溢出2）控制GC的行为。GC是一个后台处理，但是它也是会消耗系统性能的，因此要根据运行程序的特点来更改GC行为。3）控制jvm线程的内存分配。如果是多线程程序，产生线程和线程运行所消耗的内存也是可以控制的。堆大小设置-Xms初始堆大小-Xmx最大堆大小（通常与-Xms设成一样值）-Xmn年轻代的大小-XX:MaxPermSize持久代的大小-Xss单个线程的大小-XX:NewRatio=n设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5-XX:MaxTenuringThreshold对象的年龄例子1java-Xmx4g-Xms4g-Xmn2g-Xss128k-Xmx4g：设置JVM最大可用内存为4G。-Xms4g：设置JVM初始内存4G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64m，所以增大年轻代，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，经验值在3000~5000左右。例子2java-Xmx4g-Xms4g-Xss128k-XX:NewRatio=4-XX:SurvivorRatio=4-XX:MaxPermSize=16m-XX:MaxTenuringThreshold=0-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6-XX:MaxPermSize=16m设置持久代大小为16m。-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代被回收的概率2.收集器设置-XX:+UseSerialGC串行收集器-XX:+UseParallelGC并行收集器-XX:+UseParalledlOldGC并行年老代收集器-XX:+UseConcMarkSweepGC并发收集器jvm提供了三种垃圾回收器（串行、并行、并发），串行收集器只适用于数据量小的情况下，在jdk5.0以前都是串行收集器，如果想使用其它的收集器需要相应参数配置例子3java-Xmx4g-Xms4g-Xmn2g-Xss128k-XX:+UseParallelGC-XX:ParallelGCThreads=20-XX:+UseParallelGC并行垃圾收集器，只生效于年轻代，年老代依然是串行收集-XX:ParallelGCThreads=20配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。例子4java-Xmx3550m-Xms3550m-Xmn2g-Xss128k-XX:+UseParallelGC-XX:ParallelGCThreads=20-XX:+UseParallelOldGC-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。例子5java-Xmx3550m-Xms3550m-Xmn2g-Xss128k-XX:+UseParallelGC-XX:MaxGCPauseMillis=100-XX:MaxGCPauseMillis=100设置每次年轻代垃圾回收的最长时间，如果不满足此时间，JVM会自动调整年轻代大小，以满足此值。例子6java-Xmx3550m-Xms3550m-Xmn2g-Xss128k-XX:+UseParallelGC-XX:MaxGCPauseMillis=100-XX:+UseAdaptiveSizePolicy-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。例子7java-Xmx3550m-Xms3550m-Xmn2g-Xss128k-XX:+UseConcMarkSweepGC-XX:CMSFullGCsBeforeCompaction=5-XX:+UseCMSCompactAtFullCollection-XX:CMSFullGCsBeforeCompaction由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC后对内存空间进行压缩、整理。-XX:+UseCMSCompactAtFullCollection打开对年老代的压缩。可能会影响性能，但是可以消除碎片垃圾回收信息打印a）-XX:+PrintGC输出形式：[GC118250K->113543K(130112K),0.0094143secs][FullGC121376K->10414K(130112K),0.0650971secs]b)-XX:+PrintGCDetails输出形式：[GC[DefNew:8614K->781K(9088K),0.0123035secs]118250K->113543K(130112K),0.0124633secs][GC[DefNew:8614K->8614K(9088K),0.0000665secs][Tenured:112761K->10414K(121024K),0.0433488secs]121376K->10414K(130112K),0.0436268secs]c)-XX:+PrintGCApplicationConcurrentTime:打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用输出形式：Applicationtime:0.5291524secondsd)-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用输出形式：Totaltimeforwhichapplicationthreadswerestopped:0.0468229secondse)-XX:PrintHeapAtGC打印GC前后的详细堆栈信息f)-Xloggc:filename与上面几个配合使用，把相关日志信息记录到文件以便分析。",2015/4/30
282,处理线程泄露,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9011,"当一个单线程化的控制台程序因为未捕获的异常终止的时候，程序停止运行，并生了栈追踪，这与典型的程序输出不同，当一个程序发生了异常说明有不稳定的因素存在。如果并发程序中线程失败就没那么容易发现了。栈追踪可能会从控制台输出，但是没有人会去一直在看控制台，并且，当线程失败的时候，应用程序可能看起来仍在工作。就象程序能跑在50个线程池上，也能够跑在49个线程的线程池上，区别在于50个人干的活要比49个人干的活要多的多。导致线程死亡的的最主要的原因是RuntimeException。因为这些异常表明一个程序错误或者不可修复的错误，它们不着顺着栈的调用传递，此时，默认的行为是在控制台打印栈追踪的信息，并终止线程。我们举个例子，将奴隶主比作是你写的程序，奴隶比作是线程。假如你是奴隶主，你手下有5名奴隶，你分派他们一项任务去将不断开采来的石头搬到某个地方。如果中途有奴隶逃跑，那么搬运石头的效率就会下降，如果你没有措施发现奴隶逃跑，最后连一个奴隶也没有了，没有人再去搬石头了。当你发现程序有问题，比如程序刚启动的时候处理速度很快，以后越跑越慢，最后完全停止了，你可能不知道问题出在哪儿，其实这都是因为线程泄露引起的。想解决奴隶逃跑问题，不难，给每个奴隶戴上个报警器，一逃跑报警器就给你发信息，告诉哪个奴隶，因为什么原因逃跑了，可以根据需要再增加一名奴隶，让搬石头的奴隶数量始终维持在5名或着将信息记录到文件，便于分析导致线程泄露的原意改进程序。ok,我们用代码说话１、定义好报警器Java代码packagecom.bill99.thread.test;importjava.lang.Thread.UncaughtExceptionHandler;//将泄露的线程信息输出到控制台publicclassUEHLoggerimplementsUncaughtExceptionHandler{publicvoiduncaughtException(Threadt,Throwablee){System.out.println(String.format(""不好了，有奴隶逃跑了!奴隶姓名：%1$s,编号：%2$s,逃跑原因：%3$s"",t.getName(),t.getId(),e.getMessage()));System.out.println(""还剩""+HelotPool.helotPool.getActiveCount()+""个奴隶"");}}２、我们先建立一个奴隶工厂，每名奴隶出工厂的时候都会有一个报警器Java代码packagecom.bill99.thread.test;importjava.util.concurrent.ThreadFactory;//奴隶制造工厂publicclassHelotFactoryimplementsThreadFactory{privatevolatileinthelotId=0;//奴隶编号//产生一个新奴隶publicThreadnewThread(Runnabler){ThreadhelotThread=newThread(r);helotThread.setName(""helot-Thread-""+gethelotId());//设置奴隶姓名helotThread.setUncaughtExceptionHandler(newUEHLogger());//UEHLogger就是报警器returnhelotThread;}privateintgethelotId(){return++helotId;}}３、奴隶逃跑测试,看看是否会触发报警器Java代码packagecom.bill99.thread.test;importjava.util.concurrent.ThreadFactory;//奴隶逃跑测试publicclassHelotEscapeTest{privateThreadFactoryfactory=newHelotFactory();privateThreadhelotThread=null;publicHelotEscapeTest(){Runnabletask=newRunnable(){intstoneNum=1;publicvoidrun(){while(!Thread.interrupted()){System.out.println(helotThread.getName()+""搬第""+stoneNum+""块石头.."");stoneNum++;try{Thread.sleep(500);}catch(InterruptedExceptione){e.printStackTrace();}if(stoneNum>100){thrownewRuntimeException(""又饿又累没力气搬石头了"");}}}};helotThread=factory.newThread(task);}//开始干活publicvoidstartWork(){helotThread.start();}publicstaticvoidmain(String[]args){HelotEscapeTesttest=newHelotEscapeTest();test.startWork();}}运行程序后，奴隶在搬完100块石头后不干了，报警器给出提示信息不好了，有奴隶逃跑了!奴隶姓名：helot-Thread-1,编号：7,逃跑原因：又饿又累没力气搬石头了这样我就能找出线程泄露的原因了。如果在线程池中发生了泄露是否也能记录？4、奴隶池测试Java代码packagecom.bill99.thread.test;importjava.util.Random;importjava.util.concurrent.BlockingQueue;importjava.util.concurrent.LinkedBlockingQueue;importjava.util.concurrent.ThreadFactory;importjava.util.concurrent.ThreadPoolExecutor;importjava.util.concurrent.TimeUnit;publicclassHelotPoolTest{publicstaticThreadPoolExecutorhelotPool;privateinthelotNum=5;//奴隶数privateRandomrandom=newRandom(100);privateBlockingQueue<Runnable>queue=newLinkedBlockingQueue<Runnable>();publicHelotPoolTest(){ThreadFactoryfactory=newHelotFactory();helotPool=newThreadPoolExecutor(helotNum,helotNum,1000,TimeUnit.SECONDS,queue,factory);}//分配任务publicvoidassignTask(){finalintMAX=100;finalintMIN=10;Runnabletask=null;for(intj=0;j<20;j++){task=newRunnable(){intstoneNum=random.nextInt(MAX-MIN+1)+MIN;//生成10~100范围的随机数publicvoidrun(){for(inti=1;i<=stoneNum;i++){System.out.println(Thread.currentThread().getName()+""搬完""+i+""块石头"");if(i==60){thrownewRuntimeException(""搬完第60块石头不干了"");}try{Thread.sleep(100);//休息下}catch(InterruptedExceptione){e.printStackTrace();}}}};queue.add(task);}}//开始干活publicvoidstartWork(){helotPool.prestartAllCoreThreads();}publicstaticvoidmain(String[]args){HelotPoolTestpool=newHelotPoolTest();pool.assignTask();pool.startWork();}}程序启动，用Jprofiler监控，刚启动时会有5名奴隶干活不一会就会有线程退出，最后5个线程全部退，报警器对每个线程退出都能记录到导致线程退出的原因。标准的Executor实现是:在需求不高时回收空闲的线程，在需求增加时添加新的线程，如果任务抛出了异常，就会用一个全新的工作线程取代出错的那个。JDK文档是这么说的，不过通过Jprofiler监控只有在5名奴隶全部逃跑，没人干活的时候ThreadPoolExecutor才会生成一个新线程继续搬石头，并不是只要一个线程退出就会马上生成新线程去代替。",2015/4/30
283,JAVA上加密算法的实现用例,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9010,"第1章基础知识1.1.单钥密码体制单钥密码体制是一种传统的加密算法，是指信息的发送方和接收方共同使用同一把密钥进行加解密。通常,使用的加密算法比较简便高效,密钥简短，加解密速度快，破译极其困难。但是加密的安全性依靠密钥保管的安全性,在公开的计算机网络上安全地传送和保管密钥是一个严峻的问题，并且如果在多用户的情况下密钥的保管安全性也是一个问题。单钥密码体制的代表是美国的DES1.2.消息摘要一个消息摘要就是一个数据块的数字指纹。即对一个任意长度的一个数据块进行计算，产生一个唯一指印（对于SHA1是产生一个20字节的二进制数组）。消息摘要有两个基本属性：两个不同的报文难以生成相同的摘要难以对指定的摘要生成一个报文，而由该报文反推算出该指定的摘要代表：美国国家标准技术研究所的SHA1和麻省理工学院RonaldRivest提出的MD51.3.Diffie-Hellman密钥一致协议密钥一致协议是由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想。先决条件,允许两名用户在公开媒体上交换信息以生成""一致""的,可以共享的密钥代表：指数密钥一致协议(ExponentialKeyAgreementProtocol)1.4.非对称算法与公钥体系1976年，Dittie和Hellman为解决密钥管理问题，在他们的奠基性的工作""密码学的新方向""一文中，提出一种密钥交换协议，允许在不安全的媒体上通过通讯双方交换信息，安全地传送秘密密钥。在此新思想的基础上，很快出现了非对称密钥密码体制，即公钥密码体制。在公钥体制中，加密密钥不同于解密密钥，加密密钥公之于众，谁都可以使用；解密密钥只有解密人自己知道。它们分别称为公开密钥（Publickey）和秘密密钥（Privatekey）。迄今为止的所有公钥密码体系中，RSA系统是最著名、最多使用的一种。RSA公开密钥密码系统是由R.Rivest、A.Shamir和L.Adleman俊教授于1977年提出的。RSA的取名就是来自于这三位发明者的姓的第一个字母1.5.数字签名所谓数字签名就是信息发送者用其私钥对从所传报文中提取出的特征数据（或称数字指纹）进行RSA算法操作，以保证发信人无法抵赖曾发过该信息（即不可抵赖性），同时也确保信息报文在经签名后末被篡改（即完整性）。当信息接收者收到报文后，就可以用发送者的公钥对数字签名进行验证。在数字签名中有重要作用的数字指纹是通过一类特殊的散列函数（HASH函数）生成的，对这些HASH函数的特殊要求是：接受的输入报文数据没有长度限制；对任何输入报文数据生成固定长度的摘要（数字指纹）输出从报文能方便地算出摘要；难以对指定的摘要生成一个报文，而由该报文反推算出该指定的摘要；两个不同的报文难以生成相同的摘要代表：DSA第2章在JAVA中的实现2.1.相关Diffie-Hellman密钥一致协议和DES程序需要JCE工具库的支持,可以到 下载JCE,并进行安装。简易安装把jce1.2.1lib下的所有内容复制到%java_home%libext下,如果没有ext目录自行建立,再把jce1_2_1.jar和sunjce_provider.jar添加到CLASSPATH内,更详细说明请看相应用户手册2.2.消息摘要MD5和SHA的使用使用方法:首先用生成一个MessageDigest类,确定计算方法java.security.MessageDigestalga=java.security.MessageDigest.getInstance(""SHA-1"");添加要进行计算摘要的信息alga.update(myinfo.getBytes());计算出摘要byte[]digesta=alga.digest();发送给其他人你的信息和摘要其他人用相同的方法初始化,添加信息,最后进行比较摘要是否相同algb.isEqual(digesta,algb.digest())相关AIPjava.security.MessageDigest类staticgetInstance(Stringalgorithm)返回一个MessageDigest对象,它实现指定的算法参数:算法名,如SHA-1或MD5voidupdate(byteinput)voidupdate(byte[]input)voidupdate(byte[]input,intoffset,intlen)添加要进行计算摘要的信息byte[]digest()完成计算,返回计算得到的摘要(对于MD5是16位,SHA是20位)voidreset()复位staticbooleanisEqual(byte[]digesta,byte[]digestb)比效两个摘要是否相同代码：importjava.security.*;publicclassmyDigest{publicstaticvoidmain(String[]args){myDigestmy=newmyDigest();my.testDigest();}publicvoidtestDigest(){try{Stringmyinfo=""我的测试信息"";//java.security.MessageDigestalg=java.security.MessageDigest.getInstance(""MD5"");java.security.MessageDigestalga=java.security.MessageDigest.getInstance(""SHA-1"");alga.update(myinfo.getBytes());byte[]digesta=alga.digest();System.out.println(""本信息摘要是:""+byte2hex(digesta));//通过某中方式传给其他人你的信息(myinfo)和摘要(digesta)对方可以判断是否更改或传输正常java.security.MessageDigestalgb=java.security.MessageDigest.getInstance(""SHA-1"");algb.update(myinfo.getBytes());if(algb.isEqual(digesta,algb.digest())){System.out.println(""信息检查正常"");}else{System.out.println(""摘要不相同"");}}catch(java.security.NoSuchAlgorithmExceptionex){System.out.println(""非法摘要算法"");}}publicStringbyte2hex(byte[]b)//二行制转字符串{Stringhs="""";Stringstmp="""";for(intn=0;n{stmp=(java.lang.Integer.toHexString(b[n]&0XFF));if(stmp.length()==1)hs=hs+""0""+stmp;elsehs=hs+stmp;if(n}returnhs.toUpperCase();}}2.3.数字签名DSA对于一个用户来讲首先要生成他的密钥对,并且分别保存生成一个KeyPairGenerator实例java.security.KeyPairGeneratorkeygen=java.security.KeyPairGenerator.getInstance(""DSA"");如果设定随机产生器就用如相代码初始化SecureRandomsecrand=newSecureRandom();secrand.setSeed(""tttt"".getBytes());//初始化随机产生器keygen.initialize(512,secrand);//初始化密钥生成器否则keygen.initialize(512);生成密钥公钥pubkey和私钥prikeyKeyPairkeys=keygen.generateKeyPair();//生成密钥组PublicKeypubkey=keys.getPublic();PrivateKeyprikey=keys.getPrivate();分别保存在myprikey.dat和mypubkey.dat中,以便下次不在生成(生成密钥对的时间比较长java.io.ObjectOutputStreamout=newjava.io.ObjectOutputStream(newjava.io.FileOutputStream(""myprikey.dat""));out.writeObject(prikey);out.close();out=newjava.io.ObjectOutputStream(newjava.io.FileOutputStream(""mypubkey.dat""));out.writeObject(pubkey);out.close();用他私人密钥(prikey)对他所确认的信息(info)进行数字签名产生一个签名数组从文件中读入私人密钥(prikey)java.io.ObjectInputStreamin=newjava.io.ObjectInputStream(newjava.io.FileInputStream(""myprikey.dat""));PrivateKeymyprikey=(PrivateKey)in.readObject();in.close();初始一个Signature对象,并用私钥对信息签名java.security.Signaturesignet=java.security.Signature.getInstance(""DSA"");signet.initSign(myprikey);signet.update(myinfo.getBytes());byte[]signed=signet.sign();把信息和签名保存在一个文件中(myinfo.dat)java.io.ObjectOutputStreamout=newjava.io.ObjectOutputStream(newjava.io.FileOutputStream(""myinfo.dat""));out.writeObject(myinfo);out.writeObject(signed);out.close();把他的公钥的信息及签名发给其它用户其他用户用他的公共密钥(pubkey)和签名(signed)和信息(info)进行验证是否由他签名的信息读入公钥java.io.ObjectInputStreamin=newjava.io.ObjectInputStream(newjava.io.FileInputStream(""mypubkey.dat""));PublicKeypubkey=(PublicKey)in.readObject();in.close();读入签名和信息in=newjava.io.ObjectInputStream(newjava.io.FileInputStream(""myinfo.dat""));Stringinfo=(String)in.readObject();byte[]signed=(byte[])in.readObject();in.close();初始一个Signature对象,并用公钥和签名进行验证java.security.Signaturesignetcheck=java.security.Signature.getInstance(""DSA"");signetcheck.initVerify(pubkey);signetcheck.update(info.getBytes());if(signetcheck.verify(signed)){System.out.println(""签名正常"");}对于密钥的保存本文是用对象流的方式保存和传送的,也可可以用编码的方式保存.注意要importjava.security.spec.*importjava.security.*具休说明如下publickey是用X.509编码的,例码如下:byte[]bobEncodedPubKey=mypublic.getEncoded();//生成编码//传送二进制编码//以下代码转换编码为相应key对象X509EncodedKeySpecbobPubKeySpec=newX509EncodedKeySpec(bobEncodedPubKey);KeyFactorykeyFactory=KeyFactory.getInstance(""DSA"");PublicKeybobPubKey=keyFactory.generatePublic(bobPubKeySpec);对于Privatekey是用PKCS#8编码,例码如下:byte[]bPKCS=myprikey.getEncoded();//传送二进制编码//以下代码转换编码为相应key对象PKCS8EncodedKeySpecpriPKCS8=newPKCS8EncodedKeySpec(bPKCS);KeyFactorykeyf=KeyFactory.getInstance(""DSA"");PrivateKeyotherprikey=keyf.generatePrivate(priPKCS8);常用APIjava.security.KeyPairGenerator密钥生成器类publicstaticKeyPairGeneratorgetInstance(Stringalgorithm)throwsNoSuchAlgorithmException以指定的算法返回一个KeyPairGenerator对象参数:algorithm算法名.如:""DSA"",""RSA""publicvoidinitialize(intkeysize)以指定的长度初始化KeyPairGenerator对象,如果没有初始化系统以1024长度默认设置参数:keysize算法位长.其范围必须在512到1024之间，且必须为64的倍数publicvoidinitialize(intkeysize,SecureRandomrandom)以指定的长度初始化和随机发生器初始化KeyPairGenerator对象参数:keysize算法位长.其范围必须在512到1024之间，且必须为64的倍数random一个随机位的来源(对于initialize(intkeysize)使用了默认随机器publicabstractKeyPairgenerateKeyPair()产生新密钥对java.security.KeyPair密钥对类publicPrivateKeygetPrivate()返回私钥publicPublicKeygetPublic()返回公钥java.security.Signature签名类publicstaticSignaturegetInstance(Stringalgorithm)throwsNoSuchAlgorithmException返回一个指定算法的Signature对象参数algorithm如:""DSA""publicfinalvoidinitSign(PrivateKeyprivateKey)throwsInvalidKeyException用指定的私钥初始化参数rivateKey所进行签名时用的私钥publicfinalvoidupdate(bytedata)throwsSignatureExceptionpublicfinalvoidupdate(byte[]data)throwsSignatureExceptionpublicfinalvoidupdate(byte[]data,intoff,intlen)throwsSignatureException添加要签名的信息publicfinalbyte[]sign()throwsSignatureException返回签名的数组,前提是initSign和updatepublicfinalvoidinitVerify(PublicKeypublicKey)throwsInvalidKeyException用指定的公钥初始化参数ublicKey验证时用的公钥publicfinalbooleanverify(byte[]signature)throwsSignatureException验证签名是否有效,前提是已经initVerify初始化参数:signature签名数组*/importjava.security.*;importjava.security.spec.*;publicclasstestdsa{publicstaticvoidmain(String[]args)throwsjava.security.NoSuchAlgorithmException,java.lang.Exception{testdsamy=newtestdsa();my.run();}publicvoidrun(){//数字签名生成密钥//第一步生成密钥对,如果已经生成过,本过程就可以跳过,对用户来讲myprikey.dat要保存在本地//而mypubkey.dat给发布给其它用户if((newjava.io.File(""myprikey.dat"")).exists()==false){if(generatekey()==false){System.out.println(""生成密钥对败"");return;};}//第二步,此用户//从文件中读入私钥,对一个字符串进行签名后保存在一个文件(myinfo.dat)中//并且再把myinfo.dat发送出去//为了方便数字签名也放进了myifno.dat文件中,当然也可分别发送try{java.io.ObjectInputStreamin=newjava.io.ObjectInputStream(newjava.io.FileInputStream(""myprikey.dat""));PrivateKeymyprikey=(PrivateKey)in.readObject();in.close();//java.security.spec.X509EncodedKeySpecpubX509=newjava.security.spec.X509EncodedKeySpec(bX509);//java.security.spec.X509EncodedKeySpecpubkeyEncode=java.security.spec.X509EncodedKeySpecStringmyinfo=""这是我的信息"";//要签名的信息//用私钥对信息生成数字签名java.security.Signaturesignet=java.security.Signature.getInstance(""DSA"");signet.initSign(myprikey);signet.update(myinfo.getBytes());byte[]signed=signet.sign();//对信息的数字签名System.out.println(""signed(签名内容)=""+byte2hex(signed));//把信息和数字签名保存在一个文件中java.io.ObjectOutputStreamout=newjava.io.ObjectOutputStream(newjava.io.FileOutputStream(""myinfo.dat""));out.writeObject(myinfo);out.writeObject(signed);out.close();System.out.println(""签名并生成文件成功"");}catch(java.lang.Exceptione){e.printStackTrace();System.out.println(""签名并生成文件失败"");};//第三步//其他人通过公共方式得到此户的公钥和文件//其他人用此户的公钥,对文件进行检查,如果成功说明是此用户发布的信息.//try{java.io.ObjectInputStreamin=newjava.io.ObjectInputStream(newjava.io.FileInputStream(""mypubkey.dat""));PublicKeypubkey=(PublicKey)in.readObject();in.close();System.out.println(pubkey.getFormat());in=newjava.io.ObjectInputStream(newjava.io.FileInputStream(""myinfo.dat""));Stringinfo=(String)in.readObject();byte[]signed=(byte[])in.readObject();in.close();java.security.Signaturesignetcheck=java.security.Signature.getInstance(""DSA"");signetcheck.initVerify(pubkey);signetcheck.update(info.getBytes());if(signetcheck.verify(signed)){System.out.println(""info=""+info);System.out.println(""签名正常"");}elseSystem.out.println(""非签名正常"");}catch(java.lang.Exceptione){e.printStackTrace();};}//生成一对文件myprikey.dat和mypubkey.dat---私钥和公钥,//公钥要用户发送(文件,网络等方法)给其它用户,私钥保存在本地publicbooleangeneratekey(){try{java.security.KeyPairGeneratorkeygen=java.security.KeyPairGenerator.getInstance(""DSA"");//SecureRandomsecrand=newSecureRandom();//secrand.setSeed(""tttt"".getBytes());//初始化随机产生器//keygen.initialize(576,secrand);//初始化密钥生成器keygen.initialize(512);KeyPairkeys=keygen.genKeyPair();//KeyPairkeys=keygen.generateKeyPair();//生成密钥组PublicKeypubkey=keys.getPublic();PrivateKeyprikey=keys.getPrivate();java.io.ObjectOutputStreamout=newjava.io.ObjectOutputStream(newjava.io.FileOutputStream(""myprikey.dat""));out.writeObject(prikey);out.close();System.out.println(""写入对象prikeysok"");out=newjava.io.ObjectOutputStream(newjava.io.FileOutputStream(""mypubkey.dat""));out.writeObject(pubkey);out.close();System.out.println(""写入对象pubkeysok"");System.out.println(""生成密钥对成功"");returntrue;}catch(java.lang.Exceptione){e.printStackTrace();System.out.println(""生成密钥对失败"");returnfalse;};}publicStringbyte2hex(byte[]b){Stringhs="""";Stringstmp="""";for(intn=0;n{stmp=(java.lang.Integer.toHexString(b[n]&0XFF));if(stmp.length()==1)hs=hs+""0""+stmp;elsehs=hs+stmp;if(n}returnhs.toUpperCase();}}2.4.DESede/DES对称算法首先生成密钥,并保存(这里并没的保存的代码,可参考DSA中的方法)KeyGeneratorkeygen=KeyGenerator.getInstance(Algorithm);SecretKeydeskey=keygen.generateKey();用密钥加密明文(myinfo),生成密文(cipherByte)Cipherc1=Cipher.getInstance(Algorithm);c1.init(Cipher.ENCRYPT_MODE,deskey);byte[]cipherByte=c1.doFinal(myinfo.getBytes());传送密文和密钥,本文没有相应代码可参考DSA.............用密钥解密密文c1=Cipher.getInstance(Algorithm);c1.init(Cipher.DECRYPT_MODE,deskey);byte[]clearByte=c1.doFinal(cipherByte);相对来说对称密钥的使用是很简单的,对于JCE来讲支技DES,DESede,Blowfish三种加密术对于密钥的保存各传送可使用对象流或者用二进制编码,相关参考代码如下SecretKeydeskey=keygen.generateKey();byte[]desEncode=deskey.getEncoded();javax.crypto.spec.SecretKeySpecdestmp=newjavax.crypto.spec.SecretKeySpec(desEncode,Algorithm);SecretKeymydeskey=destmp;相关APIKeyGenerator在DSA中已经说明,在添加JCE后在instance进可以如下参数DES,DESede,Blowfish,HmacMD5,HmacSHA1javax.crypto.Cipher加/解密器publicstaticfinalCiphergetInstance(java.lang.Stringtransformation)throwsjava.security.NoSuchAlgorithmException,NoSuchPaddingException返回一个指定方法的Cipher对象参数:transformation方法名(可用DES,DESede,Blowfish)publicfinalvoidinit(intopmode,java.security.Keykey)throwsjava.security.InvalidKeyException用指定的密钥和模式初始化Cipher对象参数pmode方式(ENCRYPT_MODE,DECRYPT_MODE,WRAP_MODE,UNWRAP_MODE)key密钥publicfinalbyte[]doFinal(byte[]input)throwsjava.lang.IllegalStateException,IllegalBlockSizeException,BadPaddingException对input内的串,进行编码处理,返回处理后二进制串,是返回解密文还是加解文由init时的opmode决定注意:本方法的执行前如果有update,是对updat和本次input全部处理,否则是本inout的内容/*安全程序DESede/DES测试*/importjava.security.*;importjavax.crypto.*;publicclasstestdes{publicstaticvoidmain(String[]args){testdesmy=newtestdes();my.run();}publicvoidrun(){//添加新安全算法,如果用JCE就要把它添加进去Security.addProvider(newcom.sun.crypto.provider.SunJCE());StringAlgorithm=""DES"";//定义加密算法,可用DES,DESede,BlowfishStringmyinfo=""要加密的信息"";try{//生成密钥KeyGeneratorkeygen=KeyGenerator.getInstance(Algorithm);SecretKeydeskey=keygen.generateKey();//加密System.out.println(""加密前的二进串:""+byte2hex(myinfo.getBytes()));System.out.println(""加密前的信息:""+myinfo);Cipherc1=Cipher.getInstance(Algorithm);c1.init(Cipher.ENCRYPT_MODE,deskey);byte[]cipherByte=c1.doFinal(myinfo.getBytes());System.out.println(""加密后的二进串:""+byte2hex(cipherByte));//解密c1=Cipher.getInstance(Algorithm);c1.init(Cipher.DECRYPT_MODE,deskey);byte[]clearByte=c1.doFinal(cipherByte);System.out.println(""解密后的二进串:""+byte2hex(clearByte));System.out.println(""解密后的信息:""+(newString(clearByte)));}catch(java.security.NoSuchAlgorithmExceptione1){e1.printStackTrace();}catch(javax.crypto.NoSuchPaddingExceptione2){e2.printStackTrace();}catch(java.lang.Exceptione3){e3.printStackTrace();}}publicStringbyte2hex(byte[]b)//二行制转字符串{Stringhs="""";Stringstmp="""";for(intn=0;n{stmp=(java.lang.Integer.toHexString(b[n]&0XFF));if(stmp.length()==1)hs=hs+""0""+stmp;elsehs=hs+stmp;if(n}returnhs.toUpperCase();}}2.5.Diffie-Hellman密钥一致协议公开密钥密码体制的奠基人Diffie和Hellman所提出的""指数密钥一致协议""(ExponentialKeyAgreementProtocol),该协议不要求别的安全性先决条件,允许两名用户在公开媒体上交换信息以生成""一致""的,可以共享的密钥。在JCE的中实现用户alice生成DH类型的密钥对,如果长度用1024生成的时间请,推荐第一次生成后保存DHParameterSpec,以便下次使用直接初始化.使其速度加快System.out.println(""ALICE:产生DH对..."");KeyPairGeneratoraliceKpairGen=KeyPairGenerator.getInstance(""DH"");aliceKpairGen.initialize(512);KeyPairaliceKpair=aliceKpairGen.generateKeyPair();alice生成公钥发送组bobbyte[]alicePubKeyEnc=aliceKpair.getPublic().getEncoded();bob从alice发送来的公钥中读出DH密钥对的初始参数生成bob的DH密钥对注意这一步一定要做,要保证每个用户用相同的初始参数生成的DHParameterSpecdhParamSpec=((DHPublicKey)alicePubKey).getParams();KeyPairGeneratorbobKpairGen=KeyPairGenerator.getInstance(""DH"");bobKpairGen.initialize(dhParamSpec);KeyPairbobKpair=bobKpairGen.generateKeyPair();bob根据alice的公钥生成本地的DES密钥KeyAgreementbobKeyAgree=KeyAgreement.getInstance(""DH"");bobKeyAgree.init(bobKpair.getPrivate());bobKeyAgree.doPhase(alicePubKey,true);SecretKeybobDesKey=bobKeyAgree.generateSecret(""DES"");bob已经生成了他的DES密钥,他现把他的公钥发给alice,byte[]bobPubKeyEnc=bobKpair.getPublic().getEncoded();alice根据bob的公钥生成本地的DES密钥,,,,,,解码KeyAgreementaliceKeyAgree=KeyAgreement.getInstance(""DH"");aliceKeyAgree.init(aliceKpair.getPrivate());aliceKeyAgree.doPhase(bobPubKey,true);SecretKeyaliceDesKey=aliceKeyAgree.generateSecret(""DES"");bob和alice能过这个过程就生成了相同的DES密钥,在这种基础就可进行安全能信常用APIjava.security.KeyPairGenerator密钥生成器类publicstaticKeyPairGeneratorgetInstance(Stringalgorithm)throwsNoSuchAlgorithmException以指定的算法返回一个KeyPairGenerator对象参数:algorithm算法名.如:原来是DSA,现在添加了DiffieHellman(DH)publicvoidinitialize(intkeysize)以指定的长度初始化KeyPairGenerator对象,如果没有初始化系统以1024长度默认设置参数:keysize算法位长.其范围必须在512到1024之间，且必须为64的倍数注意:如果用1024生长的时间很长,最好生成一次后就保存,下次就不用生成了publicvoidinitialize(AlgorithmParameterSpecparams)throwsInvalidAlgorithmParameterException以指定参数初始化javax.crypto.interfaces.DHPublicKeypublicDHParameterSpecgetParams()返回java.security.KeyFactorypublicstaticKeyFactorygetInstance(Stringalgorithm)throwsNoSuchAlgorithmException以指定的算法返回一个KeyFactory参数:algorithm算法名SH,DHpublicfinalPublicKeygeneratePublic(KeySpeckeySpec)throwsInvalidKeySpecException根据指定的key说明,返回一个PublicKey对象java.security.spec.X509EncodedKeySpecpublicX509EncodedKeySpec(byte[]encodedKey)根据指定的二进制编码的字串生成一个key的说明参数:encodedKey二进制编码的字串(一般能过PublicKey.getEncoded()生成)javax.crypto.KeyAgreement密码一至类publicstaticfinalKeyAgreementgetInstance(java.lang.Stringalgorithm)throwsjava.security.NoSuchAlgorithmException返回一个指定算法的KeyAgreement对象参数:algorithm算法名,现在只能是DiffieHellman(DH)publicfinalvoidinit(java.security.Keykey)throwsjava.security.InvalidKeyException用指定的私钥初始化参数:key一个私钥publicfinaljava.security.KeydoPhase(java.security.Keykey,booleanlastPhase)throwsjava.security.InvalidKeyException,java.lang.IllegalStateException用指定的公钥进行定位,lastPhase确定这是否是最后一个公钥,对于两个用户的情况下就可以多次定次,最后确定参数:key公钥lastPhase是否最后公钥publicfinalSecretKeygenerateSecret(java.lang.Stringalgorithm)throwsjava.lang.IllegalStateException,java.security.NoSuchAlgorithmException,java.security.InvalidKeyException根据指定的算法生成密钥参数:algorithm加密算法(可用DES,DESede,Blowfish)*/importjava.io.*;importjava.math.BigInteger;importjava.security.*;importjava.security.spec.*;importjava.security.interfaces.*;importjavax.crypto.*;importjavax.crypto.spec.*;importjavax.crypto.interfaces.*;importcom.sun.crypto.provider.SunJCE;publicclasstestDHKey{publicstaticvoidmain(Stringargv[]){try{testDHKeymy=newtestDHKey();my.run();}catch(Exceptione){System.err.println(e);}}privatevoidrun()throwsException{Security.addProvider(newcom.sun.crypto.provider.SunJCE());System.out.println(""ALICE:产生DH对..."");KeyPairGeneratoraliceKpairGen=KeyPairGenerator.getInstance(""DH"");aliceKpairGen.initialize(512);KeyPairaliceKpair=aliceKpairGen.generateKeyPair();//生成时间长//张三(Alice)生成公共密钥alicePubKeyEnc并发送给李四(Bob),//比如用文件方式,socket.....byte[]alicePubKeyEnc=aliceKpair.getPublic().getEncoded();//bob接收到alice的编码后的公钥,将其解码KeyFactorybobKeyFac=KeyFactory.getInstance(""DH"");X509EncodedKeySpecx509KeySpec=newX509EncodedKeySpec(alicePubKeyEnc);PublicKeyalicePubKey=bobKeyFac.generatePublic(x509KeySpec);System.out.println(""alice公钥bob解码成功"");//bob必须用相同的参数初始化的他的DHKEY对,所以要从Alice发给他的公开密钥,//中读出参数,再用这个参数初始化他的DHkey对//从alicePubKye中取alice初始化时用的参数DHParameterSpecdhParamSpec=((DHPublicKey)alicePubKey).getParams();KeyPairGeneratorbobKpairGen=KeyPairGenerator.getInstance(""DH"");bobKpairGen.initialize(dhParamSpec);KeyPairbobKpair=bobKpairGen.generateKeyPair();System.out.println(""BOB:生成DHkey对成功"");KeyAgreementbobKeyAgree=KeyAgreement.getInstance(""DH"");bobKeyAgree.init(bobKpair.getPrivate());System.out.println(""BOB:初始化本地key成功"");//李四(bob)生成本地的密钥bobDesKeybobKeyAgree.doPhase(alicePubKey,true);SecretKeybobDesKey=bobKeyAgree.generateSecret(""DES"");System.out.println(""BOB:用alice的公钥定位本地key,生成本地DES密钥成功"");//Bob生成公共密钥bobPubKeyEnc并发送给Alice,//比如用文件方式,socket.....,使其生成本地密钥byte[]bobPubKeyEnc=bobKpair.getPublic().getEncoded();System.out.println(""BOB向ALICE发送公钥"");//alice接收到bobPubKeyEnc后生成bobPubKey//再进行定位,使aliceKeyAgree定位在bobPubKeyKeyFactoryaliceKeyFac=KeyFactory.getInstance(""DH"");x509KeySpec=newX509EncodedKeySpec(bobPubKeyEnc);PublicKeybobPubKey=aliceKeyFac.generatePublic(x509KeySpec);System.out.println(""ALICE接收BOB公钥并解码成功"");;KeyAgreementaliceKeyAgree=KeyAgreement.getInstance(""DH"");aliceKeyAgree.init(aliceKpair.getPrivate());System.out.println(""ALICE:初始化本地key成功"");aliceKeyAgree.doPhase(bobPubKey,true);//张三(alice)生成本地的密钥aliceDesKeySecretKeyaliceDesKey=aliceKeyAgree.generateSecret(""DES"");System.out.println(""ALICE:用bob的公钥定位本地key,并生成本地DES密钥"");if(aliceDesKey.equals(bobDesKey))System.out.println(""张三和李四的密钥相同"");//现在张三和李四的本地的deskey是相同的所以,完全可以进行发送加密,接收后解密,达到//安全通道的的目的/**bob用bobDesKey密钥加密信息*/CipherbobCipher=Cipher.getInstance(""DES"");bobCipher.init(Cipher.ENCRYPT_MODE,bobDesKey);Stringbobinfo=""这是李四的机密信息"";System.out.println(""李四加密前原文:""+bobinfo);byte[]cleartext=bobinfo.getBytes();byte[]ciphertext=bobCipher.doFinal(cleartext);/**alice用aliceDesKey密钥解密*/CipheraliceCipher=Cipher.getInstance(""DES"");aliceCipher.init(Cipher.DECRYPT_MODE,aliceDesKey);byte[]recovered=aliceCipher.doFinal(ciphertext);System.out.println(""alice解密bob的信息:""+(newString(recovered)));if(!java.util.Arrays.equals(cleartext,recovered))thrownewException(""解密后与原文信息不同"");System.out.println(""解密后相同"");}}第3章小结在加密术中生成密钥对时，密钥对的当然是越长越好，但费时也越多，请从中从实际出发选取合适的长度，大部分例码中的密钥是每次运行就从新生成，在实际的情况中是生成后在一段时间保存在文件中，再次运行直接从文件中读入，从而加快速度。当然定时更新和加强密钥保管的安全性也是必须的。",2015/4/30
284,欣赏十层12阶完美超级幻方,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/9009,"n*m*r=1440即用自然数1到1440构造的12*12*10阶幻立阵D(i,j,k)如下：幻立阵的第1层为142713141824140337139448137961137072214401114292614163514055013925913812314171414284713933814047113696213801430121439114063614152513826013914914251514202214013913964613776313727041438914312814143314075213905713832114191614264513954014026913716413781432101437314083414132713845813895114231714222013994113984413756513746861436714333014123114095413885513851914211814244313974214006713736613761434814355141032141129138656138753幻立阵的第2层为135585134696133110913221201307133129814474136883135798134410713331221320131130995134586135611913211101332143129713413081358841367731334108134397131013213191211353871348941329111132411813051351300142761366811359100134210513351241318129131193134788135411713231121330141129913613061360821365751336106134199131213013171231351891350921327113132611613031371302140781364791361102134010313371261316127131391134990135211513251141328139130113813041362801363771338104133910113141281315125幻立阵的第3层为158128416712731821260191124920612362151225129514512861561271169126218012471931238204127416812831571250192125918112262161235205155128514612961791261170127220312371941248160128216512751841258189125120812342131227129314712881541269171126417812451951240202127616612811591252190125718312282141233207153128714812941771263172127020112391961246162128016312771861256187125321012322111229129114912901521267173126617612431971242200127816412791611254188125518512302121231209151128915012921751265174126819912411981244幻立阵的第4层为230121223912012541188263117727811642871153122321712142281199241119025211752651166276120224012112291178264118725311542881163277227121321812242511189242120027511652661176232121023712032561186261117928011622851155122121912162261197243119225011732671168274120423812092311180262118525511562861161279225121522012222491191244119827311672681174234120823512052581184259118128211602831157121922112182241195245119424811712691170272120623612072331182260118325711582841159281223121722212202471193246119627111692701172幻立阵的第5层为113930111303121115325110633610913491082360290115229911413141128323111733811043471093311112930211403351105326111635910813501092114230011512891118324112731310943481103337113730311323101113327110833410893511084358292115029711433161126321111934011023451095309113130411383331107328111435710833521090114429811492911120322112531510963461101339113530511343081111329111033210873531086356294114829511453181124319112134211003431097307113330611363311109330111235510853541088114629611472931122320112331710983441099341幻立阵的第6层为374106838310573981044407103342210204311009107936110703721055385104639610314091022420105838410673731034408104339710104321019421371106936210803951045386105641910214101032376106638110594001042405103542410184291011107736310723701053387104839410294111024418106038210653751036406104139910124301017423369107136410783931047388105441710234121030378106437910614021040403103742610164271013107536510743681051389105039210274131026416106238010633771038404103940110144281015425367107336610763911049390105241510254141028幻立阵的第7层为446996455985470972479961494948503937100743399844498345797446895948195049298645699544596248097146993850494749344399743410084679734589844919494829604489944539874729704779634969465019391005435100044298145997646695748395249098845499344796447896947194050294549544199943610064659754609824899514849584509924519894749684759654989444999411003437100244097946197846495548595448899045299144996647696747394250094349743910014381004463977462980487953486956幻立阵的第8层为518924527913542900551889566876575865935505926516911529902540887553878564914528923517890552899541866576875565515925506936539901530912563877554888520922525915544898549891568874573867933507928514909531904538885555880562916526921519892550897543868574873567513927508934537903532910561879556886522920523917546896547893570872571869931509930512907533906536883557882560918524919521894548895545870572871569511929510932535905534908559881558884幻立阵的第9层为851589842600827613818624803637794648578864587853602840611829626816635805599841590852623817614828647793638804854588863577830612839601806636815625849591844598825615820622801639796646580862585855604838609831628814633807597843592850621819616826645795640802856586861579832610837603808634813627847593846596823617822620799641798644582860583857606836607833630812631809595845594848619821618824643797642800858584859581834608835605810632811629幻立阵的第10层为707733698744683757674768659781650792722720731709746696755685770672779661743697734708767673758684791649782660710732719721686756695745662780671769705735700742681759676766657783652790724718729711748694753687772670777663741699736706765675760682789651784658712730717723688754693747664778669771703737702740679761678764655785654788726716727713750692751689774668775665739701738704763677762680787653786656714728715725690752691749666776667773此幻立阵，其行和为8646，列和为8646，竖和为720586468646864686468646…………8646864686468646864686468646…………86468646720572057205720572057205…………72057205这是一个标准的12*12*10阶幻立阵!通过数序检验，从1到1440无一遗漏！检验多层幻方的各个层面上的正、副对角线及正、副斜线：86468646864686468646…………8646864686468646864686468646…………86468646这是一个10层12阶完美幻方！斜线和应是8646幻立阵内取出1层4行4列子立体的子方幻和是11528计算次数：1440这个幻立阵内含有1层4行4列的流动均匀块，恭喜，它是一个超级幻立阵！有了维数拓展法，编写好相应的c++程序，由某一偶阶幻方拓展到四层、六层、八层、……、14层、16层、……，都不为难！不再一一展示，免得欣赏至视觉疲劳？与其予人以鱼，不如授人以渔，着重学好一种幻方制作方法；如同使用高科技的电脑并不需要高难的技能，让每一个平凡的寻常人都能时时由创作而得到知识的乐趣！",2015/4/30
285,空指针的救星,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/9008,"没人会喜欢空指针异常！有什么方法可以避免它们吗？或许吧。。本文将讨论到以下几种技术Optional类型（Java8中新引入的）Objects类（Java7中原有的）Java8中的Optional类它是什么？Java8中新引入的类型它是作为某个指定类型的对象的包装器或者用于那些不存在对象(null)的场景简单来说，它是处理空值的一个更好的替代品（警告：乍一看可能并没有那么明显）基本用法它是一种类型（一个类）——那么，怎么才能创建一个这个类型的实例?使用下它的三个静态方法就可以了123publicstaticOptional<String>stringOptional(Stringinput){returnOptional.of(input);}简单明了——创建一个包含这个值的Optional包装器。记住——如果这个值是null的话，它会抛出NPE!123456publicstaticOptional<String>stringNullableOptional(Stringinput){if(!newRandom().nextBoolean()){input=null;}returnOptional.ofNullable(input);}我个人认为是要更好一点。这样就不会有NPE的风险了——如果输入为null的话，会返回一个空的Optional。123publicstaticOptional<String>emptyOptional(){returnOptional.empty();}如果你真的就是希望返回一个”空”值的话。“空”值并不意味着null。好吧，那如何去消费/使用Optional呢？123456789publicstaticvoidconsumingOptional(){Optional<String>wrapped=Optional.of(""aString"");if(wrapped.isPresent()){System.out.println(""Gotstring-""+wrapped.get());}else{System.out.println(""Gotcha!"");}}简单的方法就是检查Optional包装器是否真的有值（使用isPresent方法）——你会怀疑这和使用if(myObj!=null)相比有什么好处。别担心，这个我会解释清楚的12345678publicstaticvoidconsumingNullableOptional(){Stringinput=null;if(newRandom().nextBoolean()){input=""iCanBeNull"";}Optional<String>wrapped=Optional.ofNullable(input);System.out.println(wrapped.orElse(""default""));}你可以使用orElse方法，这样万一封装的确实是一个null值的话可以用它来返回一个默认值——它的好处显而易见。在提取出真实值的时候可以避免调用ifPresent方法这样明显多余的方式了。12345678910111213publicstaticvoidconsumingEmptyOptional(){Stringinput=null;if(newRandom().nextBoolean()){input=""iCanBeNull"";}Optional<String>wrapped=Optional.ofNullable(input);System.out.println(wrapped.orElseGet(()->{return""defaultBySupplier"";}));}这个我就有点搞不清楚了。为什么有两个同样目的的不同方法？orElse和orElseGet明明可以重载的（同名但不同参数）。不论如何，这两个方法明显的区别就在于它们的参数——你可以选择使用lambda表达式而不是Supplier的实例来完成这个（一个函数式接口）为什么使用Optional要比常见的null检查强？使用Optional最大的好处就是可以更明白地表述你的意图——返回null值的话会让消费者感到疑惑（当真的出现NPE的时候）这是不是故意返回的，因此还得查看javadoc来进一步定位。而使用Optional就相当明了了。有了Optional你就可以彻底避免NPE了——如上所提，使用Optional.ofNullable，orElse以及orElseGet可以让我们远离NPE。另一个救星！看下这个代码片段12345678910111213141516packagecom.abhirockzz.wordpress.npesaviors;importjava.util.Map;importjava.util.Objects;publicclassUsingObjects{StringgetVal(Map<String,String>aMap,Stringkey){returnaMap.containsKey(key)?aMap.get(key):null;}publicstaticvoidmain(String[]args){UsingObjectsobj=newUsingObjects();obj.getVal(null,""dummy"");}}哪个可能会为空？Map对象进行搜索使用的key方法调用的这个实例如果抛出NPE的话，我们怎么能确定到底是哪个是null的？12345678910111213141516171819packagecom.abhirockzz.wordpress.npesaviors;importjava.util.Map;importjava.util.Objects;publicclassUsingObjects{StringgetValSafe(Map<String,String>aMap,Stringkey){Map<String,String>safeMap=Objects.requireNonNull(aMap,""Mapisnull"");StringsafeKey=Objects.requireNonNull(key,""Keyisnull"");returnsafeMap.containsKey(safeKey)?safeMap.get(safeKey):null;}publicstaticvoidmain(String[]args){UsingObjectsobj=newUsingObjects();obj.getValSafe(null,""dummy"");}}requireNonNull方法如果对象不为null的话就返回它本身如果值为null的话，返回的NPE会带有指定的消息为什么比if(myObj!=null)要好？你所看到的栈跟踪信息会很清楚地看见Objects.requireNonNull的方法调用。这个再配合你自己的错误日志，可以让你更快地定位问题。。。至少在我看来是更快。你还可以自己自义校验器，比如说实现一个简单的校验器来确保没有空值1234567891011121314151617181920212223242526272829303132333435363738394041424344importjava.util.Collections;importjava.util.List;importjava.util.Objects;importjava.util.function.Predicate;publicclassRandomGist{publicstatic<T>TrequireNonEmpty(Tobject,Predicate<T>predicate,StringmsgToCaller){Objects.requireNonNull(object);Objects.requireNonNull(predicate);if(predicate.test(object)){thrownewIllegalArgumentException(msgToCaller);}returnobject;}publicstaticvoidmain(String[]args){//Usage1:anemptystring(intentional)Strings="""";System.out.println(requireNonEmpty(Objects.requireNonNull(s),(s1)->s1.isEmpty(),""MyStringisEmpty!""));//Usage2:anemptyList(intentional)Listlist=Collections.emptyList();System.out.println(requireNonEmpty(Objects.requireNonNull(list),(l)->l.isEmpty(),""ListisEmpty!"").size());//Usage3:anemptyUser(intentional)Useruser=newUser("""");System.out.println(requireNonEmpty(Objects.requireNonNull(user),(u)->u.getName().isEmpty(),""UserisEmpty!""));}privatestaticclassUser{privateStringname;publicUser(Stringname){this.name=name;}publicStringgetName(){returnname;}}}不要让NPE在错误的地方成为痛苦。我们有许多工具能更好地处理NPE，甚至彻底地根除它们！",2015/4/30
286,GDI+图片的颜色转换矩阵,孙传金,http://180.168.156.212:2262/wecenter/?/article/9007,"IGPMatrix矩阵是个接口,要通过TGPMatrix实例化后使用,其内置了很多方法和属性.TGPColorMatrix只是一个结构体,除了矩阵数据(5*5)外,它只有一个方法:TGPColorMatrix.SetToIdentity.通过SetToIdentity方法可初始化矩阵,初始化后的数据是:┏┓┃10000┃┃01000┃┃00100┃┃00010┃┃00001┃┗┛对角线上的1是比例;应用这个数据后,目标不会有任何变化.其中的第5行和第5列用于辅助运算,我们主要操作4*4的范围;为便于理解可以这样表示:┏┓┃rrgrbrar┃┃rgggbgag┃┃rbgbbbab┃┃ragabaaa┃┗┛rr、gg、bb、aa分别表示红、绿、蓝和透明度的比例;譬如aa=0.5表示半透明.第四行的ra、ga、ba分别是颜色的增减量;譬如ra=0.1表示红色增加10%.第一列的rr、rg、rb分别表示:红色应用其他颜色的比例;譬如rg=0.5,那么红色的值将是绿色成分的50%.第二列的gr、gg、gb分别表示:绿应用其他颜色的比例.第三列的br、bg、bb分别表示:蓝色应用其他颜色的比例.还有一个颜色旋转的概念://红色与绿色绕蓝色旋转(其中的f是弧度,弧度=角度*Pi/180):┏┓┃Cos(f)Sin(f)brar┃┃-Sin(f)Cos(f)bgag┃┃rbgbbbab┃┃ragabaaa┃┗┛//绿色与蓝色绕红色旋转:┏┓┃rrgrbrar┃┃rgCos(f)Sin(f)ag┃┃rb-Sin(f)Cos(f)ab┃┃ragabaaa┃┗┛//红色与蓝色绕绿色旋转:┏┓┃Cos(f)grSin(f)ar┃┃-Sin(f)ggCos(f)ag┃┃rbgbbbab┃┃ragabaaa┃┗┛这个东西可千变万化,一时很难彻底理解,譬如前人算出的灰度算法:┏┓┃0.2990.2990.2990┃┃0.5180.5180.5180┃┃0.1140.1140.1140┃┃0001┃┗┛颜色矩阵是通过ImageAttributes使用的,下面是一些简单的例子.比例设置:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{红色比例}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{绿色比例}ColorMatrix.SetToIdentity;ColorMatrix.M[1,1]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{蓝色比例}ColorMatrix.SetToIdentity;ColorMatrix.M[2,2]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{透明度比例}ColorMatrix.SetToIdentity;ColorMatrix.M[3,3]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;增减量:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{红色增减}ColorMatrix.SetToIdentity;ColorMatrix.M[4,0]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{绿色增减}ColorMatrix.SetToIdentity;ColorMatrix.M[4,1]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{蓝色增减}ColorMatrix.SetToIdentity;ColorMatrix.M[4,2]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{透明度增减}ColorMatrix.SetToIdentity;ColorMatrix.M[4,3]:=-0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;红色使用其他颜色的比例:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{红色应用红色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{红色应用绿色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[0,1]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{红色应用蓝色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[0,2]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;绿色使用其他颜色的比例:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{绿色应用红色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[1,0]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{绿色应用绿色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[1,1]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{绿色应用蓝色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[1,2]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;蓝色使用其他颜色的比例:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{蓝色应用红色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[2,0]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{蓝色应用绿色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[2,1]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{蓝色应用蓝色的比例}ColorMatrix.SetToIdentity;ColorMatrix.M[2,2]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;查看独立的颜色通道:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{只查看红色通道}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=1;ColorMatrix.M[1,1]:=0;ColorMatrix.M[2,2]:=0;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{只查看绿色通道}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=0;ColorMatrix.M[1,1]:=1;ColorMatrix.M[2,2]:=0;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{只查看蓝色通道}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=0;ColorMatrix.M[1,1]:=0;ColorMatrix.M[2,2]:=1;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{半透明查看红色通道}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=1;ColorMatrix.M[1,1]:=0;ColorMatrix.M[2,2]:=0;ColorMatrix.M[3,3]:=0.5;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;转灰度:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{灰度}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=0.299;ColorMatrix.M[0,1]:=0.299;ColorMatrix.M[0,2]:=0.299;ColorMatrix.M[1,0]:=0.518;ColorMatrix.M[1,1]:=0.518;ColorMatrix.M[1,2]:=0.518;ColorMatrix.M[2,0]:=0.114;ColorMatrix.M[2,1]:=0.114;ColorMatrix.M[2,2]:=0.114;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;加亮、变暗:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{加亮}ColorMatrix.SetToIdentity;ColorMatrix.M[3,0]:=0.2;ColorMatrix.M[3,1]:=0.2;ColorMatrix.M[3,2]:=0.2;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{变暗}ColorMatrix.SetToIdentity;ColorMatrix.M[3,0]:=-0.2;ColorMatrix.M[3,1]:=-0.2;ColorMatrix.M[3,2]:=-0.2;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;颜色旋转:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;f:Single;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(4,4,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;f:=30*Pi/180;{准备旋转30度角}{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{红色与绿色绕蓝色旋转}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=Cos(f);ColorMatrix.M[0,1]:=Sin(f);ColorMatrix.M[1,0]:=-Sin(f);ColorMatrix.M[1,1]:=Cos(f);Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{绿色与蓝色绕红色旋转}ColorMatrix.SetToIdentity;ColorMatrix.M[1,1]:=Cos(f);ColorMatrix.M[1,2]:=Sin(f);ColorMatrix.M[2,1]:=-Sin(f);ColorMatrix.M[2,2]:=Cos(f);Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);{红色与蓝色绕绿色旋转}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=Cos(f);ColorMatrix.M[0,2]:=Sin(f);ColorMatrix.M[1,0]:=-Sin(f);ColorMatrix.M[1,2]:=Cos(f);Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;对比度:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\Grapes.jpg');Rect.Initialize(10,10,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{对比度}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=1.1;ColorMatrix.M[1,1]:=1.1;ColorMatrix.M[2,2]:=1.1;ColorMatrix.M[3,0]:=0.001;ColorMatrix.M[3,1]:=0.001;ColorMatrix.M[3,2]:=0.001;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;反色:usesGdiPlus;procedureTForm1.FormPaint(Sender:TObject);varGraphics:IGPGraphics;Img:IGPImage;Attr:IGPImageAttributes;ColorMatrix:TGPColorMatrix;Rect:TGPRectF;Brush:IGPHatchBrush;beginGraphics:=TGPGraphics.Create(Handle);Brush:=TGPHatchBrush.Create(HatchStyleDiagonalCross,$FFD0D0D0,$FFFFFFFF);Graphics.FillRectangle(Brush,TGPRect.Create(ClientRect));Img:=TGPImage.Create('C:\GdiPlusImg\ImageFileSmall.jpg');Rect.Initialize(10,10,Img.Width*0.75,Img.Height*0.75);Attr:=TGPImageAttributes.Create;{原始图片}Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,nil);{反色(或叫负片、底片)效果}ColorMatrix.SetToIdentity;ColorMatrix.M[0,0]:=-1;ColorMatrix.M[1,1]:=-1;ColorMatrix.M[2,2]:=-1;ColorMatrix.M[3,0]:=0.999;ColorMatrix.M[3,1]:=0.999;ColorMatrix.M[3,2]:=0.999;Attr.SetColorMatrix(ColorMatrix);Graphics.TranslateTransform(Rect.Width+Rect.X,0);Graphics.DrawImage(Img,Rect,0,0,Img.Width,Img.Height,UnitPixel,Attr);end;",2015/4/30
287,GDI+拆分GIF动画,孙传金,http://180.168.156.212:2262/wecenter/?/article/9006,"在实际的应用中，我们会看到很多的gif动画非常的好，如果我们想用其中的图片时，如何通过代码的方式进行提取，那么下面我将给大家展示如何使用GDI+将gif拆分为图片，具体实现代码如下：unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls;typeTForm1=class(TForm)Button1:TButton;ListBox1:TListBox;OpenDialog1:TOpenDialog;procedureFormCreate(Sender:TObject);procedureFormDestroy(Sender:TObject);procedureButton1Click(Sender:TObject);procedureFormPaint(Sender:TObject);procedureListBox1Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}usesGDIPOBJ,GDIPAPI;varimg:TGPImage;GifFrame,GifFrameCount:Word;procedureTForm1.FormCreate(Sender:TObject);beginOpenDialog1.Filter:='GIF文件|*.gif';img:=TGPImage.Create;end;procedureTForm1.FormDestroy(Sender:TObject);beginimg.Free;end;procedureTForm1.Button1Click(Sender:TObject);varDimensionsCount:Integer;DimensionsIDs:PGUID;i:Integer;typeArrDimensions=arrayofTGUID;beginifnotOpenDialog1.ExecutethenExit;img.Free;img:=TGPImage.Create(OpenDialog1.FileName);{获取Gif总帧数}DimensionsCount:=img.GetFrameDimensionsCount;GetMem(DimensionsIDs,DimensionsCount*SizeOf(TGUID));img.GetFrameDimensionsList(DimensionsIDs,DimensionsCount);GifFrameCount:=img.GetFrameCount(ArrDimensions(DimensionsIDs)[0]);FreeMem(DimensionsIDs);Text:=Format('共有%d帧',[GifFrameCount]);{显示帧列表}ListBox1.Clear;fori:=1toGifFrameCountdoListBox1.Items.Add(Format('第%d帧',[i]));Repaint;end;procedureTForm1.FormPaint(Sender:TObject);varg:TGPGraphics;beging:=TGPGraphics.Create(Canvas.Handle);g.DrawImage(img,ListBox1.Width+10,10,img.GetWidth,img.GetHeight);g.Free;end;procedureTForm1.ListBox1Click(Sender:TObject);beginGifFrame:=ListBox1.ItemIndex;img.SelectActiveFrame(FrameDimensionTime,GifFrame);Repaint;end;end.窗体文件:objectForm1:TForm1Left=0Top=0Caption='Form1'ClientHeight=206ClientWidth=339Color=clBtnFaceFont.Charset=DEFAULT_CHARSETFont.Color=clWindowTextFont.Height=-11Font.Name='Tahoma'Font.Style=[]OldCreateOrder=FalseOnCreate=FormCreateOnDestroy=FormDestroyOnPaint=FormPaintPixelsPerInch=96TextHeight=13objectListBox1:TListBoxLeft=0Top=0Width=89Height=206Align=alLeftItemHeight=13TabOrder=0OnClick=ListBox1ClickendobjectButton1:TButtonLeft=256Top=173Width=75Height=25Caption='Button1'TabOrder=1OnClick=Button1ClickendobjectOpenDialog1:TOpenDialogLeft=160Top=104endend",2015/4/30
288,GDI+将图像转化为其他格式,孙传金,http://180.168.156.212:2262/wecenter/?/article/9005,"我们在实际的格式转换工具中，会用到如何将一种格式转换为其他格式，那么我们常用的格式有:BMP,JPG,PNG,GIF,TIF，使用GDI+将是非常容易的，那么如何实现呢，代码如下：unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls,ExtCtrls;typeTForm1=class(TForm)OpenDialog1:TOpenDialog;Button1:TButton;Button2:TButton;procedureFormCreate(Sender:TObject);procedureFormDestroy(Sender:TObject);procedureFormPaint(Sender:TObject);procedureButton1Click(Sender:TObject);procedureButton2Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}usesGDIPOBJ,GDIPAPI,GDIPUTIL;constOpenFileFilter='GDI+全部可以读取的图片格式|*.png;*.jpg;*.gif;*.bmp;*.tif;*.emf;*.wmf;*.ico'+'|*.png|*.png'+'|*.jpg|*.jpg'+'|*.gif|*.gif'+'|*.bmp|*.bmp'+'|*.tif|*.tif'+'|*.emf|*.emf'+'|*.wmf|*.wmf'+'|*.ico|*.ico';ArrExt:array[0..4]ofString=('.png','.jpg','.gif','.bmp','.tif');ArrEncodeName:array[0..4]ofString=('image/png','image/jpeg','image/gif','image/bmp','image/tiff');varFileName:string;img:TGPImage;procedureTForm1.FormCreate(Sender:TObject);beginimg:=TGPImage.Create;Button1.Caption:='打开';Button2.Caption:='保存';end;procedureTForm1.FormDestroy(Sender:TObject);beginimg.Free;end;procedureTForm1.FormPaint(Sender:TObject);varg:TGPGraphics;beginifFileName<>''thenbeging:=TGPGraphics.Create(Canvas.Handle);g.DrawImage(img,10,10,img.GetWidth,img.GetHeight);g.Free;end;end;procedureTForm1.Button1Click(Sender:TObject);beginOpenDialog1.Filter:=OpenFileFilter;ifOpenDialog1.ExecutethenbeginFileName:=OpenDialog1.FileName;img.Free;img:=TGPImage.Create(FileName);Repaint;end;end;procedureTForm1.Button2Click(Sender:TObject);varImgGUID:TGUID;i:Integer;beginifFileName=''thenbeginShowMessage('先要打开文件');Exit;end;{一次性保存为5种可能的格式}fori:=0to4dobeginGetEncoderClsid(ArrEncodeName[i],ImgGUID);{先获取格式编码}img.Save(ChangeFileExt(FileName,ArrExt[i]),ImgGUID);end;Beep;end;end.窗体文件:objectForm1:TForm1Left=0Top=0Caption='Form1'ClientHeight=207ClientWidth=299Color=clBtnFaceFont.Charset=DEFAULT_CHARSETFont.Color=clWindowTextFont.Height=-11Font.Name='Tahoma'Font.Style=[]OldCreateOrder=FalsePosition=poDesktopCenterOnCreate=FormCreateOnDestroy=FormDestroyOnPaint=FormPaintPixelsPerInch=96TextHeight=13objectButton1:TButtonLeft=135Top=174Width=75Height=25Caption='Button1'TabOrder=0OnClick=Button1ClickendobjectButton2:TButtonLeft=216Top=174Width=75Height=25Caption='Button2'TabOrder=1OnClick=Button2ClickendobjectOpenDialog1:TOpenDialogLeft=152Top=104endend",2015/4/30
289,GDI+坐标系转换-文字水印转换,孙传金,http://180.168.156.212:2262/wecenter/?/article/9004,"在前面的章节中介绍了如何将一般文字转换为水印文件，那么现在介绍如果将文字或者图像旋转具体代码如下：代码文件:unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs;typeTForm1=class(TForm)procedureFormPaint(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}usesGDIPOBJ,GDIPAPI;procedureTForm1.FormPaint(Sender:TObject);varg:TGPGraphics;p:TGPPen;rect:TGPRect;pt:TGPPointF;Matrix:TGPMatrix;beging:=TGPGraphics.Create(Canvas.Handle);p:=TGPPen.Create(MakeColor(255,255,0,0),0);rect:=MakeRect(30,30,100,100);{譬如准备在上面矩形的中心点旋转}pt:=MakePoint(rect.X+rect.Width/2,rect.Y+rect.Height/2);Matrix:=TGPMatrix.Create;Matrix.RotateAt(45,pt);{以指定的pt为中心,转45°角}{先画个不旋转的}g.DrawRectangle(p,rect);{再画个旋转的}p.SetColor(aclBlue);g.SetTransform(Matrix);{关键代码}g.DrawRectangle(p,rect);g.ResetTransform;{关键代码,不恢复后面就都旋转了}Matrix.Free;p.Free;g.Free;end;end.实际效果：本例效果图:",2015/4/30
290,GDI+绘制一般文本,孙传金,http://180.168.156.212:2262/wecenter/?/article/9003,"在windows平台中，实现文字水印时，我们通常需要根据文字生成水印文件，一般，我们会将文本文字转换为图片，在将图片作为水印图片绘制到相应的pdf中，那么下面通过代码的方式实现如何将文字转换为图片：实例一：简单文字绘制unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls;typeTForm1=class(TForm)Button1:TButton;Button2:TButton;procedureButton1Click(Sender:TObject);procedureButton2Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}usesGDIPOBJ,GDIPAPI;procedureTForm1.Button1Click(Sender:TObject);varg:TGPGraphics;sb:TGPSolidBrush;font:TGPFont;beging:=TGPGraphics.Create(Canvas.Handle);sb:=TGPSolidBrush.Create(aclBlack);{指定字体名和字号即可建立TGPFont类}font:=TGPFont.Create('宋体',9);g.DrawString('春眠不觉晓，处处闻啼鸟，夜来风雨声，花落知多少',-1,font,MakePoint(10.0,20),sb);{参数2为-1表示输出所有指定字符;参数4必须为TGPPointF结构}font.Free;sb.Free;g.Free;end;实例二：在矩形区域中实现文字绘制，通过设置文字的对齐方式，实现在矩形区域中绘制文字unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls,ComCtrls,ExtCtrls;typeTForm1=class(TForm)RadioGroup1:TRadioGroup;RadioGroup2:TRadioGroup;RadioGroup3:TRadioGroup;PaintBox1:TPaintBox;procedureFormCreate(Sender:TObject);procedureRadioGroup1Click(Sender:TObject);procedureRadioGroup2Click(Sender:TObject);procedurePaintBox1Paint(Sender:TObject);procedureRadioGroup3Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}usesGDIPOBJ,GDIPAPI,TypInfo;varsfFlag:Integer;procedureTForm1.FormCreate(Sender:TObject);vari:Integer;beginfori:=0to2doRadioGroup1.Items.Add(GetEnumName(TypeInfo(TStringAlignment),i));RadioGroup1.ItemIndex:=0;RadioGroup2.Items:=RadioGroup1.Items;RadioGroup2.ItemIndex:=0;RadioGroup3.Items.CommaText:='StringFormatFlagsDirectionRightToLeft,'+'StringFormatFlagsDirectionVertical,'+'StringFormatFlagsNoFitBlackBox,'+'StringFormatFlagsDisplayFormatControl,'+'StringFormatFlagsNoFontFallback,'+'StringFormatFlagsMeasureTrailingSpaces,'+'StringFormatFlagsNoWrap,'+'StringFormatFlagsLineLimit,'+'StringFormatFlagsNoClip';end;procedureTForm1.PaintBox1Paint(Sender:TObject);varg:TGPGraphics;b:TGPBrush;font:TGPFont;sf:TGPStringFormat;rect:TGPRectF;beging:=TGPGraphics.Create(PaintBox1.Canvas.Handle);b:=TGPSolidBrush.Create($FF000000);g.SetTextRenderingHint(TextRenderingHintAntiAlias);font:=TGPFont.Create('ArialBlack',22);sf:=TGPStringFormat.Create;sf.SetFormatFlags(StringFormatFlagsNoClip);sf.SetAlignment(TStringAlignment(RadioGroup1.ItemIndex));sf.SetLineAlignment(TStringAlignment(RadioGroup2.ItemIndex));sf.SetFormatFlags(sfFlag);rect.X:=0;rect.Y:=0;rect.Width:=PaintBox1.ClientWidth;rect.Height:=PaintBox1.ClientHeight;g.DrawString('Delphi',-1,font,rect,sf,b);sf.Free;font.Free;b.Free;g.Free;end;procedureTForm1.RadioGroup1Click(Sender:TObject);beginPaintBox1.Repaint;end;procedureTForm1.RadioGroup2Click(Sender:TObject);beginPaintBox1.Repaint;end;procedureTForm1.RadioGroup3Click(Sender:TObject);begincaseRadioGroup3.ItemIndexof0:sfFlag:=StringFormatFlagsDirectionRightToLeft;1:sfFlag:=StringFormatFlagsDirectionVertical;2:sfFlag:=StringFormatFlagsNoFitBlackBox;3:sfFlag:=StringFormatFlagsDisplayFormatControl;4:sfFlag:=StringFormatFlagsNoFontFallback;5:sfFlag:=StringFormatFlagsMeasureTrailingSpaces;6:sfFlag:=StringFormatFlagsNoWrap;7:sfFlag:=StringFormatFlagsLineLimit;8:sfFlag:=StringFormatFlagsNoClip;end;PaintBox1.Repaint;end;end.",2015/4/30
291,GDI+获取绘图板对象,孙传金,http://180.168.156.212:2262/wecenter/?/article/9001,"GDI+画图板叫Graphics,VCL中称之为Canvas,在Gdi+中有四种获取方法:1、通过窗口句柄获取;2、通过窗口的Canvas.Handle获取;3、通过GdiPlus利用Helper技术给部分VCL对象添加的ToGPGraphics方法获取;4、通过图像对象获取.本例效果图:具体实现代码如下：unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls;typeTForm1=class(TForm)Button1:TButton;Button2:TButton;Button3:TButton;Button4:TButton;procedureButton1Click(Sender:TObject);procedureButton2Click(Sender:TObject);procedureButton3Click(Sender:TObject);procedureButton4Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}usesGdiPlus,GdiPlusHelpers;//从窗口句柄获取IGPGraphicsprocedureTForm1.Button1Click(Sender:TObject);varGraphics:IGPGraphics;Pen:IGPPen;beginGraphics:=TGPGraphics.Create(Handle);Pen:=TGPPen.Create(TGPColor.Red,2);Graphics.DrawEllipse(Pen,20,10,150,40);end;//从HDC获取IGPGraphicsprocedureTForm1.Button2Click(Sender:TObject);varGraphics:IGPGraphics;Pen:IGPPen;beginGraphics:=TGPGraphics.Create(Canvas.Handle);Pen:=TGPPen.Create(TGPColor.Green,2);Graphics.DrawEllipse(Pen,20,40,150,40);end;//使用GdiPlusHelpers为Canvas添加的ToGPGraphics方法获取IGPGraphicsprocedureTForm1.Button3Click(Sender:TObject);varGraphics:IGPGraphics;Pen:IGPPen;beginGraphics:=Canvas.ToGPGraphics;Pen:=TGPPen.Create(TGPColor.Blue,2);Graphics.DrawEllipse(Pen,20,70,150,40);end;//从图像建立IGPGraphicsprocedureTForm1.Button4Click(Sender:TObject);varGraphicsImg:IGPGraphics;Pen:IGPPen;Image:IGPImage;beginImage:=TGPBitmap.Create(152,42);GraphicsImg:=TGPGraphics.Create(Image);Pen:=TGPPen.Create(TGPColor.Fuchsia,2);GraphicsImg.DrawEllipse(Pen,0,0,Image.Width-2,Image.Height-2);Canvas.ToGPGraphics.DrawImage(Image,20,100);end;",2015/4/30
292,通过提前获取DNS来提升网页加载速度,孙荟博,http://180.168.156.212:2262/wecenter/?/article/9000,"DNS查找时间都很高，如果能减少该时间并提速，便会让资源加载变得更加高效。幸运的是，有个很棒的技巧能让网站的加载时间变得更快。它被称为DNS预取，并且很容易实现。需做的是，在网页顶部添加以下属性作为链接(link)。<linkrel=""dns-prefetch""href=""//host_name_to_prefetch.com"">DNS预取是在用户尝试点击链接前试图解析域名。一旦域名被解析，且用户导航到该域名，则不会因DNS查找而导致加载时间变长。如果能在用户导航到下一个页面前，预取一些外部链接的DNS，这将会大大减少下一个页面的DNS查找时间。如果用户能将域名解析成IP地址并且缓存之，则DNS查找时间能低至0-1毫秒（千分之一秒）。这是相当令人印象深刻的！在网站添加DNS预取功能后，确实能显著改善页面加载时间。目前，这项技术被大多数主流浏览器所支持(除了IE)，所以，当前没有任何理由不在web应用上使用这项技术！DNS预取是一个安全的HTML5特性，它会被那些不支持该技术的老旧浏览器简单忽略掉。如果你的网页内容是来自多个域名，那么这绝对是一个聪明的，能加快页面加载速度的方法。",2015/4/29
293,Javaweb的报表制作工具JasperReports,孙荟博,http://180.168.156.212:2262/wecenter/?/article/8999,JasperReport.docx,2015/4/29
294,EHCache多实例缓存及检测工具启动优化,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8998,EHCache多实例缓存及检测工具启动优化2015年3月经验共享-黄翔宇.docx,2015/4/29
295,CSS @supports （CSS3条件判断）,李海波,http://180.168.156.212:2262/wecenter/?/article/8997,用JavaScript在客户端检测浏览器是否支持某项功能特征，目前虽然这是最可行的方法，但不好的是，对于同一个特征的检测，我们需要反复多次用相同的函数附带各种浏览器前缀。而且因为CSS没有相应的功能，使用JavaScript会导致页面闪现，多余辅助代码等问题。火狐浏览器，谷歌浏览器和Opera浏览器最近刚刚添加了一项新的功能——在CSS里支持@supports标记、在JavaScript里支持CSS.supports函数，用来检测浏览器是否支持某个期望的样式功能。下面让我们来看看是如何使用的！Link: /archives/5250,2015/4/29
296,现在起，可以在 Windows 和 OS X 电脑安装运行 Android 应用了,李海波,http://180.168.156.212:2262/wecenter/?/article/9002,作为一个急性子，昨天刚允许所有开发者把Android应用迁移到Chrome上的Google，今天就上架了提供相关运行支持的Chrome插件。无论是应用移植还是运行，依靠的都是Google在I/O2014上发布的AppRuntimeforChrome。而这次跨平台还要得益于NaCL技术，NaCL是NativeChromeClient的简称，是为Chrome应用提供本地化运行能力的框架。开发者可以通过NaCL在系统上充分利用CPU和GPU资源，获得接近于原生应用的性能。此前Slack的Windows版客户端就使用NaCL。详见： /archives/688,2015/4/28
297,关于Function.prototype.bind,李海波,http://180.168.156.212:2262/wecenter/?/article/8996,"bind()方法会创建一个新函数,称为绑定函数。当调用这个绑定函数时,绑定函数会以创建它时传入bind()方法的第一个参数作为this,传入bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。详见Link： /archives/5611",2015/4/28
298,Struts 2 REST插件教程,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8995,"REST简介REST是英文RepresentationalStateTransfer的缩写，这个术语由RoyThomasFielding博士在他的论文《ArchitecturalStylesandtheDesignofNetwork-basedSoftwareArchitectures》中提出。从这篇论文的标题可以看出：REST是一种基于网络的软件架构风格。提示：国内很多网络资料将REST翻译为“表述性状态转移”，不过笔者对这个翻译不太认同。因为这个专业术语无法传达REST的含义，读者可以先不要理会REST到底该如何翻译，尽量先去理解REST是什么？有什么用？然后再来看这个术语的翻译。关于RoyThomasFielding博士的原文参见如下地址： 。REST架构是针对传统Web应用提出的一种改进，是一种新型的分布式软件设计架构。对于异构系统如何进行整合的问题，目前主流做法都集中在使用SOAP、WSDL和WS-*规范的WebServices。而REST架构实际上也是解决异构系统整合问题的一种新思路。如果开发者在开发过程中能坚持REST原则，将可以得到一个使用了优质Web架构的系统，从而为系统提供更好的可伸缩性，并降低开发难度。关于REST架构的主要原则如下：网络上的所有事物都可被抽象为资源（Resource）。每个资源都有一个唯一的资源标识符（ResourceIdentifier）。同一资源具有多种表现形式。使用标准方法操作资源。通过缓存来提高性能。对资源的各种操作不会改变资源标识符。所有的操作都是无状态的（Stateless）。仅从上面几条原则来看REST架构，其实依然比较难以理解，下面笔者将从如下二个方面来介绍REST。资源和标识符现在的Web应用上包含了大量信息，但这些信息都被隐藏在HTML、CSS和JavaScript代码中，对于普通浏览者而言，他们进入这个系统时无法知道该系统包含哪些页面；对于一个需要访问该系统资源的第三方系统而言，同样无法明白这个系统包含多少功能和信息。URI和URL与URI相关的概念还有URL，URL是UniformResourceLocator，也就是统一资源定位符的意思。其中 p页面。浏览器里将看到如图4所示页面。图4编辑指定图书该页面单击“修改”按钮时需要修改图书信息，也就是需要使用PUT操作，但由于HTML不支持PUT操作，因此需要为该表单页增加一个额外的请求参数：_method，该请求参数的值为put。该表单页的代码如下：<%@pagecontentType=""text/html;charset=GBK""language=""java""errorPage=""""%><%@taglibprefix=""s""uri=""/struts-tags""%><!DOCTYPEhtmlPUBLIC""-//W3C//DTDXHTML1.0Transitional//EN"""" html>该表单将提交给BookController的update()方法处理，update()方法将负责修改系统里指定ID对应的图书信息。与之类似的是，当请求需要执行DELETE操作时，一样需要增加名为_method的请求参数，并将该请求参数值设置为delete。",2015/4/27
299,H5游戏性能超越Unity3d,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8994,"测试设备：小米1测试方法：在同屏跑500个动画，每个动画有10帧(每帧为不同的独立图片)，图片大小为（100*100），场景中随机切换图片，每帧移动位置，整体滚屏；测试结果：（下面有实拍视频）引擎帧数Laya.player44-52Unity3d9-18注：本次还针对其它APP引擎进行了测试，同样未进行性能优化的情况下Laya.player完胜其它APP引擎产品；测试点评：经过1200个日夜，Layabox的加速器（Laya.player）支持下的产品性能已超越APP的性能，尤其是同样未作性能优化的情况下，Laya.player对产品性能的优化程度绝对是无懈可击的完胜。除了小米1，Laya.player在512M系统内存（实际可用系统内存为300M）的早期智能机下，仍然可流畅运行重度H5游戏（例如：猎魂之刃）；H5前景：Laya.playe在未来会支持所有H5产品（不受引擎限制）的加速。H5游戏替代APP游戏已经不止是可能，而是趋势！视频实拍： H5测试代码：conch.config.setFpsParam(400,300,80,""#ffffff"");conch.config.showFps(true);//Laya加速器性能测试程序varpCanvas=window.document.createElement(""canvas"");varpContext=pCanvas.getContext(""2d"");var_width=1024;var_height=768;var_url="" 300f));obj.transform.localPosition=vec3;}}}",2015/4/27
300,Struts2中的ModelDriven机制及其运用,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8993,"为什么需要ModelDriven所谓ModelDriven，意思是直接把实体类当成页面数据的收集对象。比如，有实体类User如下：packagecn.com.leadfar.struts2.actions;publicclassUser{privateintid;privateStringusername;privateStringpassword;privateintage;privateStringaddress;publicStringgetUsername(){returnusername;}publicvoidsetUsername(Stringusername){this.username=username;}publicStringgetPassword(){returnpassword;}publicvoidsetPassword(Stringpassword){this.password=password;}publicintgetAge(){returnage;}publicvoidsetAge(intage){this.age=age;}publicStringgetAddress(){returnaddress;}publicvoidsetAddress(Stringaddress){this.address=address;}publicintgetId(){returnid;}publicvoidsetId(intid){this.id=id;}}假如要写一个Action，用来添加User。第一种做法是直接在Action中定义所有需要的属性，然后在JSP中直接用属性名称来提交数据：UserAction:publicclassUserAction{privateintid;privateStringusername;privateStringpassword;privateintage;privateStringaddress;publicStringadd(){Useruser=newUser();user.setId(id);user.setUsername(username);user.setPassword(password);user.setAge(age);user.setAddress(address);newUserManager().addUser(user);return""success"";}publicintgetId(){returnid;}publicvoidsetId(intid){this.id=id;}publicStringgetUsername(){returnusername;}publicvoidsetUsername(Stringusername){this.username=username;}publicStringgetPassword(){returnpassword;}publicvoidsetPassword(Stringpassword){this.password=password;}publicintgetAge(){returnage;}publicvoidsetAge(intage){this.age=age;}publicStringgetAddress(){returnaddress;}publicvoidsetAddress(Stringaddress){this.address=address;}}add_input.jsp:<formaction=""test/user.action""method=""post""><inputtype=""hidden""name=""method:add"">username:<inputtype=""text""name=""username""><br/>password:<inputtype=""text""name=""password""><br/>age:<inputtype=""text""name=""age""><br/>address:<inputtype=""text""name=""address""><br/><inputtype=""submit""name=""submit""value=""添加用户""></form><br/>上述做法不好之处是：如果实体类的属性非常多，那么Action中也要定义相同的属性。第二种做法是将User对象定义到UserAction中，然后在JSP中通过user属性来给user赋值：UserAction:publicclassUserAction{privateUseruser;publicStringadd(){newUserManager().addUser(user);return""success"";}publicUsergetUser(){returnuser;}publicvoidsetUser(Useruser){this.user=user;}}add_input.jsp:<formaction=""test/user.action""method=""post""><inputtype=""hidden""name=""method:add"">username:<inputtype=""text""name=""user.username""><br/>password:<inputtype=""text""name=""user.password""><br/>age:<inputtype=""text""name=""user.age""><br/>address:<inputtype=""text""name=""user.address""><br/><inputtype=""submit""name=""submit""value=""添加用户""></form><br/>这种做法不好的地方是：JSP页面上表单域中的命名变得太长第三种做法是利用ModelDriven机制，让UserAction实现一个ModelDriven接口，同时实现接口中的方法：getModel()。如下所示：publicclassUserActionimplementsModelDriven{privateUseruser;@OverridepublicObjectgetModel(){if(user==null){user=newUser();}returnuser;}publicStringadd(){newUserManager().addUser(user);return""success"";}publicUsergetUser(){returnuser;}publicvoidsetUser(Useruser){this.user=user;}}JSP的代码如下：<formaction=""test/user.action""method=""post""><inputtype=""hidden""name=""method:add"">username:<inputtype=""text""name=""username""><br/>password:<inputtype=""text""name=""password""><br/>age:<inputtype=""text""name=""age""><br/><inputtype=""submit""name=""submit""value=""添加用户""></form><br/>可见，第三种做法是比较好的，Action和JSP写起来都比较简单。ModelDriven背后的机制？ModelDriven背后的机制就是ValueStack。界面通过：username/age/address这样的名称，就能够被直接赋值给user对象，这证明user对象正是ValueStack中的一个root对象！那么，为什么user对象会在ValueStack中呢？它是什么时候被压入ValueStack的呢？答案是：ModelDrivenInterceptor（关于Interceptor的概念，请参考后续章节的说明）。ModelDrivenInterceptor是缺省的拦截器链的一部分，当一个请求经过ModelDrivenInterceptor的时候，在这个拦截器中，会判断当前要调用的Action对象是否实现了ModelDriven接口，如果实现了这个接口，则调用getModel()方法，并把返回值（本例是返回user对象）压入ValueStack。请看ModelDrivenInterceptor的代码：publicclassModelDrivenInterceptorextendsAbstractInterceptor{protectedbooleanrefreshModelBeforeResult=false;publicvoidsetRefreshModelBeforeResult(booleanval){this.refreshModelBeforeResult=val;}@OverridepublicStringintercept(ActionInvocationinvocation)throwsException{Objectaction=invocation.getAction();if(actioninstanceofModelDriven){ModelDrivenmodelDriven=(ModelDriven)action;ValueStackstack=invocation.getStack();Objectmodel=modelDriven.getModel();if(model!=null){stack.push(model);}if(refreshModelBeforeResult){invocation.addPreResultListener(newRefreshModelBeforeResult(modelDriven,model));}}returninvocation.invoke();}从ModelDrivenInterceptor中，即可以看到model对象被压入ValueStack中！其中的refreshModelBeforeResult是为了接下来描述的一个问题而提供的解决方法。理解常见的陷阱及其解决方法假设我们要更新一个实体对象，那么第一步首先是打开更新界面，请看下述模拟打开更新界面的代码：publicclassUserActionimplementsModelDriven{privateUseruser;@OverridepublicObjectgetModel(){if(user==null){user=newUser();//user.setUsername(""这是原来的User对象"");}returnuser;}publicStringupdateInput(){//根据ID，查询数据库，得到User对象user=newUserManager().findUserById(user.getId());return""update_input"";}上述代码中，newUserManager().findUserById(user.getId());这一行，将从数据库中查询相应的记录，同时转换为User对象返回。而return“update_input”；将转向更新显示页面。更新页面如下：<formaction=""test/user.action""method=""post""><inputtype=""hidden""name=""method:update"">id:<inputtype=""text""name=""id""value=""<s:propertyvalue=""id""/>""><br/>username:<inputtype=""text""name=""username""value=""<s:propertyvalue=""username""/>""><br/>password:<inputtype=""text""name=""password""value=""<s:propertyvalue=""password""/>""><br/>age:<inputtype=""text""name=""age""value=""<s:propertyvalue=""age""/>""><br/>address:<inputtype=""text""name=""address""value=""<s:propertyvalue=""address""/>""><br/><inputtype=""submit""name=""submit""value=""更新用户""></form><br/>上述代码运行起来之后，你在更新界面上将看不到数据（id属性有值，其它属性无显示）。关键的原因是在执行到updateInput之前，user对象（在getMode()方法中创建的对象）被压到ValueStack中，这时候，UserAction和ValueStack都指向同一个user对象；但紧接着，UserAction中的user被一个新的user对象覆盖，这时候，UserAction和ValueStack不再指向同一个user对象！ValueStack中是旧的user对象，而UserAction中是新的user对象！我们在JSP中，直接通过username/address等直接访问，当然是要访问ValueStack中的旧user对象，所以它们的属性都是空的(id属性除外)！理解上述问题很重要，当你理解了问题，那么问题的解决方法就可以有很多了：比如，你可以把新对象的属性拷贝到旧对象上；比如，你可以先把旧对象从ValueStack中移除，然后再把新对象压入ValueStack等……在最新的struts2版本中，ModelDrivenInterceptor提供了一个配置参数：refreshModelBeforeResult，只要将它定义为true，上述问题就被解决了！struts2的解决方案就是：先把旧的model对象从ValueStack中移除，然后再把新的model对象压入ValueStack！",2015/4/27
301,网站页面优化策略,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/8992,网站重构这样做的好处是，HTML文件的代码被精简，文件变小，搜索引擎在索引网站页面时，可以更好地索引和识别网站的内容信息，并能准确抓取页面正文的内容。Meta标签优化title标题标签告诉用户和搜索引擎一个特定网页的主题是什么。<title>标签通常放在HTML文档的<head>标签内。理想情况下，应该为网站的每一个网页创建唯一的title页面标题。description描述标签提供了关于这个网页的总括性描述，网页的标题可能是由一些单词和短语组成的，而网页的描述元标签则常常是由一两个语句或段落组成的。如果网页摘要里的某个词语恰好出现在用户的查询里，那么这个词语将被高亮显示，如果描述标签写的好，可以提升页面的点击率。keywords关键词标签，对于页面优化来说，重要性已经大不如前，甚至有种说法是，keywords标签已经没用了，不过，就算搜索引擎已经不将keywords考虑进，写一下keywords标签可能还会有些作用，不过keywords里面不要堆砌太多关键字，否则可能适得其反，写上4、5个核心关键字即可。Heading标签优化由于H标签通常会使某些文字比普通的文字大，对于用户来说，这样可以便于他们更直观地看出这些文字的重要性，多种渐变大小的H标签可以为网站的内容创建分层结构，从而使用户更容易地浏览网站。Alt优化由于搜索引擎读取图片的困难，所以在一般的写作中，需要对添加的图片，进行ALT标签注释。当然对于图片的理解，周围的文字也起到一定的作用，当图片因为一些原因不能够显示的时候，系统会显示alt属性指定的文字。链接锚文本优化锚文本的正确写法是，使用简短的描述性文字，避免使用与目标页面主题无关的文字，避免用一个长句子或是一篇短文来实现的过长的锚文本，关键词优化在关键词的布局中，还有一个概念是，关键词密度。关键词密度(KeywordDensity)也叫关键词频率(KeywordFrequency)，它是用来量度关键词在网页上出现的总次数与其他文字的比例，一般用百分比表示。相对于页面总字数而言，关键词出现的频率越高，那么关键词密度也就越大。简单地举个例子，如果某个网页共有100个字符，而关键词本身是两个字符并在其中出现5次，则可以说关键词密度为10%。通常认为，页面的关键词密度应该保持在2%到8%之间。关键字密度有时候会影响到关键词的排名，不建议采取一些极端的方法来提高关键字密度。合理的目标关键字密度可以通过关注一些长尾关键字来进行优化。长尾关键词(LongTailKeyword)是指网站上非目标关键词但也可以带来搜索流量的关键词。长尾关键词的特征是比较长，往往是2-3个词组成，甚至是短语。通过长尾关键词挖掘工具可以找到不少长尾关键词，将这些词组织到文章里，就可以做到既不提高关键词密度，又能提升关键词在页面的权重。内容优化但可惜的是，撰写高质量内容并不太容易，除了拥有过硬的专业技能知识外，作者还要拥有一流的语言组织能力，以及充足的时间，不过对于高质量内容的撰写也是有一定规律的，主要的规律包括：2、提供原创的、独特新颖的内容，不要模仿甚至抄袭别人的内容。原创内容不仅仅能吸引更多的用户，还可以招揽更多的回头客。而搜索引擎对于原创内容的识别能力也越来越高。,2015/4/27
302,Redis 3.0.0正式版发布，全新的分布式高可用数据库,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8991,Redis3.0.0正式版终于到来了！最重要的新特性是集群（RedisCluster），提供Redis功能子集（比如不支持多数据库）的分布式、容错的实现（最多支持1000结点）。Salvatore‘antirez’Sanfilippo在GoogleGroups里表示，这是Redis的重要时刻。“我相信今天的Redis3.0.0将以某种方式完全改变Redis的面貌。”他强调，人们将认识到Redis是一个全新的东西，它的自动扩展、容错和高可用性都大大提高，从此能够在更大范围承担更关键的任务。（我总结一下老大的意思吧：Redis翻开了历史新的篇章……）antirez还透露，内置的集群功能持续干了很多年，虽然能找到一些时间密集开发，但也不时被其他特性完全打断，现在终于完成了。他预计社区能用好这些功能，积累必要的经验，还要一到两年。他还说，Redis3.0.0实际上标志着一个新阶段和新的开发模式的开始。以后，大量已经开发的新功能将不再急于进入稳定版本，实际上Redis3.0.0就放弃了很多新功能，回退到2.8，以保证新的稳定版本用户能够马上使用。他在帖子里重点提及的其他更新包括：新的”embeddedstring”对象编码，提升缓存命中率。在某些工作负载（尤其是管道化的高负载）下速度大幅提高。大大改进了回收键的LRU近似算法。AOF重写功能被完全重新开发了，以减少进程最终将积累的缓冲写入时，由于硬盘速度慢而导致的延迟。而在发布声明中还列出了如下更新（相对于2.8）：WAITcommandtoblockwaitingforawritetobetransmittedtothespecifiednumberofslaves.MIGRATEconnectioncaching.Muchfasterkeysmigraitons.MIGARTEnewoptionsCOPYandREPLACE.CLIENTPAUSEcommand:stopprocessingclientrequestsforaspecifiedamountoftime.BITCOUNTperformanceimprovements.CONFIGSETacceptsmemoryvaluesindifferentunits(forexampleyoucanuse“CONFIGSETmaxmemory1gb”).Redislogformatslightlychangedreportingineachlinetheroleoftheinstance(master/slave)orifit’sasavingchildlog.INCRperformanceimprovements.详情可以点击这里查看。ITEye上powersoft同学之前翻译了Redis3.0的文档，虽然还没有来得及更新，但还是有参考价值的： /blogs/subjects/redis3。HackerNews上antirez回答了社区提出的一些问题，颇有价值，整理翻译如下。Redis之外还有什么其他更好的选择啊？（这问题让antirez怎么答，总不能不谦虚吧。仔细听，他回答得很好。）这得看使用场景，基本上还是就事论事、具体情况具体分析。程序员的本事不就体现在选择正确的技术，然后在不同情况下优化嘛。你要考虑数据模型是否匹配所要解决的问题，运维因素，持久化保证，性能（需要多少个结点），可扩展性，是否简单（搞这么复杂以后会不会老要我来支持啊），等等。其他同学提到了memcached，有人评论：现在memcached已经只相当于Redis最简单的功能了，只能作为缓存。Redis不仅能缓存，还能承担很多存储任务。此外还有人提及HyperDex，但其ACID特性实现Warp是专有的产品。此前的这个大型NoSQL比较文章，仍然有一定参考价值： cassandra-vs...redis有了Cluster，Sentinel是不是就废啦。还没那么快，Sentinel还在与Cluster并行继续开发中。目前单实例场景下需要HA的话，它还是最佳选择。但长远（可能很长远哦）看，我们会用Cluster解决Sentinel的使用场景，不过在那之前我们会很早就告诉大家的。谁能给我更详细地讲讲”embeddedstring”对象编码是啥，它针对什么工作负荷？能找到的文档都太老了。这事儿简单。一般Redis里会有包含类型字段的对象结构，还有一个指针指向实际的对象表示。假设类型是REDIS_STRING，就得有指针指向一个”sds”字符串（sds是字符串库用的名字）。现在有了embeddedstring之后，就提供了一种特殊的字符串对象，用一个位置保持对象结构和字符串本身。这样内存利用更有效，而且能够大大改进内存本地性，所以差不多所有使用字符串对象的东西（字符串，或者比较大的要用字符串对象作为集合值的集合对象）性能都更好。这种特殊字符串只用于小字符串（工作负荷里大多数字符串都不大）。RedisRedis是一个开源的高级key-value（键-值）缓存与存储，以高性能著称。它也常被称为数据结构服务器，因为其中的键可以存各种数据结构包括字符串、散列、列表、集合、有序集合、位图和hyperloglog。Redis的出现，很大程度补偿了memcached这类KV数据库的不足。不仅可以用于缓存，也可以用于一些场景的存储，在很多情况下是关系数据库很好的补充。它提供了Python，Ruby，Erlang，PHP客户端，使用非常方便。,2015/4/23
303,咨询优酷流媒体使用方法,胡瑶,http://180.168.156.212:2262/wecenter/?/article/8990,在线视频播放需要使用优酷流媒体（客户不提供服务器，不能在服务器上设置流媒体），以前都没接触过这玩意儿，所以咨询下各位这个优酷流媒体怎么弄？？,2015/4/22
304,Java 共享类,丁凯,http://180.168.156.212:2262/wecenter/?/article/8989,"学习如何使Java应用程序启动更快以及占用更少的内存如今Java应用程序面临一个问题：它们惟一可用的容器是Java虚拟机（Javavirtualmachine，JVM）进程自身。需要多个JVM来彼此隔离Java应用程序，这会带来两个主要的负面影响。第一个是每次JVM调用所花费的启动时间，第二个是每个JVM所需的内存占用。考虑到这些开销以及不能在一个JVM中隔离应用程序，很显然需要进行一些基础性工作才能解决这些问题。答案就是共享类。在本文中，IBMJavaTechnologyCenterDevelopmentTeam成员LakshmiShankar、SimonBurns和RoshanNichani讨论了JVM中共享类背后的概念、它们的工作原理以及用户如何利用这种技术。他们还讨论了这种技术的几种当前实现以及在将来会有什么样的应用。要真正彼此隔离Java应用程序，实质上需要多个JVM，然而启动成本和内存占用使这种方式不那么理想。而共享类可以同时解决这两个问题。在多JVM环境中，共享类通过将一组核心系统类装载到共享内存中，可以在多个JVM中共享这些类。这些共享类放到内存的一个共享区域中，它们在这里对所有JVM都是保持一致的。结果，共享类只需要在第一次使用时装载到内存中，这消除了在以后每次JVM调用时装载它们的固定成本，并减少了每个JVM中的内存占用。IBM在z/OS平台上实现了共享类技术。AppleComputerInc.在MacOSX上实现了名为JavaSharedArchive（JSA）的一种共享类，而Sun在J2SE1.5版中引入了基于JSA技术的ClassDataSharing（CDS）。让我们分析一下这些实现是如何工作的。IBM的实现自J2SE1.3.1以来，IBM就在z/OS平台上提供了共享类技术的实现。这种实现是通过让一个主（或称master）JVM将核心系统类装载到共享内存完成的，那么这到底是什么意思呢？分解堆内存分为共享堆和Java堆。主JVM将系统堆（即共享堆）分配到共享内存中，这里是放置系统类的地方。系统堆在主JVM的生存周期中一直存在，并且不会受到垃圾收集（GC）的影响。每一个后续（或者worker）JVM附加到这个系统堆上，如图1所示，并为自己的Java堆分配非共享内存，它会受垃圾收集的影响。Java堆包含特定于每一个workerJVM运行的应用程序的非共享类和所有实例化的对象。图1.共享类分解堆共享类装载器每个workerJVM都可以通过将类放到共享类装载器的classpath中而将它们装载到共享堆中。共享类与普通类的装载方式一样——使用parent-delegation模式。层次结构中的每一个类装载器检查其缓存，确定这个类是否已经装载。如果还没有装载，那么类装载器就向其父类装载器传递一个检查装载请求，这样一直上溯到层次结构顶部的primordial或者bootstrap类装载器。如果没有在任何缓冲区中发现这个类，那么每一个类装载器都会试图从自己的存储库中装载这个类，如果成功，就返回这个类。否则，它将请求传递给层次结构中下面的装载器。这种模型保证了首先检查最受信任的存储库，并防止信任程度低的代码通过采用与核心API成员相同的名字代替受信任的核心API类。如果类是primordial类或者定义的类装载器是共享类装载器，那么类对象将在共享堆中创建，并且类标记为共享类。图2显示了bootstrap类装载器位于类装载器层次结构的顶部，并负责装载核心API中的类。这些类是信任程度最高的。扩展类装载器装载extensions目录中的标准扩展JAR文件中的类。共享应用程序类装载器可以用于共享用户或者应用程序类。图2.类装载器层次结构但是在这种实现中，类到底是如何由多个JVM共享的呢？假定JVM1装载了java/lang/String，这是一个由bootstrap类装载器装载的系统类。如果JVM2想要装载java/lang/String，由于它不能访问JVM1的bootstrap类装载器缓存，所以它必须使用自己的bootstrap类装载器重新装载这个类。在这个例子中，JVM不共享任何类，如图3所示。图3.类没有跨JVM共享因此，最好让JVM共享相同的类，如图4所描绘的。图4.跨JVM共享的类要解决这个问题，通过创建一个名为namespace的全局类缓存，将类缓存的概念加以扩展。每个JVM的类装载器必须在这个namespace上注册。当共享类装载器装载一个类时，它被同时放到本地类缓存和namespace中（如图5所示）。这样做使得其他JVM中的类装载器（在namespace上注册的）不用装载它就可以访问这个类。图5.Namespace跨JVM共享保护域类装载器有一个或者多个代码源对象（从其中装载类的JAR文件或者目录）。这些对象用于创建保护域，它被传递给defineClass()方法调用。使用共享类的其他JVM将需要这个信息，但是不能共享保护域，因为它们包含本地信息。为了解决这个问题，将代码源放到系统堆中。打包信息也需要共享。竞争条件由于JVM会读取和写入共享数据，需要有一种方法处理竞争条件。最简单的方式是使用全局块。不过，出于性能和伸缩性的原因，应当谨慎地使用它们。一种避免锁住所有JVM的方法是使用开放式原子更新（optimisticatomicupdates）。例如，在装载一个类时，类装载器将检查其namespace（在检查其自己的本地类缓存后）。如果不能找到这个类，那么它就会装载它。装载后，它会自动检查其他JVM没有装载这个类，然后更新namespace。全局与本地数据类中有些信息（如名字）在所有JVM中都是一样的，而另一些信息要求是本地的，如装载这个类的类装载器。每个JVM都需要有装载这个类时需要它生成的那一部分的本地副本，如图6所示。JVM中类的阴影区域是本地副本。系统中类的非阴影区域是全局部分。图6.共享全局数据与共享本地数据共享类时偶尔会出现的一个问题是，当一个JVM更新一个类时（比如通过修改静态字段），所有其他JVM都会看到这种改变。这种操作是不希望的，它会造成不可预料的结果。为了保证隔离性，每个JVM都有每个共享类的所有静态字段的副本。JIT编译代码当属于共享类的代码由即时（just-in-time，JIT）编译器编译时，它是自动共享的。这意味着不管由哪个JVM编译代码，所有JVM都会获得性能上的好处（而只有一个承担JITing的开销）。启动器程序IBM的实现需要一个启动器（launcher），以便控制JVM的创建。这个启动器必须由用户以本机代码编写。如清单1显示了一个示例启动器的伪代码：清单1.启动器伪代码{createMasterJVM(andstorereturnedtoken*);while(worktodo){createaWorkerJVMpassingintokenfromMasterJVM;doworkonWorkerJVM;terminateWorkerJVM;}terminateMasterJVM;}*tokenreturnedfromtheMasterJVMistheaddressofthesharedheap. /i/v17/ic...ON.png);border-bottom:0px;background-position:0px-401px;font-weight:bold;color:rgb(116,82,133);outline-width:0px;padding-bottom:0px;padding-top:0px;outline-style:none;padding-left:16px;margin:0px;display:inline;outline-color:invert;line-height:1.06em;padding-right:0px;border-top-width:0px;opacity:0.8"">回页首结束语本文提供了对Java共享类技术的概述和一般性介绍。我们展示了不同的共享类和它们所提供的好处，如Java应用程序的启动时间更快和内存占用更小。我们还分析了可以利用共享类的当前和未来的一些技术。所有需要关注启动时间和内存占用的Java应用程序都可以通过共享类技术获益。当前的实现有局限性，如有限的能力或者不能共享应用程序类（或者这两者）。如果能够解决这些问题，那么更多用户会从这种技术中受益，使Java应用程序更有吸引力。",2015/4/14
305,JS 实现BASE64_ENCODE和BASE64_DECODE,丁凯,http://180.168.156.212:2262/wecenter/?/article/8988,"JS实现BASE64_ENCODE和BASE64_DECODE(实例代码)。需要的朋友可以过来参考下，希望对大家有所帮助<scriptlanguage='javascript'>/*utf.js-UTF-8<=>UTF-16convertion**Copyright(C)1999MasanaoIzumo<iz@onicos.co.jp>*Version:1.0*LastModified:Dec251999*Thislibraryisfree.Youcanredistributeitand/ormodifyit.*//**Interfaces:*utf8=utf16to8(utf16);*utf16=utf16to8(utf8);*/functionutf16to8(str){varout,i,len,c;out="""";len=str.length;for(i=0;i<len;i++){c=str.charCodeAt(i);if((c>=0x0001)&&(c<=0x007F)){out+=str.charAt(i);}elseif(c>0x07FF){out+=String.fromCharCode(0xE0|((c>>12)&0x0F));out+=String.fromCharCode(0x80|((c>>6)&0x3F));out+=String.fromCharCode(0x80|((c>>0)&0x3F));}else{out+=String.fromCharCode(0xC0|((c>>6)&0x1F));out+=String.fromCharCode(0x80|((c>>0)&0x3F));}}returnout;}functionutf8to16(str){varout,i,len,c;varchar2,char3;out="""";len=str.length;i=0;while(i<len){c=str.charCodeAt(i++);switch(c>>4){case0:case1:case2:case3:case4:case5:case6:case7://0xxxxxxxout+=str.charAt(i-1);break;case12:case13://110xxxxx10xxxxxxchar2=str.charCodeAt(i++);out+=String.fromCharCode(((c&0x1F)<<6)|(char2&0x3F));break;case14://1110xxxx10xxxxxx10xxxxxxchar2=str.charCodeAt(i++);char3=str.charCodeAt(i++);out+=String.fromCharCode(((c&0x0F)<<12)|((char2&0x3F)<<6)|((char3&0x3F)<<0));break;}}returnout;}/*Copyright(C)1999MasanaoIzumo<iz@onicos.co.jp>*Version:1.0*LastModified:Dec251999*Thislibraryisfree.Youcanredistributeitand/ormodifyit.*//**Interfaces:*b64=base64encode(data);*data=base64decode(b64);*/varbase64EncodeChars=""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";varbase64DecodeChars=newArray(-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1);functionbase64encode(str){varout,i,len;varc1,c2,c3;len=str.length;i=0;out="""";while(i<len){c1=str.charCodeAt(i++)&0xff;if(i==len){out+=base64EncodeChars.charAt(c1>>2);out+=base64EncodeChars.charAt((c1&0x3)<<4);out+=""=="";break;}c2=str.charCodeAt(i++);if(i==len){out+=base64EncodeChars.charAt(c1>>2);out+=base64EncodeChars.charAt(((c1&0x3)<<4)|((c2&0xF0)>>4));out+=base64EncodeChars.charAt((c2&0xF)<<2);out+=""="";break;}c3=str.charCodeAt(i++);out+=base64EncodeChars.charAt(c1>>2);out+=base64EncodeChars.charAt(((c1&0x3)<<4)|((c2&0xF0)>>4));out+=base64EncodeChars.charAt(((c2&0xF)<<2)|((c3&0xC0)>>6));out+=base64EncodeChars.charAt(c3&0x3F);}returnout;}functionbase64decode(str){varc1,c2,c3,c4;vari,len,out;len=str.length;i=0;out="""";while(i<len){/*c1*/do{c1=base64DecodeChars[str.charCodeAt(i++)&0xff];}while(i<len&&c1==-1);if(c1==-1)break;/*c2*/do{c2=base64DecodeChars[str.charCodeAt(i++)&0xff];}while(i<len&&c2==-1);if(c2==-1)break;out+=String.fromCharCode((c1<<2)|((c2&0x30)>>4));/*c3*/do{c3=str.charCodeAt(i++)&0xff;if(c3==61)returnout;c3=base64DecodeChars[c3];}while(i<len&&c3==-1);if(c3==-1)break;out+=String.fromCharCode(((c2&0XF)<<4)|((c3&0x3C)>>2));/*c4*/do{c4=str.charCodeAt(i++)&0xff;if(c4==61)returnout;c4=base64DecodeChars[c4];}while(i<len&&c4==-1);if(c4==-1)break;out+=String.fromCharCode(((c3&0x03)<<6)|c4);}returnout;}//inputbase64encodefunctionstrdecode(str){returnutf8to16(base64decode(str));}",2015/4/13
306,嵌入式数据库sqlite与灵器工具,路斌,http://180.168.156.212:2262/wecenter/?/article/8987,"灵器工具“电子文件检测工具”V2.0在设计某些场景下，需要一个数据库完成数据存储、共享。首先想到的是mysql，最新的版本已经胖的达到1个G，早期5.0绿色版本也达到40M。转向嵌入式数据库，灵器研发组（孙传金、岑沛龙、陆开奇）经过对比，最终选择了sqlite。sqlite绿色、轻量（不超过1M）、单文件、跨平台、支持作为内存数据库使用，是嵌入数据库的首选良方,^_^.另外支持blob字段、支持远程访问（文件共享方式）。实践详见附件。Sqlite实践.docx",2015/4/13
307,工时系统-增加或修改计划界面无滚动条,梁华聪,http://180.168.156.212:2262/wecenter/?/article/8986,工时系统-增加或修改计划界面无滚动条，当列表需增加较多任务时，无法操作列表中内容。使用的浏览器是IE8,2015/4/13
308,无需安装OFFICE，DLL，纯java实现Word文件转换成多种格式,王链玮,http://180.168.156.212:2262/wecenter/?/article/8985,"支持的转换格式非常多,见图楼主对docx文件,实际测试：电子公文归档一般要求[原格式].docx31页，5.31兆aspose转换结果1.58兆office转换结果2.33兆电子公文归档一般要求[原格式].docx电子公文归档一般要求[Aspose].PDF电子公文归档一般要求[office转换].pdfaspose转换.jpg",2015/4/9
309,如何优雅的在线浏览各种文件,王链玮,http://180.168.156.212:2262/wecenter/?/article/8984,"优雅浏览的正确姿势：１。客户端不安装任何插件２。最大限度还原原格式３。支持ＩＥ,FIREFOX,CHROME我们可以学习３６０云盘的在线浏览，除视频格式及容量较大的文件外，３６０云盘基本做到了在线无插件浏览３６０云盘的实现的核心技术：转换ＨＴＭＬ＋ＯＦＦＩＣＥＷＥＢＡＰＰ转换PDF为HTML的技术，３６０使用了ＰＤＦ２ＨＴＭＬＥＸ，效果非常不错演示： ",2015/4/9
310,JAVA实现类似迅雷的透明悬浮窗效果,王链玮,http://180.168.156.212:2262/wecenter/?/article/8983,灵器新产品文件格式转化软件2.0需要实现浮动窗体效果，参考网上一些示例进行整合已实现功能：1.窗体透明2.窗体置顶自动缩进3.右键菜单弹出一些思路：在实现窗体透明功能采用了曲线救国的方式，不是真正的将窗体搞成透明，而是通过鼠标放置窗体后动态截取背景图的方式，实现了“伪”透明，最终效果还不错，带磨砂效果哟悬浮窗.jpg,2015/4/7
311,探讨移动电子商务网站中的图文滚动切换设计,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/8982,探讨移动电子商务网站中的图文滚动切换设计探讨移动电子商务网站中的图文滚动切换设计.docx,2015/4/3
312,请假审批的bug，详细见截图。,陈雷,http://180.168.156.212:2262/wecenter/?/article/8979,指定审批人，每次都是“undefined”，也不知道能不能发到正确的人那里。,2015/4/2
313,Linux操作系统下安装JDK,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8978,Linux操作系统下安装JDKLinux操作系统下安装JDK.doc,2015/4/1
314,Javascript的原型和继承,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8977,"原型：我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个对象，它的用途是包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解：prototype是通过调用构造函数而创建的那个对象的原型对象。为什么要引入原型的概念呢？使用原型的目的，也是他的好处是可以让所有的对象实例共享它所包含的属性和方法。换句话说，就是不必再构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。具体代码实例：<spanstyle=""font-size:18px;"">//原型实例functionPerson(){}//声明一个构造函数Person.prototype.name='Lian';//在原型里添加属性Person.prototype.age=100;Person.prototype.run=function(){//在原型里添加方法returnthis.name+this.age+'奋斗中……';};varperson1=newPerson();varperson2=newPerson();alert(person1.run==person2.run);//返回true，说明方法的引用地址是一致的，即两个对象共享了一个方法</span>而使用原型模式创建对象也有其缺点，那就是它省略了构造函数传参初始化这一过程，带来的缺点就是初始化的值都是一样的，但是这恰恰是它最大的优点，那就是共享。继承：继承是面向对象中的一个核心概念，在比较正统的面向对象的语言中一般都会采用两种方式实现继承：一个是接口实现，一个是类继承。而我们的JavaScript只支持继承，而不支持接口实现；具体代码实例：<spanstyle=""font-size:18px;"">//继承实例functionA(){this.name='Lian';}functionB(){this.age=100;}functionC(){this.address='中国';}B.prototype.age=200;B.prototype=newA();//B继承了AC.prototype=newB();//C又继承了Bvarc=newC();alert(c.name+''+c.age);//C具有了A和B的属性</span>在JavaScript中，被继承的函数称为超类型（也就是面向对象中说的父类或者说是基类），继承的函数称为子类型（即子类或者派生类）。继承有好处，但是也有其自己的问题，比如字面量重写原型会中断关系，使用引用类型的原型，并且子类型无法给超类型传递参数。综合考虑，我们使用原形链加上构造函数，这样产生了组合继承；组合继承是JavaScript最常用的继承方式<spanstyle=""font-size:18px;"">//组合继承functionBox(age){this.name='Lee';this.age=age;}Box.prototype.run=function(){returnthis.name+this.age;};functionDesk(age){Box.call(this,age);//对象冒充，给超类型传参}Desk.prototype=newBox();//原形链继承vardesk=newDesk(100);alert(desk.run());//显然Desk继承了Box的run方法</span>",2015/4/1
315,js中firefox与IE的区别,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8976,js中firefox与IE的区别研发中心经验共享-毛璀玲[201503].doc,2015/3/31
316,从Log4j迁移到LogBack的理由,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8975, reasons-to-prefer-logbak-over-log4j?p=2,2015/3/31
317,eclipse jetty 请求的操作无法在使用用户映射区域打开的文件上执行,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8974,"使用jetty-maven-plugin在eclipse中进行运行调试,碰到无法编辑保存webapp下的文件提示:请求的操作无法在使用用户映射区域打开的文件上执行解决方法:从jetty7开始,jar存放在maven仓库中的路径为org/eclise/jetty/jetty-webapp打开对应的版本的jar包修改jar中的org/mortbay/jetty/webapp/webdefault.xml文件<init-param><param-name>useFileMappedBuffer</param-name><param-value>true</param-value><!--将这个值设为false--></init-param>改好后放回jar包另一种办法是将webdefault.xml提取出来,修改后放在给定位置,然后配置jetty插件的信息。<configuration><webAppConfig><defaultsDescriptor>src/test/resources/webdefault.xml</defaultsDescriptor></webAppConfig></configuration>",2015/3/31
318,纯JavaScript实现的兼容各浏览器的添加和移除事件封装,李海波,http://180.168.156.212:2262/wecenter/?/article/8973,"//事件处理兼容各种浏览器，采用能力检测方法，所谓能力检测，就是有能力就做，没有能力就不做//定义一个处理事件的对象，兼容各种浏览器，dom2级事件处理和ie事件，如果这两个事件都不兼容，就采用dom0级处理vareventUtil={addEvent:function(element,type,handler){if(element.addEventListener){//非IE浏览器采用dom2级事件处理，type为事件类型如：click，handler为事件处理函数，false代表事件采用冒泡处理模型，如果是true代表采用捕获型处理模型//除了netbeans采用捕获型处理模型，其他都采用冒泡型处理模型//如果是非IE浏览器添加事件为：addEventListenerelement.addEventListener(type,handler,false);}elseif(element.attachEvent){//如果为IE浏览器，添加事件采用attachEventelement.attachEvent('on'+type,handler);}else{element['on'+type]=handler;}},removeEvent:function(element,type,handler){if(element.removeEventListener){//非IE浏览器采用dom2级事件处理，type为事件类型如：click，handler为事件处理函数，false代表事件采用冒泡处理模型，如果是true代表采用捕获型处理模型//除了netbeans采用捕获型处理模型，其他都采用冒泡型处理模型//如果是非IE浏览器添加事件为：removeEventListenerelement.removeEventListener(type,handler,false);}elseif(element.detachEvent){//如果为IE浏览器，添加事件采用detachEventelement.detachEvent('on'+type,handler);}else{//dom0级事件处理，如果删除事件采用赋值nullelement['on'+type]=null;}},getEvent:function(event){//获取事件本身returnevent?event:window.event;},getType:function(event){//获取事件类型returnevent.type;},getElement:function(event){//获取事件作用元素returnevent.target||event.srcElement;},preventDefault:function(event){//阻止默认的事件行为if(event.preventDefault){event.preventDefault();}else{event.returnValue=false;}},stopProPagation:function(event){//停止事件冒泡if(event.stopProPagation){event.stopProPagation();}else{event.cancelBubble=true;}}}",2015/3/31
319,apply、call、callee、caller初步了解,李海波,http://180.168.156.212:2262/wecenter/?/article/8972,"apply和call是函数原型的一个方法，调用者的类型必须是函数。官方解释：应用某一对象的一个方法，用另一个对象替换当前对象。通常用于改变上下文的this，这点和bind相似。apply和call的区别：方法传递的参数不同。apply传递的是一个数组，如果木有第二个参数两者用法结果相同。使用方法：fun.call(thisArg[,arg1[,arg2[,…]]])fun.apply(thisArg,[arg1,arg2,…argN])fun.call(this,arg1,arg2,arg3)==fun.apply(this,arguments)==this.fun(arg1,arg2,arg3)functionfn(){console.log(this.count);}varcount=10;varobj={count:20};fn();//10fn.call();//10fn.call(window);//10fn.call(null);//10fn.call(obj);//20fn.apply(window);//10fn.apply(null);//10fn.apply(obj);//20如果没有指定this或者为null，则默认指向window。使用apply的好处是可以直接将当前函数的arguments对象当做第二个参数传入，在对象继承等地方发挥着巨大的作用。//计算数组最大值vara=[1,2,3,6,5,4,10,9,8,7];varmaxn=Math.max.apply(null,a);console.log(maxn);//10callee返回正被执行的Function对象，也就是所指定的Function对象的正文。arguments.length是实参长度，arguments.callee.length是形参长度。functionfn(a,b,c,d){console.log(arguments.length);//3console.log(arguments.callee.length);//4console.log(fn.length);//4console.log(arguments.callee===fn);//trueconsole.log(a.callee);//undefined}fn(1,2,3);caller返回一个对函数的引用（返回值是个函数），该函数调用了当前函数（调用caller的函数即下面代码中的arguments.callee）。对于函数来说，caller属性只有在函数执行时才有定义。如果函数是由Javascript程序的顶层调用的，那么caller返回的就是null。functiontest(){console.log(arguments.callee);console.log(arguments.callee.caller);}functiontest2(){test();}test();test2();首先执行test函数，arguments.callee返回函数本身（test），而该函数是顶层调用，返回null；第二次调用test2函数，arguments.callee值不变还是test，而test函数此次是在test2中调用的，所以返回test2函数。函数.caller，返回函数。",2015/3/31
320,Java获取客户端IP地址,何文,http://180.168.156.212:2262/wecenter/?/article/8971,"在JSP里，获取客户端的IP地址的方法是：request.getRemoteAddr（），这种方法在大部分情况下都是有效的。但是在通过了Apache，Squid等反向代理软件就不能获取到客户端的真实IP地址了。如果使用了反向代理软件，将 p时，则能返回客户端的真实IP地址，写了个方法去验证。原因出在了Squid上。squid.conf的配制文件forwarded_for项默认是为on，如果forwarded_for设成了off则：X-Forwarded-For：unknown于是可得出获得客户端真实IP地址的方法二：Java代码：publicStringgetIpAddr(HttpServletRequestrequest){Stringip=request.getHeader(""x-forwarded-for"");if(ip==null||ip.length()==0||""unknown"".equalsIgnoreCase(ip)){ip=request.getHeader(""Proxy-Client-IP"");}if(ip==null||ip.length()==0||""unknown"".equalsIgnoreCase(ip)){ip=request.getHeader(""WL-Proxy-Client-IP"");}if(ip==null||ip.length()==0||""unknown"".equalsIgnoreCase(ip)){ip=request.getRemoteAddr();}returnip;}可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串Ip值，究竟哪个才是真正的用户端的真实IP呢？答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。如：X-Forwarded-For：192.168.1.110，192.168.1.120，192.168.1.130，192.168.1.100用户真实IP为：192.168.1.110最近做一个安全系统，需要对用户的ip和mac地址进行验证，这里用到获取客户端ip和mac地址的两个方法，留存。1.获取客户端ip地址(这个必须从客户端传到后台)：jsp页面下，很简单，request.getRemoteAddr();因为系统的VIew层是用JSF来实现的，因此页面上没法直接获得类似request，在bean里做了个强制转换Java代码：publicStringgetMyIP(){try{FacesContextfc=FacesContext.getCurrentInstance();HttpServletRequestrequest=(HttpServletRequest)fc.getExternalContext().getRequest();returnrequest.getRemoteAddr();}catch(Exceptione){e.printStackTrace();}return"""";}2.获取客户端mac地址调用window的命令，在后台Bean里实现通过ip来获取mac地址。方法如下：Java代码：publicStringgetMACAddress(Stringip){Stringstr="""";StringmacAddress="""";try{Processp=Runtime.getRuntime().exec(""nbtstat-A""+ip);InputStreamReaderir=newInputStreamReader(p.getInputStream());LineNumberReaderinput=newLineNumberReader(ir);for(inti=1;i<100;i++){str=input.readLine();if(str!=null){if(str.indexOf(""MACAddress"")>1){macAddress=str.substring(str.indexOf(""MACAddress"")+14,str.length());break;}}}}catch(IOExceptione){e.printStackTrace(System.out);}returnmacAddress;}补充：关于获取IP地址的方式，最近在linux下有一个教训，如果单纯通过InetAddress来获取IP地址，就会出现在不同的机器上IP地址不同的问题。InetAddress.getLocalHost().getAddress()实际上是根据hostname来获取IP地址的。linux系统在刚刚装完默认的hostname是localhost，所以通过上面代码获取到的本机ip就是127.0.0.1,相对应，比如我的hostname就是rjlin.atsig.com返回的ip地址确是atsig.com的地址。暂时采用下面代码来处理，当然还不够灵活：Java代码：publicstaticbyte[]getIp()throwsUnknownHostException{byte[]b=InetAddress.getLocalHost().getAddress();EnumerationallNetInterfaces=null;try{allNetInterfaces=NetworkInterface.getNetworkInterfaces();}catch(SocketExceptione){e.printStackTrace();}InetAddressip=null;NetworkInterfacenetInterface=null;while(allNetInterfaces.hasMoreElements()){netInterface=(NetworkInterface)allNetInterfaces.nextElement();if(netInterface.getName().trim().equals(""eth0"")){Enumerationaddresses=netInterface.getInetAddresses();while(addresses.hasMoreElements()){ip=(InetAddress)addresses.nextElement();}break;}}if(ip!=null&&ipinstanceofInet4Address){returnb=ip.getAddress();}returnb;}",2015/3/30
321,检查form里的输入框属性的值是否有改变,何文,http://180.168.156.212:2262/wecenter/?/article/8970,"//检查form里的输入框属性的值是否有改变functionIsModified(the){varresult=false;//初始化返回值varcolInput=document.getElementsByTagName(""input"");//获取输入框控件for(vari=0;i<colInput.length;i++)//逐个判断页面中的input控件{//判断输入的值是否等于初始值if(colInput[i].type==""text""||colInput[i].type==""password""){if(colInput[i].value!=colInput[i].defaultValue)//判断输入的值是否等于初始值{result=true;//如果不相等，返回true，表示已经修改colInput[i].style.backgroundColor=""#ff9000"";//改变被修改控件的背景色}}//检查radio的值是否有改变if(colInput[i].type==""radio""){varcheckedValue=colInput[i].checked.toString();vardefaultValue=colInput[i].defaultChecked.toString();if(defaultValue==""true""){if(checkedValue==""true""){}else{result=true;colInput[i].style.backgroundColor=""#ff9000"";}}else{if(checkedValue==""true""){result=true;colInput[i].style.backgroundColor=""#ff9000"";}else{}}}//第一次循环结束}varselectInput=document.getElementsByTagName(""select"");//获取所有的下拉列表for(vari=0;i<selectInput.length;i++)//逐个判断页面中的input控件{//检查select的值是否有改变/*varselectedValue=selectInput[i].options[selectInput[i].selectedIndex].toString();vardefaultSelectedValue=selectInput[i].options[selectInput[i].selectedIndex].defaultSelected.toString();alert(""selectedValue""+selectedValue);alert(""defaultSelectedValue""+defaultSelectedValue);*/for(varn=0;n<selectInput[i].options.length;n++){varselectedValue=selectInput[i].options[n].selected.toString();vardefaultSelectedValue=selectInput[i].options[n].defaultSelected.toString();if(defaultSelectedValue==""true""){if(selectedValue==""true""){}else{result=true;selectInput[i].style.backgroundColor=""#ff9000"";break;}}else{if(selectedValue==""true""){result=true;selectInput[i].style.backgroundColor=""#ff9000"";break;}else{}}}/*if(!selectInput[i].options[selectInput[i].selectedIndex].defaultSelected){result=true;//如果不相等，返回true，表示已经修改selectInput[i].style.backgroundColor=""#ff9000"";//改变被修改控件的背景色alert('Y');}*///第一次循环结束}returnresult;}",2015/3/30
322,C3p0配置详解,何文,http://180.168.156.212:2262/wecenter/?/article/8969,"<c3p0-config><default-config><!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default:3--><propertyname=""acquireIncrement"">3</property><!--定义在从数据库获取新连接失败后重复尝试的次数。Default:30--><propertyname=""acquireRetryAttempts"">30</property><!--两次连接中间隔时间，单位毫秒。Default:1000--><propertyname=""acquireRetryDelay"">1000</property><!--连接关闭时默认将所有未提交的操作回滚。Default:false--><propertyname=""autoCommitOnClose"">false</property><!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default:null--><propertyname=""automaticTestTable"">Test</property><!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。Default:false--><propertyname=""breakAfterAcquireFailure"">false</property><!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException,如设为0则无限期等待。单位毫秒。Default:0--><propertyname=""checkoutTimeout"">100</property><!--通过实现ConnectionTester或QueryConnectionTester的类来测试连接。类名需制定全路径。Default:com.mchange.v2.c3p0.impl.DefaultConnectionTester--><propertyname=""connectionTesterClassName""></property><!--指定c3p0libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可Default:null--><propertyname=""factoryClassLocation"">null</property><!--Stronglydisrecommended.Settingthistotruemayleadtosubtleandbizarrebugs.（文档原文）作者强烈建议不使用的一个属性--><propertyname=""forceIgnoreUnresolvedTransactions"">false</property><!--每60秒检查所有连接池中的空闲连接。Default:0--><propertyname=""idleConnectionTestPeriod"">60</property><!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。Default:3--><propertyname=""initialPoolSize"">3</property><!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default:0--><propertyname=""maxIdleTime"">60</property><!--连接池中保留的最大连接数。Default:15--><propertyname=""maxPoolSize"">15</property><!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default:0--><propertyname=""maxStatements"">100</property><!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。Default:0--><propertyname=""maxStatementsPerConnection""></property><!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能通过多线程实现多个操作同时被执行。Default:3--><propertyname=""numHelperThreads"">3</property><!--当用户调用getConnection()时使root用户成为去获取连接的用户。主要用于连接池连接非c3p0的数据源时。Default:null--><propertyname=""overrideDefaultUser"">root</property><!--与overrideDefaultUser参数对应使用的一个参数。Default:null--><propertyname=""overrideDefaultPassword"">password</property><!--密码。Default:null--><propertyname=""password""></property><!--定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个一显著提高测试速度。注意：测试的表必须在初始数据源的时候就存在。Default:null--><propertyname=""preferredTestQuery"">selectidfromtestwhereid=1</property><!--用户修改系统配置参数执行前最多等待300秒。Default:300--><propertyname=""propertyCycle"">300</property><!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable等方法来提升连接测试的性能。Default:false--><propertyname=""testConnectionOnCheckout"">false</property><!--如果设为true那么在取得连接的同时将校验连接的有效性。Default:false--><propertyname=""testConnectionOnCheckin"">true</property><!--用户名。Default:null--><propertyname=""user"">root</property><!--早期的c3p0版本对JDBC接口采用动态反射代理。在早期版本用途广泛的情况下这个参数允许用户恢复到动态反射代理以解决不稳定的故障。最新的非反射代理更快并且已经开始广泛的被使用，所以这个参数未必有用。现在原先的动态反射与新的非反射代理同时受到支持，但今后可能的版本可能不支持动态反射代理。Default:false--><propertyname=""usesTraditionalReflectiveProxies"">false</property><propertyname=""automaticTestTable"">con_test</property><propertyname=""checkoutTimeout"">30000</property><propertyname=""idleConnectionTestPeriod"">30</property><propertyname=""initialPoolSize"">10</property><propertyname=""maxIdleTime"">30</property><propertyname=""maxPoolSize"">25</property><propertyname=""minPoolSize"">10</property><propertyname=""maxStatements"">0</property><user-overridesuser=""swaldman""></user-overrides></default-config><named-configname=""dumbTestConfig""><propertyname=""maxStatements"">200</property><user-overridesuser=""poop""><propertyname=""maxStatements"">300</property></user-overrides></named-config></c3p0-config>在hibernate.cfg.xml文件里面加入如下的配置：<!--最大连接数--><propertyname=""hibernate.c3p0.max_size"">20</property><!--最小连接数--><propertyname=""hibernate.c3p0.min_size"">5</property><!--获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒--><propertyname=""hibernate.c3p0.timeout"">120</property><!--最大的PreparedStatement的数量--><propertyname=""hibernate.c3p0.max_statements"">100</property><!--每隔120秒检查连接池里的空闲连接，单位是秒--><propertyname=""hibernate.c3p0.idle_test_period"">120</property><!--当连接池里面的连接用完的时候，C3P0一下获取的新的连接数--><propertyname=""hibernate.c3p0.acquire_increment"">2</property><!--每次都验证连接是否可用--><propertyname=""hibernate.c3p0.validate"">true</property>完整示例如下（hibernate.properties）：hibernate.connection.driver_class=org.postgresql.Driverhibernate.connection.url=jdbc:postgresql://localhost/mydatabasehibernate.connection.username=myuserhibernate.connection.password=secrethibernate.c3p0.min_size=5hibernate.c3p0.max_size=20hibernate.c3p0.timeout=1800hibernate.c3p0.max_statements=50hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect注：Hibernate除了期自身的连接池、C3PO连接池以外，还可以使用dbcp包的连接池功能",2015/3/30
323,通过与java对比，迅速掌握groovy,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8968,"Groovy和Java的相同点有：0+,3+,4+,6+,8+,10+,12+,13,14,15,18+,19+,20+,21,22,23,28+,29+,30+,31+,32++表示Groovy不但涵盖了Java的语法，而且还有增强部分Groovy和Java的不同点有：1,2,5,7,9,11,16,17,24,25,26,27，33下面所列序号不分先后顺序：0.在Groovy可以用def定义无类型的变量(定义变量方面def与JavaScript中的var相似)，和返回值为无类型的方法，而在Java中没有defGroovy:classMan{defname=""山风小子""defintroduce(){return""I'm$name""//return可以省略}}1.Java中的equals方法对应Groovy中的==,而Java中的==（判断是否引用同一对象）对应Groovy中的is方法eg.Test1.java:publicclassTest{publicstaticvoidmain(String[]args){Stringname1=""山风小子"";Stringname2=newString(""山风小子"");//Groovy中写为name1==name2if(name1.equals(name2)){System.out.println(""equal"");}else{System.out.println(""notequal"");}//Groovy中写为name1.is(name2)if(name1==name2){System.out.println(""identical"");}else{System.out.println(""notidentical"");}}与Test1.java相对应的Test1.groovy:Stringname1=""山风小子""//你也可以这样写：defname1=""山风小子""其中的def可以理解为JavaScript中定义变量的varStringname2=newString(""山风小子"")//请注意Groovy的句尾的分号时可选的，即可要可不要，前提是一行代码一条语句//Java中写为name1.equals(name2)if(name1==name2){System.out.println(""equal"");}else{System.out.println(""notequal"");}//Java中写为name1==name2if(name1.is(name2)){System.out.println(""identical"");}else{System.out.println(""notidentical"");}2.Java中的数组定义int[]a={1,2,3};在Groovy写成int[]a=[1,2,3]3.Java中的for循环for(inti=0;i<len;i++){...}在Groovy中还可以写成for(iin0..len-1){...}或者for(iin0..<len){...}Java:for(inti=0;i<len;i++){//dosomething}Groovy:for(inti=0;i<len;i++){//dosomething}//或者for(iin0..len-1){//dosomething}//或者for(iin0..<len){//dosomething}4.Java中的方法返回写为return;或者returnobj;在Groovy的方法中return是可选的Java:publicStringsayHello(){return""Hello,山风小子"";}Groovy:publicStringsayHello(){return""Hello,山风小子""}//或者publicStringsayHello(){""Hello,山风小子""}//或者StringsayHello(){""Hello,山风小子""}//或者publicsayHello(){""Hello,山风小子""}//或者defsayHello(){""Hello,山风小子""}5.Java中的innerclass即内部类，在Groovy中用Closure实现（Closure是Java7正在考虑的一个特性，比innerclass在语义方面更完善）6.Groovy中的注释比Java多了首行注释#!，其他与Java相同比如单行注释：//多行注释：/**/或者是支持javadoc的/***/Java:/**多行注释*//***javadoc注释*///单行注释Groovy:#!首行注释，使Unixshell能够定位Groovy启动程序以运行Groovy代码，例如#!/usr/bin/groovy/**多行注释*//***javadoc注释*///单行注释7.Java5中的for-each：for(Typet:iteratable){...}在Groovy中，for(tiniteratable){...}Java:for(Typet:iterable){//dosomething}Groovy:for(tiniterable){//dosomething}8.Groovy中switch语句与Java中相同，不过支持更多类型了，比如String9.Groovy的while语句跟Java相同，但废弃了do-while（考虑到语义方面的问题，而且do-while可以用其他形式的循环语句代替，使用频率低）10.Java中的String常量表示为""Hello,山风小子""，在Groovy中可如下表示//双引号""Hello,山风小子""//单引号也可以'Hello,山风小子'//多行字符串""""""Hello,山风小子""""""//或者'''Hello,山风小子'''//替代字符串defname=""山风小子""""Hello,${name}""//或者""Hello,$name""11.在Groovy中定义类，定义方法与Java中定义类相同，唯一区别在于Groovy中类，属性以及方法默认都是public的，而在Java中默认是package的，另外，在Groovy中可以用def来定义方法，请看注释。Java:publicclassHello{privateStringname=""山风小子"";publicvoidsayHello(){System.out.println(""Hello,""+name);}}Groovy:classHello{privateStringname=""山风小子""publicvoidsayHello(){//println与Java中System.out.println()相同println""Hello,$name""}/*sayHello也可以这样定义defsayHello(){println""Hello,$name""}*/}12.对象创建在Java写为Thoughtt=newThought();在Groovy也可以这样写，不过还多了种写法：deft=newThought();13.静态方法调用在Java和Groovy中相同，即ClassName.staticMethodName();14.实现接口和继承父类方面Groovy也与Java完全相同，即实现接口classClassNameimplementsInterfaceName{...}继承父类：classClassNameextendsSuperClass{...}15.定义接口方面Groovy与Java完全相同，即interfaceInterfaceName{...}//在Groovy中默认为public的16.正则表达式常量在Java中没有，在Groovy中表示为/pattern/17.Hash常量(类型为java.util.HashMap)在Java没有，在Groovy中表示为deffrequence=[""the"":5,""hello"":2,""world"":2]18.类变量即static变量，Groovy与Java相同，staticStringname=""山风小子""，在Groovy也可写为staticname=""山风小子""19.在varargs方法方面，Groovy比Java多一种表达方式，如下所示：Java://Java:publicvoidvarargsMethod(Typeargs){//dosomething}Groovy://与Java中的写法相同defvarargsMethod(Type...args){//dosomething}//Groovy还可以用[]代替...，反应出varargs的本质defvarargsMethod(Type[]args){//dosomething}20.引用当前对象，Groovy和Java相同，在Java中用this表示，在Groovy中也用this表示，而且在Groovy中，this可以出现在static范围中，指向所在类的类对象，本例中，this等同于ThisInStaticScope.class（Java写法）或ThisInStaticScope（Groovy写法）classThisInStaticScope{static{printlnthis}//请不要诧异，参数类型可以省略。如果方法声明中有修饰关键字比如public，synchronized，static等，则返回值类型可以省略。staticmain(args){printlnthis}}21.子类中调用父类方法，Groovy和Java也相同，在Java中super.methodName()，在Groovy中super.methodName()22.命名空间的定义，Groovy和Java相同，在Java中packageedu.ecust.bluesun;在Groovy中packageedu.ecust.bluesun（分号可省略）23.在导入类方面，Groovy和Java相同，在Java中importedu.ecust.bluesun.GroovyTest;在Groovy中importedu.ecust.bluesun.GroovyTest24.List常量(类型为java.util.ArrayList)在Java中没有，在Groovy中表示为deflist=[3,11,""Hello"",""山风小子"",""!""]25.在异常处理方面，Groovy与Java相同，除了不强制程序员捕获检查异常(checkedexception)外(这跟C#很像，如果我没记错的话:)并且在方法声明时，也可以不写throws语句。26.方法的默认参数，Java中没有，Groovy中表示如下：classHello{//如果没有参数传入，默认打印出Hello,山风小子defgreet(name=""山风小子""){println(""Hello,$name"")//也可省略括号()}}27.在Groovy中，语句如果单独占一行的话，句尾的分号(;)可以省略，而在Java中每条语句后面必须跟有分号(;)28.在Groovy中，如果不是Boolean或boolean类型，非null或非空(空字符串，[]，[:])为true，null为false，而Java中对象不可以表示true或false；如果是Boolean或boolean类型，与Java中的一样。29.在Groovy中，万事万物都是对象！而Java中不是这样，基本类型(primitivetype)就不是对象。30.在Java中，Class对象表示为ClassName.class，而在Groovy中，可以直接用ClassName表示Class对象31.Groovy会自动导入java.lang.*,java.util.*,java.net.*,java.io.*,java.math.BigInteger,java.math.BigDecimal,groovy.lang.*,groovy.util.*，而Java则只自动导入java.lang.*32.Groovy不仅有?:三元操作符，还有?:两元操作符，但Java只有?:三元操作符。Groovy:defa=null;//如果a为“空”（null，空串""""，[]，[:]），那么结果为?:之后的那个值;如果不为“空”，那么结果就是adefresult=a?:""defaultresult""printlnresulta=""山风小子""result=a?:""defaultresult""printlnresult33.Groovy能进行多重赋值，但Java不能Groovy:defa,b(a,b)=[1,2]//给a和b赋值println([a,b])(a,b)=[b,a]//交换a和b的值println([a,b])def(c,d)=[1,2]//声明的同时进行初始化println([c,d])",2015/3/30
324,groovy基本语法规则,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8967,"1、没有类型的java作为动态语言，groovy中所有的变量都是对象(类似于.netframework，所有对象继承自java.lang.Object)，在声明一个变量时，groovy不要求强制类型声明，仅仅要求变量名前使用关键字def（从groovyjsr1开始，在以前的版本中，甚至连def都不需要）。修改main方法中的代码：defvar=""helloworld""printlnvarprintlnvar.class你可以看到程序最后输出了var的实际类型为：java.lang.String作为例外，方法参数和循环变量的声明不需要def。2、不需要的public你可以把main方法前面的public去掉，实际上，groovy中默认的修饰符就是public，所以public修饰符你根本就不需要写，这点跟java不一样。3、不需要的语句结束符Groovy中没有语句结束符，当然为了与java保持一致性，你也可以使用;号作为语句结束符。在前面的每一句代码后面加上;号结束，程序同样正常运行(为了接受java程序员的顽固习惯)。4、字符串连接符跟java一样，如果你需要把一个字符串写在多行里，可以使用+号连接字符串。代码可以这样写：defvar=""hello""+""world""+"",groovy!""当然更groovy的写法是：defvar=""""""helloworldgroovy!""""""三个”号之间不在需要+号进行连接（不过字符串中的格式符都会被保留，包括回车和tab）。5、一切皆对象听起来象是“众生平等”的味道，事实上groovy对于对象是什么类型并不关心，一个变量的类型在运行中随时可以改变，一切根据需要而定。如果你赋给它boolean，那么不管它原来是什么类型，它接受boolean值之后就会自动把类型转变为boolean值。看下面的代码：defvar=""hello""+""world""+"",groovy!""printlnvar;printlnvar.class;var=1001printlnvar.class输出结果：helloworld,groovy!classjava.lang.Stringclassjava.lang.Integervar这个变量在程序运行中，类型在改变。一开始给它赋值String，它的类型就是String，后面给它赋值Integer，它又转变为Integer。6、循环删除整个源文件内容，用以下代码替代：defvar=""hello""+""world""+"",groovy!""defrepeat(val){for(i=0;i<5;i++){printlnval}}repeat(var)输出：helloworld,groovy!helloworld,groovy!helloworld,groovy!helloworld,groovy!helloworld,groovy!注意循环变量i前面没有def。当然也没有java中常见的int，但如果你非要加上int也不会有错，因为从Groovy1.1beta2之后开始（不包括1.1beta2），groovy开始支持java经典的for循环写法。此外，上面的for语句还可以写成：for(iin0..5)这样的结果是一样的。7、String和Gstring除了标准的java.lang.String以外（用’号括住），groovy还支持Gstring字符串类型（用“号括住）。把上面的for循环中的语句改成：println""Thisis${i}:${val}""运行一下，你就会明白什么是Gstring。8、范围这个跟pascal中的“子界”是一样的。在前面的for循环介绍中我们已经使用过的for(iin0..5)这样的用法，其中的0..5就是一个范围。范围是一系列的值。例如“0..4”表明包含整数0、1、2、3、4。Groovy还支持排除范围，“0..<4”表示0、1、2、3。还可以创建字符范围：“a..e”相当于a、b、c、d、e。“a..<e”包括小于e的所有值。范围主要在for循环中使用。9、默认参数值可以为方法指定默认参数值。我们修改repeat方法的定义：defrepeat(val,repeat=3){for(iin0..<repeat){println""Thisis${i}:${val}""}}可以看到，repeat方法增加了一个参数repeat（并且给了一个默认值3），用于指定循环次数。当我们不指定第2个参数调用repeat方法时，repeat参数取默认值3。10、集合Groovy支持最常见的两个java集合：java.util.Collection和java.util.Map。前面所说的范围实际也是集合的一种（java.util.List）。(1)CollectionGroovy中这样来定义一个Collection：defcollect=[""a"",""b"",""c""]除了声明时往集合中添加元素外，还可以用以下方式向集合中添加元素：collect.add(1);collect<<""comeon"";collect[collect.size()]=100.0Collection使用类似数组下标的方式进行检索：printlncollect[collect.size()-1]printlncollect[5]groovy支持负索引：printlncollect[-1]//索引其倒数第1个元素printlncollect[-2]//索引其倒数第2个元素Collection支持集合运算：collect=collect+5//在集合中添加元素5printlncollect[collect.size()-1]collect=collect-'a'//在集合中减去元素a(第1个)printlncollect[0]//现在第1个元素变成b了同样地，你可以往集合中添加另一个集合或删除一个集合：collect=collect-collect[0..4]//把集合中的前5个元素去掉printlncollect[0]//现在集合中仅有一个元素，即原来的最后一个元素printlncollect[-1]//也可以用负索引，证明最后一个元素就是第一个元素(2)MapMap是“键-值”对的集合，在groovy中，键不一定是String，可以是任何对象(实际上Groovy中的Map就是java.util.LinkedHashMap)。如此可以定义一个Map:defmap=['name':'john','age':14,'sex':'boy']添加项：map=map+['weight':25]//添加john的体重map.put('length',1.27)//添加john的身高map.father='Keller'//添加john的父亲可以用两种方式检索值：printlnmap['father']//通过key作为下标索引printlnmap.length//通过key作为成员名索引",2015/3/30
325,jquery指定回调函数,周敏,http://180.168.156.212:2262/wecenter/?/article/8966,一、ajax操作的链式写法二、指定同一操作的多个回调函数三、为多个操作指定回调函数四、普通操作的回调函数接口jquery指定回调函数.docx,2015/3/30
326,后端码农谈前端 ------- 定位,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8965,"最近在试图多学习前端技术，这是从网上看到并尝试的内容，忘前端大神多指导！！！1、定位的理解（1）相对定位相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。如果将top设置为20px，那么框将在原位置顶部下面20像素的地方。如果left设置为30像素，那么会在元素左边创建30像素的空间，也就是将元素向右移动。#box_relative{position:relative;left:30px;top:20px;}如下图所示：注意，在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框（2）绝对定位绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。普通流中其它元素的布局就像绝对定位的元素不存在一样：#box_relative{position:absolute;left:30px;top:20px;}如下图所示：绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。注释：根据用户代理的不同，最初的包含块可能是画布或HTML元素。提示：因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其它元素。可以通过设置z-index属性来控制这些框的堆放次序。2、CSS定位属性CSS定位属性允许你对元素进行定位。（1）position把元素放置到一个静态的、相对的、绝对的、或固定的位置中。属性值：absolute：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。元素的位置通过""left"",""top"",""right""以及""bottom""属性进行规定。fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过""left"",""top"",""right""以及""bottom""属性进行规定。relative:生成相对定位的元素，相对于其正常位置进行定位。因此，""left:20""会向元素的LEFT位置添加20像素。static:默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right或者z-index声明）。inherit:规定应该从父元素继承position属性的值。（2）top、right、bottom、left属性描述top定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。right定义了定位元素右外边距边界与其包含块右边界之间的偏移。bottom定义了定位元素下外边距边界与其包含块下边界之间的偏移。left定义了定位元素左外边距边界与其包含块左边界之间的偏移。属性值：auto：默认值。通过浏览器计算上边缘的位置。%：设置以包含元素的百分比计的上边位置。可使用负值。length：使用px、cm等单位设置元素的上边位置。可使用负值。inherit：规定应该从父元素继承top属性的值。（3）overflow设置当元素的内容溢出其区域时发生的事情。属性值：visible:默认值。内容不会被修剪，会呈现在元素框之外。hidden:内容会被修剪，并且其余内容是不可见的。scroll:内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto:如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit:规定应该从父元素继承overflow属性的值。（4）clip设置元素的形状。元素被剪入这个形状之中，然后显示出来。属性值：shape:设置元素的形状。唯一合法的形状值是：rect(top,right,bottom,left)。auto：默认值。不应用任何剪裁。inherit：规定应该从父元素继承clip属性的值。（5）vertical-align设置元素的垂直对齐方式。属性值：baseline:默认。元素放置在父元素的基线上。sub：垂直对齐文本的下标。super：垂直对齐文本的上标top：把元素的顶端与行中最高元素的顶端对齐text-top：把元素的顶端与父元素字体的顶端对齐middle：把此元素放置在父元素的中部。bottom：把元素的顶端与行中最低的元素的顶端对齐。text-bottom：把元素的底端与父元素字体的底端对齐。length%:使用""line-height""属性的百分比值来排列此元素。允许使用负值。inherit:规定应该从父元素继承vertical-align属性的值。（6）z-index:设置元素的堆叠顺序。属性值：auto:默认。堆叠顺序与父元素相等。number:设置元素的堆叠顺序。inherit:规定应该从父元素继承z-index属性的值。",2015/3/27
327,远程调试bug,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8964,"在开发过程中，我们经常会碰到在实际生产环境下发生一个bug，然而，在自己的开发环境下死活模拟不出来，有时甚至把自己的代码直连到产生环境的数据库中，还是模拟不出来问题。想到在服务器上调试吧，那台机器又没装VS，真是痛苦。猛然间发现VS中，在调试界面中，有一个远程调试，想能否利用起来呢:我们试试吧！！总体设想，为远程调试时，不能够修改远程机器的帐户信息，不能进行远程机器重启，同时需要不影响用户现有的操作。第一步：将我们本机开发环境下""VS安装目录""\Common7\IDE\RemoteDebugger下，找到有两个子文件夹：x64和x86，分别对应64位机和32位机，将该目录复制到目标调试机上（随便哪个目录）第二步：运行目录中的""msvsmon.exe""程序，运行后，如果提示下面界面，则请打开防火墙开放以下端口，或直接关闭防火墙。第三步：在启动界面上，打开工具\选项：将身份验证模式改成windows身份验证，如果用无身份验证则将不能调试C#程序，只能调试C++程序。第四步：将运行程序或web部署包，放在目标机上，然后里面一定要放上pdb文件。第五步：在客户端（调试端）机器上，新增一个用户，跟客户机器用户名、密码相同，然后再用这新建的用户登陆，完成后，打开VS代码，然后点击附加到进程：传输选择默认值(请不要选择远程，那个主要调C++)，然后在限定符中输入""用户名@IP""或""用户名@机器名""这时，在下面的可用进程中，就可以找到你的进程，再点附加就可以调试，方法与调试本机程序一至。注意点：如果连接不上远程调试机，或选不到进程，请查看下以下几个有没有设置对：目标机器上，在本地安全设置中，安全设置/本地策略/用户权利指派下面调试程序点击后，看一下服务器当前用户，是否在里面或在里面的组中。网络能够ping通，相应端口是否开通，具体端口可以在远程界面中进行查看设置。本机的用户名密码是否与服务器完全一至。如果调试的是BS程序，即需要调试w3wp进程，这里要特别重视，因为我们一点进入断点，则IE端操作将全部卡住，所以如果这是一个有很多人访问的系统时，请不要这么做，应该另启一个应用程序池，部署一个应用服务，然后代码哪怕可以用同一套，然后用把w3wp时，一定要看好是哪一个用户下的，千万不要把多个w3wp一并选住。记得把dll或exe放在远程机器上时，随时生成的pdb文件也需要复制过去。如果附加进程时，发现断点打上去后是空心的，则需要将PDB文件重新生成了放上去，服务器与本机代码已经不同步了。",2015/3/27
328,前端传值给后台的若干种方式,张加楠,http://180.168.156.212:2262/wecenter/?/article/8963,"前端传值给后台的若干种方式1、最原始的表单方式前端：<formaction=""/library/test""method=""POST""><inputid=""Name""name=""Name""type=""text""value=""""><inputid=""Id""name=""Id""type=""text""value=""""><inputtype=""submit""value=""Save""/></form>后台：[HttpPost]publicActionResultTest(FormCollectionfc){Personperson=newPerson(){Id=fc[""Id""],Name=fc[""Name""]};returnJson(person.Id+""""+person.Name,JsonRequestBehavior.AllowGet);}2、使用MVC默认的模型绑定[HttpPost]publicActionResultTest(Personperson){returnJson(person.Id+""""+person.Name,JsonRequestBehavior.AllowGet);}当前端发送数据后，person已经被填充了因为在MVC中，Person会默认绑定到后台的参数类型（模型绑定器会去去在请求的各种数据中查找对应的上的字段，若找到，则相应的数据到参数person里面）3、自定义modelbinder绑定首先，需要一个实现了IModelBinder接口的类，这个类的作用是依据需求，自定义从请求的各种数据（包括表单、URLQueryString字）中去查找要填充的值。这些请求数据位于IValueProvider中publicclassPersonModelBinder:IModelBinder{publicobjectBindModel(ControllerContextcontrollerContext,ModelBindingContextbindingContext){IValueProviderprovider=bindingContext.ValueProvider;returnnewPerson{Id=provider.GetValue(""Name"").AttemptedValue,//本例中将位于valueProvider请求的数据中key为Name的值赋给IdName=provider.GetValue(""Id"").AttemptedValue};}}然后创建一个特性类，该类实现了CustomModelBinderAttributepublicclassPersonBinderAttribute:CustomModelBinderAttribute{publicoverrideIModelBinderGetBinder(){returnnewPersonModelBinder();}}最后，使用时，在Person参数前，加上刚刚自定义的特性[PersonBinder][HttpPost]publicActionResultTest([PersonBinder]Personperson){//AddIntoDb(person);returnJson(person.Id+""""+person.Name,JsonRequestBehavior.AllowGet);}效果：这样的绑定效果，甚至直接通过访问 的序列化方法$.ajax({url:window.UrlContent(""/Library/Test?tick=""+Math.random()),data:{personStr:personStr},type:""POST"",success:function(result){}});});</script>后台使用Newtonsoft.Jsondll的方法反序列化publicActionResultTest(stringpersonStr){Personperson=JsonConvert.DeserializeObject<Person>(personStr);returnJson(person.Id+""""+person.Name,JsonRequestBehavior.AllowGet);}这种方法的优点是，在前端装配数据时自由度比较大，数据来源不需要仅从表单元素中获取。",2015/3/27
329,Oracle相关概念,盛李欢,http://180.168.156.212:2262/wecenter/?/article/8962,"在Oracle中，常见的数据类型有：字符串：字符串分为定长类型char和变长类型varchar2。数字：整数number(整数位)，小数number(总长度，小数位)，只写number，表示无限制。日期：date类型，可以保存年月日时分秒。问题：Oracle中为什么字符串类型为varchar2,它与varchar有什么关系？回答：在Oracle中，varchar已经作为了保留字。如果你使用varchar类型，Oracle也不会报错，但是建表以后你会发现，已经自动变为了varchar2类型。问题：用number还是用integer(整数)？另外Oracle也有integer等其它类型，但是用integer有缺点，就是不知道其长度，甚至可能在不同的操作系统上(如32位CPU和64位CPU)所分配的长度是不同的。而用number，指定多少，就永远是多少，一切掌握在自己手中。问题：如何为字符串和数字类型指定长度？char类型可以不指定长度，则默认为1,而varchar2必须指定长度。char和varchar类型的长度最大长度大约在4000多一点点。number表示不限整数或小数，它能够保存非常大的数字或者保存小数位非常多的数字。所以为了节约磁盘空间，尽量指定长度。date：不需要指定长度。问题：字符串最大长度约为4000。如果要保存更多的内容怎么办？回答：解决的方法有两种。第一种是用大对象类型，即CLOB或者BLOB类型，但是编程比较麻烦；第二种是用一对多的父子表实现。大对象是指大量的数据。如果用char或varchar2，列的最大长度大约在4000多；如果内容更多，其中一个方法就是将列设置为CLOB类型，但是只限制保存字符数据，如小说。如果是二进制数据，如图片、声音、office文档，则需要将列设置BLOB类型。CLOB或BLOB最大能够装4G的内容。如果是电影，则更通常的做法是在表中保存电影的名称、路径等信息，电影直接保存在磁盘上，而不是直接存储在数据库中，也不是用BFile类型。示例：创建小说表createtablexiao_shuo(xs_idnumber(10)primarykey,--小说编号xs_namevarchar2(5),--小说名称xs_contenctclob,--小说内容xs_fen_mianblob--小说封面(图片));第二种是利用父子表实现，例如：小说表(小说ID，小说标题)，内容表(小说ID，行数，行内容)，其中行内容为varchar(4000)。这表示每一行最多保存4000个字符。重点问题：定长类型和变长类型和什么区别？回答：两者主要的区别体现在存储上和查询效率上。首先讲char——定长类型。如将姓名列指定为char(8)。当保存“张三”时，数据库还会自动保存4个空格；保存“张三丰”时，数据库还会自动保存2个空格，这样每个人的姓名长度都为8，长度是固定的，所以叫做“定长”。明显，在保存信息时，定长会因为保存了很空格而多占用了磁盘空间。数据库保存这些“多余”的空格有什么作用？那就是查询时，在取到字段的长度以后，不再需要判断每一个姓名的实际长度，就可以取到数据。这样查询效率大大提高了。下面再讲varchar2——变长类型。如将姓名列指定为varchar2(8)。当保存“张三”和保存“张三丰”时，数据库都只保存数据的本身，不会自动添加空格。两个人姓名的长度分别为4和6，长度是变化的，所以叫做“变长”。这样没有多占用任何磁盘空间。但是在查询时，每个人的姓名的长度都不同，必须先判断后取数据，所以查询效率比char类型要低。",2015/3/27
330,电子商务网站互联网安全防御攻略,张加楠,http://180.168.156.212:2262/wecenter/?/article/8961,"1.信息传输加密https使用对称加密还是非对称加密？对称加密使用DES还是AES？非对称加密使用RSA还是DSA？使用什么加密算法，在购买证书的时候就要确定。一般是用RSA2048位。SSL证书需要不需要购买？不需要购买的理由-我们使用HTTPS的目的就是希望服务器与客户端之间传输内容是加密的，防止中间监听泄漏信息，去证书服务商那里申请证书不划算，因为使用服务的都是固定客户和自己内部人士，所以我们自己给自己颁发证书，忽略掉浏览器的不信任警报即可；需要购买的理由-用户体验好、专业性强。双向验证还是单向验证？单向验证验证的是服务器；双向验证服务器客户端互相验证。对于服务器来讲，单向验证能够保证传输的数据加密过了；双向验证不仅保证传输数据加密，还能够保证客户端来源的安全性。如果使用双向验证的话，需要客户端浏览器导入证书。出于客户体验的考虑，大部分https网站使用的都是单向验证(比如 *=等；特殊表达式检查，如1=11=2a'or'a'='a等；定期分析防火墙日志；服务器主动对外发起的连接；TFTP协议FTP协议数据；定期分析数据库日志同14.数据库安全防护条目提及的""访问日志""条；数据库备份记录；新库、新表建立记录；存储过程执行记录；数据的导入导出记录；定期分析IDS日志；搜索SQL攻击记录的分析；WEB端口连接IP分布以及请求分布；定期检查WEB目录文件；关键字搜索检查；文件修改时间检查；文件最后访问时间检查；特殊文件名文件检查；上传文件夹检查；文件大小检查；16.网站运行监控没有监控的网站，犹如盲人骑瞎马，夜半临深渊而不知，生死尚且未卜，就更别说提高可用性、减少故障率、监测黑客入侵了。",2015/3/27
331,js定时器setTimeout()使用实例:10秒自动跳转,盛李欢,http://180.168.156.212:2262/wecenter/?/article/8981,"####10秒自动跳转Html代码<divclass=""jf_register""><h2>您好，欢迎光临<fmt:messagekey=""b2cShowName""/>！<aclass=""blue""href=""<%=path%>/LoginRegist_turnToLogin"">请登录</a></h2></div><divclass=""jf_register_banner"">注册成功</div><divclass=""jf_password""><ul><li>感谢您选择<fmt:messagekey=""b2cShowName""/>，</li><li>您的账号<span><fontcolor=red><strong>${param.bussinessId}</strong></font></span>已经注册成功。</li><li>系统将会在<strongid=""endtime""></strong>秒后跳转到登录页！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<aclass=""blue""href=""<%=path%>/LoginRegist_turnToLogin"">直接登录</a></li></ul></div><divclass=""jf_loginfooter""><fmt:messagekey=""copyright""/>&nbsp;版权所有&nbsp;|<ahref=""Login_loginHelpTips"">联系我们</a><fmt:messagekey=""copyrightIcp""/></div><scripttype=""text/javascript"">vari=10;functionremainTime(){if(i==0){location.href='<%=path%>';}document.getElementById('endtime').innerHTML=i--;setTimeout(""remainTime()"",1000);}remainTime();</script>",2015/3/27
332,java.sql.Types的具体对应值、常见数据库字段类型与java.sql.Types的对应,余礼华,http://180.168.156.212:2262/wecenter/?/article/8960,"java.sql.Types的具体对应值:publicfinalstaticintBIT=-7;publicfinalstaticintTINYINT=-6;publicfinalstaticintSMALLINT=5;publicfinalstaticintINTEGER=4;publicfinalstaticintBIGINT=-5;publicfinalstaticintFLOAT=6;publicfinalstaticintREAL=7;publicfinalstaticintDOUBLE=8;publicfinalstaticintNUMERIC=2;publicfinalstaticintDECIMAL=3;publicfinalstaticintCHAR=1;publicfinalstaticintVARCHAR=12;publicfinalstaticintLONGVARCHAR=-1;publicfinalstaticintDATE=91;publicfinalstaticintTIME=92;publicfinalstaticintTIMESTAMP=93;publicfinalstaticintBINARY=-2;publicfinalstaticintVARBINARY=-3;publicfinalstaticintLONGVARBINARY=-4;publicfinalstaticintNULL=0;publicfinalstaticintOTHER=1111;publicfinalstaticintJAVA_OBJECT=2000;publicfinalstaticintDISTINCT=2001;publicfinalstaticintSTRUCT=2002;publicfinalstaticintARRAY=2003;publicfinalstaticintBLOB=2004;publicfinalstaticintCLOB=2005;publicfinalstaticintREF=2006;publicfinalstaticintDATALINK=70;publicfinalstaticintBOOLEAN=16;publicfinalstaticintROWID=-8;publicstaticfinalintNCHAR=-15;publicstaticfinalintNVARCHAR=-9;publicstaticfinalintLONGNVARCHAR=-16;publicstaticfinalintNCLOB=2011;publicstaticfinalintSQLXML=2009;[color=blue][/color][size=large][/size]常见数据库字段类型与java.sql.Types的对应Oracle与java.sql.Types的对应Oraclejava.sql.Typesblobblobcharcharclobclobdatedatenumberdecimallongvarbinarynclob,nvarchar2othersmallintsmallinttimestamptimstamprawvarbinaryvarchar2varcharSqlserver与java.sql.Types的对应Sqlserverjava.sql.Typesbigint(2005,2008)biginttimstamp,binarybinarybitbitchar,nchar,unqualifiedchardatetimedatemoney,smallmoney,decimaldecimalfloat(2005,2008)doublefloat(2000)floatintintegerimagelongvarbinarytext,ntext,xmllongvarcharnumericnumericrealrealsmallintsmallintdatetime,smalldatetimetimestamptinyinttinyintvarbinaryvarbinaynvarchar,varcharvarcharDB2与java.sql.Types的对应bigintbigintblobblobcharacter,graphiccharclobclobdatedatedecimaldecimaldoubledoubleintegerintegerlongvargraphiclongvarcharlongvarcharrealrealsmallintsmallinttimetimetimestamptimestampvargraphicvarcharvarcharMySQL与java.sql.Types的对应MySQLjava.sql.Typesbigintbiginttinyblobbinarybitbitenum,set,charchardate,yeardatedecimal,numericdecimaldouble,realdoublemediumint,intintegerblob,mediumblobbloblongblobfloatrealsmallintsmallinttimetimetimestamp,datetimetimestamptinyinttinyintvarbinary,binaryvarbinayvarchar,tinytext,textvarcharSybase与java.sql.Types的对应Sybasejava.sql.Typesbinarybinarybitbitchar,nchar,charmoney,smallmoney,decimaldecimalfloatdoubleintintegerimagelongvarbinarytextlongvarcharnumericnumericrealrealsmallintsmallintdatetime,smalldatetimetimestamptinyinttinyintvarbinar,timestampvarbinaynvarchar,varchar,sysnamevarchar",2015/3/26
333,一个方便的在线工具：在线代码格式化,余礼华,http://180.168.156.212:2262/wecenter/?/article/8959,在线代码格式化： xml可以做以下格式化：HTML格式化XML格式化CSS格式化JSON格式化JavaScript格式化Java格式化SQL格式化挺方便的。,2015/3/26
334,浅谈程序员的数学修养,余礼华,http://180.168.156.212:2262/wecenter/?/article/8958,可能有很多朋友在网上看过google公司早几年的招聘广告，它的第一题如下了：{first10-digitprimefoundinconsecutivedigitse}.com，e中出现的连续的第一个10个数字组成的质数。据说当时这个试题在美国很多地铁的出站口都有大幅广告，只要正确解答了这道题，在浏览器的地址栏中输入这个答案，就可以进入下一轮的测试，整个测试过程如同一个数学迷宫，直到你成为google的一员。又如Intel某年的一道面试题目：巴拿赫病故于1945年8月31日。他的出生年份恰好是他在世时某年年龄的平方，问：他是哪年出生的？这道看似很简单的数学问题，你能不能能快地解答呢？下面则是一道世界第一大软件公司微软的招聘测试题：中间只隔一个数字的两个素数被称为素数对，比如5和7，17和19，证明素数对之间的数字总能被6整除(假设这两个素数都大于6)，现在证明没有由三个素数组成的素数对。这样的试题还有很多很多，这些题目乍初看上去都是一些数学问题。但是世界上一些著名的公司都把它们用于招聘测试，可见它们对新员工数学基础的重视。数学试题与应用程序试题是许多大型软件公司面试中指向性最明显的一类试题，这些试题就是考察应聘者的数学能力与计算机能力。某咨询公司的一名高级顾问曾说：微软是一家电脑软件公司，当然要求其员工有一定的计算机和数学能力，面试中自然就会考察这类能力。微软的面试题目就考察了应聘人员对基础知识的掌握程度、对基础知识的应用能力，甚至暗含了对计算机基本原理的考察。所以，这样的面试题目的确很“毒辣”，足以筛选到合适的人。四川大学数学学院的曹广福教授曾说过：“一个大学生将来的作为与他的数学修养有很大的关系”。大学计算机专业学生都有感触，计算机专业课程中最难的几门课程莫过于离散数学、编译原理、数据结构，当然像组合数学、密码学、计算机图形学等课程也令许多人学起来相当吃力，很多自认为数据库学得很好的学生在范式、函数依赖、传递依赖等数学性比较强的概念面前感到力不从心，这些都是因为数学基础或者说数学知识的缺乏所造成的。数学是计算机的基础，这也是为什么考计算机专业研究生数学都采用最难试题（数学一）的原因，当然这也能促使一些新的交叉学科如数学与应用软件、信息与计算科学专业等飞速发展。许多天才程序员本身就是数学尖子，众所周知，BillGates的数学成绩一直都很棒，他甚至曾经期望当一名数学教授，他的母校——湖滨中学的数学系主任弗雷福·赖特曾这样谈起过他的学生：“他能用一种最简单的方法来解决某个代数或计算机问题，他可以用数学的方法来找到一条处理问题的捷径，我教了这么多年的书，没见过像他这样天分的数学奇才。他甚至可以和我工作过多年的那些优秀数学家媲美。当然，比尔也各方面表现得都很优秀，不仅仅是数学，他的知识面非常广泛，数学仅是他众多特长之一。”。影响一代中国程序人的金山软件股份有限公司董事长求伯君当年高考数学成绩满分进一步说明了问题。很多数学基础很好的人，一旦熟悉了某种计算机语言，他可以很快地理解一些算法的精髓，使之能够运用自如，并可能写出时间与空间复杂度都有明显改善的算法。程序设计当中解决的相当一部分问题都会涉及各种各样的科学计算，这需要程序员具有什么样的基础呢？实际问题转换为程序，要经过一个对问题抽象的过程，建立起完善的数学模型，只有这样，我们才能建立一个设计良好的程序。从中我们不难看出数学在程序设计领域的重要性。算法与计算理论是计算机程序设计领域的灵魂所在，是发挥程序设计者严谨，敏锐思维的有效工具，任何的程序设计语言都试图将之发挥得淋漓尽致。程序员需要一定的数学修养，不但是编程本身的需要，同时也是培养逻辑思维以及严谨的编程作风的需要。数学可以锻炼我们的思维能力，可以帮助我们解决现实中的问题。可以帮助我们更高的学习哲学。为什么经常有人对一些科学计算程序一筹莫展，他可以读懂每一行代码，但是却无法预测程序的预测结果，甚至对程序的结构与功能也一知半解，给他一个稍微复杂点的数学公式，他可能就不知道怎么把它变成计算机程序。很多程序员还停留在做做简单的MIS，设计一下MDI，写写简单的Class或用SQL语句实现查询等基础的编程工作上，对于一些需要用到数学知识的编程工作就避而远之，当然实现一个累加程序或者一个税率的换算程序还是很容易的，因为它们并不需要什么高深的数学知识。一名有过10多年开发经验的老程序员曾说过：“所有程序的本质就是逻辑。技术你已经较好地掌握了，但只有完成逻辑能力的提高，你才能成为一名职业程序员。打一个比方吧，你会十八般武艺，刀枪棍棒都很精通，但就是力气不够，所以永远都上不了战场，这个力气对程序员而言就是逻辑能力(其本质是一个人的数学修养，注意，不是数学知识)。”程序员的数学修养不是一朝一夕就可以培养的。数学修养与数学知识不一样，修养需要一个长期的过程，而知识的学习可能只是一段短暂的时间。下面是一些我个人对于程序员如何提高与培养自己的数学修养的基本看法。首先，应该意识到数学修养的重要性。作为一个优秀的程序员，一定的数学修养是十分重要也是必要的。数学是自然科学的基础，计算机科学实际上是数学的一个分支。计算机理论其实是很多数学知识的融合，软件工程需要图论，密码学需要数论，软件测试需要组合数学，计算机程序的编制更需要很多的数学知识，如集合论、排队论、离散数学、统计学，当然还有微积分。计算机科学一个最大的特征是信息与知识更新速度很快，随着数学知识与计算机理论的进一步结合，数据挖掘、模式识别、神经网络等分支科学得到了迅速发展，控制论、模糊数学、耗散理论、分形科学都促进了计算机软件理论、信息管理技术的发展。严格的说，一个数学基础不扎实的程序不能算一个合格的程序员，很多介绍计算机算法的书籍本身也就是数学知识的应用与计算机实现手册。其次，自身数学知识的积累，培养自己的空间思维能力和逻辑判断能力。数学是一门分支众多的学科，我们无法在短暂的一生中学会所有的数学知识，像泛函理论、混沌理论以及一些非线性数学问题不是三五几天就可以掌握的。数学修养的培养并不在与数学知识的多少，但要求程序员有良好的数学学习能力，能够很快地把一些数学知识和自己正在解决的问题联系起来，很多理学大师虽然不是数学出身，但是他们对数学有很强的理解能力和敏锐的观察力，于是一系列新的学科诞生了，如计算化学、计算生物学、生物信息学、化学信息学、计算物理学，计算材料学等等。数学是自然学科的基础，计算机技术作为理论与实践的结合，更需要把数学的一些精髓融入其中。从计算机的诞生来看它就是在数学的基础上产生的，最简单的0、1进制就是一个古老的数学问题。程序设计作为一项创造性很强的职业，它需要程序员有一定的数学修养，也具有一定的数学知识的积累，可以更好地把一些数学原理与思想应用于实际的编程工作中去。学无止境，不断的学习是提高修养的必经之路。第三，多在实践中运用数学。有些高等学校开设了一门这样的课程——《数学建模》。我在大学时期也曾学过，这是一门内容很丰富的课程。它把很多相关的学科与数学都联系在一起，通过很多数学模型来解决实际的生产生活问题，很多问题的解决需要计算机程序来实现。我在大学和研究生阶段都参加过数学建模竞赛，获得了不少的经验，同时也进一步提高了自己的数学修养。实际上，现在的程序设计从某些角度来看就是一个数学建模的过程，模型的好坏关系到系统的成败，现在数学建模的思想已经用于计算机的许多相关学科中，不单只是计算机程序设计与算法分析。应该知道，数学是一门需要在实践中展示其魅力的科学，而计算机程序也是为帮助解决实际问题而编制的，因此，应该尽量使它们结合起来，在这个方面，计算机密码学是我认为运用数学知识最深最广泛的，每一个好的加密算法后面都有一个数学理论的支持，如椭圆曲线、背包问题、素数理论等。作为一名优秀的程序员，应该在实际工作中根据需要灵活运用数学知识，培养一定的数学建模能力，善于归纳总结，慢慢使自己的数学知识更加全面，数学修养得到进一步提高。第四，程序员培养制度与教学的改革。许多程序员培养体制存在很多缺陷，一开始就要求学员能够快速精通某种语言，以语言为中心，对算法的核心思想与相关的数学知识都一笔带过，讲得很少，这造成很多程序员成为背程序的机器，这样不利于程序员自身的快速成长，也不利于程序员解决新问题。我在长期的程序员培训与计算机教学工作采用了一些与传统方式不一致的方法，收到了一定的效果。很多初学程序的人往往写程序时有时候会有思维中断，或者对一些稍难的程序觉得无法下手，我采用了一些课前解决数学小问题的方法来激励大家的学习兴趣，这些小问题不单单是脑筋急转弯，其中不少是很有代表意义的数学思考题。通过数学问题来做编程的热身运动，让学员在数学试题中激发自己的思维能力，记得有位专家曾经说过，经常做做数学题目会使自己变聪明，很长时间不去接触数学问题会使自己思维迟钝。通过一些经典的数学问题来培养学员的思维的严谨性和跳跃性。很多人可能不以为然，其实有些看似简单的问题并不一定能够快速给出答案，大脑也是在不断的运用中变更加灵活的。不信吗？大家有兴趣可以做做下面这道题目，看看能不能在1分钟之内想到答案，这只是一道小学数学课后习题。很多人认为自己的数学基础很好，但是据说这道题目90%以上的人不能在一个小时内给出正确答案。试试，如果你觉得我说的是错的。证明：AB+AC>DB+DC（D为三角形ABC的一个内点）。最后，多学多问，多看好书，看经典。我在这里向大家推荐两部可能大家已经很熟悉的经典的计算机算法教材，它们中间很多内容其实就是数学知识的介绍。第一部是《算法导论》，英文名称：IntroductiontoAlgorithms，作者：ThomasH.Cormen，CharlesE.Leiserson，RonaldL.Rivest，CliffordStein。本书的主要作者来自麻省理工大学计算机，作者之一RonaldL.Rivest由于其在公开秘钥密码算法RSA上的贡献获得了图灵奖。这本书目前是算法的标准教材，美国许多名校的计算机系都使用它，国内有些院校也将本书作为算法课程的教材。另外许多专业人员也经常引用它。本书基本包含了所有的经典算法，程序全部由伪代码实现，这更增添了本书的通用性，使得利用各种程序设计语言进行程序开发的程序员都可以作为参考。语言方面通俗，很适合作为算法教材和自学算法之用。另一部是很多人都应该知道的Donald.E.Knuth所著《计算机程序设计艺术》，英文名称：TheArtofComputerProgramming。Donald.E.Knuth人生最辉煌的时刻在斯坦福大学计算机系渡过，美国计算机协会图灵奖的获得者，是本领域内当之无愧的泰斗。有戏言称搞计算机程序设计的不认识Knuth就等于搞物理的不知道爱因斯坦，搞数学的不知道欧拉，搞化学的不知道道尔顿。被简称为TAOCP的这本巨著内容博大精深，几乎涵盖了计算机程序设计算法与理论最重要的内容。现在发行的只有三卷，分别为基础运算法则，半数值算法，以及排序和搜索（在写本文之际，第四卷已经出来了，我也在第一时间抢购了一本）。本书结合大量数学知识，分析不同应用领域中的各种算法，研究算法的复杂性，即算法的时间、空间效率，探讨各种适用算法等，其理论和实践价值得到了全世界计算机工作者的公认。书中引入的许多术语、得到的许多结论都变成了计算机领域的标准术语和被广泛引用的结果。另外，作者对有关领域的科学发展史也有深入研究，因此本书介绍众多研究成果的同时，也对其历史渊源和发展过程做了很好的介绍，这种特色在全球科学著作中是不多见的。至于本书的价值我觉得BillGates先生的话足以说明问题：“如果你认为你是一名真正优秀的程序员读Knuth的《计算机程序设计艺术》，如果你能读懂整套书的话，请给我发一份你的简历”。作者数学方面的功底造就了本书严谨的风格，虽然本书不是用当今流行的程序设计语言描述的，但这丝毫不损伤它“程序设计史诗”的地位。道理很简单，它内涵的设计思想是永远不会过时的。除非英语实在有困难，否则建议读者选用英文版。我个人就是阅读的该书的英文版，虽然花了不少money和时间，但是收获颇丰，值得。总之，要想成为一名有潜力有发展前途的程序员，或者想成为程序员中的佼佼者，你一定要培养良好的数学修养。切记：对于一名能够灵活自如编写各种程序的人，数学是程序的灵魂。,2015/3/26
335,【转】解析JSON对象与字符串之间的相互转换,余礼华,http://180.168.156.212:2262/wecenter/?/article/8957,"本篇文章主要是对JSON对象与字符串之间的相互转换进行了详细的介绍，需要的朋友可以过来参考下，希望对大家有所帮助在开发的过程中，如果对于少量参数的前后台传递，可以直接采用ajax的data函数，按json格式传递，后台Request即可，但有的时候，需要传递多个参数，这样后台接受的时候Request多个很麻烦，此时要按照类的格式或者集合的形式进行传递。例如：前台按类的格式传递JSON对象：varjsonUserInfo=""{\""TUserName\"":\""""+userName+""\"",\""TInterest\"":\""""+interest+""\"",\""TSex\"":\""""+sex+""\"",\""TCity\"":\""""+city+""\"",\""TDetail\"":\""""+detail+""\""}"";如拼出的jsonUserInfo无转义符号，需要varjsonArrayFinal=JSON.stringify(jsonArray);进行转换后再传递。代码如下:$.ajax({type:""post"",url:""ReceiveHandler1.ashx"",data:{userInfo:jsonUserInfo,flag:""123456"",key:""654321""},dataType:""text"",success:function(data){$(""#divShow"").html(data);}});如果前台传递多个类格式的JSON数组，也就是集合类型：例如：[{""name"":""a""},{""name"",""b""},{""name"",""c""}]，则无法传递，此时必须使用JSON.stringify将数组对象转换成字符串，再进行AJAX传递即可。比如我有两个变量，我要将a转换成字符串，将b转换成JSON对象：vara={""name"":""tom"",""sex"":""男"",""age"":""24""};varb='{""name"":""Mike"",""sex"":""女"",""age"":""29""}';在Firefox，chrome，opera，safari，ie9，ie8等高级浏览器直接可以用JSON对象的stringify()和parse()方法。JSON.stringify(obj)将JSON转为字符串。JSON.parse(string)将字符串转为JSON格式；上面的转换可以这么写：vara={""name"":""tom"",""sex"":""男"",""age"":""24""};varb='{""name"":""Mike"",""sex"":""女"",""age"":""29""}';varaToStr=JSON.stringify(a);varbToObj=JSON.parse(b);alert(typeof(aToStr));//stringalert(typeof(bToObj));//objectJSON.stringify()ie8(兼容模式),ie7和ie6没有JSON对象，不过 提供了一个json.js,这样ie8(兼容模式),ie7和ie6就可以支持JSON对象以及其stringify()和parse()方法；你可以在 。ie8(兼容模式),ie7和ie6可以使用eval()将字符串转为JSON对象，varc='{""name"":""Mike"",""sex"":""女"",""age"":""29""}';varcToObj=eval(""(""+c+"")"");alert(typeof(cToObj));jQuery中也有将字符串转为JSON格式的方法jQuery.parseJSON(json)，接受一个标准格式的JSON字符串，并返回解析后的JavaScript（JSON）对象。当然如果有兴趣可以自己封装一个jQuery扩展，jQuery.stringifyJSON(obj)将JSON转为字符串。",2015/3/26
336,转《燃烧吧，狗日的生活》,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8956,时值单位里做一个大型项目，我连续加班两个月，没有休一个周末。几乎每天忙到夜里2点上床，早晨6点醒来。劳碌命就是这样，明明筋疲力尽，但心里挂着事儿，就睡不着。不论再累，闹钟定在6点半，却总是在6点就醒来，默默关上它，起床，头疼欲裂地刷牙，换衣。带着上坟一般的心情，去上班。疲惫是能让人麻木的。已经熬了太久了，就靠惯性连轴转。琐事，杂事，大大小小层出不穷的问题，声音，任务，电话，几百人的吃喝拉撒。感觉全身每一个细胞都被工作的齿轮挤榨出汁水。一个个干瘪下去。到最后几乎人畜不分了。那天下午，因为考察团的大巴司机脾气暴躁，且没走高速，被大老板知道了，他一通电话轰到我的办公室来，不分青红皂白把我骂了个劈头盖脸。熬了这么久，如马拉松最后的三公里，已经不知道什么是筋疲力尽了，本以为百炼成钢，却还是在那通电话的瞬间，我突然很崩溃，哭到上气不接下气。原来人最受不了的，不是吃苦。而是你不知道，你这份苦，吃来为什么。想起这两个月来累死累活的日子，真是谁知盘中餐，粒粒皆辛苦。到头来，不过是被吃饭的人尝了一口，咬到一粒砂，便破口大骂，整盒米饭扔掉。什么叫人长大了，人长大了就是遇到这种事，哭完，整理了声音和情绪，继续淡定加班到晚上9点，像平常那样收拾东西回家。当然，什么叫人老去了，老去了就是遇到这种事，压根再不会哭了。走出大楼，抬头一看，月光清寒，只一镰皎光，静静悬着。暗蓝苍穹，层云如海。不知怎的，想起诗人的一句“天空一无所有，为何给我安慰”，眼底微微一阵发潮。月色至静，办公楼背后的空地上，一台破收音机嚷着俗不可耐的印度舞音乐，巨大声。一群大妈在欢快地跳健身操，围成一大圈，活像僵尸一般，平举双手，一个接一个，缓缓绕圈转动。她们的表情如此欢快，看上去很无辜。让我忍不住想——如果这辈子就是这样，从青春到暮年，不过每天上班下班，退休了在空地上跳跳“坝坝舞”，是不是等于白活了。够了，去你的，狗日的生活。仁至义尽地搞完了项目那摊子事儿之后，我心平气和地去辞职了。毕竟是有选择的人，我本来就不指望那600元的工资和1000元的绩效过活。两千字的辞职信里，我写得有些悲壮淋漓，“不愿意多年后回过头去看，一生爬过的高峰，只有上下班高峰。”所有领导都通情达理，表示理解，说，让你呆在这里的确屈才了。我们也不明白为什么你要来这里。本来以为就此顺顺利利走人了事了，从此再他妈懒得工作了，只管周游世界，喂马劈柴，关心粮食和蔬菜。可是没有想到，就在发了邮件那天夜里，大老板（就是电话里骂我的那个）他却不让我走。也是身居高位的人了，深更半夜给我回邮件，写一长串话挽留我，说“我也会改正我做事的方式”。末了，又追加一封单独的邮件：“真的不要走！！！”五个字，啪啪啪三个感叹号。第二天是一上午的工作会议，足足开到中午一点半。后来我走了，他还在继续开会。却给我发来一条短信，“不要走了。”搞得我一下子乱了阵脚：像言情电视剧里面，长期婚姻不和，大丈夫打算出轨寻求新生活，老婆却突然来挽留似的。和一个热爱潜水的朋友，说起了这些事。十年的老朋友了，我和她在QQ上聊，对她说，“你懂的，我绝不是因为吃不下这份苦，耐不住这份寂寞，而逃避生活。只是觉得人生苦短，如此下去没有意义。”她说：“我明白。”就像我，我从未把旅行当作生活的逃避。也可能是当成了，自己不愿意承认。我发现，我之所以这么热爱潜水，就是因为我发现我没法对付好岸上的世界，根本没有在复杂的现实生活中保持身心自由的能力。”我们辞职，旅行……但我们终归都要回到生活中来。生活就是，不论你是在巴黎，在布宜诺斯艾利斯，在鞍山，还是在大理，你都需要一个房间，一张床，需要衣食住行。做一个良心未泯的，入世的人罢，要承认，我们都没办法做到彻底遁世，周游世界喂马劈柴。一个人要承认自己的局限，是很不容易的。曾经我比谁都爱宣扬那一套东西——就像那个大名人在脱口秀里面说的那样：“你不约会、不谈恋爱、不出去玩、不喝酒、不逛街、不疯不闹、不叛逆、不追星、不暗恋、不表白、不聚会、不k歌、不撒野，因为你要学习，你要工作。请问你的青春被狗吃了么？”但我现在，更想问那个大名人：“你是靠约会恋爱出去玩喝酒逛街疯闹叛逆追星暗恋表白聚会K歌撒野，才成为你的吗？”抱歉我还是要再提一次这条微博：“你苦战通宵时，布里斯班的灯鱼已划过珊瑚丛；你赶场招聘会时，蒙巴萨的小蟹刚溜出渔夫的掌心；你写程序代码时，布拉格的电车正晃过金色夕阳……”但我现在，只想说，对于我们绝大多数投胎技术活不好，不是富二代官二代的人来说，不苦战通宵，不赶招聘会，不写程序代码，怎么可能有钱，有能力，去看布里斯班的灯鱼，去蒙巴萨看渔夫，去布拉格看夕阳？别扯了。我能明白，人人都爱美丽与精致的东西。虚构于银幕或纸面的生活，往往优裕，奢华，精致，悠闲。面孔美丽身材高挑的年轻男女，白天坐在咖啡店聊天，晚上在夜店狂欢，没完没了的朋友聚会和环球旅行；早晨起床的时候也是一脸精致妆容，发型一丝不乱，没有眼屎，也不用急着尿尿，而是深情款款和恋人展开措辞考究的对话。当然，这情有可原。除却商业因素大众审美不谈，可能是现实生活已然如此苍白刻薄，使我们十足疲惫；难得休息一刻，因此宁愿看一些美丽而轻松的虚构。但你懂的，虚构是虚构，生活是生活。制造那个虚构的人，自己都不是按照虚构中那样生活的。所以别上当了。努力学习，努力工作，就等于青春被狗吃了吗？每天挤公交挤地铁，按时上班下班的日子，反而是毫无意义了的吗？去你的。所有的，旅行，暗恋，K歌，追星，吃喝玩乐……都只是人生的点缀。你知道你不可能这样度过一生。除非你只想苦修投胎术，成为一个X二代。那么所有的X一代，都是奋斗过的。要照那一套理论来说的话，他们的青春，都是被狗吃了的；他们曾经拼命学习和工作的日子，都是毫无意义的。毕竟，就连傍富婆和傍大款，都是需要学习，需要忍耐，需要做工作的；还有梦碎的危险。是的，我们在高三时做过的那些该死的题，和我们现在工作中这些该死的事情，那些艰苦时吃的泡面，跑客户时骑过的自行车，都没有意义。但是我们必须要经过这些无意义，才能累积成一个有意义的人生。《云图》中说，一滴水，不是海。但一滴水都没有，永远不会有海。扯远了。这个故事的结局就是，我并未一意孤行，而是暂时接受了他们的挽留；因为挽留，就像嫉妒，是一个人对另一个人最大的肯定。弱者总是在自己感觉最糟糕的时候，辞职离开，寄希望于环境的改变能带来点儿什么；而强者，是在自己感觉最好的时候，辞职离开，寻求更高更远的天地。这话不是我说的，俞敏洪说的。大意如此。要相信你所做的，总有意义。燃烧吧，狗日的生活。,2015/3/26
337,JS内存泄漏排查方法-Chrome Profiles,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8955,"一、概述GoogleChrome浏览器提供了非常强大的JS调试工具，HeapProfiling便是其中一个。HeapProfiling可以记录当前的堆内存（heap）快照，并生成对象的描述文件，该描述文件给出了当时js运行所用到的所有对象，以及这些对象所占用的内存大小、引用的层级关系等等。这些描述文件为内存泄漏的排查提供了非常有用的信息。注意：本文里的所有例子均基于GoogleChrome浏览器。什么是heapJS运行的时候，会有栈内存（stack）和堆内存（heap），当我们用new实例化一个类的时候，这个new出来的对象就保存在heap里面，而这个对象的引用则存储在stack里。程序通过stack里的引用找到这个对象。例如vara=[1,2,3];，a是存储在stack里的引用，heap里存储着内容为[1,2,3]的Array对象。二、HeapProfiling打开工具打开Chrome浏览器（版本25.0.1364.152m），打开要监视的网站（这里以游戏大厅为例），按下F12调出调试工具，点击“Profiles”标签。可以看到下图：JS内存泄漏排查方法-ChromeProfiles可以看到，该面板可以监控CPU、CSS和内存，选中“TakeHeapSnapshot”，点击“Start”按钮，就可以拍下当前JS的heap快照，如下图所示：JS内存泄漏排查方法-ChromeProfiles右边视图列出了heap里的对象列表。由于游戏大厅使用了Quark游戏库，所以这里可以清楚地看到Quark.XXX之类的类名称（即Function对象的引用名称）。注意：每次拍快照前，都会先自动执行一次GC，所以在视图里的对象都是可及的。视图解释列字段解释：Constructor—类名Distance—估计是对象到根的引用层级距离ObjectsCount—给出了当前有多少个该类的对象ShallowSize—对象所占内存（不包含内部引用的其它对象所占的内存）(单位：字节)RetainedSize—对象所占总内存（包含内部引用的其它对象所占的内存）(单位：字节)下面解释一下部分类名称所代表的意思：(compiledcode)—未知，估计是程序代码区(closure)—闭包(array)—未知Object—JS对象类型(system)—未知(string)—字符串类型，有时对象里添加了新属性，属性的名称也会出现在这里Array—JS数组类型cls—游戏大厅特有的继承类Window—JS的window对象Quark.DisplayObjectContainer—Quark引擎的显示容器类Quark.ImageContainer—Quark引擎的图片类Quark.Text—Quark引擎的文本类Quark.ToggleButton—Quark引擎的开关按钮类对于cls这个类名，是由于游戏大厅的继承机制里会使用“cls”这个引用名称，指向新建的继承类，所以凡是使用了该继承机制的类实例化出来的对象，都放在这里。例如程序中有一个类ClassA，继承了Quark.Text，则new出来的对象是放在cls里，不是放在Quark.Text里。查看对象内容点击类名左边的三角形，可以看到所有该类的对象。对象后面的“@70035”表示的是该对象的ID（有人会错认为是内存地址，GC执行后，内存地址是会变的，但对象ID不会）。把鼠标停留在某一个对象上，会显示出该对象的内部属性和当时的值。JS内存泄漏排查方法-ChromeProfiles这个视图有助于我们辨别这是哪个对象。但该视图跟踪不了是被谁引用了。查看对象的引用关系点击其中一个对象，能看到对象的引用层级关系，如下图：JS内存泄漏排查方法-ChromeProfilesObject’sretainingtree视图显示出了该对象被哪些对象引用了，以及这个引用的名称。图中的这个对象被5个对象引用了，分别是：一个cls对象的_txtContent变量；一个闭包函数的context变量；同一个闭包函数的self变量；一个数组对象的0位置；一个Quark.Tween对象的target变量。看到context和self这两个引用，可以知道这个Quark.Text对象使用了JS常用的上下文绑定机制，被一个闭包里的变量引用着，相当于该Quark.Text对象多了两个引用，这种情况比较容易出现内存泄漏，如果闭包函数不释放，这个Quark.Text对象也释放不了。展开_textContent，可以看到下一级的引用：JS内存泄漏排查方法-ChromeProfiles把这个树状图反过来看，可以看到，该对象(ID@70035)其中的一条引用链是这样的：GameListV_curV_gameListV省略...\|/\|/_noticeWidget|_noticeC|_noticeV|_txtContent||Quark.Text@70035内存快照的对比通过快照对比的功能，可以知道程序在运行期间哪些对象变更了。刚才已经拍下了一个快照，接下来再拍一次，如下图：JS内存泄漏排查方法-ChromeProfiles点击图中的黑色实心圆圈按钮，即可得到第二个内存快照：JS内存泄漏排查方法-ChromeProfiles然后点击图中的“Snapshot2”，视图才会切换到第二次拍的快照。JS内存泄漏排查方法-ChromeProfiles点击图中的“Summary”，可弹出一个列表，选择“Comparison”选项，结果如下图：JS内存泄漏排查方法-ChromeProfiles这个视图列出了当前视图与上一个视图的对象差异。列名字段解释：#New—新建了多少个对象#Deleted—回收了多少个对象#Delta—对象变化值，即新建的对象个数减去回收了的对象个数SizeDelta—变化的内存大小(字节)注意Delta字段，尤其是值大于0的对象。下面以Quark.Tween为例子，展开该对象，可看到如下图所示：JS内存泄漏排查方法-ChromeProfiles在“#New”列里，如果有“.”，则表示是新建的对象。在“#Deleted”列里，如果有“.”，则表示是回收了的对象。平时排查问题的时候，应该多拍几次快照进行对比，这样有利于找出其中的规律。三、内存泄漏的排查JS程序的内存溢出后，会使某一段函数体永远失效（取决于当时的JS代码运行到哪一个函数），通常表现为程序突然卡死或程序出现异常。这时我们就要对该JS程序进行内存泄漏的排查，找出哪些对象所占用的内存没有释放。这些对象通常都是开发者以为释放掉了，但事实上仍被某个闭包引用着，或者放在某个数组里面。观察者模式引起的内存泄漏有时我们需要在程序中加入观察者模式（Observer）来解藕一些模块，但如果使用不当，也会带来内存泄漏的问题。排查这类型的内存泄漏问题，主要重点关注被引用的对象类型是闭包（closure）和数组Array的对象。下面以德州扑克游戏为例：JS内存泄漏排查方法-ChromeProfilesJS内存泄漏排查方法-ChromeProfiles测试人员发现德州扑克游戏存在内存溢出的问题，重现步骤：进入游戏–退出到分区–再进入游戏–再退出到分区，如此反复几次便出现游戏卡死的问题。排查的步骤如下：1.打开游戏；2.进入第一个分区（快速场5/10）；3.进入后，拍下内存快照；4.退出到刚才的分区界面；5.再次进入同一个分区；6.进入后，再次拍下内存快照；7.重复步骤2到6，直到拍下5组内存快照；8.将每组的视图都转换到Comparison对比视图；9.进行内存对比分析。经过上面的步骤后，可以得到下图结果：JS内存泄漏排查方法-ChromeProfiles先看最后一个快照，可以看到闭包（closure）+1，这是需要重点关注的部分。（string）、（system）和（compiledcode）类型可以不管，因为提供的信息不多。JS内存泄漏排查方法-ChromeProfiles接着点击倒数第二个快照，看到闭包（closure）类型也是+1。JS内存泄漏排查方法-ChromeProfiles接着再看上一个快照，闭包还是+1。这说明每次进入游戏都会创建这个闭包函数，并且退出到分区的时候没有销毁。展开（closure），可以看到非常多的function对象：JS内存泄漏排查方法-ChromeProfiles建新的闭包数量是49个，回收的闭包数量是48个，即是说这次操作有48个闭包正确释放了，有一个忘记释放了。每个新建和回收的function对象的ID都不一样，找不到任何的关联性，无法定位是哪一个闭包函数出了问题。接下来打开Object’sretainingtree视图，查找引用里是否存在不断增大的数组。如下图，展开“Snapshot5”每个function对象的引用：JS内存泄漏排查方法-ChromeProfiles其中有个function对象的引用deleFunc存放在一个数组里，下标是4，数组的对象ID是@45599。继续查找“Snapshot4”的function对象：JS内存泄漏排查方法-ChromeProfiles发现这里有一个function的引用名称也是deleFunc，也存放在ID为@45599的数组里，下标是3。这个对象极有可能是没有释放掉的闭包。继续查看“Snapshot3”里的function对象：JS内存泄漏排查方法-ChromeProfiles从图中可以看到同一个function对象，下标是2。那么这里一定存在内存泄漏问题。数组下面有一个引用名称“login_success”，在程序里搜索一下该关键字，终于定位到有问题的代码。因为进入游戏的时候注册了“login_success”通知：ob.addListener(""login_success"",_onLoginSuc);但退出到分区的时候，没有移除该通知，下次进入游戏的时候，又再注册了一次，所以造成function不断增加。改成退出到分区的时候移除该通知：ob.removeListener(""login_success"",_onLoginSuc);这样就成功解决这个内存泄漏的问题了。德州扑克这种问题多数见于观察者设计模式中，使用一个全局数组存储所有注册的通知，如果忘记移除通知，则该数组会不断增大，最终造成内存溢出。上下文绑定引起的内存泄漏很多时候我们会用到上下文绑定函数bind（也有些人写成delegate），无论是自己实现的bind方法还是JS原生的bind方法，都会有内存泄漏的隐患。下面举一个简单的例子：<br/>varClassA=function(name){<br/>this.name=name;<br/>this.func=null;<br/>};<br/><br/>vara=newClassA(""a"");<br/>varb=newClassA(""b"");<br/><br/>b.func=bind(function(){<br/>console.log(""Iam""+this.name);<br/>},a);<br/><br/>b.func();//输出Iama<br/><br/>a=null;//释放a<br/>//b=null;//释放b<br/><br/>//模拟上下文绑定<br/>functionbind(func,self){<br/>returnfunction(){<br/>returnfunc.apply(self);<br/>};<br/>};<br/>上面的代码中，bind通过闭包来保存上下文self，使得事件b.func里的this指向的是a，而不是b。首先我们把b=null;注释掉，只释放a。看一下内存快照：JS内存泄漏排查方法-ChromeProfiles可以看到有两个ClassA对象，这与我们的本意不相符，我们释放了a，应该只存在一个ClassA对象b才对。JS内存泄漏排查方法-ChromeProfiles从上面两个图可以看出这两个对象中，一个是b，另一个并不是a，因为a这个引用已经置空了。第二个ClassA对象是bind里的闭包的上下文self，self与a引用同一个对象。虽然a释放了，但由于b没有释放，或者b.func没有释放，使得闭包里的self也一直存在。要释放self，可以执行b=null或者b.func=null。把代码改成：<br/>varClassA=function(name){<br/>this.name=name;<br/>this.func=null;<br/>};<br/><br/>vara=newClassA(""a"");<br/>varb=newClassA(""b"");<br/><br/>b.func=bind(function(){<br/>console.log(""Iam""+this.name);<br/>},a);<br/><br/>b.func();//输出Iama<br/>a=null;//释放a<br/><br/>b.func=null;//释放self<br/><br/>//模拟上下文绑定<br/>functionbind(func,self){<br/>returnfunction(){<br/>returnfunc.apply(self);<br/>};<br/>};<br/>再看看内存：JS内存泄漏排查方法-ChromeProfiles可以看到只剩下一个ClassA对象b了，a已被释放掉了。四、结语JS的灵活性既是优点也是缺点，平时写代码时要注意内存泄漏的问题。当代码量非常庞大的时候，就不能仅靠复查代码来排查问题，必须要有一些监控对比工具来协助排查。之前排查内存泄漏问题的时候，总结出以下几种常见的情况：1.闭包上下文绑定后没有释放；2.观察者模式在添加通知后，没有及时清理掉；3.定时器的处理函数没有及时释放，没有调用clearInterval方法；4.视图层有些控件重复添加，没有移除。",2015/3/26
338,关于js当中一些糟糕的特性,周敏,http://180.168.156.212:2262/wecenter/?/article/8980,"首先，不可否认,js是一门具有许多优秀特性的弱类型语言，但是这门语言在设计之初就投入了工程实践，没有经历严格的实验室测试，以致力于它是如此的粗糙，在相当长的一段时间很不受开发者待见，被视为一门玩具性的语言，而且有些特性确实设计的很糟糕，今天就这些糟糕的特性我就具体谈一谈。1.js当中首要的最糟糕的特性应该要数它对全局变量的依赖性。什么是全局变量？也就是对所有域都开放，能在任意时间、任意部分对其进行修改，这极大地降低了程序的可靠性。其次对于大型项目而言，随着业务拓展，代码量的增加，程序越来越庞大，子程序当中的变量命名很有可能与全局变量出现命名冲突，这很有可能导致程序无法正常运行。最理想的设计就是整个程序只有一个全局变量，这一点可以利用闭包来实现。2.作用域。js没有块级作用域，只有函数作用域，，在变量声明的不符合一般习惯，当然这里也可以利用闭包来模拟块级作用域。3.保留字。js里面有许多不会使用但会保留的单词，如class，它们不能被命名成变量或参数，用作对象声明的属性名时必须加引号，以保留字做对象属性的名字，不能通过点表示法来访问，只能通过括号表示法来访问。4.typeof运算符。typeof运算符用于返回一个对象所属的基本类型，如:typeof1返回number，但是很可惜在typeofnull中返回的是object，而我们更期望它返回的是null，因为返回object毫无意义。5.浮点数。二进制浮点数不能正确地处理十进制小数，如0.1+0.2的结果绝不可能是0.3。这是遵循二进制浮点数算术标准造成的，这有点不合我们一直所学的数学知识，如果不了解个中原因会造成一定的误导，不过对于整数的处理倒是精确的。6.NaN.这表示一个特殊的数量值，但它不是一个数字，尽管typeofNaN===""number""(在这里又要吐槽一下typeof了，太坑了)。要注意NaN并不等于它本身，即NaN!==NaN(这是true。切记!!!)。NaN的产生主要是你想要将一个非数字的字符串转化成数字而产生。7.伪数组。严格意义上来说，JavaScript上没有真正的数组，它里面的数组实际上是一个属性名为整数，且具有一个length属性的对象，在运行效率上比不上真正的数组，但是我们不必担心发生越界错误。通过typeof无法判断数组和对象。一个看起来比较可靠的判断一个值是数组的程序可能是这样:if(value&&typeofvalue===""object""&&value.constructor===Array){//value是数组}，但是在不同帧或窗口创建的数组会得到false，下面的程序是我所知最可靠的检测数组的程序，下面分享给大家，代码如下:if(value&&typeofvalue===""object""&&typeofvalue.length===""number""&&typeofvalue.splice===""function""&&!(value.propertyIsEnumerable(""length""))){//value是一个数组};当然JavaScript糟糕的特性还不止上面这些，比如还有自动插入分号导致return换行以后返回值是undefined，Unicode字符，parseInt函数，连接符""+""，假值等等。",2015/3/25
339,静态html传参数,何文,http://180.168.156.212:2262/wecenter/?/article/8954,"a.html<html><head><body><ahref=""c.html?test=大师大师""target=""_blank"">aaaaaaaaaaa</a></body></html><html><head><body><ahref=""c.html?test=大师大师""target=""_blank"">aaaaaaaaaaa</a></body></html>c.html<html><head><scriptlanguage=""javascript"">functiongetParameter(param){varquery=window.location.search;//获取URL地址中？后的所有字符variLen=param.length;//获取你的参数名称长度variStart=query.indexOf(param);//获取你该参数名称的其实索引if(iStart==-1)//-1为没有该参数return"""";iStart+=iLen+1;variEnd=query.indexOf(""&"",iStart);//获取第二个参数的其实索引if(iEnd==-1)//只有一个参数returnquery.substring(iStart);//获取单个参数的参数值returnquery.substring(iStart,iEnd);//获取第二个参数的值}functioninit(){varparam=getParameter(""test"");document.getElementById(""a"").value=param;}</script></head><bodyonload=""init()"">thisisatest<br><inputid=""a""type=""text""/></body></html><html><head><scriptlanguage=""javascript"">functiongetParameter(param){varquery=window.location.search;//获取URL地址中？后的所有字符variLen=param.length;//获取你的参数名称长度variStart=query.indexOf(param);//获取你该参数名称的其实索引if(iStart==-1)//-1为没有该参数return"""";iStart+=iLen+1;variEnd=query.indexOf(""&"",iStart);//获取第二个参数的其实索引if(iEnd==-1)//只有一个参数returnquery.substring(iStart);//获取单个参数的参数值returnquery.substring(iStart,iEnd);//获取第二个参数的值}functioninit(){varparam=getParameter(""test"");document.getElementById(""a"").value=param;}</script></head><bodyonload=""init()"">thisisatest<br><inputid=""a""type=""text""/></body></html>",2015/3/19
340,OFD与PDF的关联和差异,王链玮,http://180.168.156.212:2262/wecenter/?/article/8953, ,2015/3/19
341,写给Web开发人员看的HTML5教程,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8952,写给web开发人员看的html5教程通过结合大量实际案例和源代码对html5的重要特性进行了详细讲解，内容全面丰富，易于理解。全书共分为12章，从html5的历史故事讲起，涉及了文档结构和语义、智能表单、视频与音频、画布、svg与mathml、地理定位、web存储与离线web应用程序、websockets套接字、webworker多线程、微数据以及以拖曳为代表的一些全局属性，涵盖了html5所有的重要特性。此外，《写给web开发人员看的html5教程》还提供了大量的案例源代码，供读者在学习过程中参考，帮助读者提升html5的实际应用技能。第1章web标准概述1第2章文档结构和语义17第3章智能表单31第4章视频与音频59第5章画布91第6章svg与mathml153第7章地理定位159第8章web存储及离线web应用程序177第9章网页套接字199第10章多线程215第11章微数据225第12章写在最后：一些全局属性235下载地址： /s/17V96X,2015/3/19
342,【NULLS】Oracle对SQL排序后NULL值位置的“特殊关照”,丁凯,http://180.168.156.212:2262/wecenter/?/article/8951,"Oralce对NULL值的排序后的位置有一个特殊的“关照”，这就是“NULLSFIRST”和“NULLSLAST”选项，使用这个选项便可以在SQL排序中强制指定NULL值出现的位置（是显示在最前，还是显示在最后）。演示并总结在此，供参考。1.创建演示表T并初始化7条数据sec@ora10g>createtablet(xint);sec@ora10g>insertintotvalues(1);sec@ora10g>insertintotvalues(2);sec@ora10g>insertintotvalues(3);sec@ora10g>insertintotvalues(4);sec@ora10g>insertintotvalues(null);sec@ora10g>insertintotvalues(null);sec@ora10g>insertintotvalues(null);sec@ora10g>commit;2.不加“关照”的orderby升序排序效果--NULL值在后。sec@ora10g>select*fromtorderbyx;X----------12347rowsselected.3.不加“关照”的orderby降序排序效果--NULL值在前。sec@ora10g>select*fromtorderbyxdesc;X----------43217rowsselected.4.特殊“关照”的orderby升序排序效果--NULL值在前。sec@ora10g>select*fromtorderbyxnullsfirst;X----------12347rowsselected.5.特殊“关照”的orderby降序排序效果--NULL值在后。sec@ora10g>select*fromtorderbyxdescnullslast;X----------43217rowsselected.6.规律总结1）不加“关照”的情况下，我们可以把那些NULL值假想为所有内容中值是最大的，因此，升序排序后NULL值在最后，倒序排序后NULL值在最前！2）特殊“关照”的情况下，当指定“NULLSFIRST”时，无论是升序排序还是倒序排序，NULL值都会排列在最前面；当指定“NULLSLAST”时，无论是升序排序还是倒序排序，NULL值都会排列在最后面。7.Oracle官方文档中有关“NULLSFIRST|NULLSLAST”的参考内容 #i2171079摘录在此：NULLSFIRST|NULLSLASTSpecifywhetherreturnedrowscontainingnullvaluesshouldappearfirstorlastintheorderingsequence.NULLSLASTisthedefaultforascendingorder,andNULLSFIRSTisthedefaultfordescendingorder.8.小结通过这篇内容的介绍，我们可以看到Oracle的确是无微不至。有了这个NULL值位置的强制方法，我们在书写SQL时的灵活性和可控性便可进一步得到加强。Goodluck.secooler10.01.30--TheEnd--",2015/3/16
343,JAVA正则表达式 Pattern和Matcher,丁凯,http://180.168.156.212:2262/wecenter/?/article/8950,"java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。1.简介：java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern和MatcherPattern一个Pattern是一个正则表达式经编译后的表现模式。Matcher一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。以下我们就分别来看看这两个类：2.Pattern类:Pattern的方法如下：staticPatterncompile(Stringregex)将给定的正则表达式编译并赋予给Pattern类staticPatterncompile(Stringregex,intflags)同上，但增加flag参数的指定，可选的flag参数包括：CASEINSENSITIVE,MULTILINE,DOTALL,UNICODECASE，CANONEQintflags()返回当前Pattern的匹配flag参数.Matchermatcher(CharSequenceinput)生成一个给定命名的Matcher对象staticbooleanmatches(Stringregex,CharSequenceinput)编译给定的正则表达式并且对输入的字串以该正则表达式为模开展匹配,该方法适合于该正则表达式只会使用一次的情况，也就是只进行一次匹配工作，因为这种情况下并不需要生成一个Matcher实例。Stringpattern()返回该Patter对象所编译的正则表达式。String[]split(CharSequenceinput)将目标字符串按照Pattern里所包含的正则表达式为模进行分割。String[]split(CharSequenceinput,intlimit)作用同上，增加参数limit目的在于要指定分割的段数，如将limi设为2，那么目标字符串将根据正则表达式分为割为两段。一个正则表达式，也就是一串有特定意义的字符，必须首先要编译成为一个Pattern类的实例，这个Pattern对象将会使用matcher()方法来生成一个Matcher实例，接着便可以使用该Matcher实例以编译的正则表达式为基础对目标字符串进行匹配工作，多个Matcher是可以共用一个Pattern对象的。现在我们先来看一个简单的例子，再通过分析它来了解怎样生成一个Pattern对象并且编译一个正则表达式，最后根据这个正则表达式将目标字符串进行分割：复制代码代码如下:importjava.util.regex.*;publicclassReplacement{publicstaticvoidmain(String[]args)throwsException{//生成一个Pattern,同时编译一个正则表达式Patternp=Pattern.compile(""[/]+"");//用Pattern的split()方法把字符串按""/""分割String[]result=p.split(""Kevinhasseen《LEON》sevealtimes,becauseitisagoodfilm.""+""/凯文已经看过《这个杀手不太冷》几次了，因为它是一部""+""好电影。/名词:凯文。"");for(inti=0;i<result.length;i++)System.out.println(result[i]);}}输出结果为：Kevinhasseen《LEON》sevealtimes,becauseitisagoodfilm.凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。名词:凯文。很明显，该程序将字符串按""/""进行了分段，我们以下再使用split(CharSequenceinput,intlimit)方法来指定分段的段数，程序改动为：tring[]result=p.split(""Kevinhasseen《LEON》sevealtimes,becauseitisagoodfilm./凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。/名词:凯文。""，2);这里面的参数""2""表明将目标语句分为两段。输出结果则为：Kevinhasseen《LEON》sevealtimes,becauseitisagoodfilm.凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。/名词:凯文。由上面的例子，我们可以比较出java.util.regex包在构造Pattern对象以及编译指定的正则表达式的实现手法与我们在上一篇中所介绍的Jakarta-ORO包在完成同样工作时的差别，Jakarta-ORO包要先构造一个PatternCompiler类对象接着生成一个Pattern对象，再将正则表达式用该PatternCompiler类的compile()方法来将所需的正则表达式编译赋予Pattern类：PatternCompilerorocom=newPerl5Compiler();Patternpattern=orocom.compile(""REGULAREXPRESSIONS"");PatternMatchermatcher=newPerl5Matcher();但是在java.util.regex包里，我们仅需生成一个Pattern类，直接使用它的compile()方法就可以达到同样的效果:Patternp=Pattern.compile(""[/]+"");因此似乎java.util.regex的构造法比Jakarta-ORO更为简洁并容易理解。3.Matcher类:Matcher方法如下：MatcherappendReplacement(StringBuffersb,Stringreplacement)将当前匹配子串替换为指定字符串，并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个StringBuffer对象里。StringBufferappendTail(StringBuffersb)将最后一次匹配工作后剩余的字符串添加到一个StringBuffer对象里。intend()返回当前匹配的子串的最后一个字符在原目标字符串中的索引位置。intend(intgroup)返回与匹配模式里指定的组相匹配的子串最后一个字符的位置。booleanfind()尝试在目标字符串里查找下一个匹配子串。booleanfind(intstart)重设Matcher对象，并且尝试在目标字符串里从指定的位置开始查找下一个匹配的子串。Stringgroup()返回当前查找而获得的与组匹配的所有子串内容Stringgroup(intgroup)返回当前查找而获得的与指定的组匹配的子串内容intgroupCount()返回当前查找所获得的匹配组的数量。booleanlookingAt()检测目标字符串是否以匹配的子串起始。booleanmatches()尝试对整个目标字符展开匹配检测，也就是只有整个目标字符串完全匹配时才返回真值。Patternpattern()返回该Matcher对象的现有匹配模式，也就是对应的Pattern对象。StringreplaceAll(Stringreplacement)将目标字符串里与既有模式相匹配的子串全部替换为指定的字符串。StringreplaceFirst(Stringreplacement)将目标字符串里第一个与既有模式相匹配的子串替换为指定的字符串。Matcherreset()重设该Matcher对象。Matcherreset(CharSequenceinput)重设该Matcher对象并且指定一个新的目标字符串。intstart()返回当前查找所获子串的开始字符在原目标字符串中的位置。intstart(intgroup)返回当前查找所获得的和指定组匹配的子串的第一个字符在原目标字符串中的位置。（光看方法的解释是不是很不好理解？不要急，待会结合例子就比较容易明白了）一个Matcher实例是被用来对目标字符串进行基于既有模式（也就是一个给定的Pattern所编译的正则表达式）进行匹配查找的，所有往Matcher的输入都是通过CharSequence接口提供的，这样做的目的在于可以支持对从多元化的数据源所提供的数据进行匹配工作。我们分别来看看各方法的使用：★matches()/lookingAt()/find()：一个Matcher对象是由一个Pattern对象调用其matcher()方法而生成的，一旦该Matcher对象生成,它就可以进行三种不同的匹配查找操作：matches()方法尝试对整个目标字符展开匹配检测，也就是只有整个目标字符串完全匹配时才返回真值。lookingAt()方法将检测目标字符串是否以匹配的子串起始。find()方法尝试在目标字符串里查找下一个匹配子串。以上三个方法都将返回一个布尔值来表明成功与否。★replaceAll()/appendReplacement()/appendTail()：Matcher类同时提供了四个将匹配子串替换成指定字符串的方法：replaceAll()replaceFirst()appendReplacement()appendTail()replaceAll()与replaceFirst()的用法都比较简单，请看上面方法的解释。我们主要重点了解一下appendReplacement()和appendTail()方法。appendReplacement(StringBuffersb,Stringreplacement)将当前匹配子串替换为指定字符串，并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个StringBuffer对象里，而appendTail(StringBuffersb)方法则将最后一次匹配工作后剩余的字符串添加到一个StringBuffer对象里。例如，有字符串fatcatfatcatfat,假设既有正则表达式模式为""cat""，第一次匹配后调用appendReplacement(sb,""dog""),那么这时StringBuffersb的内容为fatdog，也就是fatcat中的cat被替换为dog并且与匹配子串前的内容加到sb里，而第二次匹配后调用appendReplacement(sb,""dog"")，那么sb的内容就变为fatdogfatdog，如果最后再调用一次appendTail（sb）,那么sb最终的内容将是fatdogfatdogfat。还是有点模糊？那么我们来看个简单的程序：//该例将把句子里的""Kelvin""改为""Kevin""importjava.util.regex.*;publicclassMatcherTest{publicstaticvoidmain(String[]args)throwsException{//生成Pattern对象并且编译一个简单的正则表达式""Kelvin""Patternp=Pattern.compile(""Kevin"");//用Pattern类的matcher()方法生成一个Matcher对象Matcherm=p.matcher(""KelvinLiandKelvinChanarebothworkinginKelvinChen'sKelvinSoftShopcompany"");StringBuffersb=newStringBuffer();inti=0;//使用find()方法查找第一个匹配的对象booleanresult=m.find();//使用循环将句子里所有的kelvin找出并替换再将内容加到sb里while(result){i++;m.appendReplacement(sb,""Kevin"");System.out.println(""第""+i+""次匹配后sb的内容是：""+sb);//继续查找下一个匹配对象result=m.find();}//最后调用appendTail()方法将最后一次匹配后的剩余字符串加到sb里；m.appendTail(sb);System.out.println(""调用m.appendTail(sb)后sb的最终内容是:""+sb.toString());}}最终输出结果为：第1次匹配后sb的内容是：Kevin第2次匹配后sb的内容是：KevinLiandKevin第3次匹配后sb的内容是：KevinLiandKevinChanarebothworkinginKevin第4次匹配后sb的内容是：KevinLiandKevinChanarebothworkinginKevinChen'sKevin调用m.appendTail(sb)后sb的最终内容是：KevinLiandKevinChanarebothworkinginKevinChen'sKevinSoftShopcompany.看了上面这个例程是否对appendReplacement()，appendTail()两个方法的使用更清楚呢，如果还是不太肯定最好自己动手写几行代码测试一下。★group()/group(intgroup)/groupCount()：该系列方法与我们在上篇介绍的Jakarta-ORO中的MatchResult.group()方法类似(有关Jakarta-ORO请参考上篇的内容)，都是要返回与组匹配的子串内容，下面代码将很好解释其用法：importjava.util.regex.*;publicclassGroupTest{publicstaticvoidmain(String[]args)throwsException{Patternp=Pattern.compile(""(ca)(t)"");Matcherm=p.matcher(""onecat,twocatsintheyard"");StringBuffersb=newStringBuffer();booleanresult=m.find();System.out.println(""该次查找获得匹配组的数量为：""+m.groupCount());for(inti=1;i<=m}}输出为：该次查找获得匹配组的数量为：2第1组的子串内容为：ca第2组的子串内容为：tMatcher对象的其他方法因比较好理解且由于篇幅有限，请读者自己编程验证。4．一个检验Email地址的小程序：最后我们来看一个检验Email地址的例程，该程序是用来检验一个输入的EMAIL地址里所包含的字符是否合法，虽然这不是一个完整的EMAIL地址检验程序，它不能检验所有可能出现的情况，但在必要时您可以在其基础上增加所需功能。复制代码代码如下:importjava.util.regex.*;publicclassEmail{publicstaticvoidmain(String[]args)throwsException{Stringinput=args[0];//检测输入的EMAIL地址是否以非法符号"".""或""@""作为起始字符Patternp=Pattern.compile(""^.|^@"");Matcherm=p.matcher(input);if(m//检测是否以""www.""为起始p=Pattern.compile(""^www."");m=p.matcher(input);if(m//检测是否包含非法字符p=Pattern.compile(""[^A-Za-z0-9.@_-~#]+"");m=p.matcher(input);StringBuffersb=newStringBuffer();booleanresult=m.find();booleandeletedIllegalChars=false;while(result){//如果找到了非法字符那么就设下标记deletedIllegalChars=true;//如果里面包含非法字符如冒号双引号等，那么就把他们消去，加到SB里面m.appendReplacement(sb,"""");result=m.find();}m.appendTail(sb);input=sb.toString();if(deletedIllegalChars){System.out.println(""输入的EMAIL地址里包含有冒号、逗号等非法字符，请修改"");System.out.println(""您现在的输入为:""+args[0]);System.out.println(""修改后合法的地址应类似:""+input);}}}例如，我们在命令行输入：javaEmailwww.kevin@163.net""rel=""nofollow""target=""_blank"">www.kevin@163.net那么输出结果将会是：EMAIL地址不能以'www.'起始如果输入的EMAIL为@kevin@163.net则输出为：EMAIL地址不能以'.'或'@'作为起始字符当输入为：cgjmail#$%@163.net那么输出就是：输入的EMAIL地址里包含有冒号、逗号等非法字符，请修改您现在的输入为:cgjmail#$%@163.net修改后合法的地址应类似:cgjmail@163.net",2015/3/16
344,Java的内存回收机制,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8949,"在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，这两方面工作都是由JVM自动完成的，降低了Java程序员的学习难度，避免了像C/C++直接操作内存的危险。但是，也正因为内存管理完全由JVM负责，所以也使Java很多程序员不再关心内存分配，导致很多程序低效，耗内存。因此就有了Java程序员到最后应该去了解JVM，才能写出更高效，充分利用有限的内存的程序。1.Java在内存中的状态首先我们先写一个代码为例子：Person.javapackagetest;importjava.io.Serializable;publicclassPersonimplementsSerializable{staticfinallongserialVersionUID=1L;Stringname;//姓名Personfriend;//朋友publicPerson(){}publicPerson(Stringname){super();this.name=name;}}Test.javapackagetest;publicclassTest{publicstaticvoidmain(String[]args){Personp1=newPerson(""Kevin"");Personp2=newPerson(""Rain"");Personp3=newPerson(""Sunny"");p1.friend=p2;p3=p2;p2=null;}}把上面Test.java中main方面里面的对象引用画成一个从main方法开始的对象引用图的话就是这样的（顶点是对象和引用，有向边是引用关系）：当程序运行起来之后，把它在内存中的状态看成是有向图后，可以分为三种：1）可达状态：在一个对象创建后，有一个以上的引用变量引用它。在有向图中可以从起始顶点导航到该对象，那它就处于可达状态。2）可恢复状态：如果程序中某个对象不再有任何的引用变量引用它，它将先进入可恢复状态，此时从有向图的起始顶点不能再导航到该对象。在这个状态下，系统的垃圾回收机制准备回收该对象的所占用的内存，在回收之前，系统会调用finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态。3）不可达状态：当对象的所有关联都被切断，且系统调用finalize()方法进行资源清理后依旧没有使该对象变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源。上述三种状态的转换图如下：2.Java对对象的4种引用1）强引用：创建一个对象并把这个对象直接赋给一个变量，eg：Personperson=newPerson(“sunny”);不管系统资源有么的紧张，强引用的对象都绝对不会被回收，即使他以后不会再用到。2）软引用：通过SoftReference类实现，eg:SoftReference<Person>p=newSoftReference<Person>(newPerson(“Rain”));,内存非常紧张的时候会被回收，其他时候不会被回收，所以在使用之前要判断是否为null从而判断他是否已经被回收了。3）弱引用：通过WeakReference类实现，eg:WeakReference<Person>p=newWeakReference<Person>(newPerson(“Rain”));不管内存是否足够，系统垃圾回收时必定会回收。4）虚引用：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference类和引用队列ReferenceQueue类联合使用实现，eg：packagetest;importjava.lang.ref.PhantomReference;importjava.lang.ref.ReferenceQueue;publicclassTest{publicstaticvoidmain(String[]args){//创建一个对象Personperson=newPerson(""Sunny"");//创建一个引用队列ReferenceQueue<Person>rq=newReferenceQueue<Person>();//创建一个虚引用，让此虚引用引用到person对象PhantomReference<Person>pr=newPhantomReference<Person>(person,rq);//切断person引用变量和对象的引用person=null;//试图取出虚引用所引用的对象//发现程序并不能通过虚引用访问被引用对象，所以此处输出为nullSystem.out.println(pr.get());//强制垃圾回收System.gc();System.runFinalization();//因为一旦虚引用中的对象被回收后，该虚引用就会进入引用队列中//所以用队列中最先进入队列中引用与pr进行比较，输出trueSystem.out.println(rq.poll()==pr);}}运行结果：3.Java垃圾回收机制其实Java垃圾回收主要做的是两件事：1）内存回收2）碎片整理3.1垃圾回收算法1）串行回收（只用一个CPU）和并行回收（多个CPU才有用）：串行回收是不管系统有多少个CPU，始终只用一个CPU来执行垃圾回收操作，而并行回收就是把整个回收工作拆分成多个部分，每个部分由一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但复杂度增加，另外也有一些副作用，如内存碎片增加。2）并发执行和应用程序停止：应用程序停止（Stop-the-world）顾名思义，其垃圾回收方式在执行垃圾回收的同时会导致应用程序的暂停。并发执行的垃圾回收虽然不会导致应用程序的暂停，但由于并发执行垃圾需要解决和应用程序的执行冲突（应用程序可能在垃圾回收的过程修改对象），因此并发执行垃圾回收的系统开销比Stop-the-world高，而且执行时需要更多的堆内存。3）压缩和不压缩和复制：①支持压缩的垃圾回收器（标记-压缩=标记清除+压缩）会把所有的可达对象搬迁到一端，然后直接清理掉端边界以外的内存，减少了内存碎片。②不压缩的垃圾回收器（标记-清除）要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片③复制式的垃圾回收器：将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。3.2堆内存的分代回收1）分代回收的依据：①对象生存时间的长短：大部分对象在Young期间就被回收②不同代采取不同的垃圾回收策略：新（生存时间短）老（生存时间长）对象之间很少存在引用2)堆内存的分代：①Young代：Ⅰ回收机制：因为对象数量少，所以采用复制回收。Ⅱ组成区域：由1个Eden区和2个Survivor区构成，同一时间的两个Survivor区，一个用来保存对象，另一个是空的；每次进行Young代垃圾回收的时候，就把Eden，From中的可达对象复制到To区域中，一些生存时间长的就复制到了老年代，接着清除Eden，From空间，最后原来的To空间变为From空间，原来的From空间变为To空间。Ⅲ对象来源：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中。Ⅳ回收频率：因为Young代对象大部分很快进入不可达状态，因此回收频率高且回收速度快。②Old代：Ⅰ回收机制：采用标记压缩算法回收。Ⅱ对象来源：1.对象大直接进入老年代。2.Young代中生存时间长的可达对象Ⅲ回收频率：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成。③Permanent代：Ⅰ用途：用来装载Class，方法等信息，默认为64M，不会被回收Ⅱ对象来源：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGenspace的错误，这就是Permanent代内存耗尽所导致的错误。Ⅲ回收频率：不会被回收3.3常见的垃圾回收器在此之前，我们先讲一下下面将会涉及到的并发和并行两个词的解释：1）并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；2）并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续执行，而垃圾收集程序运行于另一个CPU上。好啦，继续讲垃圾回收器：1）串行回收器（只使用一个CPU）：Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停，2）并行回收器：对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理；对Old代的处理和串行回收器完全一样，依旧是单线程。3）并行压缩回收器：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：①将Old代划分成几个固定区域；②mark阶段（多线程并行），标记可达对象；③summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域④compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间。4）并发标识—清理回收（CMS）：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：①初始标识（程序暂停）：标记被直接引用的对象(一级对象)；②并发标识（程序运行）：通过一级对象寻找其他可达对象；③再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）④并发清理（程序运行）4.内存管理小技巧1）尽量使用直接量，eg：StringjavaStr=“小学徒的成长历程”;2）使用StringBuilder和StringBuffer进行字符串连接等操作;3）尽早释放无用对象;4）尽量少使用静态变量;5）缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache;6）尽量不使用finalize()方法;7）在必要的时候可以考虑使用软引用SoftReference。",2015/3/16
345,GOOGLE高级搜索技巧,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8948,"一，GOOGLE简介Google（www.google.com）是一个搜索引擎，由两个斯坦福大学博士生LarryPage与SergeyBrin于1998年9月发明，GoogleInc.于1999年创立。2000年7月份，Google替代Inktomi成为Yahoo公司的搜索引擎，同年9月份，Google成为中国网易公司的搜索引擎。98年至今，GOOGLE已经获得30多项业界大奖。二，GOOGLE特色GOOGLE支持多达132种语言，包括简体中文和繁体中文；GOOGLE网站只提供搜索引擎功能，没有花里胡哨的累赘；GOOGLE速度极快，据说有8000多台服务器，200多条T3级宽带；GOOGLE的专利网页级别技术PageRank能够提供高命中率的搜索结果；GOOGLE的搜索结果摘录查询网页的部分具体内容，而不仅仅是网站简介；GOOGLE智能化的“手气不错”功能，提供可能最符合要求的网站；OOGLE的“网页快照”功能，能从GOOGLE服务器里直接取出缓存的网页。三，基本搜索：+，-，ORGOOGLE无需用明文的“+”来表示逻辑“与”操作，只要空格就可以了。示例：搜索所有包含关键词“易筋经”和“吸星**”的中文网页搜索：“易筋经+吸星**”结果：已搜索有关易筋经吸星**的中文(简体)网页。共约有726项查询结果，这是第1-10项。搜索用时0.13秒。注意：文章中搜索语法外面的引号仅起引用作用，不能带入搜索栏内。GOOGLE用减号“-”表示逻辑“非”操作。示例：搜索所有包含“易筋经”而不含“吸星++”的中文网页搜索：“易筋经-吸星**”结果：已搜索有关易筋经-吸星**的中文(简体)网页。共约有5,440项查询结果，这是第1-10项。搜索用时0.13秒。注意：这里的“+”和“-”号，是英文字符，而不是中文字符的“＋”和“－”。此外，操作符与作用的关键字之间，不能有空格。比如“易筋经–吸星+++”，搜索引擎将视为逻辑“与”操作，中间的“-”被忽略。GOOGLE用大写的“OR”表示逻辑“或”操作。但是，关键字为中文的或查询似乎还有BUG，无法得到正确的查询结果。示例：搜索包含布兰妮“Britney”或者披头士“Beatles”、或者两者均有的中文网页。搜索：“britneyORbeatles”结果：已搜索有关britneyORbeatles的中文(简体)网页。共约有14,600项查询结果，这是第1-10项。搜索用时0.08秒。搜索：“布兰妮OR披头士”结果：找不到和您的查询-布兰妮OR披头士-相符的网页。注意：小写的“or”，在查询的时候将被忽略；这样上述的操作实际上变成了一次“与”查询。“+”和“-”的作用有的时候是相同的，都是为了缩小搜索结果的范围，提高查询结果命中率。例：查阅天龙八部具体是哪八部。分析：如果光用“天龙八部”做关键字，搜索结果有26,500项，而且排前列的主要与金庸的小说《天龙八部》相关，很难找到所需要的资讯。可以用两个方法减少无关结果。1，如果你知道八部中的某一部，比如阿修罗，增加“阿修罗”关键字，搜索结果就只有995项，可以直接找到全部八部，“天龙八部阿修罗”。2，如果你不知道八部中的任何一部，但知道这与佛教相关，可以排除与金庸小说相关的记录，查询结果为1,010项，可以迅速找到需要的资料，“天龙八部佛教-金庸”。四，辅助搜索：通配符、大小写、句子、忽略字符以及强制搜索GOOGLE不支持通配符，如“*”、“?”等，只能做精确查询，关键字后面的“*”或者“?”会被忽略掉。GOOGLE对英文字符大小写不敏感，“GOD”和“god”搜索的结果是一样的。GOOGLE的关键字可以是词组（中间没有空格），也可以是句子（中间有空格），但是，用句子做关键字，必须加英文引号。示例：搜索包含“long,longago”字串的页面。搜索：“”long,longago””结果：已向英特网搜索”long,longago”.共约有28,300项查询结果，这是第1-10项。搜索用时0.28秒。注意：和搜索英文关键字串不同的是，GOOGLE对中文字串的处理并不十分完善。比如，搜索“”啊，我的太阳””，我们希望结果中含有这个句子，事实并非如此。查询的很多结果，“啊”、“我的”、“太阳”等词语是完全分开的，但又不是“啊我的太阳”这样的与查询。显然，GOOGLE对中文的支持尚有欠缺之处。GOOGLE对一些网路上出现频率极高的词（主要是英文单词），如“i”、“com”，以及一些符号如“*”、“.”等，作忽略处理，如果用户必须要求关键字中包含这些常用词，就要用强制语法“+”。示例：搜索包含“WhoamI?”的网页。如果用“”whoami?””，“Who”、“I”、“?”会被省略掉，搜索将只用“am”作关键字，所以应该用强制搜索。搜索：“”+who+am+i””结果：已向英特网搜索”+who+am+i”.共约有362,000项查询结果，这是第1-10项。搜索用时0.30秒。注意：英文符号（如问号，句号，逗号等）无法成为搜索关键字，加强制也不行。五，高级搜索：site，link，inurl，allinurl，intitle，allintitle“site”表示搜索结果局限于某个具体网站或者网站频道，如“sina.com.cn”、“edu.sina.com.cn”，或者是某个域名，如“com.cn”、“com”等等。如果是要排除某网站或者域名范围内的页面，只需用“-网站/域名”。示例：搜索中文教育科研网站（edu.cn）上所有包含“金庸”的页面。搜索：“金庸site:edu.cn”结果：已搜索有关金庸site:edu.cn的中文(简体)网页。共约有2,680项查询结果，这是第1-10项。搜索用时0.31秒。示例：搜索包含“金庸”和“古龙”的中文新浪网站页面，搜索：“金庸古龙site:sina.com.cn”结果：已在sina.com.cn搜索有关金庸古龙的中文(简体)网页。共约有869项查询结果，这是第1-10项。搜索用时0.34秒。注意：site后的冒号为英文字符，而且，冒号后不能有空格，否则，“site:”将被作为一个搜索的关键字。此外，网站域名不能有“http”以及“www”前缀，也不能有任何“/”的目录后缀；网站频道则只局限于“频道名.域名”方式，而不能是“域名/频道名”方式。诸如“金庸site:edu.sina.com.cn/1/”的语法是错误的。“link”语法返回所有链接到某个URL地址的网页。示例：搜索所有含指向华军软件园“www.newhua.com”链接的网页。搜索：“link:www.newhua.com”结果：搜索有链接到www.newhua.com的网页。共约有695项查询结果，这是第1-10项。搜索用时0.23秒。注意：“link”不能与其他语法相混合操作，所以“link:”后面即使有空格，也将被GOOGLE忽略。inurl语法返回的网页链接中包含第一个关键字，后面的关键字则出现在链接中或者网页文档中。有很多网站把某一类具有相同属性的资源名称显示在目录名称或者网页名称中，比如“MP3”、“GALLARY”等，于是，就可以用INURL语法找到这些相关资源链接，然后，用第二个关键词确定是否有某项具体资料。INURL语法和基本搜索语法的最大区别在于，前者通常能提供非常精确的专题资料。示例：查找MIDI曲“沧海一声笑”。搜索：“inurl:midi沧海一声笑”结果：已搜索有关inurl:midi沧海一声笑的中文(简体)网页。共约有14项查询结果，这是第1-10项。搜索用时0.01秒。示例：查找微软网站上关于windows2000的安全课题资料。搜索：“inurl:securitywindows2000site:microsoft.com”结果：已在microsoft.com内搜索有关inurl:securitywindows2000的网页。共约有198项查询结果，这是第1-10项。搜索用时0.37秒。注意：“inurl:”后面不能有空格，GOOGLE也不对URL符号如“/”进行搜索。GOOGLE对“cgi-bin/phf”中的“/”当成空格处理。allinurl语法返回的网页的链接中包含所有查询关键字。这个查询的对象只集中于网页的链接字符串。示例：查找可能具有PHF安全漏洞的公司网站。通常这些网站的CGI-BIN目录中含有PHF脚本程序（这个脚本是不安全的），表现在链接中就是“域名/cgi-bin/phf”。语法：“allinurl:”cgi-bin”phf+com”搜索：已向英特网搜索allinurl:”cgi-bin”phf+com.共约有40项查询结果，这是第1-10项。搜索用时0.06秒。allintitle和intitle的用法类似于上面的allinurl和inurl，只是后者对URL进行查询，而前者对网页的标题栏进行查询。网页标题，就是HTML标记语言title中之间的部分。网页设计的一个原则就是要把主页的关键内容用简洁的语言表示在网页标题中。因此，只查询标题栏，通常也可以找到高相关率的专题页面。示例：查找日本明星藤原纪香的照片集。搜索：“intitle:藤原纪香写真”结果：已搜索有关intitle:藤原纪香写真的中文(简体)网页。共约有284项查询结果，这是第1-10项。搜索用时0.03秒。GOOGLE的罕用高级搜索语法：related，cache，inforelated用来搜索结构内容方面相似的网页。例：搜索所有与中文新浪网主页相似的页面（如网易首页，搜狐首页，中华网首页等），“related:www.sina.com.cn/index.shtml”。cache用来搜索GOOGLE服务器上某页面的缓存，这个功能同“网页快照”，通常用于查找某些已经被删除的死链接网页，相当于使用普通搜索结果页面中的“网页快照”功能。info用来显示与某链接相关的一系列搜索，提供cache、link、related和完全包含该链接的网页的功能。示例：查找和新浪首页相关的一些资讯。搜索：“info:www.sina.com.cn”结果：有关www.sina.com.cn的网页信息。新浪首页北京站上海站广东站.…游戏世界,|,影音娱乐,|,Club缘,|,男人女人,|,论坛聊天,|,时尚潮流,|,文教育儿,|,车行天下,|,软件下载.…Google提供这个网址的信息:查看Google网页快照里www.sina.com.cn的存档寻找和www.sina.com.cn类似的网页寻找网页有链接到www.sina.com.cn寻找网页包含有’www.sina.com.cn’六，其他重要功能目录服务如果不想搜索网页，而是想寻找某些专题网站，可以访问GOOGLE的分类目录“ ”。Q：如何切换google.com的初始语言界面？A：点击搜索栏右边的“使用偏好”（Preferences），选择“界面语言”（InterfaceLanguage）中你期望的语言，点击最下面的“设定使用偏好”（SavePreferences）按钮。需要提醒的是，GOOGLE用cookie记录这个偏好，所以如果你把浏览器的cookie功能关掉，就无法进行设定。Q：如何设定每页搜索结果显示数量？A：同上，进入使用偏好，在该页的“查看结果”（NumberofResults）选择显示结果数，数目越大，显示结果需要的时间越长，默认是10项。Q：搜索到的链接无法打开怎么办？A：链接无法打开的原因很多，比如网站当机，或者ISP过滤等，可以点击GOOGLE的“网页快照”查看在GOOGLE服务器上的网页缓存。Q：打开搜索结果的链接，可是该页面太大，很难找到一下子找到目的资料怎么办？A：直接打开“网页快照”，GOOGLE会把关键词用不同颜色标记出来，很容易找到。",2015/3/16
346,当前国内最炙手可热的版式文件格式OFD，今后也是文书类电子档案长期保存的格式,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8947,什么方正的CEB(X)、书生的SEP统统被秒杀，PDF也只能靠边站，作为利用格式。目前国内在从事OFD格式研究的主要是福昕公司和数科网维公司。附件是报批稿，正是标准预计2015年年内发布。6-电子文件存储与交换格式文书类版式文档.pdf,2015/3/16
347,Red5之Flash流媒体服务器的安装与使用教程完整版,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8946,"Red5流媒体服务器简介Red5是一个采用Java开发开源的Flash流媒体服务器。它支持：把音频（MP3）和视频（FLV）转换成播放流；录制客户端播放流（只支持FLV）；共享对象；现场直播流发布；远程调用。Red5使用RSTP作为流媒体传输协议，在其自带的一些示例中演示了在线录制，flash流媒体播放，在线聊天，视频会议等一些基本功能。软件环境既然是Java开发的，自然少不了要安装JDK，这里使用的是JDK6.x版本，Red5用的是0.9.1版本，Red5内嵌了Tomcat6.x服务器。为了测试和使用Red5，需要另外搭建开发环境，开发部署相应的服务端应用，开发IDE为Eclipse3.3.x+MyEclipse6.x，Web服务器为Tomcat6.x.Red5下载： 安装软件与环境配置1.安装JDK。这里使用的是jdk-6u21-windows-i586.exe，双击按提示安装即可2.安装Red5因为是Windows环境，这里下载的是setup-Red5-0.9.1.exe。直接双击安装程序安装，安装过程中，需要填写服务器IP地址和端口，由于是本地测试，直接填写127.0.0.1，端口随意，不冲突即可，建议>1024，这里使用5050。安装完之后不要忘记设置RED5_HOME环境变量。Red5安装程序会默认把Red5注册为系统服务自动启动，打开系统服务，查看是否服务是否已经存在：我们看到服务已安装，但还没有启动，需要我们手动启动一下，选择Red5服务，鼠标右键，选择启动或者重新启动即可。系统界面操作，不赘述。如无意外，应该可以正常启动。如果启动不了，请检查前面的环境变量设置是否设置完毕并且正确，最后检查Red5的启动日志文件，看看是否有相应的提示信息，日志文件在Red5主目录下的log目录下，日志文件有多个，查看red5_service.log即可。启动后，打开浏览器，敲入安装Red5时的IP地址和端口，正常情况下，看到如下信息，说明Red5已经正确安装了。这个时候可以点击Install进入下载其官方提供的demo进行研究学习，安装后的demo文件在Red5根目录下的webapps下，如D:\Red5\webapps。安装操作比较简单，这里不详细介绍，不过要这里要提醒一下，安装完的demo后，需要重新启动一下Red5服务器，重启操作参考上面的介绍。3.安装配置开发环境主要安装配置Eclipse3.3.x+MyEclipse6.x+Tomcat6.x。Eclipse下载的是eclipse3.3.1.zip，直接解压到D:\ProgramFiles目录下；Tomcat下载apache-tomcat-6.0.36-windows-x86.zip,直接解压到D:\ProgramFiles目录即可；然后安装MyEclipse6.x，这里用的是MyEclipse_6.0.1GA_E3.3.1_Installer.exe,双击按提示安装完毕即可。配置Tomcat服务器和默认字符集为UTF-8至此，软件的安装与环境配置完成，接下来就是开发和部署我们的流媒体服务器应用以及测试应用了。",2015/3/13
348,Android 之NDK开发,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8945,Android之NDK开发Android之NDK开发.docx,2015/3/12
349,Android之流媒体播放,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8944,Android之流媒体播放Android之流媒体播放.docx,2015/3/10
350,JVM深入,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8943,"1JVM简介JVM是我们Javaer的最基本功底了，刚开始学Java的时候，一般都是从“HelloWorld”开始的，然后会写个复杂点class，然后再找一些开源框架，比如Spring，Hibernate等等，再然后就开发企业级的应用，比如网站、企业内部应用、实时交易系统等等，直到某一天突然发现做的系统咋就这么慢呢，而且时不时还来个内存溢出什么的，今天是交易系统报了StackOverflowError，明天是网站系统报了个OutOfMemoryError，这种错误又很难重现，只有分析Javacore和dump文件，运气好点还能分析出个结果，运行遭的点，就直接去庙里烧香吧！每天接客户的电话都是战战兢兢的，生怕再出什么幺蛾子了。我想Java做的久一点的都有这样的经历，那这些问题的最终根结是在哪呢？——JVM。JVM全称是JavaVirtualMachine，Java虚拟机，也就是在计算机上再虚拟一个计算机，这和我们使用VMWare不一样，那个虚拟的东西你是可以看到的，这个JVM你是看不到的，它存在内存中。我们知道计算机的基本构成是：运算器、控制器、存储器、输入和输出设备，那这个JVM也是有这成套的元素，运算器是当然是交给硬件CPU还处理了，只是为了适应“一次编译，随处运行”的情况，需要做一个翻译动作，于是就用了JVM自己的命令集，这与汇编的命令集有点类似，每一种汇编命令集针对一个系列的CPU，比如8086系列的汇编也是可以用在8088上的，但是就不能跑在8051上，而JVM的命令集则是可以到处运行的，因为JVM做了翻译，根据不同的CPU，翻译成不同的机器语言。JVM中我们最需要深入理解的就是它的存储部分，存储？硬盘？NO，NO，JVM是一个内存中的虚拟机，那它的存储就是内存了，我们写的所有类、常量、变量、方法都在内存中，这决定着我们程序运行的是否健壮、是否高效，接下来的部分就是重点介绍之。2JVM的组成部分我们先把JVM这个虚拟机画出来，如下图所示：从这个图中可以看到，JVM是运行在操作系统之上的，它与硬件没有直接的交互。我们再来看下JVM有哪些组成部分，如下图所示：该图参考了网上广为流传的JVM构成图，大家看这个图，整个JVM分为四部分：ClassLoader类加载器类加载器的作用是加载类文件到内存，比如编写一个HelloWord.java程序，然后通过javac编译成class文件，那怎么才能加载到内存中被执行呢？ClassLoader承担的就是这个责任，那不可能随便建立一个.class文件就能被加载的，ClassLoader加载的class文件是有格式要求，在《JVMSpecification》中式这样定义Class文件的结构：ClassFile{u4magic;u2minor_version;u2major_version;u2constant_pool_count;cp_infoconstant_pool[constant_pool_count-1];u2access_flags;u2this_class;u2super_class;u2interfaces_count;u2interfaces[interfaces_count];u2fields_count;field_infofields[fields_count];u2methods_count;method_infomethods[methods_count];u2attributes_count;attribute_infoattributes[attributes_count];}需要详细了解的话，可以仔细阅读《JVMSpecification》的第四章“TheclassFileFormat”，这里不再详细说明。友情提示：ClassLoader只管加载，只要符合文件结构就加载，至于说能不能运行，则不是它负责的，那是由ExecutionEngine负责的。ExecutionEngine执行引擎执行引擎也叫做解释器(Interpreter)，负责解释命令，提交操作系统执行。NativeInterface本地接口本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须有一个聪明的、睿智的调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是NativeMethodStack中登记native方法，在ExecutionEngine执行时加载nativelibraies。目前该方法使用的是越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机，或者Java系统管理生产设备，在企业级应用中已经比较少见，因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用WebService等等，不多做介绍。Runtimedataarea运行数据区运行数据区是整个JVM的重点。我们所有写的程序都被加载到这里，之后才开始运行，Java生态系统如此的繁荣，得益于该区域的优良自治，下一章节详细介绍之。整个JVM框架由加载器加载文件，然后执行器在内存中处理数据，需要与异构系统交互是可以通过本地接口进行，瞧，一个完整的系统诞生了！2JVM的内存管理所有的数据和程序都是在运行数据区存放，它包括以下几部分：qStack栈栈也叫栈内存，是Java程序的运行区，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束，该栈就Over。问题出来了：栈中存的是那些数据呢？又什么是格式呢？栈中的数据都是以栈帧（StackFrame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“先进后出”原则。那栈帧中到底存在着什么数据呢？栈帧中主要保存3类数据：本地变量（LocalVariables），包括输入参数和输出参数以及方法内的变量；栈操作（OperandStack），记录出栈、入栈的操作；栈帧数据（FrameData），包括类文件、方法等等。光说比较枯燥，我们画个图来理解一下Java栈，如下图所示：图示在一个栈中有两个栈帧，栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。Heap堆内存一个JVM实例只存在一个堆类存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，以方便执行器执行，堆内存分为三部分：PermanentSpace永久存储区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class,Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。YoungGenerationSpace新生区新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Edenspace）和幸存者区（Survivorpace），所有的类都是在伊甸区被new出来的。幸存区有两个：0区（Survivor0space）和1区（Survivor1space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。Tenuregenerationspace养老区养老区用于保存从新生区筛选出来的JAVA对象，一般池对象都在这个区域活跃。三个区的示意图如下：MethodArea方法区方法区是被所有线程共享，该区域保存所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。PCRegister程序计数器每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令。NativeMethodStack本地方法栈3JVM相关问题问：堆和栈有什么区别答：堆是存放对象的，但是对象内的临时变量是存在栈内存中，如例子中的methodVar是在运行期存放到栈中的。栈是跟随线程的，有线程就有栈，堆是跟随JVM的，有JVM就有堆内存。问：堆内存中到底存在着什么东西？答：对象，包括对象变量以及对象方法。问：类变量和实例变量有什么区别？答：静态变量是类变量，非静态变量是实例变量，直白的说，有static修饰的变量是静态变量，没有static修饰的变量是实例变量。静态变量存在方法区中，实例变量存在堆内存中。问：我听说类变量是在JVM启动时就初始化好的，和你这说的不同呀！答：那你是道听途说，信我的，没错。问：Java的方法（函数）到底是传值还是传址？答：都不是，是以传值的方式传递地址，具体的说原生数据类型传递的值，引用类型传递的地址。对于原始数据类型，JVM的处理方法是从MethodArea或Heap中拷贝到Stack，然后运行frame中的方法，运行完毕后再把变量指拷贝回去。问：为什么会产生OutOfMemory产生？答：一句话：Heap内存中没有足够的可用内存了。这句话要好好理解，不是说Heap没有内存了，是说新申请内存的对象大于Heap空闲内存，比如现在Heap还空闲1M，但是新申请的内存需要1.1M，于是就会报OutOfMemory了，可能以后的对象申请的内存都只要0.9M，于是就只出现一次OutOfMemory，GC也正常了，看起来像偶发事件，就是这么回事。但如果此时GC没有回收就会产生挂起情况，系统不响应了。问：我产生的对象不多呀，为什么还会产生OutOfMemory？答：你继承层次忒多了，Heap中产生的对象是先产生父类，然后才产生子类，明白不？问：OutOfMemory错误分几种？答：分两种，分别是“OutOfMemoryError:javaheapsize”和”OutOfMemoryError:PermGenspace”，两种都是内存溢出，heapsize是说申请不到新的内存了，这个很常见，检查应用或调整堆内存大小。“PermGenspace”是因为永久存储区满了，这个也很常见，一般在热发布的环境中出现，是因为每次发布应用系统都不重启，久而久之永久存储区中的死对象太多导致新对象无法申请内存，一般重新启动一下即可。问：为什么会产生StackOverflowError？答：因为一个线程把Stack内存全部耗尽了，一般是递归函数造成的。问：一个机器上可以看多个JVM吗？JVM之间可以互访吗？答：可以多个JVM，只要机器承受得了。JVM之间是不可以互访，你不能在A-JVM中访问B-JVM的Heap内存，这是不可能的。在以前老版本的JVM中，会出现A-JVMCrack后影响到B-JVM，现在版本非常少见。问：为什么Java要采用垃圾回收机制，而不采用C/C++的显式内存管理？答：为了简单，内存管理不是每个程序员都能折腾好的。问：为什么你没有详细介绍垃圾回收机制？答：垃圾回收机制每个JVM都不同，JVMSpecification只是定义了要自动释放内存，也就是说它只定义了垃圾回收的抽象方法，具体怎么实现各个厂商都不同，算法各异，这东西实在没必要深入。问：JVM中到底哪些区域是共享的？哪些是私有的？答：Heap和MethodArea是共享的，其他都是私有的，问：什么是JIT，你怎么没说？答：JIT是指JustInTime，有的文档把JIT作为JVM的一个部件来介绍，有的是作为执行引擎的一部分来介绍，这都能理解。Java刚诞生的时候是一个解释性语言，别嘘，即使编译成了字节码（bytecode）也是针对JVM的，它需要再次翻译成原生代码(nativecode)才能被机器执行，于是效率的担忧就提出来了。Sun为了解决该问题提出了一套新的机制，好，你想编译成原生代码，没问题，我在JVM上提供一个工具，把字节码编译成原生码，下次你来访问的时候直接访问原生码就成了，于是JIT就诞生了，就这么回事。问：JVM还有哪些部分是你没有提到的？答：JVM是一个异常复杂的东西，写一本砖头书都不为过，还有几个要说明的：常量池（constantpool）：按照顺序存放程序中的常量，并且进行索引编号的区域。比如inti=100，这个100就放在常量池中。安全管理器（SecurityManager）：提供Java运行期的安全控制，防止恶意攻击，比如指定读取文件，写入文件权限，网络访问，创建进程等等，ClassLoader在SecurityManager认证通过后才能加载class文件的。方法索引表（Methodstable），记录的是每个method的地址信息，Stack和Heap中的地址指针其实是指向Methodstable地址。问：为什么不建议在程序中显式的生命System.gc()？答：因为显式声明是做堆内存全扫描，也就是FullGC，是需要停止所有的活动的（StopTheWorldCollection），你的应用能承受这个吗？问：JVM有哪些调整参数？答：非常多，自己去找，堆内存、栈内存的大小都可以定义，甚至是堆内存的三个部分、新生代的各个比例都能调整。",2015/3/9
351,java实现常用的八种内排序方法,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8942,"虽然以前写过两篇关于内排序的博客，但时间一长这算法也就容易忘记了，所以最近又整理了一次，将八种排序方法一一实现下，它们分别是：直接插入排序希尔排序冒泡排序快速排序直接选择排序堆排序归并排序最低位优先的基数排序前面七种排序我用的数据结构是hashMap，其储存方式为<key,value>的键值对形式，我选的则是<Integer,Integer>（读者也可以使用数组类型保存数据，正如我前两篇博客那样），值得一提的是哈希表中的0号位全是来用作交换数据的中间值（即hashMap.put(0,null);//第一位置空），如对HashMap不熟悉的读者可以参考相关API，程序中会使用到的方法也只有hashPut.put(key,value)、hashMap.get(key)和hashMap.clear()而已。算法的思想我在这里就不一一详细介绍了，原因是下面的代码中有更为详尽的解释，我就不多此一举了。——————————————————直接插入排序——————————————————————packagecom.sorting;importjava.util.HashMap;/***直接插入排序*@authorHHF*2014年3月19日*/publicclassInsertSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数publicstaticvoidmain(String[]args){System.out.println(""直接插入排序：\n假设前面的序列都已经排序好了，把后面未排序的数往已排好序的序列内插入,时间复杂度O(n^2),空间复杂度O(1)，稳定排序"");HashMap<Integer,Integer>hashMap=newHashMap<Integer,Integer>();init(hashMap);//初始化System.out.println(""初始序列为："");print(hashMap,0);//打印insert(hashMap);//排序}/***初始化函数*@paramhashMap*/privatestaticvoidinit(HashMap<Integer,Integer>hashMap){hashMap.put(0,null);//第一位置空hashMap.put(1,0);hashMap.put(2,5);hashMap.put(3,11);hashMap.put(4,12);hashMap.put(5,13);hashMap.put(6,4);hashMap.put(7,1);hashMap.put(8,5);hashMap.put(9,8);hashMap.put(10,6);hashMap.put(11,4);hashMap.put(12,8);}/***进行插入排序*@paramhashMap待排序的表*/privatestaticvoidinsert(HashMap<Integer,Integer>hashMap){System.out.println(""开始插入排序："");inti,j;//排序开始时间longstart=System.currentTimeMillis();for(i=2;i<hashMap.size();i++){//从第二个开始排序，知道最后一个结束hashMap.put(0,hashMap.get(i));//储存待排序的数，以便前面的书好向后交换位置swapCount++;//发生一次交换j=i-1;//指向有序列while(hashMap.get(0)<hashMap.get(j)){//当发现有比待排序书大的时候该数后移一位hashMap.put(j+1,hashMap.get(j));j--;//继续向前寻找合适的位置swapCount++;//发生一次交换contrastCount++;//发生一次对比}contrastCount++;//跳出while循环还有一次对比hashMap.put(j+1,hashMap.get(0));//放入合适的位置swapCount++;//发生一次交换/*比如说我发现从第5号元素开始前面的数都比待排序值小则j=5，且第6号元素位为合适的位置且为空所以有j++*/print(hashMap,i-1);//输出每趟的序列}//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(hashMap,0);//输出排序结束的序列hashMap.clear();//清空System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");}/***打印已排序好的元素*@paramhashMap已排序的表*@paramj第j趟排序*/privatestaticvoidprint(HashMap<Integer,Integer>hashMap,intj){if(j!=0)System.out.print(""第""+j+""趟：\t"");for(inti=1;i<hashMap.size();i++){//从第一个一直输出到最后一个System.out.print(hashMap.get(i)+""\t"");}System.out.println();}}——————————————————希尔排序————————————————————————packagecom.sorting;importjava.util.HashMap;/***希尔排序*@authorHHF*2014年3月19日*/publicclassHillSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数publicstaticvoidmain(String[]args){System.out.println(""希尔排序：\n分间隔的直接插入排序，假定一个增量d，把全部n个记录分成d组，各组内直接插入排序；再取d1<d，重复分组排序，直到d=1,时间复杂度O(n^1.3),空间复杂度O(1)，不稳定排序"");HashMap<Integer,Integer>hashMap=newHashMap<Integer,Integer>();init(hashMap);//初始化System.out.println(""初始序列为："");print(hashMap,0,0);//打印hill(hashMap);//排序}/***初始化函数*@paramhashMap*/privatestaticvoidinit(HashMap<Integer,Integer>hashMap){hashMap.put(0,null);//第一位置空hashMap.put(1,10);hashMap.put(2,5);hashMap.put(3,11);hashMap.put(4,12);hashMap.put(5,13);hashMap.put(6,4);hashMap.put(7,1);hashMap.put(8,5);hashMap.put(9,8);hashMap.put(10,6);hashMap.put(11,4);hashMap.put(12,8);}/***进行希尔排序*@paramhashMap待排序的表*/privatestaticvoidhill(HashMap<Integer,Integer>hashMap){System.out.println(""开始希尔排序："");//排序开始时间longstart=System.currentTimeMillis();intd=hashMap.size()-1;//初始化增量dintcount=1;//只为统计执行次数while(true){d=d/2;//增量每次对半减for(intx=1;x<=d;x++){//一共有d组x表示每一组的一个数的下表for(inti=x+d;i<hashMap.size();i=i+d){//开始直接插入排序每组内的数下标间隔di表示这一组数的下标hashMap.put(0,hashMap.get(i));//当前被待排序的书swapCount++;//发生一次交换intj=0;//i之前的同一组数的下标for(j=i-d;j>=0&&(hashMap.get(j)>hashMap.get(0));j=j-d){//寻找i的当前合适位置从i-d开始往前找//只有当被查下标有效且被查值比待排序值大时才应该发生交换hashMap.put(j+d,hashMap.get(j));contrastCount++;//发生一次对比swapCount++;//发生一次交换}contrastCount++;//跳出for循环还有一次对比hashMap.put(j+d,hashMap.get(0));//放入合适的位置swapCount++;//发生一次交换//一趟直接插入排序结束}}print(hashMap,count++,d);if(d==1){break;}}//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(hashMap,0,0);//输出排序结束的序列hashMap.clear();//清空System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");}/***打印已排序好的元素*@paramhashMap已排序的表*@paramj第j趟排序*@paramd当前的增量*/privatestaticvoidprint(HashMap<Integer,Integer>hashMap,intj,intd){if(j!=0)System.out.print(""第""+j+""趟：（d=""+d+""）\t"");for(inti=1;i<hashMap.size();i++){//从第一个一直输出到最后一个System.out.print(hashMap.get(i)+""\t"");}System.out.println();}}——————————————————冒泡排序————————————————————————packagecom.sorting;importjava.util.HashMap;/***冒泡排序*@authorHHF*2014年3月19日*/publicclassBubbleSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数publicstaticvoidmain(String[]args){System.out.println(""冒泡排序：\n第一轮使最大值沉淀到最底下，采用从头开始的两两比较的办法，如果i大于i++则交换，下一次有从第一个开始循环，比较次数减一，然后依次重复即可,""+""\n如果一次比较为发生任何交换，则可提前终止，时间复杂度O(n^2),空间复杂度O(1)，稳定排序"");HashMap<Integer,Integer>hashMap=newHashMap<Integer,Integer>();init(hashMap);//初始化System.out.println(""初始序列为："");print(hashMap,0);//打印bubble(hashMap);//排序}/***初始化函数*@paramhashMap*/privatestaticvoidinit(HashMap<Integer,Integer>hashMap){hashMap.put(0,null);//第一位置空hashMap.put(1,10);hashMap.put(2,5);hashMap.put(3,11);hashMap.put(4,12);hashMap.put(5,13);hashMap.put(6,4);hashMap.put(7,1);hashMap.put(8,5);hashMap.put(9,8);hashMap.put(10,6);hashMap.put(11,4);hashMap.put(12,8);}/***进行冒泡排序*@paramhashMap待排序的表*/privatestaticvoidbubble(HashMap<Integer,Integer>hashMap){System.out.println(""开始冒泡排序："");//排序开始时间longstart=System.currentTimeMillis();booleanswap=false;//是否发生交换intcount=1;//只为了计数for(inti=1;i<hashMap.size();i++){swap=false;for(intj=1;j<hashMap.size()-i;j++){if(hashMap.get(j)>hashMap.get(j+1)){//需要发生交换j和j+1hashMap.put(0,hashMap.get(j));hashMap.put(j,hashMap.get(j+1));hashMap.put(j+1,hashMap.get(0));swap=true;contrastCount++;//发生一次对比swapCount++;//发生一次交换swapCount++;//发生一次交换swapCount++;//发生一次交换}contrastCount++;//跳出if还有一次对比}print(hashMap,count++);if(!swap)break;}//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(hashMap,0);//输出排序结束的序列hashMap.clear();//清空System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");}/***打印已排序好的元素*@paramhashMap已排序的表*@paramj第j趟排序*/privatestaticvoidprint(HashMap<Integer,Integer>hashMap,intj){if(j!=0)System.out.print(""第""+j+""趟：\t"");for(inti=1;i<hashMap.size();i++){//从第一个一直输出到最后一个System.out.print(hashMap.get(i)+""\t"");}System.out.println();}}——————————————————快速排序————————————————————————packagecom.sorting;importjava.util.HashMap;/***快速排序*@authorHHF*2014年3月19日*/publicclassQuickSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数publicstaticvoidmain(String[]args){System.out.println(""快速排序：\n任取一个数作为分界线，比它小的放到左边，比它大的放在其右边，然后分别对左右进行递归,时间复杂度O(nLgn),空间复杂度O(n)，不稳定排序"");HashMap<Integer,Integer>hashMap=newHashMap<Integer,Integer>();init(hashMap);//初始化System.out.println(""初始序列为："");print(hashMap,0,0);//打印System.out.println(""开始快速排序："");//排序开始时间longstart=System.currentTimeMillis();quick(hashMap,1,hashMap.size()-1);//排序//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(hashMap,0,0);//输出排序结束的序列hashMap.clear();//清空System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");System.out.println(""(注：此输出序列为代码执行过程的序列，即先左边递归再右边递归，而教科书上的递归序列往往是左右同时进行的结果，特此说明)"");}/***初始化函数*@paramhashMap*/privatestaticvoidinit(HashMap<Integer,Integer>hashMap){hashMap.put(0,null);//第一位置空hashMap.put(1,10);hashMap.put(2,5);hashMap.put(3,11);hashMap.put(4,12);hashMap.put(5,13);hashMap.put(6,4);hashMap.put(7,1);hashMap.put(8,5);hashMap.put(9,8);hashMap.put(10,6);hashMap.put(11,4);hashMap.put(12,8);}/***进行快速排序*@paramhashMap待排序的表*@paramlow*@paramhigh*/staticintcount=1;privatestaticvoidquick(HashMap<Integer,Integer>hashMap,intlow,inthigh){if(low<high){//跳出递归的条件intk=quickOnePass(hashMap,low,high);//开始一趟排序print(hashMap,count++,hashMap.get(k));quick(hashMap,low,k-1);//对左边的序列递归排序quick(hashMap,k+1,high);//对右边的序列递归排序}}/***进行快速排序*@paramhashMap待排序的表*@paramlow*@paramhigh*/privatestaticintquickOnePass(HashMap<Integer,Integer>hashMap,intlow,inthigh){hashMap.put(0,hashMap.get(low));//选择一个分界值此时第low位元素内的值已经无所谓被覆盖了swapCount++;//发生一次交换while(low<high){//左右两边还有数据为检查时while(low<high&&hashMap.get(0)<hashMap.get(high)){//先开始从右往左走直到有不对的数据或者到头了high--;contrastCount++;//发生一次对比}if(low<high){//如果停下来是因为不对的数据而不是到头了hashMap.put(low++,hashMap.get(high));swapCount++;//发生一次交换}while(low<high&&hashMap.get(0)>hashMap.get(low)){//开始从左往右走直到有不对的数据或者到头了low++;contrastCount++;//发生一次对比}if(low<high){//如果停下来是因为不对的数据而不是到头了hashMap.put(high--,hashMap.get(low));swapCount++;//发生一次交换}}hashMap.put(low,hashMap.get(0));swapCount++;//发生一次交换returnlow;}/***打印已排序好的元素*@paramhashMap已排序的表*@paramj第j趟排序*@paramk第k个元素被选中为分界线*/privatestaticvoidprint(HashMap<Integer,Integer>hashMap,intj,intk){if(j!=0)System.out.print(""第""+j+""趟：(分界线为""+k+"")\t"");for(inti=1;i<hashMap.size();i++){//从第一个一直输出到最后一个System.out.print(hashMap.get(i)+""\t"");}System.out.println();}}——————————————————直接选择排序——————————————————————packagecom.sorting;importjava.util.HashMap;/***选择排序*@authorHHF*2014年3月19日*/publicclassSelectionSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数publicstaticvoidmain(String[]args){System.out.println(""选择排序：\n每次选择最小的，然后与对应的位置处元素交换,时间复杂度O(n^2),空间复杂度O(1)，不稳定排序"");HashMap<Integer,Integer>hashMap=newHashMap<Integer,Integer>();init(hashMap);//初始化System.out.println(""初始序列为："");print(hashMap,0,0);//打印select(hashMap);//排序}/***初始化函数*@paramhashMap*/privatestaticvoidinit(HashMap<Integer,Integer>hashMap){hashMap.put(0,null);//第一位置空hashMap.put(1,10);hashMap.put(2,5);hashMap.put(3,11);hashMap.put(4,12);hashMap.put(5,13);hashMap.put(6,4);hashMap.put(7,1);hashMap.put(8,5);hashMap.put(9,8);hashMap.put(10,6);hashMap.put(11,4);hashMap.put(12,8);}/***进行选择排序*@paramhashMap待排序的表*/privatestaticvoidselect(HashMap<Integer,Integer>hashMap){System.out.println(""开始选择排序："");//排序开始时间longstart=System.currentTimeMillis();intcount=1;//只为统计执行次数for(inti=hashMap.size()-1;i>1;i--){//需要循环查询的次数最后一个元素不用考虑intk=i;//记录本次查找序列最大值的下标初始为该数应该要放的位置for(intj=1;j<i;j++){//if(hashMap.get(k)<hashMap.get(j)){k=j;//记录当前最大的数的下标contrastCount++;//发生一次对比}}//此时k中保存了i位置应该放的数的下标于是发生交换if(i!=k){hashMap.put(0,hashMap.get(k));hashMap.put(k,hashMap.get(i));hashMap.put(i,hashMap.get(0));swapCount++;//发生一次交换swapCount++;//发生一次交换swapCount++;//发生一次交换}print(hashMap,count++,i);//输出排序结束的序列}//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(hashMap,0,0);//输出排序结束的序列hashMap.clear();//清空System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");}/***打印已排序好的元素*@paramhashMap已排序的表*@paramj第j趟排序*@paramd被选到的数*/privatestaticvoidprint(HashMap<Integer,Integer>hashMap,intj,intd){if(j!=0)System.out.print(""第""+j+""趟：\t"");for(inti=1;i<hashMap.size();i++){//从第一个一直输出到最后一个System.out.print(hashMap.get(i)+""\t"");}System.out.println();}}——————————————————堆排序—————————————————————————packagecom.sorting;importjava.util.HashMap;/***堆排序——极大堆*@authorHHF*2014年3月19日*/publicclassHeapSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数privatestaticintprintCount=1;//执行打印次数publicstaticvoidmain(String[]args){System.out.println(""堆排序：\n首先建立一个堆（方法是首先把序列排成二叉树，然后从下往上，从右往左使得每一个小子树中的父节点大于子节点，然后从上往下，从左往右记录堆入序列）,""+""\n然后把堆的根节点和最底下的孩子节点交换，整理堆，再重复交换，整理，时间复杂度O(nlgn),空间复杂度O(1)，不稳定排序"");HashMap<Integer,Integer>hashMap=newHashMap<Integer,Integer>();init(hashMap);//初始化System.out.println(""初始序列为："");print(hashMap,0);//打印heap(hashMap);//排序}/***初始化函数*@paramhashMap*/privatestaticvoidinit(HashMap<Integer,Integer>hashMap){hashMap.put(0,null);//第一位置空hashMap.put(1,10);hashMap.put(2,5);hashMap.put(3,11);hashMap.put(4,12);hashMap.put(5,13);hashMap.put(6,4);hashMap.put(7,1);hashMap.put(8,5);hashMap.put(9,8);hashMap.put(10,6);hashMap.put(11,4);hashMap.put(12,8);}/***进行堆排序*@paramhashMap待排序的表*/privatestaticvoidheap(HashMap<Integer,Integer>hashMap){System.out.println(""开始建堆："");//排序开始时间87longstart=System.currentTimeMillis();for(inti=(hashMap.size()-1)/2;i>=1;i--){//开始建堆sift(hashMap,i,hashMap.size()-1);//把所有的节点调好位置即可以}System.out.println(""建堆成功"");for(intj=hashMap.size()-1;j>=1;j--){//每次都把第一个元素与最后一个未排序的交换然后再调整第一个节点即可hashMap.put(0,hashMap.get(1));hashMap.put(1,hashMap.get(j));hashMap.put(j,hashMap.get(0));sift(hashMap,1,j-1);//剩下要排序的数位为j-1swapCount++;//发生一次交换swapCount++;//发生一次交换swapCount++;//发生一次交换}//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(hashMap,0);//输出排序结束的序列hashMap.clear();//清空System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");}/***把第i位的元素移动到合适位置与其子孩子的最大值比较如果有发生交换则继续往下比较*@paramhashMap*@parami待移动的数下标*@paramn表示要查找的范围从1到n个*/privatestaticvoidsift(HashMap<Integer,Integer>hashMap,inti,intn){intj=2*i;//j为i的左孩子hashMap.put(0,hashMap.get(i));//当前被待排序的数while(j<=n){//如果有左孩子的if(hashMap.containsKey(j+1)&&hashMap.get(j)<hashMap.get(j+1)){//保证j为最大的孩子j++;}contrastCount++;//发生一次对比if(hashMap.get(0)<hashMap.get(j)){//如果是孩子比较大hashMap.put(i,hashMap.get(j));//交换i=j;//转移根节点下标j*=2;//转移孩子节点下标swapCount++;//发生一次交换}else//如果是根比较大break;contrastCount++;//发生一次对比}hashMap.put(i,hashMap.get(0));//i为当前的合适位置swapCount++;//发生一次交换print(hashMap,printCount++);//输出排序结束的序列}/***打印已排序好的元素*@paramhashMap已排序的表*@paramj第j趟排序*/privatestaticvoidprint(HashMap<Integer,Integer>hashMap,intj){if(j!=0)System.out.print(""第""+j+""趟：\t"");for(inti=1;i<hashMap.size();i++){//从第一个一直输出到最后一个System.out.print(hashMap.get(i)+""\t"");}System.out.println();}}——————————————————归并排序————————————————————————packagecom.sorting;importjava.util.HashMap;/***归并排序*@authorHHF*2014年3月19日*/publicclassMergeSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数privatestaticintprintCount=1;//只为统计执行次数publicstaticvoidmain(String[]args){System.out.println(""归并尔排序：\n先将数据分为n组，然后没两组开始合并，相邻两个合并为一个新的有序队列，重复合并直到整个队列有序,时间复杂度O(nlgn),空间复杂度O(n)，稳定排序"");HashMap<Integer,Integer>hashMap=newHashMap<Integer,Integer>();//未排序HashMap<Integer,Integer>hashMapNew=newHashMap<Integer,Integer>();//已排序hashMapNew.put(0,null);//第一位置空init(hashMap);//初始化System.out.println(""初始序列为："");print(hashMap,0);//打印System.out.println(""开始归并尔排序："");//排序开始时间longstart=System.currentTimeMillis();merge(hashMap,hashMapNew,1,hashMap.size()-1);//排序//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(hashMapNew,0);//输出排序结束的序列hashMap.clear();//清空System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");System.out.println(""(注：此输出序列为代码执行过程的序列，即先左边递归再右边递归，而教科书上的递归序列往往是左右同时进行的结果，特此说明)"");}/***初始化函数*@paramhashMap*/privatestaticvoidinit(HashMap<Integer,Integer>hashMap){hashMap.put(0,null);//第一位置空hashMap.put(1,10);hashMap.put(2,5);hashMap.put(3,11);hashMap.put(4,12);hashMap.put(5,13);hashMap.put(6,4);hashMap.put(7,1);hashMap.put(8,5);hashMap.put(9,8);hashMap.put(10,6);hashMap.put(11,4);hashMap.put(12,8);}/***进行归并尔排序*@paramhashMap待排序的表*@paramhashMapNew已排序的表*/privatestaticvoidmerge(HashMap<Integer,Integer>hashMap,HashMap<Integer,Integer>hashMapNew,intlow,inthigh){if(low==high){hashMapNew.put(low,hashMap.get(low));swapCount++;//发生一次交换}else{intmeddle=(int)((low+high)/2);//将这一序列数均分的中间值merge(hashMap,hashMapNew,low,meddle);//继续对左边的序列递归merge(hashMap,hashMapNew,meddle+1,high);//对右边的序列递归mergeSort(hashMap,hashMapNew,low,meddle,high);//把相邻的序列组合起来for(inti=low;i<=high;i++){//将已经排好序的hashMapNew【low，high】覆盖hashMap【low，high】以便进入下一次的递归归并hashMap.put(i,hashMapNew.get(i));swapCount++;//发生一次交换}}}/***进行归并尔排序把【low，meddle】和【meddle+1，high】和并为一个有序的hashMapNew【low,high】*@paramhashMap待排序的表*@paramhashMapNew已排序的表*@paramlow低位*@parammeddle中位*@paramhigh高位*/privatestaticvoidmergeSort(HashMap<Integer,Integer>hashMap,HashMap<Integer,Integer>hashMapNew,intlow,intmeddle,inthigh){intk=low;intj=meddle+1;while(low<=meddle&&j<=high){//两个序列组合成一个序列从小到达的顺序if(hashMap.get(low)<hashMap.get(j)){hashMapNew.put(k++,hashMap.get(low++));//放入合适的位置}else{hashMapNew.put(k++,hashMap.get(j++));//放入合适的位置}contrastCount++;//发生一次对比swapCount++;//发生一次交换}//如果有一方多出来了则直接赋值while(low<=meddle){hashMapNew.put(k++,hashMap.get(low++));//放入合适的位置swapCount++;//发生一次交换}while(j<=high){hashMapNew.put(k++,hashMap.get(j++));//放入合适的位置swapCount++;//发生一次交换}print(hashMapNew,printCount++);}/***打印已排序好的元素*@paramhashMap已排序的表*@paramj第j趟排序*/privatestaticvoidprint(HashMap<Integer,Integer>hashMap,intj){if(j!=0)System.out.print(""第""+j+""趟：\t"");for(inti=1;i<hashMap.size();i++){//从第一个一直输出到最后一个System.out.print(hashMap.get(i)+""\t"");}System.out.println();}}——————————————————最低位优先基数排序———————————————————packagecom.sorting;/***最低位优先基数排序*@authorHHF**/publicclassLSDSort{privatestaticintcontrastCount=0;//对比次数privatestaticintswapCount=0;//交换次数privatestaticintprintCount=1;//只为统计执行次数publicstaticvoidmain(String[]args){System.out.println(""最低位优先基数排序：\n按个位、十位、百位排序，不需要比较，只需要对数求余然后保存到相应下标的二维数组内，然后依次读取，每一进制重复依次,时间复杂度O(d（n+rd）),空间复杂度O(n+rd)，稳定排序"");int[]data={173,22,93,43,55,14,28,65,39,81,33,100};System.out.println(""初始序列为："");print(data,0);//打印LSD(data,3);}publicstaticvoidLSD(int[]number,intd){//d表示最大的数有多少位intk=0;//number的小标intn=1;//当比较十位的时候n=10比较百位的时候n=100用来吧高位降低方便求余数intm=1;//正在比较number中数据的倒数第几位int[][]temp=newint[10][number.length];//数组的第一维表示可能的余数0-9二维依次记录该余数相同的数int[]order=newint[10];//数组orderp[i]用来表示该位的余数是i的数的个数//排序开始时间longstart=System.currentTimeMillis();while(m<=d){//d=5则比较五次for(inti=0;i<number.length;i++){//把number中的数按余数插入到temp中去intlsd=((number[i]/n)%10);//求得该数的余数temp[lsd][order[lsd]]=number[i];//保存到相应的地方order[lsd]++;//该余数有几个swapCount++;//发生一次交换}for(inti=0;i<10;i++){//将temp中的数据按顺序提取出来if(order[i]!=0)//如果该余数没有数据则不需要考虑for(intj=0;j<order[i];j++){//有给余数的数一共有多少个number[k]=temp[i][j];//一一赋值k++;swapCount++;//发生一次交换}order[i]=0;//置零，以便下一次使用}n*=10;//进制+1往前走k=0;//从头开始m++;//进制+1print(number,printCount++);}//排序结束时间longend=System.currentTimeMillis();System.out.println(""结果为："");print(number,0);//输出排序结束的序列System.out.print(""一共发生了""+contrastCount+""次对比\t"");System.out.print(""一共发生了""+swapCount+""次交换\t"");System.out.println(""执行时间为""+(end-start)+""毫秒"");}/***打印已排序好的元素*@paramdata已排序的表*@paramj第j趟排序*/privatestaticvoidprint(int[]data,intj){if(j!=0)System.out.print(""第""+j+""趟：\t"");for(inti=0;i<data.length;i++){System.out.print(data[i]+"""");}System.out.println();}}——————————————————算法分析————————————————————————排序方法最好时间平均时间最坏时间辅助空间稳定性直接插入O(n)O(n^2)O(n^2)O(1)稳定冒泡O(n)O(n^2)O(n^2)O(1)稳定简单选择O(n^2)O(n^2)O(n^2)O(1)不稳定希尔O(n^1.3)O(1)不稳定快速O(nLNn)O(nLNn)O(n^2)O(LNn)不稳定堆O(nLNn)O(nLNn)O(nLNn)O(1)不稳定归并O(nLNn)O(nLNn)O(nLNn)O(n)稳定基数O(d(n+rd))O(d(n+rd))O(d(n+rd))O(n+rd)稳定",2015/3/9
352,中国首个用大数据追踪网络诈骗的“中国网络骗子地图”,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8941, fishsite,2015/3/9
353,关于提高页面加载速度的一些方法,周敏,http://180.168.156.212:2262/wecenter/?/article/8940,1.图片加载2.页面内容加载3.ajax外部程序调用加载关于提高页面加载速度的一些方法.docx,2015/3/9
354,关于建立oracle全文索引的方法,周敏,http://180.168.156.212:2262/wecenter/?/article/8939,1.以管理员用户sys登陆，执行以下脚本2.以username登陆，设置词法分析器(lexer)3.以username用户登陆，配置参数4.创建全文检索所索引建立oracle全文索引.doc,2015/3/9
355,webm格式,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8938,WebM由Google提出，是一个开放、免费的媒体文件格式。WebM影片格式其实是以Matroska（即MKV）容器格式为基础开发的新容器格式，里面包括了VP8影片轨和OggVorbis音轨，其中Google将其拥有的VP8视频编码技术以类似BSD授权开源，OggVorbis本来就是开放格式。WebM标准的网络视频更加偏向于开源并且是基于HTML5标准的，WebM项目旨在为对每个人都开放的网络开发高质量、开放的视频格式，其重点是解决视频服务这一核心的网络用户体验。Google说WebM的格式相当有效率，应该可以在netbook、tablet、手持式装置等上面顺畅地使用。简介WebM格式，其实是以Matroska（就是我们熟知的MKV）容器格式为基础开发的新容器格式，里面包括了VP8视频和OggVorbis音轨。OggVorbis本来就是开放格式，VP8则是Google当年买下On2公司时取得的视频编码器，这次Google也把这个编码器以类似BSD授权开放，因此WebM应该是不会有H.264的那些潜在的专利问题。效率Google说WebM格式相当有效率，应该可以在上网本、平板电脑、手持设备等中流畅地使用，当然自家的Youtube也会支持WebM的播放。Adobe的FlashPlayer会支持WebM格式，AMD、ARM、Broadcom、Freescale、NVIDIA、Qualcomm、TI等也会支持。但是Intel不支持。在浏览器方面，Chrome不用说，Firefox、Opera都支持该格式。微软IE9的支持就没这么直接，出厂时仅会支持H.264影片的播放，但如果你另外下载并安装了VP8，那当然你也可以播放HTML/VP8的影片。,2015/3/6
356,unity3d发布一个Android的apk文件,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8937,unity3d发布一个Android的apk文件unity3d发布一个Android的apk文件.docx,2015/3/5
357,unity发布iOS app,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8936,RTunity发布iosapp流程.docx,2015/3/5
358,jsp和Servlet之间传值出现中文乱码的解决方案,王雷2,http://180.168.156.212:2262/wecenter/?/article/8935,见附件jsp和Servlet之间传值出现中文乱码的解决方案.doc,2015/2/28
359,Jackson 框架，轻易转换JSON,王雷2,http://180.168.156.212:2262/wecenter/?/article/8934,Jackson框架，轻易转换JSON.doc,2015/2/28
360,groovy优化spring的样本案例,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8933,在低版本spring下配置和使用groovybean的案例j-groovierspringcode.zip,2015/2/27
361,《把时间当作朋友》转,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8932,前言：所有人的困境常发现在工作学习中，有人问起，这个单词什么意思？这个函数怎么用的？但事实上，象这类问题都可以在网上，在字典中很方便地查到，但为什么还要有人问呢，可以说：所有学生提问都是源自于所有人的共有的弱点：懒惰。甚至会问一些很弱智的问题，而这些很可能是他以前懒惰，没有好好学习到，造成现在不知道。所以当知道的人被问起这些问题时会觉得很烦。但事实上，发现这问这些问题的人有时并不能用懒惰解释一切，这些人为了考托福，半夜起来背书，敲代码也要弄到半夜。这种既勤奋又懒惰的矛盾到处可以发现。经过多年的历练，作者发现了根本原因，这种“即勤奋又懒惰”的怪异现象来自于他们的“时间压力”。“没有时间了”或者“时间不够了”的感受和恐惧，使得他们超乎寻常地勤奋，哪怕是虚假的“勤奋”，也使得他们终日寻找捷径，美其名曰“提高效率”，而实际上去想着“最好不费吹灰之力”。一切归于“时间”，假想下，如果人们可以长生不老，那么，就不会有人在千百年之间不停地嘲笑追日的夸父，国为夸父几百岁之后终究可以明白自己做法的局限进而采取其他策略；也不会有人惊讶于鲁班造出来的木鸢，国为只不过千百年而已。但我们又怎能长生不老呢，所有总会受到时间的困惑，但会有一些人从容，优雅，善于化解各种压力，安静地去做他们认为应该做的事情，并总是有所成就。本书就是讨论着如果达到这些少数人的境界！心智“老师，这种方法真的有用么？”有时会听到这样的问题，但大多老师都没有给出好的解释，最多说这种方法已经多方面论证了，“你照这样的方法学习，肯定有进步的”之类的话来。认为问这问题的人自己应该试下，问老师不是多余的么。“你怎么还在浪费时间想这样的没用的问题呢？要是你早就开始照这方法做的话，现在不就知道这方法行不行了么！”很不理智的问题，但从某种义意上来看，是彻头彻尾地出自于理性！他们的逻辑是这样的：我觉得你的方法颇有些道理，但我不是很确定。问题在于，如是要我决定使用你的方法的话，那么就好像投资一样，是要投入时间、精力，甚到金钱的。如果在我根本不能确定我的这个选择究竟能给我带来怎样的结果的情况下，我就投入时间、精为和多金钱，那我不就是连傻瓜都不如了么？所有你必须告诉我，你的方法到底是否真的有用？如果答案不是确定的，我才不会采取行动呢。所以可以想通了，很多不愿意学习的人，原因就是自己不能够确定学习了后，会给他带来什么样的结果，所有他就不愿投入时间、精力了，理直气壮地拒绝学习。而另一些人（肯定是少数）心里想的是“不知道学它究竟有什么用……但正因为不知道有什么用，才可能更有价值呢！”——或都他们根本就没想过这个问题，时间干脆都花在直接去学上去了。而N年后，惊喜地发现，多亏了当初学了下XXX，不然也没现在的机会了。因“不知道学习有什么用”拒绝学习的人，会在接下来的日子里虚度光阴，哪怕他们天天“科学地”制定计划，编制“任务列表”。而与之相反，因“不知道学习有什么用”而选择努力学习的人，每时每刻都充满了收获，并且会在将来的某一天获得更多的“意外”收获，哪怕他们可能显得“漫无目的”。这可能就是所谓的心智差别了，换了个角度想问题，来影响你的行为，可能会导致绝然不同的结果。常常听人慨叹“人与人之间怎么会有那么大的差异呢？”，其实当我们看到本质后，想想，量变最小，但会引起质变。想想了解的人中这些例子不少，大多数成功人士并不是一开始就瞄着他的目的而努力的。王石每天乘公交车时看书学习时，绝对不是为了搞房地产；许三多，每天早起踢正步，并不是为了要超过他的班长。初中时候玩五笔打字游戏时，也绝对不是为了现在打文章的。但最后的结果，可以说，对于当时行为的目标来说都是属于“意外收获”。开启自己的心智大脑是个奇的东西，因为我们可以用大脑来控制大脑。留点神，我们控制大脑；不留神，我们就被大脑来控制。那么我们所获得的结果，是因为我们之前所做的，而每件所做的事，其实都是由我们大脑来控制的。结果的好坏，可以说就是这个控制力的差别了。如果能够通过改变对大脑的控制来做出相应的行为来达到目的呢，看个故事：作者的一位朋友得知自己要拿奖学金就必须要得GRE高分，然后一看，考G所需要的词汇量很高，共要20000个单词，很多人都被这个词汇量吓到了，于是他用了两天的时间才想办法说服自己这应该是件快的事情。他想，如果搞定20000个单词，那就有可能获得奖学金每年40000美金，并且连续４年没有失业可能。算下来每个单词得值20元人民币。于是想通了这点后，就强迫自己背200个单词一天。每天睡觉时总感觉心满意足，因为今天又赚了4000块。显然，这位大哥很有心智，用心智的力量控制自己，最后获得了成功。“推迟满足感”是心智成熟的人必备的能力，也是需要挣扎和锻炼才可以习得的能力。老美N年前做过实验，让一帮小孩坐在教室里，面前放了一粒糖，要求，一会儿老师来了后，面前的糖没吃掉的话，可以再奖一粒，而吃掉的人则没有奖励。当然，结果总会是一部份人先吃掉了，问题答案在N年后揭晓了，一开始就吃掉糖的人基本都没有后吃的人有成绩。希望自己的欲望马上获得满足是大多数人的天性；而野性永远是少数人的天性。赌鬼与财王的区别就是，赌鬼是潜意识里多了一个“马上看到结果”，所有没成得了赌王，最终选择了去跟***玩，国为这个很快会有结果。耐心有着神奇的力量。当每个人都在拖延，最后又手忙脚乱的时候，你的生活却非常从容。因为你从一开始就知道你今天的所有轻松安逸，都可能是未来的成本；所以，你早就把一些轻松安逸安排到未来的某个时段，而心平气和地每天完成相应的工作。于是，你不仅从容，而且快乐。你会变成一个守时的人，一个生活有规律的人，一个身边朋友都信赖的人。你会定时去健身房，从不为自己瘦得太慢而烦恼的同意竟然用节食甚至吞食泻药的方法去减肥，因为，在那些人因为无奈而抱怨的人而临绝望的时候，你早已经是持续锻炼了许多年的健康的人。,2015/2/27
362,Oracle&SQLServer;中实现跨库查询,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8931,"一、在SQLServer中连接另一个SQLServer库数据在SQL中，要想在本地库中查询另一个数据库中的数据表时，可以创建一个链接服务器：EXECmaster.dbo.sp_addlinkedserver@server=N'别名',@srvproduct=N'库名',@provider=N'SQLOLEDB',@datasrc=N'服务器地址'EXECmaster.dbo.sp_addlinkedsrvlogin@rmtsrvname=N'别名',@locallogin=NULL,@useself=N'False',@rmtuser=N'用户名',@rmtpassword=N'密码'创建完后，就可以通过“Select*from别名.库名.dbo.表名”来查询了。或者也可以手工创建：二、在Oracle中连接另一个Oracle库数据在Oracle中，其实也类似，要连接到其他库时，也需要创建一个类似这样的连接：createdatabaselink别名connectto模式名（用户名）identifiedby""密码""using'TNS名';注意：这里面的TNS名就是你需要连接的另一个库的TNS名，而且是必需是在你当前连接的库的服务器端所配置的TNS名。创建完后，我们也就可以访问了：“Select*from表名@别名”如果使用的是PL/SQL开发工具，那么我们也可以直接在工具里创建：三、在SQLServer中连接Oracle数据同样，也创建一个数据库连接即可，这时我们采用OleDB方式连接数据库：EXECmaster.dbo.sp_addlinkedserver@server=N'别名',@srvproduct=N'库名',@provider=N'MSDAORA',@datasrc=N'TNS名'EXECmaster.dbo.sp_addlinkedsrvlogin@rmtsrvname=N'别名',@locallogin=NULL,@useself=N'False',@rmtuser=N'模式名',@rmtpassword=N'密码'注意：这里面的TNS名，是在该SQLServer器端所配置的TNS名，不是在客户端本地哦。创建好了后，使用“select*fromopenquery(别名,'select*from模式名.表名”来执行查询。要连接到其他类型的数据库时，其实方式也类同，只要用相应的provider来连接即可。四、在Oracle中连接SQLServer数据在oracle中连接SQLServer也很类似，创建一个DBLink，但问题是，创建DBLink里，里面用的TNS名称都是连接到Oracle的，没有配置连接到SQLServer中的。于是想到采用Oracle中的透明网关来实现，首先在Oracle的安装名中装上，OracleNetServices和OracleTransparentGateways,并在此项下选择OracleTransparentGatewayforMicrosoftSQLServer。配置透明网关，编辑%ORACLE_HOME%/tg4msql/admin/init%ORACLE_SID%.ora,该文件包含了TGforSQLServer的配置信息,其中%ORACLE_SID%是给TG的""SID"",默认为tg4msql.修改文件中的行HS_FDS_CONNECT_INFO=""SERVER=SQL服务器地址;DATABASE=库名""。然后创建监听器：编辑%ORACLE_HOME%/network/admin/listener.ora,编辑对应listener的SID_LIST：SID_LIST_LISTENER=(SID_LIST=(SID_DESC=(SID_NAME=%ORACLE_SID%)(ORACLE_HOME=oracle_home_directory)(PROGRAM=tg4msql)))其中%ORACLE_SID%为第二布中设置的SID,默认值为tg4msql.修改listener.ora文件后需重启listener使修改生效.最后就可以配置TNS名了，如果直接修改Tnsname.ora文件的话，添加的格式是：TNS名=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=sqlserver)(PORT=1521))(CONNECT_DATA=(SID=网关ID))(HS=OK))这样，TNS名后就可以创建DBLinks，然后查询的方式与前面一至。",2015/2/27
363,使用groovy配置spring4.0,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8930,"背景:Groovy是用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。Groovy是JVM的一个替代语言（替代是指可以用Groovy在Java平台上进行Java编程），使用方式基本与使用Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使Groovy与Java代码的互操作很容易。在spring4.0中，我们可以用groovy作为spring的配置文件。比起最早的基于xml配置，使用groovy会更加灵活，而且干扰信息会更少。比起基于java的配置，groovy配置还要更加精炼！下面展示一个很简单的例子，一场足球赛，有homeTeam主队和awayTeam客队，这两个bean是通过构造函数传入。另外还有homeScore和awayScore表示主队和客队分别得到的分数，通过property的方式传入。下面比较xml、java、groovy三种配置方式1.使用xml进行bean配置football-match-config.xml<?xmlversion=""1.0""encoding=""UTF-8""?><beansxmlns="" beans>比起基于纯粹xml的bean配置，基于java的bean配置不再受限于xml本身。配置本身更清晰。3.使用groovy进行bean配置使用gradle引入依赖：compile(""org.springframework:spring-core:4.0.0.RELEASE"",""org.springframework:spring-context:4.0.0.RELEASE"")FootballMatchConfig.groovyimportorg.kiwi.spring.groovy.FootballMatchimportorg.kiwi.spring.groovy.FootballTeambeans{homeTeam(FootballTeam,""ManchesterUnited"")awayTeam(FootballTeam,""ACMilan"")footballMatch(FootballMatch,homeTeam,awayTeam){homeScore=3awayScore=1}}简单吧！谁看到这种简单的配置方式不会心动呢？与之前的ApplcationContext不同，为了支持基于groovy的bean配置。spring4中提供了新的正对Groovy的ApplicationContext：GenericGroovyApplicationContext。publicclassFootballApp{publicstaticvoidmain(String[]args){finalGenericGroovyApplicationContextcontext=newGenericGroovyApplicationContext(""FootballMatchConfig.groovy"");finalFootballMatchfootballMatch=(FootballMatch)context.getBean(""footballMatch"");System.out.println(footballMatch.display());}}虽然没有写太多基于groovy配置更加强大的方面，但是简洁是显而易见的。简洁就是美。",2015/2/27
364,关于java堆内存溢出的几种情况,张建涛,http://180.168.156.212:2262/wecenter/?/article/8929,"【情况一】：java.lang.OutOfMemoryError:Javaheapspace：这种是java堆内存不够，一个原因是真不够，另一个原因是程序中有死循环；如果是java堆内存不够的话，可以通过调整JVM下面的配置来解决：<jvm-arg>-Xms3062m</jvm-arg><jvm-arg>-Xmx3062m</jvm-arg>【情况二】java.lang.OutOfMemoryError:GCoverheadlimitexceeded【解释】：JDK6新增错误类型，当GC为释放很小空间占用大量时间时抛出；一般是因为堆太小，导致异常的原因，没有足够的内存。【解决方案】：1、查看系统是否有使用大内存的代码或死循环；2、通过添加JVM配置，来限制使用内存：<jvm-arg>-XX:-UseGCOverheadLimit</jvm-arg>【情况三】：java.lang.OutOfMemoryError:PermGenspace：这种是P区内存不够，可通过调整JVM的配置：<jvm-arg>-XX:MaxPermSize=128m</jvm-arg><jvm-arg>-XXermSize=128m</jvm-arg>【注】：JVM的Perm区主要用于存放Class和Meta信息的,Class在被Loader时就会被放到PermGenspace，这个区域成为年老代，GC在主程序运行期间不会对年老区进行清理，默认是64M大小，当程序需要加载的对象比较多时，超过64M就会报这部分内存溢出了，需要加大内存分配，一般128m足够。【情况四】：java.lang.OutOfMemoryError:Directbuffermemory调整-XX:MaxDirectMemorySize=参数，如添加JVM配置：<jvm-arg>-XX:MaxDirectMemorySize=128m</jvm-arg>【情况五】：java.lang.OutOfMemoryError:unabletocreatenewnativethread【原因】：Stack空间不足以创建额外的线程，要么是创建的线程过多，要么是Stack空间确实小了。【解决】：由于JVM没有提供参数设置总的stack空间大小，但可以设置单个线程栈的大小；而系统的用户空间一共是3G，除了Text/Data/BSS/MemoryMapping几个段之外，Heap和Stack空间的总量有限，是此消彼长的。因此遇到这个错误，可以通过两个途径解决：1.通过-Xss启动参数减少单个线程栈大小，这样便能开更多线程（当然不能太小，太小会出现StackOverflowError）；2.通过-Xms-Xmx两参数减少Heap大小，将内存让给Stack（前提是保证Heap空间够用）。【情况六】：java.lang.StackOverflowError【原因】：这也内存溢出错误的一种，即线程栈的溢出，要么是方法调用层次过多（比如存在无限递归调用），要么是线程栈太小。【解决】：优化程序设计，减少方法调用层次；调整-Xss参数增加线程栈大小。",2015/2/27
365,上传组件支持html5和iframe两种模式,孟帅,http://180.168.156.212:2262/wecenter/?/article/8928,jQueryFileUpload是一个Jquery图片上传组件，支持多文件上传、取消、删除，上传前缩略图预览、列表显示图片大小，支持上传进度条显示；支持各种动态语言开发的服务器端。能对文件类型判断，上传大小控制，并且支持ie6+；ie10以下是用iframe数据传输的，唯一的缺点就是ie10以下上传后文件的路径是全路径，需要额外的处理，其他浏览器都是用html5内核做的给出地址吧！ ,2015/2/27
366,解决 TSVNCache.exe 占CPU 的问题,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8927,安装了SVN后会有一个TSVNCache.exe的进程驻留内存，这个进程会定时地去扫描Subversion管理的文件夹/文件是否被修改了，一旦发现有更新，那本地的这些有更新的文件/文件夹就会被更新，这个动作不仅会占用10-50MB左右的内存，而且也会在执行的瞬间占用超过CPU50%的负载。[解决方法]方法1、打开系统的文件夹管理–>右键–>TortoiseSVN–>settings–>IconOverlays–>Statuscache设为”none”就可以了。按照(1)操作，就会屏蔽掉文件状态图标。不建议采用方法1。方法2、在settings——>Iconoverlays里先把所有盘符加入excludepaths里，每个分区一行。注意：1、后面要加上*，表示子目录排除，例：c:\*d:\*2、每个排除目录都是以换行来区分的。需要换行然后把源码存放目录加到includepaths里，比如我的源码全部放在D:\project下面，就加上：D:\projec\*这样TSVNCache占用的内存会少很多，并且也能显示文件状态图标。,2015/2/27
367,Eclipse设置、调优、使用,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8926, /blog/974082,2015/2/27
368,关于JS中的constructor与prototype【转】,孟帅,http://180.168.156.212:2262/wecenter/?/article/8925,学习js必须要学的东西 ,2015/2/27
369,推荐大家一款API管理及查看软件（ZEAL）,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8924,对常用的API进行管理，不过都是原版的API英文的里面的API很多很全，应该够大家用的了,2015/2/12
370,SWT中集成firefox内核后调用firefox的插件,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8923,原因：默认的滚动条太难看，想修改滚动条的样式。Chrome和IE可以通过修改CSS来修改，但是Firefox只能通过插件来修改解决方法，在firefox内下载Stylish插件，编写样式从firfox默认配置路径提取出以下文件：extensions文件夹，extensions.ini，stylish.sqlite放入SWT使用的配置目录中，并修改extensions.ini中的插件绝对路径启动后就可以看到修改好的结果,2015/2/12
371,关于JavaScript定义类和对象的几种方式,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8922,"在说这个话题之前，我想先说几句题外话：最近偶然碰到有朋友问我“hoisting”的问题。即在js里所有变量的声明都是置顶的，而赋值则是在之后发生的。可以看看这个例子：vara='global';(function(){alert(a);vara='local';})();大家第一眼看到这个例子觉得输出结果是什么？‘global’？还是‘local’？其实都不是，输出的是undefined，不用迷惑，我的题外话就是为了讲这个东西的。其实很简单，看一看JavaScript运行机制就会明白。我们可以把这种现象看做“预声明”。但是如果稍微深究一下，会明白得更透彻。这里其实涉及到对象属性绑定机制。因为所有JavaScript函数都是一个对象。在函数里声明的变量可以看做这个对象的“类似属性”。对象属性的绑定在语言里是有分“早绑定”和“晚绑定”之分的。【早绑定】是指在实例化对象之前定义其属性和方法。解析程序时可以提前转换为机器代码。通常的强类型语言如C++，java等，都是早绑定机制的。而JavaScript不是强类型语言。它使用的是“晚绑定”机制。【晚绑定】是指在程序运行前，无需检查对象类型，只要检查对象是否支持特性和方法即可。可以在绑定前对对象执行大量操作而不受任何惩罚。上面代码出现的“预声明”现象，我们大可用“晚绑定”机制来解释。在函数的作用域中，所有变量都是“晚绑定”的。即声明是顶级的。所以上面的代码和下面的一致：vara='global';(function(){vara;alert(a);a='local';})();在alert(a)之前只对a作了声明而没有赋值。所以结果可想而知。<!--题外话到此结束-->RT:本文要说的是，在JavaScript里，我所知道的几种定义类和对象的方式：<!--声明：以下内容大部分来自《JavaScript高级程序设计》，只是个人叙述方式不同而已-->【直接量方式】使用直接量构建对象是最基础的方式，但也有很多弊端。varObj=newObject;Obj.name='sun';Obj.showName=function(){alert('this.name');}我们构建了一个对象Obj，它有一个属性name，一个方法showName。但是如果我们要再构建一个类似的对象呢？难道还要再重复一遍？NO！，我们可以用一个返回特定类型对象的工厂函数来实现。就像工厂一样，流水线的输出我们要的特定类型结果。【工厂方式】functioncreateObj(name){vartempObj=newObject;tempObj.name=name;tempObj.showName=function(){alert(this.name);};returntempObj;}varobj1=createObj('obj_one');varobj2=createObj('obj_two');这种工厂函数很多人是不把他当做构建对象的一种形式的。一部分原因是语义：即它并不像使用了运算符new来构建的那么正规。还有一个更大的原因，是因为这个工厂每次产出一个对象都会创建一个新函数showName(),即每个对象拥有不同的版本，但实际上他们共享的是同一个函数。有些人把showName在工厂函数外定义，然后通过属性指向该方法，可以避开这个问题：代码可惜的是，这种方式让showName()这个函数看起来不像对象的一个方法。【构造函数方式】这种方式是为了解决上面工厂函数的第一个问题，即没有new运算符的问题。可是第二个问题它依然不能解决。我们来看看。functionObj(name){this.name=name;this.showName=function(){alert(this.name);}}varobj1=newObj('obj_one');varobj2=newObj('obj_two');它的好处是不用在构造函数内新建一个对象了，因为new运算符执行的时候会自动创建一个对象，并且只有通过this才能访问这个对象。所以我们可以直接通过this来对这个对象进行赋值。而且不用再return，因为this指向默认为构造函数的返回值。同时，用了new关键字来创建我们想要的对象是不是感觉更“正式”了。可惜，它仍然不能解决会重复生成方法函数的问题，这个情况和工厂函数一样。【原型方式】这种方式对比以上方式，有个很大的优势，就是它解决了方法函数会被生成多次的问题。它利用了对象的prototype属性。我们依赖原型可以重写对象实例。varObj=function(){}Obj.prototype.name='me';Obj.prototype.showName=function(){alert(this.name);}varobj1=newObj();varobj2=newObj();我们依赖原型对构造函数进行重写，无论是属性还是方法都是通过原型引用的方式给新建的对象，因此都只会被创建一次。可惜的是，这种方式存在两个致命的问题：1。没办法在构建对象的时候就写入想要的属性，因为原型在构造函数作用域外边，没办法通过传递参数的方式在对象创建的时候就写入属性值。只能在对象创建完毕后对值进行重写。2。致命问题在于当属性指向对象时，这个对象会被多个实例所共享。考虑下面的代码：varObj=function(){}Obj.prototype.name='me';Obj.prototype.flag=newArray('A','B');Obj.prototype.showName=function(){alert(this.name);}varobj1=newObj();varobj2=newObj();obj1.flag.push('C');alert(obj1.flag);//A,B,Calert(obj2.flag);//A,B,C是的，当flag属性指向对象时，那么实例obj1和obj2都共享它，哪怕我们仅仅改变了obj1的flag属性，但是它的改变在实例obj2中任然可见。面对这个问题，让我们不得不想是否应该把【构造函数方式】和【原型方式】结合起来，让他们互补。。。【构造函数和原型混合方式】我们让属性用构造函数方式创建，方法用原型方式创建即可：varObj=function(name){this.name=name;this.flag=newArray('A','B');}Obj.prototype={showName:function(){alert(this.name);}}varobj1=newObj();varobj2=newObj();obj1.flag.push('C');alert(obj1.flag);//A,B,Calert(obj2.flag);//A,B这种方式有效地结合了原型和构造函数的优势，是目前用的最多，也是副作用最少的方式。不过，有些追求完美的家伙还不满足，因为在视觉上还没达到他们的要求，因为通过原型来创建方法的过程在视觉上还是会让人觉得它不太像实例的方法（尤其对于传统OOP语言的开发者来说。）所以，我们可以让原型活动起来，让他也加入到构造函数里面去，好让这个构造函数在视觉上更为统一。而这一系列的过程只需用一个判断即可完成。varObj=function(name){this.name=name;this.flag=newArray('A','B');if(typeofObj._init=='undefined'){Obj.prototype={showName:function(){alert(this.name);}};Obj._init=true;}}如上，用_init作为一个标志来判断是否已经给原型创建了方法。如果是那么就不再执行。这样其实在本质上是没有任何变化的，方法仍是通过原型创建，唯一的区别在于这个构造函数看起来“江山统一”了。但是这种动态原型的方式是有问题的，《JavaScript高级程序设计》里并没有深究。创建第一个对象的时候会因为prototype在对象实例化之前没来的及建起来，是根本无法访问的。所以第一个对象是无法访问原型方法的。同时这种方式在子类继承中也会有问题。关于解决方案，我会在下一文中说明。其实就使用方便来说的话，个人觉得是没必要做这个判断的。。。呵呵^_^",2015/2/12
372,常用的MySQL复杂查询语句写法,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8921,"常用的MySQL复杂查询语句写法上一篇讲了一些MySQL比较常用的一些SQL语句写法，这篇再记录下，平时可能会用到的复杂点的查询语句的写法。复杂查询语句一般是在报表查询中比较常见，大象之前在“使用jxl生成复杂报表的分析与设计（二）”中就讲过，处理复杂报表，首先需要搞清楚它的业务关系，这个非常关键，如果你连这些业务都没弄明白就开始动手做，最后肯定是会有问题的。搞清楚业务关系后，就可以对报表进行分解，看看到底要准备什么数据，按照这些数据加上对应的业务关系来写SQL语句，一步一步做下来，就可以实现所需要的功能了。大家应该看到下面两个例子都是查询语句，但是如果我们在前面加上INSERTINTOTABLE(COLUMN1,COLUMN2,COLUMN3,...)语句，我们就可以将数据插入到统计结果表中，这样每次查询的时候，就可以只查一张表就行了，这样效率是不是提高了很多呢？查询项目数据与销售统计SELECTa.*,f.ORG_NAMEDEPT_NAME,IFNULL(d.CONT_COUNT,0)SIGN_CONT_COUNT,IFNULL(d.TOTAL_PRICE,0)SIGN_CONT_MONEY,IFNULL(c.CONT_COUNT,0)SIGN_ARRI_CONT_COUNT,IFNULL(c.TOTAL_PRICE,0)SIGN_ARRI_CONT_MONEY,IFNULL(b.CONT_COUNT,0)TOTAL_ARRI_CONT_COUNT,IFNULL(b.TOTAL_PRICE,0)TOTAL_ARRI_MONEY,0PUBLISH_TOTAL_COUNT,0PROJECT_COUNT,0COMMON_COUNT,0STOCK_COUNT,0MERGER_COUNT,0INDUSTRY_COUNT,0BRAND_COUNTFROM(--查询包含客户经理,部门主管,公司主管三种类型所有分公司的人员SELECTu.USER_ID,u.REAL_NAME,u.ORG_PARENT_ID,o.ORG_NAME,u.ORG_IDFROMSE_USERuINNERJOINSE_ORGANIZoONu.ORG_PARENT_ID=o.ORG_IDWHEREu.`STATUS`=1ANDu.`LEVEL`IN(1,2,3)ANDo.PARENT_ID<>0)a--查询部门名称LEFTJOINSE_ORGANIZfONa.ORG_ID=f.ORG_ID--签约合同数与合同金额LEFTJOIN(SELECTCUST_MGR_ID,COUNT(CONT_ID)CONT_COUNT,SUM(TOTAL_PRICE)TOTAL_PRICEFROMSE_CONTRACTWHEREDATE_FORMAT(CREATE_TIME,'%Y-%m-%d')='2012-06-08'GROUPBYCUST_MGR_ID)dONa.USER_ID=d.CUST_MGR_ID--签约并回款合同数与回款金额LEFTJOIN(SELECTCUST_MGR_ID,COUNT(CONT_ID)CONT_COUNT,SUM(TOTAL_PRICE)TOTAL_PRICEFROMSE_CONTRACTWHERE(STATUS=6ORSTATUS=10)ANDDATE_FORMAT(CREATE_TIME,'%Y-%m-%d')='2012-06-08'GROUPBYCUST_MGR_ID)cONa.USER_ID=c.CUST_MGR_ID--总回款合同数与总回款金额LEFTJOIN(SELECTc.CUST_MGR_ID,COUNT(c.CONT_ID)CONT_COUNT,SUM(c.TOTAL_PRICE)TOTAL_PRICEFROMSE_CONTRACTcINNERJOINSE_CONT_AUDITaONc.CONT_ID=a.CONT_IDWHERE(c.STATUS=6ORc.STATUS=10)ANDa.IS_PASS=1ANDDATE_FORMAT(a.AUDIT_TIME,'%Y-%m-%d')='2012-06-08'GROUPBYc.CUST_MGR_ID)bONa.USER_ID=b.CUST_MGR_IDORDERBYa.ORG_PARENT_ID,a.USER_ID项目数据月度环比SELECTk.*,IF(k.LAST_PUBLISH_TOTAL_COUNT>0,ROUND((k.RISE_PUBLISH_TOTAL_COUNT/k.LAST_PUBLISH_TOTAL_COUNT)*100,2),0)RELATIVE_PUBLISH_RATIO,IF(k.LAST_PROJECT_COUNT>0,ROUND((k.RISE_PROJECT_COUNT/k.LAST_PROJECT_COUNT)*100,2),0)RELATIVE_PROJECT_RATIO,IF(k.LAST_COMMON_COUNT>0,ROUND((k.RISE_COMMON_COUNT/k.LAST_COMMON_COUNT)*100,2),0)RELATIVE_COMMON_RATIOFROM(SELECTm.ORG_NAME,IFNULL(n.LAST_PUBLISH_TOTAL_COUNT,0)LAST_PUBLISH_TOTAL_COUNT,IFNULL(n.LAST_PROJECT_COUNT,0)LAST_PROJECT_COUNT,IFNULL(n.LAST_COMMON_COUNT,0)LAST_COMMON_COUNT,m.PUBLISH_TOTAL_COUNT,m.PROJECT_COUNT,m.COMMON_COUNT,IFNULL(m.PUBLISH_TOTAL_COUNT-n.LAST_PUBLISH_TOTAL_COUNT,0)RISE_PUBLISH_TOTAL_COUNT,IFNULL(m.PROJECT_COUNT-n.LAST_PROJECT_COUNT,0)RISE_PROJECT_COUNT,IFNULL(m.COMMON_COUNT-n.LAST_COMMON_COUNT,0)RISE_COMMON_COUNTFROM(SELECT'全国'ASORG_NAME,SUM(PUBLISH_TOTAL_COUNT)ASPUBLISH_TOTAL_COUNT,SUM(PROJECT_COUNT)ASPROJECT_COUNT,SUM(COMMON_COUNT)ASCOMMON_COUNTFROMSE_STAT_ORGWHEREDATE_FORMAT(RECORD_DATE,'%Y-%m')='2012-07')mLEFTJOIN(SELECT'全国'ASORG_NAME,SUM(PUBLISH_TOTAL_COUNT)ASLAST_PUBLISH_TOTAL_COUNT,SUM(PROJECT_COUNT)ASLAST_PROJECT_COUNT,SUM(COMMON_COUNT)ASLAST_COMMON_COUNTFROMSE_STAT_ORGWHEREDATE_FORMAT(RECORD_DATE,'%Y-%m')='2012-06')nONm.ORG_NAME=n.ORG_NAMEUNIONSELECTa.ORG_NAME,IFNULL(b.LAST_PUBLISH_TOTAL_COUNT,0)LAST_PUBLISH_TOTAL_COUNT,IFNULL(b.LAST_PROJECT_COUNT,0)LAST_PROJECT_COUNT,IFNULL(b.LAST_COMMON_COUNT,0)LAST_COMMON_COUNT,a.PUBLISH_TOTAL_COUNT,a.PROJECT_COUNT,a.COMMON_COUNT,IFNULL(a.PUBLISH_TOTAL_COUNT-b.LAST_PUBLISH_TOTAL_COUNT,0)RISE_PUBLISH_TOTAL_COUNT,IFNULL(a.PROJECT_COUNT-b.LAST_PROJECT_COUNT,0)RISE_PROJECT_COUNT,IFNULL(a.COMMON_COUNT-b.LAST_COMMON_COUNT,0)RISE_COMMON_COUNTFROM(SELECTORG_ID,ORG_NAME,SUM(PUBLISH_TOTAL_COUNT)ASPUBLISH_TOTAL_COUNT,SUM(PROJECT_COUNT)ASPROJECT_COUNT,SUM(COMMON_COUNT)ASCOMMON_COUNTFROMSE_STAT_ORGWHEREDATE_FORMAT(RECORD_DATE,'%Y-%m')='2012-07'GROUPBYORG_ID)aLEFTJOIN(SELECTORG_ID,SUM(PUBLISH_TOTAL_COUNT)ASLAST_PUBLISH_TOTAL_COUNT,SUM(PROJECT_COUNT)ASLAST_PROJECT_COUNT,SUM(COMMON_COUNT)ASLAST_COMMON_COUNTFROMSE_STAT_ORGWHEREDATE_FORMAT(RECORD_DATE,'%Y-%m')='2012-06'GROUPBYORG_ID)bONa.ORG_ID=b.ORG_ID)k",2015/2/12
373,求助：需要导出浙江天宇的CGRS的数据，有熟悉的人吗？,包士杰,http://180.168.156.212:2262/wecenter/?/article/8920,需要导出浙江天宇的CGRS的数据，有熟悉的人吗？或者提供安装程序也可以,2015/2/10
374,HTML5 全屏,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8919,页面要实现全屏预览，需要隐藏浏览器地址栏工具类等组件，那么需要考虑下用户体验。w3c规范中的fullscreen标准可以查看： 当前在firefox，chrome，safari中已经支持这个API。除FireFox10外，仅Chrome15与Safari5.1或更高版本的浏览器支持原生全屏API。也就是说，你的浏览器版本不满足这个条件，可就不能正常运行这个功能。目前所有的IE浏览器都暂不支持那么我们简单看看这个代码实现：1.请求全屏Requestingfullscreen为了兼容这几个浏览器需要这么写：vardocElm=document.documentElement;if(docElm.requestFullscreen){docElm.requestFullscreen();}elseif(docElm.mozRequestFullScreen){docElm.mozRequestFullScreen();}elseif(docElm.webkitRequestFullScreen){docElm.webkitRequestFullScreen();}这里各个浏览器的API方法的大小写不一样，w3c规范中建议方法都是小写。这里是把整个docuement请求全屏，我们也可以只针对某个元素需要全屏展示，比如video。2.取消全屏Cancellingfullscreenif(document.exitFullscreen){document.exitFullscreen();}elseif(document.mozCancelFullScreen){document.mozCancelFullScreen();}elseif(document.webkitCancelFullScreen){document.webkitCancelFullScreen();}w3c中使用exitFullscreen这个API，但是浏览器却都有自己的实现。,2015/2/10
375,Java开发二维码,管俊,http://180.168.156.212:2262/wecenter/?/article/8918,attached研发中心经验共享[201501]_管俊.doc,2015/2/10
376,兼容sqlserver和oracle一次插入多条语句的实现,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8917,兼容sqlserver和oracle一次插入多条语句的实现研发中心经验共享-毛璀玲[201501].doc,2015/2/10
377,赛迪顾问重磅发布：中国IT系统自主可控与信息安全白皮书,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8916,国产化已经成为国内政务信息系统建设不可逆转的趋势，而且力度会越来越大。但是“国产化”这个名字太排外，所以现在改称“自主可控”。赛迪顾问的这份报告虽然有给部分国产厂商做广告的嫌疑，但总体来说还是有一定阅读和参考价值的。中国IT系统自主可控与信息安全白皮书.pdf,2015/2/5
378,提升Web性能的8个技巧总结（转）,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/8915,在互联网盛行的今天，越来越多的在线用户希望得到安全可靠并且快速的访问体验。针对Web网页过于膨胀以及第三脚本蚕食流量等问题，Radware向网站运营人员提出以下改进建议，帮助他们为用户提供最快最优质的访问体验。1.管理“页面膨胀”页面大小与性能有着密切的关系。Radware最新电商性能“行业现状”报告显示，100强电商页面大小中位数达到了1492KB，比一年半之前增大了48%。在研究报告里加载最快的10个页面中，页面包含的资源请求中位数为50个，页面大小中位数为556KB。而加载最慢的10个页面中，页面包含的资源请求中位数为141个，页面大小中位数为3289KB。换句话说，加载最慢的页面的资源中位数几乎是加载最快的页面的三倍，页面大小则是六倍。仔细研究页面尺寸大小，我们可以得到更多的信息。加载最快的10个页面所包含的资源总数范围比较密集：在15个~72个之间;页面尺寸最小的仅为251KB，最大的2003KB。而加载最慢的10个页面所包含的资源总数范围则比较广泛：在89个~373个之间;页面尺寸最小为2073KB，最大的则超过了10MB。2.进行图像优化图像是造成页面膨胀的罪魁祸首之一，通常占据页面字节数的50-60%。在页面中添加图片或是将现有图片放大，是迅速获取用户并提高业务转化率的有效方式。但是这种方法会对性能造成严重的影响。进行图像优化是提升性能最简单的一种方法，它可以使页面加载更快。为了更有效的完成图像渲染，图像必须经过压缩和整合、图像的尺寸和格式必须经过仔细调整，图像质量也必须经过优化，这样才可以依据图像的重要性进行区别化的加载处理。3.控制第三方脚本在典型的页面服务器请求中，来自于第三方脚本的请求占了其中的50%或更多。这些第三方脚本不仅会增加页面的字节数，带来延迟，而且也会成为Web页面中最大的潜在故障点。无响应、未经优化的第三方脚本会降低整个网络的加载速度。解决办法是延迟第三方脚本的加载，将其放在关键页面内容之后进行加载，更为理想的情况是放在页面onLoad事件之后加载，这样才不会影响企业的搜索排名(谷歌将onLoad事件作为加载时间指标)。对于一些分析工具和第三方广告商而言，如果延迟第三方脚本加载的方法不可行，可以利用脚本的异步版本，与关键内容的加载同步进行。用户必须了解网站中有哪些脚本，删除那些无用的脚本，并对第三方脚本的性能进行持续监控。4.真正做到移动设备优先“移动设备优先”并不是一个全新的概念。早在2013年，移动设备的使用量就已经超过了台式机，然而与众多口头承诺的移动性能相比，真正专注于移动设备的开发还是存在一定的差距。例如，2011年11月，移动设备上的平均页面大小为475KB，现在则增长至897KB。也就是说，在短短三年之间，平均页面大小几乎翻了一番。尽管移动设备和网络取得了一些进展，但就性能而言，还是无法与大小已接近1MB的服务页面需求保持同步。我们知道，页面大小与加载时间息息相关，移动用户对缓慢的加载速度尤其敏感。如果企业希望网站可以真正做到“移动设备优先”，就必须正确处理这些问题。5.在进行响应式Web设计时兼顾性能响应式设计让设计人员和开发人员可以更好地控制Web页面的外观和感觉。它可以使跨多平台和设备上的页面变得更漂亮。但同时也会带来巨大的性能损失，这些性能损失并不能通过更快速的浏览器、网络和小工具得到缓解。而且随着时间的推移，这样影响还将持续恶化。响应式设计建立在样式表和JavaScript之上。然而，低效的CSS和JS所带来的性能问题远远大于其设计优势给我们带来的好处。样式表应当放在HEAD文档中，用以实现页面的逐步渲染。然而，样式表却经常出现在页面其它位置，这就阻碍了页面的渲染速度。换句话说，JavaScript文件应当放在页面底部或在关键内容加载完成之后再被加载才是合理的处理方式。6.实时监控性能大家都知道要解决一个问题就必须先对问题有充分的了解。要解决页面性能问题，企业就必须知道用户在什么时候可以看到主要页面内容并与之进行交互;同时，企业还需了解性能和可用性问题是如何影响业务指标的。企业需要有方法获取实际的性能指标并对其进行分析。实时用户监控(RUM)工具可以从真实用户的角度实时获取、分析并记录网站的性能和可用性。7.切勿过分依赖CDN解决所有性能问题Radware季度电商性能“行业现状”报告中存在一项最具争议性的调查结果，即：使用内容分发网络(CDN)的网站完成主要内容渲染所需的时间比未曾使用CDN的网站要长的多。这是一个相关性问题，而非因果关系：通常情况下，相较于未使用CDN的网站，使用CDN的网站页面更大，也更复杂。页面的大小和复杂程度才是造成性能问题的元凶，而非CDN。但这一结果也表明，仅依靠CDN并不能解决所有的性能难题。如果部署得当，CDN会是解决延迟问题非常有效的工具：缩短托管服务器接收、处理并响应图像、CSS文件等页面资源请求所需的时间。但是，延迟仅仅只是现代电商网站的关键问题之一。为了实现最佳的加速效果，网站运营人员可以采用组合解决方案：CDN+前端优化(如RadwareFastView解决方案)+应用交付控制器(ADC)和内部管理。8.在企业内部加强Web性能观念的宣传大量研究证明，提高页面速度可以对所有的关键性能指标产生积极影响：页面访问量、用户粘连度、业务转化率、用户满意度、客户保持、购物车的内容多少和收入。然而，正如上述7个建议中所表明的那样，许多企业都犯了同样的错误，最终损害了Web性能。目前，企业应该重点解决Web开发目标和在线业务目标之间的差距问题，而且，每个企业都应该至少拥有一个内部性能专家，以便更好的解决Web性能问题。,2015/2/5
379,流媒体服务器,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8914,"流媒体指以流方式在网络中传送音频、视频和多媒体文件的媒体形式。相对于下载后观看的网络播放形式而言，流媒体的典型特征是把连续的音频和视频信息压缩后放到网络服务器上，用户边下载边观看，而不必等待整个文件下载完毕。由于流媒体服务器流媒体技术的优越性，该技术广泛应用于视频点播、视频会议、远程教育、远程医疗和在线直播系统中。作为新一代互联网应用的标志，流媒体技术在近几年得到了飞速的发展。而流媒体服务器又是流媒体应用的核心系统，是运营商向用户提供视频服务的关键平台。其主要功能是对媒体内容进行采集、缓存、调度和传输播放，流媒体应用系统的主要性能体现都取决于媒体服务器的性能和服务质量。因此，流媒体服务器是流媒体应用系统的基础，也是最主要的组成部分。主要产品流媒体服务器：大并发视频服务器、直播时移服务器、P2P直播服务器、视频交互应用服务器视频应用管理：媒体内容管理系统、H.264/MPEG-4编码工具、机顶盒终端管理系统、节目导航与发布系统。流媒体服务器的主要功能是以流式协议（RTP/RTSP、MMS、RTMP等）将视频文件传输到客户端，供用户在线观看；也可从视频采集、压缩软件接收实时视频流，再以流式协议直播给客户端。典型的流媒体服务器有微软的WindowsMediaService（WMS），它采用MMS协议接收、传输视频，采用WindowsMediaPlayer（WMP）作为前端播放器；RealNetworks公司的HelixServer，采用RTP/RTSP协议接收、传输视频，采用RealPlayer作为播放前端；Adobe公司的FlashMediaServer,采用RTMP(RTMPT/RTMPE/RTMPS)协议接收、传输视频，采用FlashPlayer作为播放前端。值得注意的是，随着Adobe公司的Flash播放器的普及（根据Adobe官方数据，Flash播放器装机量已高达99%以上），越来越多的网络视频开始采用Flash播放器作为播放前端，因此，越来越多的企业开始采用兼容Flash播放器的流媒体服务器，而开始淘汰其他类型的流媒体服务器。支持Flash播放器的流媒体服务器，除了AdobeFlashMediaServer，还有UltrantFlashMediaServer流媒体服务器软件，以及基于Java语言的开源软件Red5。本司原先使用的是UltrantMediaServer，但它不支持MP4格式的视频，不支持MP3音频，未授权版单服务器只支持20个连接，而red5免费开源，支持MP4视频，支持基于H264编码的mov格式视频，支持MP3音频，单服务器支持400个连接。本司正逐步使用red5替换UltrantMediaServer。",2015/2/5
380,struts的FormFile进行文件上传的时候，当上传一个较大的文件时报错,张伟,http://180.168.156.212:2262/wecenter/?/article/8913,"一、在使用struts的FormFile进行文件上传的时候，当上传一个较大的文件时，会出现后台action中获取不到FormFile的属性值，全部值为空的情况，后台也不报异常。前台报空指针异常。但找不到错误在什么地方。在网上查到了在文件上传的时候文件的大小是有限制的，并搞清楚了出错原因：在使用struts的FormFile进行文件上传的时候，默认上传文件的最大大小为250M,如果大于250M则会报上述错误。解决方法：在struts-config.xml文件中，配置<controllermaxFileSize=""1G""></controller>注意：<controller>标记要放在<action-mappings>标记的后面，否则会报错。后来从网上看到有人使用别的方式做的，就是自己写一个类并在struts-config.xml中进行配置。下面是改写的类：publicclassCommonsMultipartRequestHandler{classCommonsFormFile{}publicstaticfinallongDEFAULT_SIZE_MAX=0xfa00000L;publicstaticfinalintDEFAULT_SIZE_THRESHOLD=0x40000;privateHashtableelementsAll;privateHashtableelementsFile;privateHashtableelementsText;privateActionServletservlet;publicvoidhandleRequest(HttpServletRequestrequest)throwsServletException{//Gettheappconfigforthecurrentrequest.ModuleConfigac=(ModuleConfig)request.getAttribute(Globals.MODULE_KEY);//DiskFileItem工厂,主要用来设定上传文件的参数DiskFileItemFactoryfileItemFactory=newDiskFileItemFactory();//上传文件所用到的缓冲区大小,超过此缓冲区的部分将被写入到磁盘fileItemFactory.setSizeThreshold((int)this.getSizeThreshold(ac));//上传文件用到的临时文件存放位置fileItemFactory.setRepository(this.getRepository(ac));//使用fileItemFactory为参数实例化一个ServletFileUpload对象//注意:该对象为commons-fileupload-1.2新增的类.//对于1.2以下的commons-fileupload版本并不存在此类.ServletFileUploadupload=newServletFileUpload(fileItemFactory);//从session中读取对本次上传文件的最大值的限制StringmaxUploadSize=(String)request.getSession().getAttribute(BasicConstants.maxUploadSize);//获取struts-config文件中controller标签的maxFileSize属性来确定默认上传的限制//如果struts-config文件中controller标签的maxFileSize属性没设置则使用默认的上传限制250M.longdefaultOrConfigedMaxUploadSize=this.getSizeMax(ac);if(maxUploadSize!=null&&maxUploadSize!=""""){//如果maxUploadSize设定不正确则上传限制为defaultOrConfigedMaxUploadSize的值//正确则为maxUploadSize转换成的字节数upload.setSizeMax((long)this.convertSizeToBytes(maxUploadSize,defaultOrConfigedMaxUploadSize));}else{//如果maxUploadSize没设置则使用默认的上传限制upload.setSizeMax(defaultOrConfigedMaxUploadSize);}//从session中清空maxUploadSizerequest.getSession().removeAttribute(""maxUploadSize"");//Createthehashtablestobepopulated.elementsText=newHashtable();elementsFile=newHashtable();elementsAll=newHashtable();//Parsetherequestintofileitems.Listitems=null;//ServletFileUpload类来处理表单请求//抛出的异常为FileUploadException的子异常//如果捕获这些异常就将捕获的异常放到session中返回.try{items=upload.parseRequest(request);}catch(FileUploadBase.SizeLimitExceededExceptione){//请求数据的size超出了规定的大小.request.getSession().setAttribute(BasicConstants.baseSizeLimitExceededException,e);return;}catch(FileUploadBase.FileSizeLimitExceededExceptione){//请求文件的size超出了规定的大小.request.getSession().setAttribute(BasicConstants.baseFileSizeLimitExceededException,e);return;}catch(FileUploadBase.IOFileUploadExceptione){//文件传输出现错误,例如磁盘空间不足等.request.getSession().setAttribute(BasicConstants.baseIOFileUploadException,e);return;}catch(FileUploadBase.InvalidContentTypeExceptione){//无效的请求类型,即请求类型enctype!=""multipart/form-data""request.getSession().setAttribute(BasicConstants.baseInvalidContentTypeException,e);return;}catch(FileUploadExceptione){//如果都不是以上子异常,则抛出此总的异常,出现此异常原因无法说明.request.getSession().setAttribute(BasicConstants.FileUploadException,e);return;}//Partitiontheitemsintoformfieldsandfiles.Iteratoriter=items.iterator();while(iter.hasNext()){FileItemitem=(FileItem)iter.next();if(item.isFormField()){addTextParameter(request,item);}else{addFileParameter(item);}}}protectedlongconvertSizeToBytes(Strings,longl){inti=1;if(s.endsWith(""K""))i=1024;elseif(s.endsWith(""M""))i=0x100000;elseif(s.endsWith(""G""))i=0x40000000;if(i!=1)s=s.substring(0,s.length()-1);longl1=0L;try{l1=Long.parseLong(s);}catch(NumberFormatExceptionnumberformatexception){//log.warn(""Invalidformatforfilesize('""+s+""').Usingdefault."");l1=l;i=1;}returnl1*(long)i;}protectedvoidaddTextParameter(HttpServletRequesthttpservletrequest,FileItemfileitem){Strings=fileitem.getFieldName();Strings1=null;booleanflag=false;Strings2=httpservletrequest.getCharacterEncoding();if(s2!=null)try{s1=fileitem.getString(s2);flag=true;}catch(Exceptionexception){}if(!flag){try{s1=fileitem.getString(""ISO-8859-1"");}catch(UnsupportedEncodingExceptionunsupportedencodingexception){s1=fileitem.getString();}booleanflag1=true;}if(httpservletrequestinstanceofMultipartRequestWrapper){MultipartRequestWrappermultipartrequestwrapper=(MultipartRequestWrapper)httpservletrequest;multipartrequestwrapper.setParameter(s,s1);}Stringas[]=(String[])elementsText.get(s);Stringas1[];if(as!=null){as1=newString[as.length+1];System.arraycopy(as,0,as1,0,as.length);as1[as.length]=s1;}else{as1=(newString[]{s1});}elementsText.put(s,as1);elementsAll.put(s,as1);}protectedvoidaddFileParameter(FileItemfileitem){CommonsFormFilecommonsformfile=newCommonsFormFile(fileitem);elementsFile.put(fileitem.getFieldName(),commonsformfile);elementsAll.put(fileitem.getFieldName(),commonsformfile);}protectedlonggetSizeMax(ModuleConfigmoduleconfig){returnconvertSizeToBytes(moduleconfig.getControllerConfig().getMaxFileSize(),0xfa00000L);}protectedlonggetSizeThreshold(ModuleConfigmoduleconfig){returnconvertSizeToBytes(moduleconfig.getControllerConfig().getMemFileSize(),0x40000L);}protectedFilegetRepository(ModuleConfigmoduleconfig){Strings=moduleconfig.getControllerConfig().getTempDir();Filefile=null;if(s==null||s.length()==0){if(servlet!=null){ServletContextservletcontext=servlet.getServletContext();file=(File)servletcontext.getAttribute(""javax.servlet.context.tempdir"");s=file.getAbsolutePath();}if(s==null||s.length()==0)s=System.getProperty(""java.io.tmpdir"");}/*if(log.isTraceEnabled())log.trace(""Fileuploadtempdir:""+s);*/returnfile;}}配置文件：<controller><set-propertyvalue=""true""property=""inputForward""/><set-propertyvalue=""text/html;charset=UTF-8""property=""contentType""/><!--通过写类的全名来替代struts默认的MultipartRequestHandler--><set-propertyproperty=""multipartClass""value=""com.amplesky.commonmodule.struts.AmpleskyMultipartRequestHandler""/><!--规定的上传文件的最大值--><set-propertyproperty=""maxFileSize""value=""15M""/><!--缓冲区大小--><set-propertyproperty=""memFileSize""value=""5M""/></controller>二、cell单元格的编辑后的验证问题_this.cell.attachEvent(""EditFinish"",function(txt,app){varpatt=/^\d+$/;varpattern=/^([1-2]{1}(\d){3})$/;varcol=_this.cell.GetCurrentCol();varrow=_this.cell.GetCurrentRow();if(col==7&&row==3){if(txt&&!txt.match(pattern)){alert(""请正确输入4位有效年份！"");(function(){_this.S(col,row,0,"""");_this.cell.Invalidate();}).defer(10);}}elseif((col==7&&row>6&&row<94)||(col==14&&row>6&&row<94)){if(txt&&!txt.match(patt)){alert(""请输入正整数！"");(function(){_this.S(col,row,0,"""");_this.cell.Invalidate();}).defer(10);}}});",2015/2/5
381,javascript常见异常分析,张伟,http://180.168.156.212:2262/wecenter/?/article/8912,"JavaScript“未结束的字符串常量”原因及其解决办法总结项目开发中，接触JS是在所难免的，但有时老是出现“未结束的字符串常量”根据自己的经验和网络上常见的现象，做下总结。大致分为以下三种情况：①JAVASCRIPT和JSP(或其他网页)文件的编码类型不一致现象：比如，你的jsp网页用的编码格式是utf-8，但是你的js文件用的编码格式却是gb2312。这样文件内部特殊字符因格式不一致就会在解码时出现乱码，从而导致编译器在未到达引号(""或')前提前结束，产生“未结束的字符串常量”。这种不太容易发现错误。解决：如果你的js是外部引用进来的，而不是在jsp页面上编写的，可以在<scripttype=”text/javascript”src=”XXX.js”charset=”###″>中设置charset=""###""与你的jsp网页编码一致就可以了；如果你的js是在jsp页面上直接编写的，基本排除这种类型的错误，请往下看。②在JAVASCRIPT中，字符串前后标记（如单引号或双引号）不匹配或者嵌套错误现象：这种最常见，也最容易发现错误。字符串中单引号(')或双引号("")前后不配对，或者在document.write()时，没有正确输出单引号(')或双引号("")，还有就是在单双引号嵌套时出现错误。解决：让前后引号正确配对；共有两层嵌套时，双引号内嵌套单引号是正确的，单引号内嵌套双引号也是正确的。共有三层嵌套时，最里面一层引号不能和最外面一层相同，这样是错误的，可以在最里面一层引号前加上转义字符“\”。③传递的参数变量内或者jsp脚本变量中包含HTML标记语言、包含换行符或包含引号现象：这种情况是最难发现的，容易忽略了变量内部文字原因产生的，将字符串以参数形式传递给一个函数或者href、action时，该字符串里包含换行符、引号或HTML标记，造成了此错误。如：a.测试时使用单行数据是正常的，未出现这个错误；使用多行数据并使用回车键换行，就出现了此错误，因为里面包含换行符。b.mArray[<%=n_id%>]=""<%=loopnum%><><%=n_topic%><><%=state%><><%=n_sendtime%><><%=n_content%>"";看似无误，但是<%=n_topic%>、<%=n_content%>中包含了多个单双引号，就出现了此错误。解决：对于这种情况，我的解决方法有两个，一个是将字符串变量进行替换操作，将双引号替换成单引号，单引号替换成“\""”，不过这样在传递后读取时还得替换成原文；第二种方法是不直接将数据以参数形式传递，而是先将其赋值给一个隐藏文本内，函数里只需读取文本中的内容即可。4.乱码也可能会导致报“未结束的字符串常量”",2015/2/5
382,wotalk问题,方元凯,http://180.168.156.212:2262/wecenter/?/article/8911,wotalk无法打开，说是少个java，装上去了，系统环境变量那里也参照百度修改，还是一样没用,2015/2/4
383,推荐一本好书，《淘宝技术这十年》----好的框架都是进化来的，不是设计来的,蔡世杰,http://180.168.156.212:2262/wecenter/?/article/8910,本想在网上买实体书，既然找到了电子版，那就拿出来大家分享一下。也希望中信有如此底蕴和机遇，从使用技术到创造技术。淘宝技术这十年.pdf,2015/2/4
384,前端js脚本执行错误收集,丁凯,http://180.168.156.212:2262/wecenter/?/article/8909,前端js脚本执行错误收集前端js脚本执行错误收集.doc,2015/2/3
385,svn cleanup失败办法,丁凯,http://180.168.156.212:2262/wecenter/?/article/8908,svncleanup失败解决办法svncleanup失败.docx,2015/2/3
386,PhoneGap与ExMobi(烽火平台）对比分析PPT,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8907,RT，感兴趣的同事可以下载PPT。EXMobi与PhoneGap对比分析报告.pptx,2015/2/3
387,隐藏在背后的交互设计,王链玮,http://180.168.156.212:2262/wecenter/?/article/8906,文章非本人所创，网上转载，希望能给公司产品经理、设计人员一些帮助行人对交互设计的第一印象是什么？画线框图的？做草稿的？的确，大家所看到交互设计师的日常工作成果都是一些线框图，从表面上理解的确是这样。其实，交互设计师做的远远不止这些。往深一步想，信息架构、界面、流程，都是设计师需要考虑的问题。下面，想谈一下我理解的交互设计。/交互设计最重要的两个因素：信息&互动1.信息人们每天面对那么多信息，在杂乱的信息中筛选出对用户有价值的，呈现给用户，帮助用户做选择，指引用户完成任务。信息的筛选直接影响着用户使用，在用户需要的时候无法提供有用的信息，将导致任务无法进行下去。所以信息是交互设计师需要关注的第一要素。2.互动有了信息后，就需要设计用户如何与这些信息进行互动了。信息的分类、布局将影响用户与信息的交互。用户获取信息后，做出了反应，采取了行动，应用也需要有来有往地给予足够的反馈，来协助用户完成任务。/以上2要素，都是从用户直观感受上去体现的，也就是说往往是表现在用户界面上。我们可以把它称之为“看得见的交互设计”。具体的形式包括：信息架构：把筛选好的信息进行分类，通过页面来承载这些信息，并且把信息（页面）的层次规划好界面设计：把信息在一个页面上进行布局流程设计：把一个任务中涉及的页面信息串联起来，使任务形成一个线性流的关系以上三个关键点，是对交互设计师的基本要求，很多情况下，非专业人员也能做得7788，但还有一部分的交互设计，并不是直观能看到的，也许用户会轻微感受到，但他总在不经意间使用户使用得更加流畅。我们可以把它称之为“看不见的交互设计”。而这些看不见的交互设计，也是初级交互设计师容易忽略的。/如今移动互联网发展迅速，移动产品对这些看不见的交互设计更为注重。因为移动应用的使用场景、网络环境、使用心态都与用户在使用web产品时有着大大的不同。所以在了解这些看不见的交互设计时前，需要对移动应用的情景有一定的了解。1.使用场景用户在使用移动产品，有可能会在户外人多的公众场合使用，这时候需要特别注意移动应用设计的隐私安全。用户有可能在家里、在床上、在厕所，用着各种姿态使用产品，所以对交互的便利性和容错性要特别注意2.网络环境网络环境是“看不见的交互设计中”非常关键的一点。用户会在2G、3G、wifi甚至无联网的情况下使用产品，所以对于各种网络环境进行合理的交互设计是移动产品交互设计师需要考虑的重中之重3.使用心态产品的存在是为了解决用户的问题，而移动产品是用户的贴身工具，当用户需要时，能立刻开始运作，需要快速、直接、有效，用户不喜欢等待。有研究结果表示：在移动产品这种特殊的环境下，“看不见的交互设计”会相较于web产品更为重要，特别是针对网络环境和用户等待的体验需要特别注意下面将展开讨论一下“看不见的交互设计”总的来讲，可以归结为三大点：1.加载机制2.刷新机制3.缓存机制//加载机制通常情况下，我们使用的绝大部分是网络App，他的工作原理是这样的用户在客户端的界面上进行操作，客户端发送请求到服务器，服务器处理请求，返回数据给客户端，并显示给用户其中，客户端和服务器的交互过程，用户是感知不到的，而他确实会耗费时间，在不同的网络环境下耗费的时间也会有所差异，如何让用户在这段时间里有友好的体验呢？这时候“加载过程”起了作用。/加载过程的关键可以总结为：1.让用户感知产品正在努力为他运作2.让用户有基本的心理预期需要等待的时间长短3.让用户在无聊的等待中获得更多乐趣/进度条是一个针对加载过程很好的设计动态的加载进度表示产品正在工作，总进度和当前进度能让用户及时了解情况，让用户能根据这些信息预判时间，有了心理预期有趣的进度条设计or在加载过程中展示一些功能介绍提示（常用于游戏）能有效减少用户等待时的焦躁心理，也能有效地提高用户的容忍度/进度条是web产品时代的产物，还有另外一种加载设计，就是加载图标由于移动产品请求的数据量并不大，所以进度条往往会在一瞬间就完成了，在这种情境下，简化了加载的设计，很多移动产品转而使用加载图标来表示加载过程以上为两种比较常用的加载方式，下面将具体介绍他们与移动产品结合的用法/页面加载机制移动产品的信息都是通过页面来承载的，页面的加载方案设计是交互设计师面临的一个重要难题方案一：单页面整体加载这种加载比较简单，一般运用在页面内容比较单一的情况下，所以直接一次性加载完所有数据后再显示内容单页面加载失败的状态也比较好处理/方案二：单页面分块加载这种方案的特点是，能让用户逐步看到内容，在这个渐进的过程中降低用户的焦虑心理其中又可以分为，模块间有关联性的，先加载父内容，再加载子内容如优酷，先把栏目加载出来，再加载各栏目的内容模块间没有绝对关联性的，可独自加载各自模块内容，根据请求的速度不同分别显示。这样处理有一定几率让用户在没完全刷出数据的情况下就能找到自己需要的功能，如大众点评、淘宝客户端框架固定，内容更新的，可先把框架显示出来，再把各模块的数据各自加载显示，如各种iOS自带应用，云音乐这种分模块加载的需要特别注意加载失败的状态，毕竟每个模块都提示加载失败，点击重试是很挫的一件事，可以根据信息的优先级来决定哪些数据失败了采用默认状态，哪些数据采用失败提示/方案三：跨页面加载父页面&子页面or同一app内，页面间字段可以复用的，在加载子页面时不需要重新加载新数据方案四：预加载这种加载方式的特点是，在加载一个页面内容的同时，预测用户的下一步行为，并为他下一步需要使用的页面加载内容，使得他在下一步的操作中能立刻获取信息而不需要加载等待。预加载提供给用户无缝的产品使用体验，使得用户在使用产品的过程中更直接流畅，没有被打断的感觉。具体的例子有：在浏览图集的时候，当看到第一张的图片时，就自动后台加载第二第三第四张图片，用户浏览完第一张图片切换到第二张时就不会有加载等待的过程在浏览新闻列表时，就把每篇新闻的内容在后台进行预加载，用户选择看某篇新闻时，能立刻阅读到内容/但是这种方案需要面临很多的问题，最直接的是流量问题，因为会自动跑掉很多用户可能根本用不上的数据流量，所以一般情况下可以设定在wifi环境才采用这种加载模式。又或者设定加载规则，只把主要内容预加载，而部分次要内容可以在用户真的用到的时候才加载，例如预加载新闻正文的情况，可以只加载文本信息，图片信息等到用户进入内页才加载。这种预加载与分块加载结合的方式也普遍运用在各个场景。另外，预加载也需要时间的，他只是不在客户端显示给用户，默默在后台运作而已，需要特殊考虑未加载完用户就使用到那些信息的情况，所以在做预加载设计时需要同时考虑另一种适合该情况的普通加载方式。预加载需要根据具体的场景来进行设计，设定好信息优先级，综合考虑各种类型信息的具体大小流量，整体考虑预加载的方式，这些都是需要经过精心分析思考的。随着网络环境的发展，预加载将成为以后产品普遍的加载方式，他提供给用户的无缝使用体验大大地提升了产品的可用性。/操作加载机制除了页面的信息需要加载，页面内的操作也是需要通过给服务器发送请求记录的方案一：加载层进行一个操作后，弹出模态的提示层，告知用户正在加载。采用模态的提示主要是防止用户在该过程中进行其他操作，导致当前加载出错。由于采用模态的提示，并且有可能因为网络原因导致长时间处于加载状态，建议提供一个“关闭”的操作，中止本次加载，恢复App可用状态。加载失败时可在当前浮层变换为失败提示。模态提示层是最稳妥的方式，但他会使用户在使用过程中有打断的感觉。/方案二：控件自身加载状态这种方式是把操作加载的状态与控件的样式结合起来了，对某个控件进行操作后，控件变换为加载状态，此时控件不能重复操作由于这种加载方式是控件的自身状态，不影响其他操作，所以用户也可以对页面进行其他操作，可能会导致同时有多个请求的情况，增加了加载失败的风险，这也算是这种方式的弊端，不过这种极端情况很少出现。请求失败后，可配合Toast提示告知用户失败的原因。/方案三：后台加载用户在操作后，客户端立刻反馈操作成功，然后把请求放到后台与服务器交互，这一过程用户不需要了解，不需要等待，在正常情况下体验是非常棒的。但是在极端情况下会出现一些莫名其妙的状况，由于是后台记录请求并与服务器交互，所以实际请求是否成功客户端是不说明的，全部以操作成功来显示，这就会导致用户误以为操作成功了，但实际上下次来看发现没有成功。所以这种加载方式是需要根据具体使用场景来权衡使用的，对于一些重要的操作，建议还是使用模态的方式加载，对于一些小操作，如点赞、订阅、关注，可采用后台加载的方式。//刷新机制刷新机制也是设计师很容易忽略的问题，合理的刷新机制能让产品使用起来更流畅普遍情况下，刷新机制有以下三种：方案一：手势刷新通过手指在屏幕上的左划右划上划下划达到刷新的目的，也包括一些浏览器产品的自定义手势，如横折折勾，进行刷新最常见的下拉刷新也属于手势刷新的一种/方案二：点击刷新通过点击一个按钮达到刷新数据的目的，但是如今刷新按钮的存在已经成为一种过时的表现，况且在手机那么小的界面上还需要为刷新按钮腾出空间，会挺费劲的。不过避免形式主义，用得恰到好处才是设计的精髓，这种刷新方案还是按需使用吧。方案三：自动刷新根据设定好的规则，如时间、事件规则自动向服务器获取新数据并替换旧数据。使用自动刷新需要根据场景来考虑是否合适场景一——对于频繁更新的内容、有时效性的内容，用户在一个设定的时间没有使用，则可考虑在下次使用时，自动刷新，把新的内容推送给用户类似微博、新闻这种具有时效性的产品，用户在24小时内未打开产品，则在下次打开时帮用户自动更新Timeline场景二——对于一个相对稳定，数据不会经常变化的页面，可以考虑设定时间规则，在后台为用户默默更新数据并替换旧数据//缓存机制“缓存”这个词在web时代也经常听到，但在移动产品上，他的重要性得到了很好的重视一张图解释什么是缓存和缓存的作用“缓存”就是把已经加载过的数据保存起来，并在下次需要重复使用的时候，不需要向服务器加载，直接获取本地数据我理解的“缓存”可如下分类临时缓存常用于一个功能页面内，保存各栏目的缓存。同一个功能里会把子功能分为多个栏目进行划分，每个标签栏目下的内容在本次使用中都可保存为临时缓存，在该功能里切换栏目，不需要重新加载数据，使用缓存显示。对于用户来说，使用时达到了无缝切换浏览，对于服务器来说，在短时间内数据很少会有更新，所以在一般情况下能满足用户的正常需求，并达到体验优秀临时缓存的清理机制是：退出该功能模块就清除之前的缓存。也就是说下次进入该功能模块，需要重新获取一次数据很多时候我们都会用到临时缓存，因为那些信息真的不是那么重要，而且不需要经常反复查看，那对于那些我们经常使用而且经常需要反复查看的信息，我们就会采取固定缓存保存在本地，方便下次翻阅时不需要再一次向服务器请求数据了其中又会细分为可手动清理的缓存，和不可手动清理的缓存第一种是我们最常见的缓存，几乎所有产品都采用这种缓存方式。平时用户浏览文章、图集加载的数据就以这种形式缓存在本地，下次看回这篇文章、图集时就不需要加载了。用户也可以手动把这些缓存清理了，释放空间。而对于某些特殊场景，例如一些相对固定的数据，我们不愿意一开始就打包进App里，这样会占太大容量，造成产品包很大，也不愿意每次进入页面都向服务器加载这些信息，那怎么办？解决方法就是我们可以只加载一次就永远存在本地了，这样安装包也不会大，以后也不用加载了。例如一些页面的背景图，相对固定不常更换，所以在用户首次进入该页面时就加载背景图并保存在本地，这种缓存是不可清理的，下次再进入该页面就读取本地缓存显示即可。这种缓存方案使用得很少，因为场景太少，具体使用场景还有待开发。/对于这些保存在本地的缓存，都是会占空间的，手机的容量是有限的，那产品是通过怎样的方式清理缓存的呢？大家熟知的有手动清理，一般App都会在“设置”里提供一个清理缓存的功能，一键把空间释放。除此之外，App最好要设计自动清理机制。可以通过两个维度来设计这个机制。时间通过设定一个固定的时间，或者根据用户使用周期灵活设定时间来清理缓存。每个产品的场景不一，用户使用频率不一，设定这个机制的时候就需要结合实际情况考虑了容量一般是设定一个容量上限，采用堆栈的设计原理进行缓存清理，溢出堆栈的旧数据将自动清除//小结这些“看不见的交互设计”就是纠结在那些细节，但作为交互设计师千万不要以为这些是很细小的点，其实他是有大文章可作的。刷新、加载、缓存机制的设计，我不清楚是否应该归纳进交互设计师的职业范畴，但是作为一名用户体验设计师，这些点或多或少地影响着用户的使用体验，我们都应该给予足够多的重视。这些机制，独立来看都有现有模式可参考，但是交互设计师不应该把他们割裂地设计，他们往往是合并在一起时才会有意义。不同机制的结合，往往有妙用，这就需要设计师根据每个产品的不同场景来特殊制定了。,2015/2/3
388,电子文件封装规范,张建涛,http://180.168.156.212:2262/wecenter/?/article/8905,电子文件封装规范DAT46—2009文书电子文件元数据方案.docDAT48—2009基于XML的电子文件封装规范.docDAT47—2009版式电子文件长期保存格式需求.doc,2015/2/3
389,JavaScript是按值传递还是按引用传递,周敏,http://180.168.156.212:2262/wecenter/?/article/8904,"最近遇到个有趣的问题：“JS中的值是按值传递，还是按引用传递呢？”在分析这个问题之前，我们需了解什么是按值传递(callbyvalue)，什么是按引用传递(callbyreference)。在计算机科学里，这个部分叫求值策略(EvaluationStrategy)。它决定变量之间、函数调用时实参和形参之间值是如何传递的。按值传递VS.按引用传递按值传递(callbyvalue)是最常用的求值策略：函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。按引用传递(callbyreference)时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。按引用传递会使函数调用的追踪更加困难，有时也会引起一些微妙的BUG。按值传递由于每次都需要克隆副本，对一些复杂类型，性能较低。两种传值方式都有各自的问题。我们先看一个C的例子来了解按值和引用传递的区别：复制代码voidModify(intp,int*q){p=27;//按值传递-p是实参a的副本,只有p被修改*q=27;//q是b的引用，q和b都被修改}intmain(){inta=1;intb=1;Modify(a,&b);//a按值传递,b按引用传递,//a未变化,b改变了return(0);}这里我们可以看到：?a=>p按值传递时，修改形参p的值并不影响实参a，p只是a的副本。?b=>q是按引用传递，修改形参q的值时也影响到了实参b的值。探究JS值的传递方式JS的基本类型，是按值传递的。vara=1;functionfoo(x){x=2;}foo(a);console.log(a);//仍为1,未受x=2赋值所影响再来看对象：varobj={x:1};functionfoo(o){o.x=3;}foo(obj);console.log(obj.x);//3,被修改了!说明o和obj是同一个对象，o不是obj的副本。所以不是按值传递。但这样是否说明JS的对象是按引用传递的呢？我们再看下面的例子：varobj={x:1};functionfoo(o){o=100;}foo(obj);console.log(obj.x);//仍然是1,obj并未被修改为100.如果是按引用传递，修改形参o的值，应该影响到实参才对。但这里修改o的值并未影响obj。因此JS中的对象并不是按引用传递。那么究竟对象的值在JS中如何传递的呢？按共享传递callbysharing准确的说，JS中的基本类型按值传递，对象类型按共享传递的(callbysharing，也叫按对象传递、按对象共享传递)。该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。如下面例子中，不可以通过修改形参o的值，来修改obj的值。varobj={x:1};functionfoo(o){o=100;}foo(obj);console.log(obj.x);//仍然是1,obj并未被修改为100.然而，虽然引用是副本，引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参的属性值。varobj={x:1};functionfoo(o){o.x=3;}foo(obj);console.log(obj.x);//3,被修改了!对于对象类型，由于对象是可变(mutable)的，修改对象本身会影响到共享这个对象的引用和引用副本。而对于基本类型，由于它们都是不可变的(immutable)，按共享传递与按值传递(callbyvalue)没有任何区别，所以说JS基本类型既符合按值传递，也符合按共享传递。vara=1;//1是number类型，不可变varb=a;b=6;据按共享传递的求值策略，a和b是两个不同的引用(b是a的引用副本)，但引用相同的值。由于这里的基本类型数字1不可变，所以这里说按值传递、按共享传递没有任何区别。基本类型的不可变(immutable)性质基本类型是不可变的(immutable)，只有对象是可变的(mutable).例如数字值100,布尔值true,false，修改这些值(例如把1变成3,把true变成100)并没有什么意义。比较容易误解的，是JS中的string。有时我们会尝试“改变”字符串的内容，但在JS中，任何看似对string值的”修改”操作，实际都是创建新的string值。varstr=""abc"";str[0];//""a""str[0]=""d"";str;//仍然是""abc"";赋值是无效的。没有任何办法修改字符串的内容而对象就不一样了，对象是可变的。varobj={x:1};obj.x=100;varo=obj;o.x=1;obj.x;//1,被修改o=true;obj.x;//1,不会因o=true改变这里定义变量obj，值是object，然后设置obj.x属性的值为100。而后定义另一个变量o，值仍然是这个object对象，此时obj和o两个变量的值指向同一个对象（共享同一个对象的引用）。所以修改对象的内容，对obj和o都有影响。但对象并非按引用传递，通过o=true修改了o的值，不会影响obj。结论“JS中基本类型是按值传递的，对象类型是按共享传递的。”",2015/2/3
390,分享几个小工具,周敏,http://180.168.156.212:2262/wecenter/?/article/8903,JsonViewer：Json格式的数据阅读性很差，但是日常开发调试中难免要阅读，如果数据量不大还好，数据量大的话就有点无从下手了。发现一个Json阅读器，支持粘贴数据并进行可视化展示以及自动格式化数据的功能。FFmpeg：是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。技术经验共享201402_周敏.rar,2015/2/3
391,《IT不再重要》读后感 转,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8901,《IT不再重要》这本书并不是讲技术的，而是一本以云技术为背景讲解IT世界的发展与变化。在人类历程上，一开始，人们都是以手工操作的方式来制人类工具或生活用品，打铁磨豆腐都是纯手工制用。慢慢的，发现可以利用自然界的力量，出现了一些水车，风车，利用水和风的力量，通过传动机制将动力传入到一间“工厂”，驱动相应设备来运作，这类“工厂”一般都会建筑在河边上，或者是动力源边上。因为这些传动机制没办法将动力传得更远。随着发展，蒸汽动力的发明，改变了这种现状，只要能产生蒸汽，也就能来驱动机器了。这时候，也就可以不用把所有的“工厂”都建在河边，在工厂里面只需要一个锅炉就可以来驱动一些机器，所以说蒸汽机推动了工业革命。当电和电灯的出现，在工厂间，蒸汽机与机器之间也不需要到处是蒸汽管道来传送，而是用更方便控制操作的电线。因为有了电，机器的控制也就变得更方便，精确，良性循环，使得生产出来的产品也越精致。在电出现后的几个年代，通用电汽公司一直主要生产着发电机，电动机等设备，各家工厂自己搭建着发电机和机器来运用。这时候，有些公司就开始想，这个发电机，能不能用更大的机器来代替，不是每家都要装，而是几家工厂的机器，可以由一家的发电机来带动。于是出现了专门来供电的一些单位，有了电的计量技术后，他们也就可以靠为别人供电来获取利润。这对于工厂来说，也更方便了，不用自己来投资设备来发电，成本更低了。再经过几百年的发展，这些供电单位野心扩大了，想能不能将电送得更远，功能更大，于是这年代又发明了更大的发电机组以及通过交流电来送时，但是各家之间电压，频率标准不同，无法合并。所以在行业内形成了一些行规，统一了标准。逐渐这些小的供电单位也不存在了，取而代之的是几个大型发电机制，通过输电网向全国送电，各种设备直接接入电网即可使用。主要更换原因是，成本更低，互相得利。再回头看看我们IT界吧，一开始也就是零新的几台电脑在少数人手里，在电脑存储的是各类信息。但是随着发展，人们需要将信息进行交互，于是出现了网络。这时候，我们要想把信息公布出去，就需要搭建一个网站，然后别人就可以通过用的网站来访问到你的信息。这里面的网站就相当于一个个小的发电站，向外面输送着信息（电）。当不断的发现，人们发现，为了要共享自己的信息，而自己维护一个网站，很费精力，成本也很高。这时候，出现了一些大型的网站，通过一定的形式，比如博客，你就可以很方便的将信息发布上去，然后由别人来访问。随着使用的人越来越多，对于这些大型网站，就需要更大的“发电机”来处理这些信息。于是出现在象Google这样的公司，他们把上千上万台的机器放到一个集中的地方，通过高速光纤的接入，来并行处理全球的访问。而通过N多台机搭建来实现巨大的处理量，就称为云技术。云技术有哪些好处，原先一些公司可能采用大型计算机来处理，但发现计算机的发展淘汰是如此之快，大型计算机当然也会淘汰，而这个更换的成本是可以相象的，但是使用的云后，我们可以一批批来更新。同样一台机器处理时一旦down机，将会全部瘫痪，而用了云后，一但坏一台，其他机会顶上，对于使用者来说，是无法查觉得。云技术的不断的发展，在云端能够处理的功能将会越来越多，就不能发现，慢慢的一些小的网站将会被淘汰，逐渐被几家大型计算中心代替。对比一些，这跟电力的发现是极为相似的，最终小的发电站会被大型发电站取消。甚至个人电脑将会取消。为什么会被取消，因为大型机制的处理成本更低，稳定性更高。甚至个人电脑逐渐取消，可能有些人不同意了，但是，让我们仔细想一想，在Google音乐搜索很方便以前，我们机器上是不是存放着大量的mp3，但是当可以直接在网上找到任何音乐时，我们机上的mp3都可以删除了。当所以资料都不用存在你的电脑上时，都可以放网上时，这时候，你的机器也就只有上网功能咯。当网络继续发展，甚至整个操作系统都能在一个网页中展示时，觉得电脑还有必要不？这时候接收这些信息的设备可能就不需要电脑，取而代之是一些智能手机，上网本，甚至一些家具，比如象现在市场上的挂墙上的电子钟，上面有着天气显示，而这信息恐怕以后也会通过网络到“云”上来抓取吧。有人说，计算机的个人化是第一次革命；手机操作系统的出现，结合3G将是第二次计算机革命。我觉得第二句话变动一下，信息终端多样化的出现以及“云”技术的出现将会带来计算机的第二次革命！,2015/1/30
392,分享一个js写的的小游戏,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8900,rtFlappyPig.doc,2015/1/30
393,Jackson 框架，轻易转换JSON,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8902,"平时开发中转换json用gson比较多，公司框架中用的是Jackson,所以学习一下。 ",2015/1/30
394,微软正式面向安卓平板用户推出免费Office,管俊,http://180.168.156.212:2262/wecenter/?/article/8899,1月30日消息，纳德拉执掌微软后，全面开始向安卓和iOS平台提供微软拳头产品Office。本周四，微软这一计划迈出重要一步。微软正式开始向安卓平板电脑用户推出正式版的Office套件，另外微软还向iOS用户推出了一个Outlook邮箱客户端。据报道，三个月前，谷歌开始面向安卓平板用户推出预览版的Office套件。本周四，微软面向安卓平板的Word、PPT、Excel三个软件，已经取消了“预览版”标志，在谷歌Play商店提供正式版的下载，安卓平板用户将能够免费下载使用。外媒评论称，在移动生态系统中，微软已经落后于苹果和谷歌公司，而新任CEO纳德拉已经做出了一场豪赌，要利用Office等微软传统的优势应用软件，重新获取移动端的用户。去年三月份，纳德拉首先打破了微软的传统，开始面向苹果的iPad平板电脑，推出免费的触摸版Office套件。当时，微软甚至尚未面向Windows平板电脑推出触摸版的Office。周四，微软还面向苹果iPhone和iPad用户，发布了一个Outlook邮箱管理工具。微软希望全世界习惯于在电脑上使用Outlook软件的用户，也能够在移动设备上继续使用Outlook。英国路透社分析说，通过面向苹果iOS和谷歌安卓操作系统提供完全免费的Office套件，微软另有目的，那就是逐步培养用户习惯，未来鼓励这些用户升级到微软功能更加全面的基于互联网提供的Office365产品，该产品目前每月收费7美元。据报道，在提供预览版安卓Office的三个月时间里，微软一共获得了25万次的下载量，正式版的推出，意味着下载量将会大增。据微软公布的数据，在iOS平台，去年三月份推出的iOS版Office套件，累计下载量高达8000万次，成为苹果软件商店中最热门的免费软件之一。据悉，今年晚些时候，微软将会正式推送Windows10操作系统，届时，微软将会面相Windows的移动设备，推出一款支持触摸操作的Office套件。在移动版Office上，微软免费的动作也一步步扩大。最早移动版Office仅支持浏览文档，不支持编辑，不过面对用户的反馈，微软很快宣布，将全面支持浏览和编辑功能。需要指出的是，周四推出的免费版Office套件，仅限于7英寸到10.1英寸的安卓平板电脑，支持1GB内存和ARM处理器平台。目前暂时只支持安卓4.4.4系统（这一系统的安装用户已经占到了安卓的四成）。对于10.1英寸以上的安卓平板电脑，微软建议用户使用收费版的Office365套件。在Outlook客户端方面，去年12月，微软收购了一家iOS平台上的邮箱管理软件Acompli，这一功能能够让邮件和用户的日程等应用进行整合。通过整合这一工具，微软推出了新的iOS版Outlook。除了安卓平台之外，周四，微软也面向安卓平台推出了一款Outlook工具，但仍然是测试版。另外，就在此前一天，电子商务巨头亚马逊，推出了一款名为WorkMail的邮箱管理工具，正式进入企业邮箱市场，这一工具可以兼容微软Outlook、以及现有安卓和iOS平台的多个邮箱客户端，邮件信息将保存在亚马逊的云服务中。美国《华盛顿邮报》指出，亚马逊这一产品最直接的对手正是微软公司。,2015/1/30
395,bearyboard，设计稿讨论白板,王链玮,http://180.168.156.212:2262/wecenter/?/article/8898,"白板是一款设计图实时讨论工具,旨在为设计师提供一个更好的方式将设计展示给团队,以原地作标记的方式与团队进行实时讨论,同时简单轻松地收集和整理反馈,节省团队沟通bearyboard.jpg",2015/1/29
396,React.js 开发移动原生应用,李海波,http://180.168.156.212:2262/wecenter/?/article/8897,几个小时前，React.jsConf2015会议上，Facebook发布了ReactNative，可以基于目前大热的开源JavaScript库React.js来开发iOS和Android原生App。而且ReactNative已经用于生产环境——FacebookGroupsiOS应用就是基于它开发的。Facebook也已确认，这个项目很快将会开源。根据ProgVille的文章，ReactNative的原理是，在JavaScript中用React抽象操作系统原生的UI组件，代替DOM元素来渲染，比如以<View>取代<div>，以<Image>替代<img>等。在幕后，ReactNative在主线程之外，在另一个背景线程里运行JavaScript引擎，两个线程之间通过一批量化的async消息协议来通信（有一个专门的React插件）。UI方面ReactNative提供跨平台的类似Flexbox的布局系统，还支持CSS子集。可以用JSX或者普通JavaScript语言，还有CoffeeScript和TypeScript来开发。有评论说，React的UI层模型要比UIKit好很多。更好的是，由于基于Web技术，开发起来可以像在浏览器里那样随时在仿真程序中查看应用运行情况，刷新一下就行，无需编译，爽吧。只是不知道这种架构下App的性能、流畅度如何。更多信息，请持续关注本文。更多详情可以参考会议视频： /watch?v=KVZ-P-ZI6W4（墙内可以看这里）转自： 2823762-facebook-announces-react-native,2015/1/29
397,HTML5 所见一斑,李海波,http://180.168.156.212:2262/wecenter/?/article/8896,HTML5时代，不仅对网页开发技术有了更进一步的拓展，而且对浏览器也有了更高的要求。与之前IE版本相比，IE10或11才有资格称为“现代浏览器”，这主要体现在对HTML5的支持上，新版本IE确实给用户带来了全新的浏览体验。 390823904,2015/1/29
398,国家档案局将全力推动《意见》在各地区各系统各单位落地生根,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8895,国家档案局将全力推动《意见》在各地区各系统各单位落地生根作者：宁宇龙来源：《中国档案报》2015年01月28日中共中央办公厅、国务院办公厅《关于加强和改进新形势下档案工作的意见》（以下简称《意见》），是党中央、国务院在新形势下全面加强和改进档案工作的纲领性、指导性文件，反映了党和国家对档案工作的新要求。2015年，国家档案局将利用定期发通报、开展专项督查等方式，全力推动《意见》在各地区各系统各单位落地生根。在不久前召开的全国档案局长馆长会议上，国家档案局局长杨冬权指出，《意见》是各级档案部门今后争取各方面支持、做好档案工作的“尚方宝剑”，各级档案部门要紧紧抓住这个机会，积极用好这个文件。他说，《意见》的核心内容可归纳为3句话，即“完善体制机制，健全‘三个体系’，加大支持保障”。这3句话，包括了5个方面，它们共同组成了档案工作之“本”。“本”字一共5笔，每一笔可代表这5个方面中的一个：上边的一长横代表体制机制，中间的一竖代表安全体系，左边的一撇代表资源体系，右边的一捺代表利用体系，下边的一短横代表支持保障。其中，一撇一捺同时又是一个“人”字，表明档案资源体系和利用体系建设都要以人为本，以人为核心，做好档案工作必须写好“人”字；还有，以安全体系作为中间的这一竖，是因为安全是贯穿于档案工作各个方面、各个环节的，是档案工作的中心。国家档案局要求，凡是还没有出台本地区本系统本单位实施《意见》文件的，一定要在2015年内推动出台，并要争取在实施文件中有一些含金量高的实质性内容；凡未完成这一任务的档案部门，要把这项任务作为2015年的一项刻不容缓的硬任务去完成或去督促检查；已完成这一任务的要抓紧对文件逐项落实。国家档案局明确提出，各级档案部门贯彻落实《意见》，要把重点放在5个方面，即完善体制机制、加大支持保障、健全档案资源体系、健全档案利用体系、健全档案安全体系。在完善体制机制和加大支持保障方面，要按照《意见》切实提高档案部门的履职能力。各级档案部门要加强向领导的请示汇报，每年至少向党委、政府或本单位领导汇报一次工作，特别是要积极主动地为领导和有关部门服务，以多请示、多汇报、多服务来争取领导和社会的重视和支持。要大胆履行好自身职责，凡属档案，都理直气壮地去管理；凡属档案事务，都放心大胆地去抓；凡属档案服务，都积极主动地去开展。要积极发挥各种社会力量的作用，利用更多的社会力量参与档案事务。在健全档案资源体系方面，要突出一个“全”字，注意一个“新”字，把各种新形成的档案，包括新的档案形成者的档案、新的专业档案、新的载体档案等，全面建立起来，做到应建尽建、应归尽归、应收尽收。在健全档案利用体系方面，要突出一个“活”字，注意“主动”和“方便”这两点，主动地用各种形式和渠道开发档案资源，把档案用活，并让广大人民群众非常方便地利用到档案和政府公开信息，实现档案利用量的扩大与质的提升。在健全档案安全体系方面，要突出一个“保”字，要有底线思维，通过人防、物防、技防，通过定制度、搞检查、抓整改，严防死守，坚决保住安全保密这个底线。“三个体系”健全与否，关系档案工作的好坏。因为检验档案工作好坏的标准，主要看档案收得全不全、用得好不好、安全不安全。据统计，目前已有12个省、自治区、直辖市，8家中央国家机关，21家中央企业已出台本地区本系统本单位实施《意见》的文件。,2015/1/28
399,jQuery的性能优化,张建涛,http://180.168.156.212:2262/wecenter/?/article/8894,"=================================================================一、选择器性能优化建议=================================================================1.总是从#id选择器来继承这是jQuery选择器的一条黄金法则。jQuery选择一个元素最快的方法就是用ID来选择了。1.$('#content').hide();复制代码或者从ID选择器继承来选择多个元素:1.$('#contentp').hide();复制代码2.在class前面使用tagjQuery中第二快的选择器就是tag选择器（如$(‘head’)），因为它和直接来自于原生的Javascript方法getElementByTagName()。所以最好总是用tag来修饰class(并且不要忘了就近的ID)1.varreceiveNewsletter=$('#nslForminput.on');复制代码jQuery中class选择器是最慢的，因为在IE浏览器下它会遍历所有的DOM节点。尽量避免使用class选择器。也不要用tag来修饰ID。下面的例子会遍历所有的div元素来查找id为’content’的那个节点：1.varcontent=$('div#content');//非常慢，不要使用复制代码用ID来修饰ID也是画蛇添足：1.vartraffic_light=$('#content#traffic_light');//非常慢，不要使用复制代码3.使用子查询将父对象缓存起来以备将来的使用1.varheader=$('#header');2.varmenu=header.find('.menu');3.//或者4.varmenu=$('.menu',header);复制代码4.优化选择器以适用Sizzle的“从右至左”模型自版本1.3之后，jQuery采用了Sizzle库，与之前的版本在选择器引擎上的表现形式有很大的不同。它用“从左至右”的模型代替了“从右至左”的模型。确保最右的选择器具体些，而左边的选择器选择范围较宽泛些：varlinkContacts=$('.contact-linksdiv.side-wrapper');而不要使用varlinkContacts=$('a.contact-links.side-wrapper');5.采用find()，而不使用上下文查找.find()函数的确快些。但是如果一个页面有许多DOM节点时，需要来回查找时，可能需要更多时间:1.vardivs=$('.testdiv','#pageBody');//2353onFirebug3.62.vardivs=$('#pageBody').find('.testdiv');//2324onFirebug3.6-Thebesttime3.vardivs=$('#pageBody.testdiv');//2469onFirebug3.6复制代码6.利用强大的链式操作采用jQuery的链式操作比缓存选择器更有效：1.$('li.menu-item').click(function(){alert('testclick');})2..css('display','block')3..css('color','red')4.fadeTo(2,0.7);复制代码记住，永远不要让相同的选择器在你的代码里出现多次：（1）为了区分普通的JavaScript对象和jQuery对象，可以在变量首字母前加上$符号。7.编写属于你的选择器如果你经常在代码中使用选择器，那么扩展jQuery的$.expr[':']对象吧，编写你自己的选择器。下面的例子中，我创建了一个abovethefold选择器，用来选择不可见的元素：1.$.extend($.expr[':'],{2.abovethefold:function(el){3.return$(el).offset().top<$(window).scrollTop()+$(window).height();4.}5.});6.varnonVisibleElements=$('div:abovethefold');//选择元素复制代码=================================================================二、优化DOM操作建议=================================================================8.缓存jQuery对象将你经常用的元素缓存起来：1.varheader=$('#header');2.vardivs=header.find('div');3.varforms=header.find('form');复制代码9.当要进行DOM插入时，将所有元素封装成一个元素这里的基本思想是在内存中建立你确实想要的东西，然后更新DOM。这并不是一个jQuery最佳实践，但必须进行有效的JavaScript操作。直接的DOM操作速度很慢直接的DOM操作很慢。尽可能少的去更改HTML结构。1.varmenu='<ulid=""menu"">';2.for(vari=1;i<100;i++){3.menu+='<li>'+i+'</li>';4.}5.menu+='</ul>';6.$('#header').prepend(menu);7.//千万不要这样做：8.$('#header').prepend('<ulid=""menu""></ul>');9.for(vari=1;i<100;i++){10.$('#menu').append('<li>'+i+'</li>');11.}复制代码冒泡事件：除非在特殊情况下,否则每一个js事件(例如:click,mouseover等.)都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点会很有用。代替这种效率很差的多元素事件监听的方法就是,你只需向它们的父节点绑定一次。比如,我们要为一个拥有很多输入框的表单绑定这样的行为:当输入框被选中时为它添加一个class传统的做法是，直接选中input，然后绑定focus等，如下所示：1.$(""#entryforminput"").bind(""focus"",function(){2.$(this).addClass(""selected"");3.}).bind(""blur"",function(){4.$(this).removeClass(""selected"");5.});复制代码当然上面代码能帮我们完成相应的任务，但如果你要寻求更高效的方法，请使用如下代码：1.$(""#entryform"").bind(""focus"",function(e){2.var$cell=$(e.target);//e.target捕捉到触发的目标元素3.$cell.addClass(""selected"");4.}).bind(""blur"",function(e){5.var$cell=$(e.target);6.$cell.removeClass(""selected"");7.});复制代码通过在父级监听获取焦点和失去焦点的事件，对目标元素进行操作。在上面代码中，父级元素扮演了一个调度员的角色,它可以基于目标元素绑定事件。如果你发现你给很多元素绑定了同一个事件监听,那么现在的你肯定知道哪里做错了。同理，在Table操作时，我们也可以使用这种方式加以改进代码：普通的方式1.$('#myTabletd').click(function(){2.$(this).css('background','red');3.});4.改进方式：5.$('#myTable').click(function(e){6.var$clicked=$(e.target);7.$clicked.css('background','red');8.});复制代码假设有100个td，在使用普通的方式的时候，你绑定了100个事件。在改进方式中，你只为一个元素绑定了1个事件，至于是100个事件的效率高，还是1个事件的效率高，相信你也能自行分辨了。10.尽管jQuery不会抛出异常，但开发者也应该检查对象尽管jQuery不会抛出大量的异常给用户，但是开发者也不要依赖于此。jQuery通常会执行了一大堆没用的函数之后才确定一个对象是否存在。所以在对一个作一系列引用之前，应先检查一下这个对象存不存在。11.使用直接函数，而不要使用与与之等同的函数为了获得更好的性能，你应该使用直接函数如$.ajax()，而不要使用$.get(),$.getJSON(),$.post()，因为后面的几个将会调用$.ajax()。12.缓存jQuery结果，以备后来使用你经常会获得一个javasript应用对象——你可以用App.来保存你经常选择的对象，以备将来使用：1.App.hiddenDivs=$('div.hidden');2.//之后在你的应用中调用：3.App.hiddenDivs.find('span');复制代码13.采用jQuery的内部函数data()来存储状态不要忘了采用.data()函数来存储信息：1.$('#head').data('name','value');2.//之后在你的应用中调用:3.$('#head').data('name');复制代码14.使用jQueryutility函数不要忘了简单实用的jQuery的utility函数。我最喜欢的是$.isFunction(),$isArray()和$.each()。15.为HTML块添加“JS”的class当jQuery载入之后，首先给HTML添加一个叫”JS”的class$('HTML').addClass('JS');只有当用户启用JavaScript的时候，你才能添加CSS样式。例如/*在css中*/.JS#myDiv{display:none;}所以当JavaScript启用的时候，你可以将整个HTML内容隐藏起来，用jQuery来实现你想实现的（譬如：收起某些面板或当用户点击它们时展开）。而当Javascript没有启用的时候，浏览器呈现所有的内容，搜索引擎爬虫也会勾去所有内容。我将来会更多的使用这个技巧。=================================================================三、关于优化事件性能的建议=================================================================16.推迟到$(window).load有时候采用$(window).load()比$(document).ready()更快，因为后者不等所有的DOM元素都下载完之前执行。你应该在使用它之前测试它。17.使用EventDelegation当你在一个容器中有许多节点，你想对所有的节点都绑定一个事件，delegation很适合这样的应用场景。使用Delegation，我们仅需要在父级绑定事件，然后查看哪个子节点(目标节点)触发了事件。当你有一个很多数据的table的时候，你想对td节点设置事件，这就变得很方便。先获得table，然后为所有的td节点设置delegation事件：1.$(""table"").delegate(""td"",""hover"",function(){2.$(this).toggleClass(""hover"");3.});复制代码18.使用ready事件的简写如果你想压缩js插件，节约每一个字节，你应该避免使用$(document).onready()1./也不要使用2.$(document).ready(function(){3.//代码4.});5.//你可以如此简写：6.$(function(){7.//代码8.});复制代码=================================================================四、测试jQuery=================================================================19.jQuery单元测试测试JavaSript代码最好的方法就是人来测试。但你可以使用一些自动化的工具如Selenium，Funcunit，QUit，QMock来测试你的代码（尤其是插件）。我想在另外一个专题来讨论这个话题因为实在有太多要说的了。20.标准化你的jQuery代码经常标准化你的代码，看看哪个查询比较慢，然后替换它。你可以用Firebug控制台。你也可以使用jQuery的快捷函数来使测试变得更容易些：1.//在Firebug控制台记录数据的快捷方式2.$.l($('div'));3.//获取UNIX时间戳4.$.time();5.//在Firebug记录执行代码时间6.$.lt();7.$('div');8.$.lt();9.//将代码块放在一个for循环中测试执行时间10.$.bm(""vardivs=$('.testdiv','#pageBody');"");//2353onFirebug3.6复制代码=================================================================五、其他常用jQuery性能优化建议=================================================================21.使用最新版本的jQuery最新的版本往往是最好的。更换了版本后，不要忘记测试你的代码。有时候也不是完全向后兼容的。22.使用HMTL5新的HTML5标准带来的是更轻巧的DOM结构。更轻巧的结构意味着使用jQuery需要更少的遍历，以及更优良的载入性能。所以如果可能的话请使用HTML5。23.如果给15个以上的元素加样式时，直接给DOM元素添加style标签要给少数的元素加样式，最好的方法就是使用jQuey的css()函数。然而更15个以上的较多的元素添加样式时，直接给DOM添加style标签更有效些。这个方法可以避免在代码中使用硬编码(hardcode)。1.$('<styletype=""text/css"">div.class{color:red;}</style>')2..appendTo('head');复制代码24.避免载入多余的代码将Javascript代码放在不同的文件中是个好的方法，仅在需要的时候载入它们。这样你不会载入不必要的代码和选择器。也便于管理代码。25.压缩成一个主JS文件，将下载次数保持到最少当你已经确定了哪些文件是应该被载入的，那么将它们打包成一个文件。用一些开源的工具可以自动帮你完成，如使用Minify(和你的后端代码集成)或者使用JSCompressor，YUICompressor或DeanEdwardsJSpacker等在线工具可以为你压缩文件。我最喜欢的是JSCompressor。26.需要的时候使用原生的Javasript使用jQuery是个很棒的事情，但是不要忘了它也是Javascript的一个框架。所以你可以在jQuery代码有必要的时候也使用原生的Javascript函数，这样能获得更好的性能。27.从Google载入jQuery框架当你的应用正式上线的时候，请从GoogleCDN载入jQuery，因为用户可以从最近的地方获取代码。这样你可以减少服务器请求，而用户如果浏览其他网站，而它也使用GoogleCDN的jQuery时，浏览器就会立即从缓存中调出jQuery代码。1.//链接特定版本的压缩代码2.<scripttype=""text/javascript""src=""[color=blue!important] ""></script>复制代码28.缓慢载入内容不仅能提高载入速度，也能提高SEO优化（LazyloadcontentforspeedandSEObenefits）使用Ajax来载入你的网站吧，这样可以节约服务器端载入时间。你可以从一个常见的侧边栏widget开始。",2015/1/28
400,15个提高编程技巧的JavaScript工具,李海波,http://180.168.156.212:2262/wecenter/?/article/8893,JavaScript脚本库是一个预先用JavaScript语言写好的库，它方便了我们开发基于JavaScript的应用程序，特别适合AJAX和其他一些以Web为中心的技术。JavaScript主要用于编写嵌入或者包含在HTML页面的函数，从而实现DOM之间的交互。这篇文章收集了15个可用于提高编程技巧的JavaScript工具，助你轻松快速完成工作。下面的这些JavaScript工具能让你管理Javascript状态、压缩JavaScript代码、重构脚本代码结构等等。JavaScriptStateManager是一种轻量级的、易于使用的状态管理器，主要用于响应式网站。它不需要任何的JavaScript框架。你可以定义断点将运行在当前断点的JavaScript代码打包在一起。官方网站： ,2015/1/28
401,Java程序员应该知道的10个Eclipse调试技巧,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8892,Eclipse是众多Java程序员实用的开发工具，其中开发技巧也是繁多，但作为优秀的Java程序员，需要掌握最起码的调试技巧。1条件断点如果你不知道如何添加断点，只需点击左边面板(行号前面)断点即被创建。在调试界面中，“断点”视图会把所有被创建的断点列出来。我们可以给它加一个布尔条件，也就是说，该断点会被激活并且如果布尔条件为真，就会执行该断点，否则将会跳过往下执行。2异常断点在断点视图中，有一个J!标记按钮!我们可以使用该按钮来添加一个Java异常断点。例如，我们想让程序在遇到空指针异常(NullPointerException)时，仍然能继续调试，那么我们可以使用该按钮来添加一个异常断点!3监视点这是一个非常好的功能，当选定的属性访问或修改程序时，程序会停止执行并允许进行调试。在Outline视图中选择一个类变量并从上下文菜单中选择切换监视点，属性监视点将会被创建，在断点(Breakpoints)视图中会把所有监视点用列表的形式显示出来。4评估/检查按Ctrl+Shift+D或者Ctrl+Shift+I来显示选定变量或者表达式的值。我们也可以给一个变量或表达式添加永久观察点，当程序在调试时，这些观察点就会在表达式视图(Expressionview)中显示出来。5修改变量值在调试过程中，我们可以修改变量值。先选好一个变量然后进入变量视图(Variablesview)，根据变量类型在其对应的value列里输入值即可。6在Main函数里面停止执行在运行/调试设置中，编辑配置对话框中有“Main”这个选项卡，我们可以勾选“Stopinmain”这个复选框。如果选中，那么在调试一个基于main方法的Java程序时，程序会在main方法第一行位置便停止执行。7环境变量并不是在系统属性中添加环境变量，我们可以在编辑配置对话框中很方便地进行添加。8DroptoFrame调试期间，可以重新跳到调用堆栈框架的开始处执行，并且变量值也会回到最初。根据回档调整堆栈的深度，这个功能的主要用途是所有变量状态可以快速回到方法开始执行时候的样子，然后你可以重新进行一遍一遍执行，这样就可以在你关注的地方进行多次调试，但是在执行过程中也会产生一些副作用，比如插入到数据库里面的数据是无法删除的!9分布过滤当我们进入(F5)方法的时候，我们还可以访问其外部库(比如JAVA.*)，我们可能不需要这个库，就可以在Perference选项卡页面添加一个过滤器来排除这个包。10进入、跳出和返回F5——进入：移动到下一个步骤，如果当前行有一个方法调用，该控件将会跳转到被调用方法的第一行执行。F6——跳出：移动到下一行。如果在当前行有方法调用，那么会直接移动到下一行执行。不会进入被调用方法体里面。F7——返回：从当前方法中跳出，继续往下执行。F8——移动到下一个断点处执行。,2015/1/27
402,Linux命令大全 CHM帮助文档,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8891,文档见附件Linux命令大全(Linuxidc.com修改版).chm,2015/1/27
403,SQL趣题,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8890,390822352,2015/1/27
404,Windows 10 中文技术预览版个人试用报告,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8889,使用虚拟机安装在虚拟机上安装这个版本，装的时候会提示“找不到驱动程序”的经典问题。在这种情况下也可以尝试用多种方法解决。官方的办法简单粗暴：直接升级到最新版Parallels就可以了。但是有些人用的并非正版。因此，也可以使用老毛桃启动虚拟机，执行硬盘安装器。在重启的时候选择从官方安装光盘启动，选择恢复控制台当中的启动修复，就可以完成安装过程。目前为止来说，这是最简单的一个方法，以后即使出了Win10正式版也可以使用，而无需每次都升级Parallels。按照硬盘安装法安装好以后的虚拟机是不带光驱的——这里需要注意一下，如果想要安装ParallelsTools的话，需要把prl-tools-win.iso拷贝到U盘里，再接入U盘后双击ISO文件安装。安装完之后依然没有光驱，不过对于其他的实际使用不受影响。prl-tools-win.iso需要在“应用程序”找到“ParallelsDesktop”，右击点“显示包内容”，然后定位到“Contents”-“Resources”-“Tools”。如果想要尝鲜体验不同姿势的话，现在就可以了。效率这个测试版进一步改良了一般x86程序的运行效率。跟Windows8或者8.1相比，9926对于系统的要求和空间占用都不是更高，相反可能会运行的更流畅一点。但是也因为是测试版的缘故，打开很多常见功能的时候都会出现问题。特别不能忍受的是Metro应用打开速度极慢，跟x86同类应用不成比例的慢。也许是因为这次测试版使用了新的引擎的缘故，或者是其他原因，开始菜单也和其他Metro程序一样动不动就罢工，就算是换一张壁纸，或者是把图标缩小为小尺寸的时候，都很有可能引起崩溃，而一崩溃我就必须等上半分钟左右。我没用过上一个测试版，据说上一版还要难受，如果开始菜单崩溃了，整个资源管理器进程跟着一起崩溃，并且甚至有可能陷入死循环。虽然这次跟之前相比，官方开设了一个意见收集的反馈渠道，但是，从这些渠道当中到底能有多少信息被工作人员成功地看到并且使用也是未知数，因为工作人员根本不可能逐一解答所有问题。为了用小娜我切到美国去了（但很可惜！小娜如果第一次打开的时候在中国，以后切换语言也无法激活了。我去旧金山的时候再试试看）。在中国区的时候好多反馈都是哭天抢地要用回Aero界面…………槽点下面来说一下其中我看到的几个值得吐槽的地方。这张图可能不太明显，就是后台运行的程序是下方有一条细线，看时间长了也就习惯了肯定没有测试过任务栏竖着放，开始菜单那三个按钮细到没法用！三个按钮不对齐，逼死强迫症！鼠标移动到左侧边缘就想把通知面板resize，结果动不了。文档翻译还有好多值得吐槽的地方我还是觉得新版学习成本太高——尽管已经两三年过去了。跟这么长一串入门比起来，Mac的入门相当简单——当然也不排除你看不懂：Mac新手//不过也许和Windows这个入门对应的应该是这一页：Mac基础知识更新的音乐App可以在线搜索匹配本地音乐元数据，但检查了一下发现好像并非覆盖ID3标签，而是更新到单独的数据库，就像iTunes而且也是可以pin专辑到开始菜单的。上一次尝试付费音乐是MSNMusic，然后是EDGE，不知道这次能坚持多久。Vista开始留到现在的遗产——语音识别。这个组件到现在就没变过。从Windows8开始存在的两套附件的问题开始解决了：计算器只有一个了。通讯录、Windows邮件也分别被人脉和邮件App替代。但是Windows传真和扫描与扫描App、两个录音机的重叠仍在；WindowsMediaPlayer被取消了文件关联却还保留着，也应该被剔除。其他应该去除的附件还有：Windows日记本、便签（TabletPC时代的遗产，应该被换成OneNote）；画图（应该被换成FreshPaint）；远程桌面连接（有一个对应的MetroApp）。你喜欢怎么折腾你的开始菜单？左侧程序目录被分成三列且无法修改，所以还是善用右侧，做快速启动用。这是我调整好的开始菜单的样子。吐槽一下“最常用”的计数完全不对，建议这个跟“最近添加”还是合并到一起并且不做文字提示，我们也可以像以前一样手动固定某个快捷方式在左边。还有小图标的非MetroApp留白太严重，没必要非得用16×16的图标啊，放大点啊。,2015/1/27
405,微软斯巴达浏览器原生支持 Chrome 浏览器扩展,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8888,今天是微软的大日子，微软会在今天向外界揭示Windows10消费者预览版，并且炫耀新的斯巴达浏览器。根据Neowin网站报道，斯巴达浏览器将原生支持Chrome浏览器扩展，以提升斯巴达浏览器对开发者的吸引力。另外，Chrome浏览器开发者也在努力让Chrome浏览器扩展可以在斯巴达浏览器上正常工作。这些消息证明斯巴达浏览器和Chrome浏览器之间存在不少相似性，这种做法也可以节省开发商不少时间。之前，开发者针对一款新浏览器，不得不重新开始研发一个新的扩展。而现在，他们可以简单地把他们的Chrome扩展交给斯巴达浏览器，以最小的努力迅速覆盖两种浏览器。,2015/1/27
406,distinct函数在oracle和Sqlserver中的区别,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8887,首先来看下distinct函数的定义和用法:可以一同使用DISTINCT和COUNT关键词，来计算非重复结果的数目。语法:SELECTCOUNT(DISTINCTcolumn(s))FROMtable但是虽然此函数适用于oracle和Sqlserver，但也有一定的区别，当使用此函数在hibernate环境下查找一个结果为空的语句时，oracle中返回的结果是null而Sqlserver中返回的结果是“”，所以当应用这个函数来执行结果时，如果要同时兼容oracle和Sqlserver，就需要在处理返回结果时，使用isEmpty方法来判断是否为空，而不能草率的使用nul来比较,2015/1/27
407,DBCP 应用的总结,王雷2,http://180.168.156.212:2262/wecenter/?/article/8886,详见附件DBCP应用的总结.docx,2015/1/27
408,系统配置平台启动后、长时间不操作 ，会报数据库连接问题,王雷2,http://180.168.156.212:2262/wecenter/?/article/8885,"系统启动后、长时间不操作连接无效就会报这个错session由spring管理2012-07-1613:08:21,889WARN[org.hibernate.engine.jdbc.spi.SqlExceptionHelper]SQLError:0,SQLState:null2012-07-1613:08:21,889ERROR[org.hibernate.engine.jdbc.spi.SqlExceptionHelper]Alreadyclosed.2012-07-1613:08:21,896DEBUG[org.springframework.orm.hibernate4.SessionFactoryUtils]CouldnotcloseHibernateSessionorg.hibernate.exception.GenericJDBCException:Couldnotcloseconnectionatorg.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:54)atorg.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:125)atorg.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:110)atorg.hibernate.engine.jdbc.internal.LogicalConnectionImpl.releaseConnection(LogicalConnectionImpl.java:327)atorg.hibernate.engine.jdbc.internal.LogicalConnectionImpl.close(LogicalConnectionImpl.java:199)atorg.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl.close(JdbcCoordinatorImpl.java:141)atorg.hibernate.engine.transaction.internal.TransactionCoordinatorImpl.close(TransactionCoordinatorImpl.java:276)atorg.hibernate.internal.SessionImpl.close(SessionImpl.java:335)atorg.springframework.orm.hibernate4.SessionFactoryUtils.closeSession(SessionFactoryUtils.java:126)atorg.springframework.orm.hibernate4.HibernateTransactionManager.doBegin(HibernateTransactionManager.java:437)atorg.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:371)atorg.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:335)atorg.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:105)atorg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)atorg.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:90)atorg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)atorg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)at$Proxy19.getAllTopmostSubjectMain(UnknownSource)atcom.hstba.action.SubjectMainAction.welcome(SubjectMainAction.java:32)atsun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethod)atsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)atsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)atjava.lang.reflect.Method.invoke(Method.java:601)atcom.opensymphony.xwork2.DefaultActionInvocation.invokeAction(DefaultActionInvocation.java:453)atcom.opensymphony.xwork2.DefaultActionInvocation.invokeActionOnly(DefaultActionInvocation.java:292)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:255)atorg.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:256)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.DefaultWorkflowInterceptor.doIntercept(DefaultWorkflowInterceptor.java:176)atcom.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.validator.ValidationInterceptor.doIntercept(ValidationInterceptor.java:265)atorg.apache.struts2.interceptor.validation.AnnotationValidationInterceptor.doIntercept(AnnotationValidationInterceptor.java:68)atcom.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.ConversionErrorInterceptor.intercept(ConversionErrorInterceptor.java:138)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:211)atcom.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:211)atcom.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:190)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atorg.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:75)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atorg.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:90)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atorg.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:243)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:100)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:141)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:145)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:171)atcom.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:176)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atorg.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:192)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atcom.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:187)atcom.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:249)atorg.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:54)atorg.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:510)atorg.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:77)atorg.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:91)atorg.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)atorg.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)atorg.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:224)atorg.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:169)atorg.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472)atorg.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:168)atorg.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:98)atorg.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:927)atorg.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)atorg.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407)atorg.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:987)atorg.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:579)atorg.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:1805)atjava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)atjava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)atjava.lang.Thread.run(Thread.java:722)Causedby:java.sql.SQLException:Alreadyclosed.atorg.apache.commons.dbcp.PoolableConnection.close(PoolableConnection.java:114)atorg.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.close(PoolingDataSource.java:191)atorg.hibernate.service.jdbc.connections.internal.DatasourceConnectionProviderImpl.closeConnection(DatasourceConnectionProviderImpl.java:148)atorg.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.releaseConnection(AbstractSessionImpl.java:283)atorg.hibernate.engine.jdbc.internal.LogicalConnectionImpl.releaseConnection(LogicalConnectionImpl.java:323)...84more[解决办法]Spring的连接池配置加上validationQuery，来检测数据库连接是否失效，如果失效则自动从新连接destroy-method=""close"">510523000true180truetruetrueselect1",2015/1/27
409,Dhtmlx使用心得,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8884,"dhtmlxTabbar(一)Tab组件支持渲染html元素，但渲染过程不比从javascript构造简单，因此仍然建议使用构造函数dhtmlXTabBar新建。此函数接受两个参数，第一个参数是填充目标，第二个参数是样式(top、bottom、left、right)。(二)接下来必须用setImagePath指明图像资源目录。(三)接下来使用addTab为Tab添加页签。addTab接受三个参数，第一个参数是id，第二个参数是label，第三个参数是宽度。(四)可以进一步为每个页签指明内容，使用setContent、setContentHTML以及setContentHref可以将其他元素、HTML源代码、其他url作为页签内容。123456789101112131415Vartabbar=newdhtmlXTabBar(""tab"",""top"");tabbar.setImagePath(""./tabbar/codebase/imgs/"");tabbar.setSkinColors(""#FCFBFC"",""#F4F3EE"",""#FCFBFC"");tabbar.setHrefMode(""iframes"");tabbar.addTab(""s0"",""首页"",""100px"");tabbar.addTab(""s8"",""159成本核算信息系统"",""150px"");tabbar.setTabActive(""s8"",true,false);tabbar.setContentHref(""s0"",""/"");tabbar.setContentHref(""s8"",""./159/index.html"");//tabbar.loadXML(""module.xml"");tabbar.enableAutoReSize(true);dhtmlxGridjs构建A先创建表各种属性：表头皮肤图片路径等B增加表格的body可以采用的方式如下123456789101112131415dhtmlxGridsupportsdifferenttypesofdatasources:-xml;-csv;-json;-javascriptarray.基于服务器端：grid.load(url)-loadsdatafromaremotefile,xmlisexpectedbydefault;grid.load(url,""csv"")-thesameforcsvformat;grid.load(url,""json"")-thesameforjsonformat;grid.load(url,""jsarray"")-thesameforjsarrayformat.基于本地：grid.parse(object)-loadsdatafromastring|object,xmlisexpectedbydefault;grid.parse(data,""csv"")-thesameforcsvformat;grid.parse(data,""json"")-thesameforjsonformat;grid.parse(data,""jsarray"")-thesameforjsarrayformat.",2015/1/27
410,2015年 网页设计趋势,李海波,http://180.168.156.212:2262/wecenter/?/article/8883,（1）高度的响应式HTML5视频；（2）质感设计；（3）影子按钮；（4）扁平设计仍是主流；（5）点击滚动；（6）圆形进度按钮；（7）更加注重排版；（8）微交互；（9）慢速显示； /news/30153,2015/1/27
411,jQuery的选择器中的通配符[id^='code'],何文,http://180.168.156.212:2262/wecenter/?/article/8882,"1.选择器(1)通配符：$(""input[id^='code']"");//id属性以code开始的所有input标签$(""input[id$='code']"");//id属性以code结束的所有input标签$(""input[id*='code']"");//id属性包含code的所有input标签(2)根据索引选择$(""tbodytr:even"");//选择索引为偶数的所有tr标签$(""tbodytr:odd"");//选择索引为奇数的所有tr标签(3)获得jqueryObj下一级节点的input个数jqueryObj.children(""input"").length;(4)获得class为main的标签的子节点下所有<a>标签$("".main>a"");(5)选择紧邻标签jqueryObj.next(""div"");//获取jqueryObj标签的后面紧邻的一个div，nextAll获取所有2.筛选器//not$(""#codeinput:not([id^='code'])"");//id为code标签内不包含id以code开始的所有input标签3.事件//处理文本框上的键盘操作jqueryObj.keyup(function(event){varkeyCode=event.which;//获取当前按下键盘的键值，回车键为13}4.工具函数$('#someField').val($.trim($('#someField').val()));//消除空格，语法：$.trim(value)",2015/1/26
412,MOVE 模式,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8881,MVC模式在编程中的应用，是一个很了不起的主意。“数据模型（Model）”可以封装与应用程序的业务逻辑相关的数据及对数据的处理方法；“视图层（View）”能够实现数据有目的的显示；“控制器（Controller）”能够在不同层面间起到组织作用，对应用程序的流程进行控制。不过，可能你在使用这种三层架构模式的过程中会逐渐迷惑。因为有很多代码你不知道把它放哪，就只好把它放到控制层，最后发现在控制层中塞了太多的代码。LinkedIn的软件工程师ConradIrwin也遇到同样的问题，于是他开始使用另一种模式：MOVE，即Models（模型）、Operations（操作）、Views（视图）、Events（事件）。近日ConradIrwin在个人博客上分享了关于这种模式的一些观点。概述Irwin结合上图对MOVE模式先作了简单定义：Models，封装该应用程序中知道的一切；Operations，封装该应用程序要做的一切；Views，帮助用户与应用程序完成交互；Events，用于安全地连接所有这些组件。为了避免意大利面条式的代码，图中标示出了对哪种类型的对象进行操作是允许的。例如，视图允许监听由模型产生的事件；操作允许修改模型，但模型不应涉及视图或操作。Models（模型）这里以一个“User”对象为原型，它至少应用有一个Email地址，也可能有用户名和电话号码。在一个MOVE模式的Models中只包装知识。这意味着除了Get和Set功能，它们可以包含检查用户密码是否正确这样的方法，但不会包含把密码保存到数据库或传递给外部API这样的功能，因为后面这些工作将由Operations来完成。Operations（操作）对应用程序来说，一个常见的操作是用户登陆。这实际上是由两个子操作组成：首先从用户那里获得邮件地址和密码，然后从数据库载入“user”模型并检查密码是否匹配。Operations是MOVE模式中的行动者。它负责修改模型，在正确的时间显示正确的视图，以及响应由用户交互引发的事件。在一个分解良好的应用程序中，每个子操作都可以独立运行。采用这种方式的操作有一点很令人振奋，即程序启动后，整个应用本身就可以被当作一个Operations。它会根据需要生成尽可能多的子操作，其中每个子操作都并行地运行。当所有子操作都完成时，程序也便退出。Views（视图）登陆页面即是一个视图，它负责显示一些文本框给用户。当用户点击“登陆”按钮时，视图将产生一个“loginAttempt”事件，其中包含用户输入的用户名和密码。用户能够看到的内容，以及能感受到的互动都由视图提供支持。它们会以一种用户能理解的形式呈现应用反馈，同时还能将简单的用户交互转换成有意义的事件。更重要的是视图不会直接改变模型，它们只是向Operations发起事件，然后通过监听等待由模型发起的事件。Events（事件）当用户登陆时，视图会发起“loginAttempt”事件。在登陆操作完成后，“currentUser”模型会发起一个事件通知应用登陆状态已改变。事件监听让MOVE（及MVC）实现控制反转，允许模型更新视图。这是一种强大的抽象技巧，允许组件互不干扰地耦合在一起。为什么是现在？当然，ConradIrwin并不想被人认为自己是在暗示MVC模式很差，这种大型应用程序架构在过去的几十年里确实非常成功。不过几十年后的今天，新的编程技术已经变得越来越流行，所以你也会在使用过程中逐渐产生一些疑惑。MVC模式确实很了不起，但它毕竟是几十年前为老的技术而设计。MOVE模式是在其基础上的升级，让你可以更好地利用当前已有的新工具。,2015/1/23
413,HTML5开发 拖拽文件上传,管俊,http://180.168.156.212:2262/wecenter/?/article/8880,"Drag&Drop拖拽功能的处理关于HTML5拖拽文件上传，其实国外已经有很多网站有这样的应用，最早推出拖拽上传应用的是Gmail，它支持标准浏览器下拖拽本地文件到浏览器中作为邮件的附件发送，但其实现在利用HTML5的功能实现，主要借助于新版支持的浏览器来实现，IE还是弱很多。拖拽上传应用主要使用了以下HTML5技术：Drag&Drop:HTML5基于拖拽的事件机制.FileAPI:可以很方便的让Web应用访问文件对象，FileAPI包括FileList、Blob、File、FileReader、URIscheme，本文主要讲解拖拽上传中用到的FileList和FileReader接口。FormData:FormData是基于XMLHttpRequestLevel2的新接口，可以方便web应用模拟Form表单数据，重要的是它支持文件的二进制流数据，这样我们就能够通过它来实现AJAX向后端发送文件数据了。HTML5Drag&Drop事件过去我们想实现网页中的拖拽效果，基本上都是使用DOM事件模型中的mousedown、mousemove、mouseup的事件监听来模拟拖拽效果，为了实现实时的拖拽移动效果，还要不停地获取鼠标的坐标，还要不停的修改元素的位置，代码要堆很多，而且性能上也很不好(不停地修改元素位置会导致页面reflow，除非绝对定位)，现在有了html5原生的Drag&Drop拖拽事件，真的是方便了许多，用”事半功倍”来形容绝不为过。Drag&Drop包括以下事件：dragstart：要被拖拽的元素开始拖拽时触发，这个事件对象是被拖拽元素dragenter：拖拽元素进入目标元素时触发，这个事件对象是目标元素dragover：拖拽某元素在目标元素上移动时触发，这个事件对象是目标元素dragleave：拖拽某元素离开目标元素时触发，这个事件对象是目标元素dragend：在drop之后触发，就是拖拽完毕时触发，这个事件对象是被拖拽元素drop：将被拖拽元素放在目标元素内时触发，这个事件对象是目标元素完成一次成功页面元素拖拽的行为事件过程：dragstart–>dragenter–>dragover–>drop–>dragend要想实现拖拽，首页需要阻止浏览器默认行为，一共四个事件。1$(document).on({2dragleave:function(e){//拖离3e.preventDefault();4$('.dashboard_target_box').removeClass('over');5},6drop:function(e){//拖后放7e.preventDefault();8},9dragenter:function(e){//拖进10e.preventDefault();11$('.dashboard_target_box').addClass('over');12},13dragover:function(e){//拖来拖去14e.preventDefault();15$('.dashboard_target_box').addClass('over');16}17});获取文件数据HTML5FileAPIFileAPI中的FileList接口,它主要通过两个途径获取本地文件列表：一种是<inputtype=“file”>的表单形式，一种是e.dataTransfer.files拖拽事件传递的文件信息varfileList=e.dataTransfer.files;使用files方法将会获取到拖拽文件的数组形势的数据，每个文件占用一个数组的索引，如果该索引不存在文件数据，将返回null值。可以通过length属性获取文件数量.varfileNum=fileList.length;判断文件类型fileList[0].type.indexOf(’image’);FormData模拟表单实现Ajax文件上传file.getAsBinary获取文件流很简单，但是要想上传数据，就要模拟一下表单的数据格式了，首先看看模拟表单的js代码,FormData模拟表单数据时更是简洁，不用麻烦的去拼字符串，而是直接将数据append到formdata对象中即可1xhr=newXMLHttpRequest();2xhr.open(""post"",""test.php"",true);3xhr.setRequestHeader(""X-Requested-With"",""XMLHttpRequest"");4varfd=newFormData();5fd.append('ff',fileList[0]);6xhr.send(fd);前端的代码如下：1<scriptsrc="" ('<strong>'+fileList[0].name+'</strong>('+(fileList[0].type||""n/a"")+')-'+picsize.toFixed(2)+'KB<ahref=""pic/'+fileList[0].name+'""target=""_blank"">查看图片</a>');119120},false);121122});123</script>124125<divid=""target_box""class=""dashboard_target_box"">126<divid=""drop_zone_home""class=""dashboard_target_messages_container"">127<pid=""dtb-msg2""class=""dashboard_target_box_message""style=""top:-44px"">选择你的图片<br>128开始上传</p>129<pid=""dtb-msg1""class=""dashboard_target_box_message""style=""top:-44px"">拖动图片到<br>130这里</p>131</p>132</div>133<divid=""Lists""></div>134</div>",2015/1/22
414,windows10 发布，Spartan来了，IE要被革命,路斌,http://180.168.156.212:2262/wecenter/?/article/8879,组件库小组，挑战来了。。。。。。。。,2015/1/22
415,最近国家档案局一口气发布了九项档案行业标准，求标准文本,袁嘉新,http://180.168.156.212:2262/wecenter/?/article/8878,1．DA/T50-2014《数码照片归档与管理规范》2．DA/T51-2014《电影艺术档案著录规则》3．DA/T52-2014《档案数字化光盘标识规范》4．DA/T53-2014《数字档案COM和COLD技术规范》5.DA/T54-2014《照片类电子档案元数据方案》6.DA/T55-2014《特藏档案库基本要求》7.DA/T56-2014《档案信息系统运行维护规范》8.DA/T57-2014《档案关系型数据库转换为XML文件的技术规范》9.DA/T58-2014《电子档案管理基本术语》 DAT50-DAT58.rarGBT18894电子文件归档与电子档案管理规范（送审稿）.pdf,2015/1/21
416,dbf文件协议,孙传金,http://180.168.156.212:2262/wecenter/?/article/8877,"最近导入导出工具在进行读取，网上找到的都是java的代码，只是没有源代码，delphi采用文件流读取的时候，只能通过文件协议直接解析文件，从而获取记录信息，DBF文件结构：表文件由头记录及数据记录组成。头记录定义该表的结构并包含与表相关的其他信息。头记录由文件位置0开始。数据记录1紧接在头记录之后（连续的字节），包含字段中实际的文本。记录的长度（以字节为单位）等于所有字段定义的长度之和。表文件中存储整数时低位字节在前。1．表头记录的结构：字节偏移说明0文件类型0x02FoxBASE0x03FoxBASE+/dBASEIIIPLUS，无备注0x30VisualFoxPro0x43dBASEIVSQL表文件，无备注0x63dBASEIVSQL系统文件，无备注0x83FoxBASE+/dBASEIIIPLUS，有备注0x8BdBASEIV有备注0xCBdBASEIVSQL表文件，有备注0xF5FoxPro2.x（或更早版本）有备注0xFBFoxBASE1–3最近一次更新的时间（YYMMDD）4–7文件中的记录数目8–9第一个数据记录的位置10–11每个数据记录的长度（包括删除标记）12–27保留28表的标记0x01具有.cdx结构的文件0x02文件包含备注。0x04文件是数据库（.dbc）请注意，这个字节可以包含任何上面值的和。例如，0x03表明表具有结构化.cdx和一个备注字段。29代码页标记30–31保留，包含0x0032–n字段子记录字段的数目决定了字段子记录的数目。表中每个字段都对应一个字段子记录。n+1头记录终止符（0x0D），n+2到n+264此范围内的263个字节包含后链信息（相关数据库(.dbc)的相对路径）。如果第一个字节为0x00，则该文件不与数据库关联。因此数据库文件本身总是包含0x00。1头记录中的第8到第9个字节指示数据文件中数据的起始位置。数据记录从除标记字节开始。如果此字节为ASCII空格(0x20)，该记录没有删除标记，如果第一字节为星号(0x2A),该记录有删除标记。在标记之后是字段记录中所命名各字段中的数据2．字段子记录结构字节偏移说明0–10字段名（最多10个字符-若少于10则用空字符(0x00)填充）11字段类型C-字符型Y-货币型N-数值型F-浮点型D-日期型T-日期时间型B-双精度型I-整型L-逻辑型M-备注型G-通用型C-字符型（二进制）M-备注型（二进制）P-图片型12–15记录中该字段的偏移量16字段长度（以字节为单位）17小数位数18字段标记0x01系统列（用户不可见）0x02可存储null值的列0x04二进制列（只适于字符型和备注型）19–32保留格式保存的文件标头：支持null值日期时间型、货币型及双精度型数据字符字段和备注字段标记为二进制在数据库(.dbc)文件中添加表提示可以使用下面的公式求出表文件中字段的数目：(x–296/32)公式中，x表示第一个记录的位置（表头记录的第8到第9个字节），296表示263（后链信息）+1（头记录终止符）+32（第一个字段子记录），32是字段子记录的长度。",2015/1/21
417,Java Se : Java NIO（服务端）与BIO（客户端）通信,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8876,"Java目前有三种IO相关的API了,下面简单的说一下:BIO，阻塞IO，最常用的JavaIOAPI，提供一般的流的读写功能。相信学习Java的人，都用过。NIO，非阻塞IO，在JDK1.4中开始出现，大量应用与服务器端编程，用于提高并发访问的性能，常用的NIO框架有Netty，Mina。AIO，异步IO，在JDK1.7开始出现。还没有了解过，等以后了解了再说。阻塞、非阻塞，同步、异步在写这篇文章前，在网上了解了一下，其中争议最的问题要数阻塞、非阻塞怎么理解，异步、同步怎么理解。由于每个人想法的不同，很难达到一个一致的答案，又没有真正的大牛出来给这一个准确的定义。这里也简单的说一下，我对这两组名词的理解。1）阻塞、非阻塞我认为，BIO，NIO没有大家想的那么复杂，就是操作系统进行数据的读写（IO）采取的两种方案，只不过非阻塞读写要比阻塞IO读写更快一些。2）同步、异步同步与异步，我认为说的并不是IO本身，我认为说的是程序采用的编程模型，也就是说采用的是同步的编程模型还是异步的编程模型。BIO、NIO，他们的区别是操作系统读写数据采用的方式，他们是Java中的概念，在Java领域，他们的底层实现采用的是同步的编程模型。所以说BIO、NIO都是同步的。AIO的底层实现应当是异步的编程模型，所以说它是异步IO。这里我只是阐述了我对它们的理解，没有与大家争论到底怎么去理解他们。也许我没有大家想的那么深远，毕竟我只是学习了NIO不到一天时间而已。针对BIO、NIO，服务器编程如何提高性能一个程序运行的快慢，一般有会受到两个因素的影响：1）程序代码是否高效，2）IO读写是否高效。曾经看过这么一幅图，大致内容是：一帮不同角色的人（程序员、运维、项目经理等角色的人）在一起讨论一个应用程序效率地下的问题。程序员说的是：给我3个月时间，我能够让程序运行效率提高，当然了，我要调整代码的整体结构…运维说：…项目经理说：换用读写更快的硬件设备解决这个问题。故事我已经无法还原，但是这个故事说的内容就是程序优化带来的效率的提升远不及提高IO速度带来的提升。相比于BIO，NIO就是从读写来提升效率的。性能对于服务器来说尤为重要，服务器端编程并不是都采用了NIO编程。Tomcat服务器内部，就有BIO、NIO两种方式。1）BIO如何提高并发访问BIO，是一种阻塞IO，服务器端使用BIO进行数据读写时，一般都是采用了一个Socket请求对应一个Thread的方式来提高性能的。但是一台服务器上，可以跑的线程数量也是有限制的：线程不是越多越好，毕竟线程间的切换，也是有不小的开销。也不是越少越好，线程太少，极端情况下一个线程，如果用一个线程来解决用户的并发访问，服务器接收一个客户的请求时，其他人都要处于等待状态。你访问网页，多数情况下超过5秒，估计你就关掉它了吧。2）采用NIO编程时如何提高并发访问采用选择器轮询可用通道，读写数据。具体的怎么做的就不说了，网上一大坨一大坨的，虽然网上大家写的大多是copy别人的。下面给会出一个例子，所以这里就不多说了，不知道的可以网上找相关的文章。一个Thread下开一个Selector，一个Selector处理多个Socket通道（也就是多个用于请求），这样就是一个Thread线程可以同时处理多个用户请求。孰优孰劣假若说，服务器设置同时处理1000个用户请求（也就是1000个处理用户请求的线程）。假若有10000个人来发请求。如果采用BIOAPI编程，那么就同时只能为1000个人服务，其他的9000人就处于等待状态。如果采用NIOAPI编程，也开启1000个线程，因为一个Thread可以同时处理多个用户请求，咱不说让它处理太多了，就处理10个吧，这样算下来，这个10000个用户请求，就都可以处理了。BIO（客户端）与NIO（服务端）通信今天学习了NIO，就用NIO来处理浏览器用户请求吧。浏览器发送的肯定不是采用NIOAPI发送Socket请求的，肯定是使用了阻塞式IO，也就是对应于Java中的BIO了。packagecom.fjn.other.nio.socket;importjava.io.IOException;importjava.io.InputStream;importjava.io.OutputStream;importjava.net.InetSocketAddress;importjava.net.ServerSocket;importjava.net.Socket;importjava.nio.ByteBuffer;importjava.nio.channels.SelectionKey;importjava.nio.channels.Selector;importjava.nio.channels.ServerSocketChannel;importjava.nio.channels.SocketChannel;importjava.util.ArrayList;importjava.util.Collection;importjava.util.Iterator;importjava.util.concurrent.Callable;importjava.util.concurrent.ExecutorService;importjava.util.concurrent.Executors;@SuppressWarnings({""unchecked""})publicclassNioServer{ServerSocketChannelserverChannel;ServerSocketserverSocket;publicfinalintport;privateSelectorselector;ByteBufferbuffer=ByteBuffer.allocate(1024);NioServer(finalintport){this.port=port;}voidinit()throwsException{//创建ServerSocketChannel、ServerSocketserverChannel=ServerSocketChannel.open();serverSocket=serverChannel.socket();serverSocket.bind(newInetSocketAddress(port));//设置通道为非阻塞模式serverChannel.configureBlocking(false);//开启通道选择器，并注册ServerSocketChannelselector=Selector.open();serverChannel.register(selector,SelectionKey.OP_ACCEPT);}voidgo()throwsException{while(true){intnum=selector.select();if(num<=0)continue;Iterator<SelectionKey>keyIter=selector.selectedKeys().iterator();while(keyIter.hasNext()){finalSelectionKeykey=keyIter.next();//接收一个Socket连接//key.isAcceptable（）如果为true，说明channnel支持accept（）,也就是说明是一个ServerSocketChannelif(key.isAcceptable()){SocketChannelclientChannel=serverChannel.accept();if(clientChannel!=null){clientChannel.configureBlocking(false);clientChannel.register(selector,SelectionKey.OP_READ|SelectionKey.OP_WRITE);}}//如果isReadable()为true,说明是一个SocketChannelif(key.isReadable()){StringrequestContent=read(key);//业务处理//responseContent=doSomthing(requestContent);write(key,""ok""/*responseContent*/);}keyIter.remove();}}}//从通道读取数据Stringread(SelectionKeykey)throwsException{SocketChannelsocketChannel=(SocketChannel)key.channel();buffer.clear();//这一步必须有intlen=0;StringBufferstr=newStringBuffer();while((len=socketChannel.read(buffer))>0){byte[]bs=buffer.array();Stringblock=newString(bs,0,len);System.out.println(""Serverread:""+block);str.append(block);}buffer.clear();returnstr.toString();}//写数据到通道voidwrite(SelectionKeykey,Stringstr)throwsException{SocketChannelsocketChannel=(SocketChannel)key.channel();buffer.clear();buffer.put(str.getBytes());buffer.flip();//这一步必须有socketChannel.write(buffer);}publicstaticvoidmain(String[]args)throwsException{finalintport=10000;NioServerserver=newNioServer(port);server.init();///========================================================//接下来模拟3个Client并发访问服务器intpoolsize=3;ExecutorServicepool=Executors.newFixedThreadPool(poolsize);Collection<Callable>tasks=newArrayList<Callable>(10);finalStringclientname=""clientThread"";for(inti=0;i<poolsize;i++){finalintn=i;//若每一个Client都保持使用BIO方式发送数据到Server，并读取数据。tasks.add(newCallable(){@OverridepublicObjectcall()throwsException{Socketsocket=newSocket(""127.0.0.1"",port);finalInputStreaminput=socket.getInputStream();finalOutputStreamout=socket.getOutputStream();finalStringclientname_n=clientname+""_""+n;//BIO读取数据线程newThread(clientname_n+""_read""){@Overridepublicvoidrun(){byte[]bs=newbyte[1024];while(true){try{Thread.sleep(1000);}catch(InterruptedExceptione){e.printStackTrace();}intlen=0;try{while((len=input.read(bs))!=-1){System.out.println(""Clinetthread""+Thread.currentThread().getName()+""read:""+newString(bs,0,len));}}catch(IOExceptione){e.printStackTrace();}}}}.start();//BIO写数据线程newThread(clientname_n+""_write""){@Overridepublicvoidrun(){inta=0;while(true){try{Thread.sleep(100);}catch(InterruptedExceptione){e.printStackTrace();}Stringstr=Thread.currentThread().getName()+""hello,""+a;try{out.write(str.getBytes());a++;}catch(IOExceptione){e.printStackTrace();}}}}.start();returnnull;}});}pool.invokeAll((Collection<?extendsCallable<Object>>)tasks);server.go();}}上面的测试的是3个Client采用BIOAPI不断的并发的发送Socket请求到Server端。Server采用NIOAPI处理Client的请求并作出响应，然后Client接收响应。",2015/1/20
418,<转自知乎>一种古籍数字档案化的新思路,陈城,http://180.168.156.212:2262/wecenter/?/article/8875,"如果借鉴该思路把把验证码做成汉字。。。转载：很多人已经知道神人LuisvonAhn和reCAPTCHA了，我再啰嗦讲一下。LuisvonAhn是CMU教授，2000左右和别人提出了CAPTCHA，就是万恶的验证码。现在看来也许验证码是个显而易见的点子，但是从历史上看，它绝对是个判断正在输入的是人类还是机器的简单高效方法。再后来，这个教授就想了，每天这么多人都在识别输入一串字符，能不能利用它呢？于是后来他就又搞出了reCAPTCHA。如果我们想电子化一些从前的文档，比如19世纪的纽约时报，我们要不得依靠人力，手动地一个一个字地输入电脑，要不然就直接扫描，然后用软件识别。但是软件识别的准确率不能保证，尤其是扫描或者文档本身质量很差的时候，比如：reCAPTCHA做的，简单来说就是把上图的单词切割抽取出来，然后与一组自动生成的字符混合，生成验证码，发送到各各网站上，像这样：reCAPTCHA默认如果电脑产生的字符你输入正确，那么从文档中抽取的字符你的输入也将是正确的，然后通过交叉验证，重复验证，各种算法保证准确率。于是坐在电脑前上网的我们，每次输入验证码的时候，就可能顺便为某个图书馆的文档录入做出了贡献。详细点的介绍可看：关于reCAPTCHA验证码。一个经常被提到的实例就是，借助广大网民之手，纽约时报从1851年到现在的所有报纸，总共超过1千3百万篇文章都已经成功录入计算机。如果依靠手工输入，人力，资金，时间都将是巨大的，然而借助reCAPTCHA,以及每天上网的我们，这项工作短时间内已经完成了。09年reCAPTCHA被谷歌收购了，大家可能也都注意到了，谷歌更进一步利用验证码来帮助它们识别门牌号，路牌等等，用来修正谷歌地图的精度。这样谷歌地图的准确度，以及用户的体验都得到了提升。LuisvonAhn真是很有想法的人，后来他又创办了很火的Duolingo，帮助大家学外语。update1-15====收了好多赞，但我觉得我只是个搬运工============================可以听听LuisvonAhn自己怎么说的，下面是他上个月在youtube上介绍reCAPTCHAproject的一段几分钟视频： /watch?v=PQ-xzwj_p_4据他说，目前有已经有11亿人次帮助他们至少输入了一个单词，谷歌每年电子化了相当于200万本书的文本。比较有趣的是，留言里部分人义愤填膺，觉得自己被利用了或者被验证码折磨了。再补充一段Duolingo志愿者推荐的视频： -Ht4qiDRZE8，“主要就是讲Luis怎么用众包的概念创立公司的。他也曾在TechCrunch的演讲里提到过那个自己幼年构想发电健身房的故事，可能这样能更好地回答题主的疑问。几乎我们所有多邻国的志愿者都有看过这个。”有个评论提到了，LuisvonAhn现在更多地投入在Duolingo上。帮助大家学习外语的同时，类似reCAPTCHA的思路，Duolingo利用大家的学习参与过程，实现翻译文本。（例如截取CNN新闻的片段让你翻译成其他语言（暂时没有中文），多个参与者的练习拼凑起来就是一篇翻译好的文本，然后卖回去给CNN。）========评论里还会有人问起是怎么保证正确率的？用评论里的回复的补充===============以上面街景截图带门派号的验证码为例子，左边一组数字是街景的截图（希望你帮系统识别出来的，系统原来并不知道是上面数字），右边一组是系统产生的数字(系统知道是上面数字)。当你正确输入了右边的数字，系统就判断你是人，于是默认你左边输入的数字就是他们原来并不知道的门牌号。如果有人不小心或者故意把左边的门牌输错怎么办？另外一个机制是，系统会把左边的图发送给多个用户验证，然后从多个用户里取出现次数大于一定阀值的那个答案，（例如10个人，有8个人给出相同的答案，那可以认为就是正确答案了）。否则就重复以上步骤，或者其他更复杂的机制。总结一下reCAPTCHA有效的两个机制就是：1.和传统验证码配合使用，确保你是个人类，人类识别字符是轻而易举的。2.多重验证，保证正确率。",2015/1/20
419,利用ant进行远程tomcat部署,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8874,"利用ant进行远程tomcat部署在javaEE项目中，需要将工程部署到远程服务器上，如果部署的频率比较高，手动部署的方式就比较麻烦，可以利用Ant工具实现快捷的部署。这篇博文详细介绍了ant配置的步骤（ ），但是在tomcat7以上不适用，需要修改配置，具体如下：1.配置tomcat的用户角色tomcat7中的用户角色有：manager-gui—AccesstotheHTMLinterface.manager-status—Accesstothe""ServerStatus""pageonly.manager-script—Accesstothetools-friendlyplaintextinterfacethatisdescribedinthisdocument,andtothe""ServerStatus""page.manager-jmx—AccesstoJMXproxyinterfaceandtothe""ServerStatus""page.我们要用到的是manager-script，在tomcat-users.xml中进行配置。加入以下代码：<rolerolename=""manager-script""/><userusername=""用户名""password=""密码""roles=""manager-script"">2.配置Ant环境以前在6.0的时候,我们会在classpath中加入catalina-ant.jar包,具体操作为:window-->preferences,左边:ant-->runtime,在右边的classpath标签中的globalentries下加入externaljars,路径指向tomcat_home/lib/catalina-ant.jar,只需这一个即可,但是现在7.0得再加几个才行:lib/catalina-ant.jar,lib/tomcat-coyote.jar,lib/tomcat-util.jar,bin/tomcat-juli.jar3.编写build.xml文件<projectname=""工程名""default=""redeploy""basedir="".""><!--Configurethedirectoryintowhichthewebapplicationisbuilt--><propertyname=""build""value=""${basedir}/build""/><!--Configurethecontextpathforthisapplication--><propertyname=""path""value=""/应用的名称""/><!--ConfigurepropertiestoaccesstheManagerapplication--><propertyname=""url""value="" project>最后运行该文件，你的工程就可以部署到远程tomcat上了。",2015/1/19
420,Hibernate HQL查询 插入 更新（update）实例,何文,http://180.168.156.212:2262/wecenter/?/article/8873,"1、实体查询：有关实体查询技术，其实我们在先前已经有多次涉及，比如下面的例子：Stringhql=”fromUseruser”;Listlist=session.CreateQuery(hql).list();上面的代码执行结果是，查询出User实体对象所对应的所有数据，而且将数据封装成User实体对象，并且放入List中返回。这里需要注意的是，Hibernate的实体查询存在着对继承关系的判定，比如我们前面讨论映射实体继承关系中的Employee实体对象，它有两个子类分别是HourlyEmployee，SalariedEmployee,如果有这样的HQL语句：“fromEmployee”,当执行检索时Hibernate会检索出所有Employee类型实体对象所对应的数据（包括它的子类HourlyEmployee，SalariedEmployee对应的数据）。因为HQL语句与标准SQL语句相似，所以我们也可以在HQL语句中使用where字句，并且可以在where字句中使用各种表达式，比较操作符以及使用“and”,”or”连接不同的查询条件的组合。看下面的一些简单的例子：fromUseruserwhereuser.age=20;fromUseruserwhereuser.agebetween20and30;fromUseruserwhereuser.agein(20,30);fromUseruserwhereuser.nameisnull;fromUseruserwhereuser.namelike‘%zx%’;fromUseruserwhere(user.age%2)=1;fromUseruserwhereuser.age=20anduser.namelike‘%zx%’;2、实体的更新和删除：在继续讲解HQL其他更为强大的查询功能前，我们先来讲解以下利用HQL进行实体更新和删除的技术。这项技术功能是Hibernate3的新加入的功能，在Hibernate2中是不具备的。比如在Hibernate2中，如果我们想将数据库中所有18岁的用户的年龄全部改为20岁，那么我们要首先将年龄在18岁的用户检索出来，然后将他们的年龄修改为20岁，最后调用Session.update()语句进行更新。在Hibernate3中对这个问题提供了更加灵活和更具效率的解决办法，如下面的代码：Transactiontrans=session.beginTransaction();Stringhql=”updateUserusersetuser.age=20whereuser.age=18”;Queryqueryupdate=session.createQuery(hql);intret=queryupdate.executeUpdate();trans.commit();通过这种方式我们可以在Hibernate3中，一次性完成批量数据的更新，对性能的提高是相当的可观。同样也可以通过类似的方式来完成delete操作，如下面的代码：Transactiontrans=session.beginTransaction();Stringhql=”deletefromUseruserwhereuser.age=18”;Queryqueryupdate=session.createQuery(hql);intret=queryupdate.executeUpdate();trans.commit();如果你是逐个章节阅读的化，那么你一定会记起我在第二部分中有关批量数据操作的相关论述中，讨论过这种操作方式，这种操作方式在Hibernate3中称为bulkdelete/update，这种方式能够在很大程度上提高操作的灵活性和运行效率，但是采用这种方式极有可能引起缓存同步上的问题(请参考相关论述)。3、属性查询：很多时候我们在检索数据时，并不需要获得实体对象所对应的全部数据，而只需要检索实体对象的部分属性所对应的数据。这时候就可以利用HQL属性查询技术，如下面程序示例：Listlist=session.createQuery(“selectuser.namefromUseruser”).list();for(inti=0;iSystem.out.println(list.get(i));}我们只检索了User实体的name属性对应的数据，此时返回的包含结果集的list中每个条目都是String类型的name属性对应的数据。我们也可以一次检索多个属性，如下面程序：Listlist=session.createQuery(“selectuser.name,user.agefromUseruser”).list();for(inti=0;iObject[]obj=(Object[])list.get(i);System.out.println(obj[0]);System.out.println(obj[1]);}此时返回的结果集list中，所包含的每个条目都是一个Object[]类型，其中包含对应的属性数据值。作为当今我们这一代深受面向对象思想影响的开发人员，可能会觉得上面返回Object[]不够符合面向对象风格，这时我们可以利用HQL提供的动态构造实例的功能对这些平面数据进行封装，如下面的程序代码：Listlist=session.createQuery(“selectnewUser(user.name,user.age)fromUseruser”).list();for(inti=0;iUseruser=(User)list.get(i);System.out.println(user.getName());System.out.println(user.getAge());}这里我们通过动态构造实例对象，对返回结果进行了封装，使我们的程序更加符合面向对象风格，但是这里有一个问题必须注意，那就是这时所返回的User对象，仅仅只是一个普通的Java对象而以，除了查询结果值之外，其它的属性值都为null（包括主键值id），也就是说不能通过Session对象对此对象执行持久化的更新操作。如下面的代码：Listlist=session.createQuery(“selectnewUser(user.name,user.age)fromUseruser”).list();for(inti=0;iUseruser=(User)list.get(i);user.setName(“gam”);session.saveOrUpdate(user);//这里将会实际执行一个save操作，而不会执行update操作，因为这个User对象的id属性为null，Hibernate会把它作为一个自由对象（请参考持久化对象状态部分的论述），因此会对它执行save操作。}4、分组与排序A、Orderby子句：与SQL语句相似，HQL查询也可以通过orderby子句对查询结果集进行排序，并且可以通过asc或者desc关键字指定排序方式，如下面的代码：fromUseruserorderbyuser.nameasc,user.agedesc;上面HQL查询语句，会以name属性进行升序排序，以age属性进行降序排序，而且与SQL语句一样，默认的排序方式为asc,即升序排序。B、Groupby子句与统计查询：在HQL语句中同样支持使用groupby子句分组查询，还支持groupby子句结合聚集函数的分组统计查询，大部分标准的SQL聚集函数都可以在HQL语句中使用，比如：count(),sum(),max(),min(),avg()等。如下面的程序代码：Stringhql=”selectcount(user),user.agefromUserusergroupbyuser.agehavingcount(user)>10”;Listlist=session.createQuery(hql).list();C、优化统计查询：假设我们现在有两张数据库表，分别是customer表和order表，它们的结构如下：customerIDvarchar2(14)agenumber(10)namevarchar2(20)orderIDvarchar2(14)order_numbernumber(10)customer_IDvarchar2(14)现在有两条HQL查询语句，分别如下：fromCustomercinnerjoinc.ordersogroupbyc.age;(1)selectc.ID,c.name,c.age,o.ID,o.order_number,o.customer_IDfromCustomercinnerjoinc.orderscgroupbyc.age;(2)这两条语句使用了HQL语句的内连接查询（我们将在HQL语句的连接查询部分专门讨论），现在我们可以看出这两条查询语句最后所返回的结果是一样的，但是它们其实是有明显区别的，语句（1）检索的结果会返回Customer与Order持久化对象，而且它们会被置于Hibernate的Session缓存之中，并且Session会负责它们在缓存中的唯一性以及与后台数据库数据的同步，只有事务提交后它们才会从缓存中被清除；而语句（2）返回的是关系数据而并非是持久化对象，因此它们不会占用Hibernate的Session缓存，只要在检索之后应用程序不在访问它们，它们所占用的内存就有可能被JVM的垃圾回收器回收，而且Hibernate不会同步对它们的修改。在我们的系统开发中，尤其是Mis系统，不可避免的要进行统计查询的开发，这类功能有两个特点：第一数据量大；第二一般情况下都是只读操作而不会涉及到对统计数据进行修改，那么如果采用第一种查询方式，必然会导致大量持久化对象位于Hibernate的Session缓存中，而且Hibernate的Session缓存还要负责它们与数据库数据的同步。而如果采用第二种查询方式，显然就会提高查询性能，因为不需要Hibernate的Session缓存的管理开销，而且只要应用程序不在使用这些数据，它们所占用的内存空间就会被回收释放。因此在开发统计查询系统时，尽量使用通过select语句写出需要查询的属性的方式来返回关系数据，而避免使用第一种查询方式返回持久化对象（这种方式是在有修改需求时使用比较适合），这样可以提高运行效率并且减少内存消耗。㊣真正的高手并不是精通一切，而是精通在合适的场合使用合适的手段。5、参数绑定：Hibernate中对动态查询参数绑定提供了丰富的支持，那么什么是查询参数动态绑定呢？其实如果我们熟悉传统JDBC编程的话，我们就不难理解查询参数动态绑定，如下代码传统JDBC的参数绑定：PrepareStatementpre=connection.prepare(“select*fromUserwhereuser.name=?”);pre.setString(1,”zhaoxin”);ResultSetrs=pre.executeQuery();在Hibernate中也提供了类似这种的查询参数绑定功能，而且在Hibernate中对这个功能还提供了比传统JDBC操作丰富的多的特性，在Hibernate中共存在4种参数绑定的方式，下面我们将分别介绍：A、按参数名称绑定：在HQL语句中定义命名参数要用”:”开头，形式如下：Queryquery=session.createQuery(“fromUseruserwhereuser.name=:customernameanduser:customerage=:age”);query.setString(“customername”,name);query.setInteger(“customerage”,age);上面代码中用:customername和:customerage分别定义了命名参数customername和customerage，然后用Query接口的setXXX()方法设定名参数值，setXXX()方法包含两个参数，分别是命名参数名称和命名参数实际值。B、按参数位置邦定：在HQL查询语句中用”?”来定义参数位置，形式如下：Queryquery=session.createQuery(“fromUseruserwhereuser.name=?anduser.age=?”);query.setString(0,name);query.setInteger(1,age);同样使用setXXX()方法设定绑定参数，只不过这时setXXX()方法的第一个参数代表邦定参数在HQL语句中出现的位置编号（由0开始编号），第二个参数仍然代表参数实际值。注：在实际开发中，提倡使用按名称邦定命名参数，因为这不但可以提供非常好的程序可读性，而且也提高了程序的易维护性，因为当查询参数的位置发生改变时，按名称邦定名参数的方式中是不需要调整程序代码的。C、setParameter()方法：在Hibernate的HQL查询中可以通过setParameter()方法邦定任意类型的参数，如下代码：Stringhql=”fromUseruserwhereuser.name=:customername”;Queryquery=session.createQuery(hql);query.setParameter(“customername”,name,Hibernate.STRING);如上面代码所示，setParameter()方法包含三个参数，分别是命名参数名称，命名参数实际值，以及命名参数映射类型。对于某些参数类型setParameter()方法可以更具参数值的Java类型，猜测出对应的映射类型，因此这时不需要显示写出映射类型，像上面的例子，可以直接这样写：query.setParameter(“customername”,name);但是对于一些类型就必须写明映射类型，比如java.util.Date类型，因为它会对应Hibernate的多种映射类型，比如Hibernate.DATA或者Hibernate.TIMESTAMP。D、setProperties()方法：在Hibernate中可以使用setProperties()方法，将命名参数与一个对象的属性值绑定在一起，如下程序代码：Customercustomer=newCustomer();customer.setName(“pansl”);customer.setAge(80);Queryquery=session.createQuery(“fromCustomercwherec.name=:nameandc.age=:age”);query.setProperties(customer);setProperties()方法会自动将customer对象实例的属性值匹配到命名参数上，但是要求命名参数名称必须要与实体对象相应的属性同名。这里还有一个特殊的setEntity()方法，它会把命名参数与一个持久化对象相关联，如下面代码所示：Customercustomer=(Customer)session.load(Customer.class,”1”);Queryquery=session.createQuery(“fromOrderorderwhereorder.customer=:customer”);query.setProperties(“customer”,customer);Listlist=query.list();上面的代码会生成类似如下的SQL语句：Select*fromorderwherecustomer_ID=’1’;E、使用绑定参数的优势：我们为什么要使用绑定命名参数？任何一个事物的存在都是有其价值的，具体到绑定参数对于HQL查询来说，主要有以下两个主要优势：①、可以利用数据库实施性能优化，因为对Hibernate来说在底层使用的是PrepareStatement来完成查询，因此对于语法相同参数不同的SQL语句，可以充分利用预编译SQL语句缓存，从而提升查询效率。②、可以防止SQLInjection安全漏洞的产生：SQLInjection是一种专门针对SQL语句拼装的攻击方式，比如对于我们常见的用户登录，在登录界面上，用户输入用户名和口令，这时登录验证程序可能会生成如下的HQL语句：“fromUseruserwhereuser.name=’”+name+”’anduser.password=’”+password+”’”这个HQL语句从逻辑上来说是没有任何问题的，这个登录验证功能在一般情况下也是会正确完成的，但是如果在登录时在用户名中输入”zhaoxinor‘x’=’x”,这时如果使用简单的HQL语句的字符串拼装，就会生成如下的HQL语句：“fromUseruserwhereuser.name=’zhaoxin’or‘x’=’x’anduser.password=’admin’”;显然这条HQL语句的where字句将会永远为真，而使用户口令的作用失去意义，这就是SQLInjection攻击的基本原理。而使用绑定参数方式，就可以妥善处理这问题,当使用绑定参数时，会得到下面的HQL语句：fromUseruserwhereuser.name=’’zhaoxin’’or‘’x=’’x’’‘anduser.password=’admin’;由此可见使用绑定参数会将用户名中输入的单引号解析成字符串（如果想在字符串中包含单引号，应使用重复单引号形式），所以参数绑定能够有效防止SQLInjection安全漏洞。",2015/1/19
421,关于电子文档标注规范咨询。。。。,叶民,http://180.168.156.212:2262/wecenter/?/article/8872,谁有ISO的PDF/A规范或GB/T23286.1-2009标准规范文档共享下呗19005-1.pdfGBT23286.1-2009文献管理长期保存的电子文档文件格式第1部分：PDF1.4(PDFA-1)的使用.pdf,2015/1/17
422,HashMap的工作原理,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8871,"HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！先来些简单的问题“你用过HashMap吗？”“什么是HashMap？你为什么用到它？”几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：“你知道HashMap的工作原理吗？”“你知道HashMap的get()方法的工作原理吗？”你也许会回答“我没有详查标准的JavaAPI，你可以看看Java源代码或者OpenJDK。”“我可以用Google找到答案。”但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key,value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collisiondetection)以及碰撞的解决方法：“当两个对象的hashcode相同会发生什么？”从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：“如果两个键的hashcode相同，你如何获取值对象？”面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。“如果HashMap的大小超过了负载因子(loadfactor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。如果你能够回答这道问题，下面的问题来了：“你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(racecondition)。当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tailtraversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）热心的读者贡献了更多的关于HashMap的问题：为什么String,Interger这样的wrapper类适合作为键？String,Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。我们可以使用自定义的对象作为键吗？这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：hashing的概念HashMap中解决碰撞的方法equals()和hashCode()的应用，以及它们在HashMap中的重要性不可变对象的好处HashMap多线程的条件竞争重新调整HashMap的大小总结HashMap的工作原理HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时会发生什么？它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。",2015/1/15
423,高效主从表关联查询经验：用于工作流的已办项,胡东平,http://180.168.156.212:2262/wecenter/?/article/8870,"row_number()over(partitionby....orderby...)用法分组排序row_number()OVER(PARTITIONBYCOL1ORDERBYCOL2)表示根据COL1分组，在分组内部根据COL2排序，而此函数计算的值就表示每组内部排序后的顺序编号（组内连续的唯一的)SQL>SELECTG.*,ROW_NUMBER()OVER(PARTITIONBYa,bORDERBYcDESC)ROWN2from(select'1'a,'2'b,'1'c3fromdual4unionall5select'1','2','2'6fromdual7unionall8select'1','3','3'9fromdual10unionall11select'1','3','4'12fromdual13unionall14select'1','4','5'fromdual15unionall16select'1','3','5'fromdual)G17;ABCROWN-------------122112121351134213331451与rownum的区别在于：使用rownum进行排序的时候是先对结果集加入伪列rownum然后再进行排序，而此函数在包含排序从句后是先排序再计算行号码．row_number()和rownum差不多，功能更强一点（可以在各个分组内从1开时排序）．rank()是跳跃排序，有两个第二名时接下来就是第四名（同样是在各个分组内）．dense_rank()l是连续排序，有两个第二名时仍然跟着第三名。相比之下row_number是没有重复值的．lag（arg1,arg2,arg3):arg1是从其他行返回的表达式arg2是希望检索的当前行分区的偏移量。是一个正的偏移量，时一个往回检索以前的行的数目。arg3是在arg2表示的数目超出了分组的范围时返回的值。语句一:selectrow_number()over(orderbysale/cntdesc)assort,sale/cntfrom(select-60assale,3ascntfromdualunionselect24assale,6ascntfromdualunionselect50assale,5ascntfromdualunionselect-20assale,2ascntfromdualunionselect40assale,8ascntfromdual);执行结果:SORTSALE/CNT--------------------11025344-105-20语句二:查询员工的工资,按部门排序selectename,sal,row_number()over(partitionbydeptnoorderbysaldesc)assal_orderfromscott.emp;执行结果:ENAMESALSAL_ORDER----------------------------------------KING50001CLARK24502MILLER13003SCOTT30001FORD30002JONES29753ADAMS11004SMITH8005BLAKE28501ALLEN16002TURNER15003WARD12504MARTIN12505JAMES9506已选择14行。语句三:查询每个部门的最高工资selectdeptno,ename,salfrom(selectdeptno,ename,sal,row_number()over(partitionbydeptnoorderbysaldesc)assal_orderfromscott.emp)wheresal_order<2;执行结果:DEPTNOENAMESAL----------------------------------------10KING500020SCOTT300030BLAKE2850已选择3行。语句四：selectdeptno,sal,rank()over(partitionbydeptnoorderbysal)asrank_orderfromscott.emporderbydeptno;执行结果:DEPTNOSALRANK_ORDER------------------------------101300110245021050003208001201100220297532030004203000430950130125023012502301500430160053028506已选择14行。语句五：selectdeptno,sal,dense_rank()over(partitionbydeptnoorderbysal)asdense_rank_orderfromscott.emporderbydeptn;执行结果：DEPTNOSALDENSE_RANK_ORDER------------------------------------101300110245021050003208001201100220297532030004203000430950130125023012502301500330160043028505已选择14行。语句六：selectdeptno,ename,sal,lag(ename,1,null)over(partitionbydeptnoorderbyename)aslag_fromscott.emporderbydeptno;执行结果：DEPTNOENAMESALLAG_------------------------------------------------------------10CLARK245010KING5000CLARK10MILLER1300KING20ADAMS110020FORD3000ADAMS20JONES2975FORD20SCOTT3000JONES20SMITH800SCOTT30ALLEN160030BLAKE2850ALLEN30JAMES950BLAKE30MARTIN1250JAMES30TURNER1500MARTIN30WARD1250TURNER已选择14行。",2015/1/14
424,超重量级发布：档办发[2014]6号《数字档案馆系统测试办法》，各地档案部门2015年的工作重点,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8869,对全国数字档案馆建设情况进行测评，是国家档案局技术部2015年的工作重点，这是不是也意味着我司的生意又来了？档办发[2014]6号《数字档案馆系统测试办法》.pdf,2015/1/14
425,TongWeb5.0应用服务器简介以及使用安装,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8868,TongWeb5.0是遵循JavaEE5规范的企业级应用服务器，它为企业应用提供了可靠、可伸缩、可管理和高安全的基础平台。同时具有功能完善、支持开放标准和基于组件开发、多层架构等特点，为开发和部署企业应用提供了必需的底层核心功能。用户通过TongWeb5.0的管理控制台可方便的对应用进行管理，同时能够监控系统组件和应用运行时的状态及调优。因此TongWeb5.0适用于高度可用、可靠、可伸缩，稳定的业务领域。TongWeb5.0用户使用手册.pdfTongWeb5.0_MyEclipesTool.pdf,2015/1/13
426,Oracle 表中的列带有default值的陷阱,管俊,http://180.168.156.212:2262/wecenter/?/article/8867,"在Oracle中,对于表的列可以为其指定默认值,这样在insert数据的时候,如果该列不出现在insert语句中的时候,会为其赋上默认值.注意这里是该列不出现在insert语句中,而不是该列的值为空值的时候.如下面的表:createtabletest(idnumber(10),namevarchar2(20)default'name')当用下面的SQL语句插入行的时候,会给name列赋默认值.insertintotest(id)values(1)查询结果为:select*fromtestIDNAME1name当用下面的SQL语句插入行的时候,不会给name列赋默认值.insertintotestvalues(2,null)查询结果发现ID为2的行的name的值为空:select*fromtestIDNAME1name2select*fromtestwherenameisnull能将ID为2的行查询出来.同样,在通过JAVA代码用JDBC,一些ORM框架插入数据的时候,也需要注意同样的问题.privatestaticvoidtestNULL()throwsSQLException{Stringsqlstr=""insertintotestvalues(?,?)"";Connectionconn=NONXADBUtil.getConnection(""jdbc:oracle:thin:@xxx:orcl"",""xxx"",""xxx"");PreparedStatementsta=conn.prepareStatement(sqlstr);sta.setInt(1,3);sta.setString(2,null);##1sta.executeUpdate();sta.close();conn.commit();conn.close();}上面的代码插入的行,name列也不会被赋值为默认值,将##1处改为sta.setString(2,"""")同样插入的是空值(null).",2015/1/12
427,JAVA Socket,丁凯,http://180.168.156.212:2262/wecenter/?/article/8866,"一、概述socket通常也称作""套接字""，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过""套接字""向网络发出请求或者应答网络请求。Socket和ServerSocket类库位于java.net包中。ServerSocket用于服务器端，Socket是建立网络连接时使用的。在连接成功时，应用程序两端都会产生一个Socket实例，操作这个实例，完成所需的会话。对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。二、重要的SocketAPIjava.net.Socket继承于java.lang.Object，有八个构造器，其方法并不多，下面介绍使用最频繁的三个方法，其它方法大家可以见JDK文档。1、Accept方法用于产生""阻塞""，直到接受到一个连接，并且返回一个客户端的Socket对象实例。""阻塞""是一个术语，它使程序运行暂时""停留""在这个地方，直到一个会话产生，然后程序继续；通常""阻塞""是由循环产生的。2、getInputStream方法获得网络连接输入，同时返回一个InputStream对象实例。3、getOutputStream方法连接的另一端将得到输入，同时返回一个OutputStream对象实例。注意：其中getInputStream和getOutputStream方法均会产生一个IOException，它必须被捕获，因为它们返回的流对象，通常都会被另一个流对象使用。三、程序示例①服务器-客户端简单示例服务器，使用ServerSocket监听指定的端口，端口可以随意指定（由于1024以下的端口通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于1024的端口），等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。客户端，使用Socket对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话完成后，关闭Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个1024以上的端口。服务器示例：publicclassServer{privateServerSocketss;privateSocketsocket;privateBufferedReaderin;privatePrintWriterout;publicServer(){try{ss=newServerSocket(10000);while(true){socket=ss.accept();in=newBufferedReader(newInputStreamReader(socket.getInputStream()));out=newPrintWriter(socket.getOutputStream(),true);Stringline=in.readLine();out.println(""youinputis:""+line);out.close();in.close();socket.close();}ss.close();}catch(IOExceptione){}}publicstaticvoidmain(String[]args){newServer();}}这个程序建立了一个服务器，它一直监听10000端口，等待用户连接。在建立连接后给客户端返回一段信息，然后结束会话。这个程序一次只能接受一个客户连接。客户端示例：publicclassClient{Socketsocket;BufferedReaderin;PrintWriterout;publicClient(){try{socket=newSocket(""xxx.xxx.xxx.xxx"",10000);in=newBufferedReader(newInputStreamReader(socket.getInputStream()));out=newPrintWriter(socket.getOutputStream(),true);BufferedReaderline=newBufferedReader(newInputStreamReader(System.in));out.println(line.readLine());line.close();out.close();in.close();socket.close();}catch(IOExceptione){}}publicstaticvoidmain(String[]args){newClient();}}这个客户端连接到地址为xxx.xxx.xxx.xxx的服务器，端口为10000，并从键盘输入一行信息，发送到服务器，然后接受服务器的返回信息，最后结束会话。②多个客户同时连接示例在实际的网络环境里，同一时间只对一个用户服务是不可行的。一个优秀的网络服务程序除了能处理用户的输入信息，还必须能够同时响应多个客户端的连接请求。在java中，实现以上功能特点是非常容易的。publicclassServerextendsServerSocket{privatestaticfinalintSERVER_PORT=10000;publicServer()throwsIOException{super(SERVER_PORT);try{while(true){Socketsocket=accept();newCreateServerThread(socket);}}catch(IOExceptione){}finally{close();}}//---CreateServerThreadclassCreateServerThreadextendsThread{privateSocketclient;privateBufferedReaderin;privatePrintWriterout;publicCreateServerThread(Sockets)throwsIOException{client=s;in=newBufferedReader(newInputStreamReader(client.getInputStream(),""GB2312""));out=newPrintWriter(client.getOutputStream(),true);out.println(""---Welcome---"");start();}publicvoidrun(){try{Stringline=in.readLine();while(!line.equals(""bye"")){Stringmsg=createMessage(line);out.println(msg);line=in.readLine();}out.println(""---Seeyou,bye!---"");client.close();}catch(IOExceptione){}}privateStringcreateMessage(Stringline){xxxxxxxxx;}}publicstaticvoidmain(String[]args)throwsIOException{newServer();}}这个程序监听10000端口，并将接入交给CreateServerThread线程运行。CreateServerThread线程接受输入，并将输入回应客户，直到客户输入""bye""，线程结束。我们可以在createMessage方法中，对输入进行处理，并产生结果，然后把结果返回给客户③实现信息共享:在Socket上的实时交流网络的伟大之一也是信息共享，Server可以主动向所有Client广播消息，同时Client也可以向其它Client发布消息。publicclassServerextendsServerSocket{privatestaticArrayListUser_List=newArrayList();privatestaticArrayListThreader=newArrayList();privatestaticLinkedListMessage_Array=newLinkedList();privatestaticintThread_Counter=0;privatestaticbooleanisClear=true;protectedstaticfinalintSERVER_PORT=10000;protectedFileOutputStreamLOG_FILE=newFileOutputStream(""d:/connect.log"",true);publicServer()throwsFileNotFoundException,IOException{super(SERVER_PORT);newBroadcast();//appendconnectionlogCalendarnow=Calendar.getInstance();Stringstr=""[""+now.getTime().toString()+""]Acceptedaconnection\015\012"";byte[]tmp=str.getBytes();LOG_FILE.write(tmp);try{while(true){Socketsocket=accept();newCreateServerThread(socket);}}finally{close();}}publicstaticvoidmain(String[]args)throwsIOException{newServer();}//---BroadcastclassBroadcastextendsThread{publicBroadcast(){start();}publicvoidrun(){while(true){if(!isClear){Stringtmp=(String)Message_Array.getFirst();for(inti=0;i<Threader.size();i++){CreateServerThreadclient=(CreateServerThread)Threader.get(i);client.sendMessage(tmp);}Message_Array.removeFirst();isClear=Message_Array.size()>0?false:true;}}}}//---CreateServerThreadclassCreateServerThreadextendsThread{privateSocketclient;privateBufferedReaderin;privatePrintWriterout;privateStringUsername;publicCreateServerThread(Sockets)throwsIOException{client=s;in=newBufferedReader(newInputStreamReader(client.getInputStream()));out=newPrintWriter(client.getOutputStream(),true);out.println(""---Welcometothischatroom---"");out.println(""Inputyournickname:"");start();}publicvoidsendMessage(Stringmsg){out.println(msg);}publicvoidrun(){try{intflag=0;Thread_Counter++;Stringline=in.readLine();while(!line.equals(""bye"")){if(line.equals(""l"")){out.println(listOnlineUsers());line=in.readLine();continue;}if(flag++==0){Username=line;User_List.add(Username);out.println(listOnlineUsers());Threader.add(this);pushMessage(""[<""+Username+""comeonin>]"");}else{pushMessage(""<""+Username+"">""+line);}line=in.readLine();}out.println(""---Seeyou,bye!---"");client.close();}catch(IOExceptione){}finally{try{client.close();}catch(IOExceptione){}Thread_Counter--;Threader.remove(this);User_List.remove(Username);pushMessage(""[<""+Username+""left>]"");}}privateStringlistOnlineUsers(){Strings=""-+-Onlinelist-+-\015\012"";for(inti=0;i<User_List.size();i++){s+=""[""+User_List.get(i)+""]\015\012"";}s+=""-+---------------------+-"";returns;}privatevoidpushMessage(Stringmsg){Message_Array.addLast(msg);isClear=false;}}}",2015/1/12
428,Urlrewrite,丁凯,http://180.168.156.212:2262/wecenter/?/article/8865,UrlRewrite就是我们通常说的地址重写，用户得到的全部都是经过处理后的URL地址。研发中心经验共享[201412]_丁凯.doc,2015/1/12
429,PhoneGap开发APP可行性分析,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8864,PhoneGap开发APP可行性分析PhoneGap开发跨平台APP可行性分析报告.docx,2015/1/12
430,"国家档案局局长杨冬权表示""将尽快启动为各级国家政府网站网页存档工作""",杨安荣,http://180.168.156.212:2262/wecenter/?/article/8863,国家档案局局长杨冬权表示将尽快启动为各级国家政府网站网页存档工作11月19日，国家档案局局长杨冬权会见阿里巴巴集团副总裁兼“阿里云”总裁胡晓明及其团队时表示，将尽快启动为各级国家政府网站网页存档工作。杨冬权说，当前，国家政府网站通过政府信息公开向公众提供信息服务，以保障公众的知情权和监督权，收集网站上对国家和社会有保存价值的记录，是国家最高档案行政管理部门的职责所在，也是互联网时代档案部门面临的新课题。近几年，国家档案局对此也在进行探讨和研究，将尽快启动为各级国家政府网站网页存档工作，希望加强与有关单位合作，将中央、省、市、县各级国家政府网站，以及各国有企业、中央企业等网站网页保存好、记录好。阿里巴巴集团副总裁胡晓明介绍了阿里巴巴集团的有关情况和“阿里云”的概况。他表示，“阿里云”及其技术团队愿为国家档案局打造一个专属的“档案云”，从而提升档案尤其是电子档案的长期保存、快速加工及档案资源利用的管理水平。浙江省档案局馆长刘芸参加了会见。原载于《中国档案报》2014年12月1日总第2692期第一版,2015/1/10
431,15分钟的效率法则,管俊,http://180.168.156.212:2262/wecenter/?/article/8859,我总是拖延。我会把一件要做的事拖到最后一刻才开始。我还学会了用后期的超高效来弥补之前的拖延，反正我最终我总能在deadline之前完成它！但我知道我的问题就出在：当我坐下开始工作时，我总是先去做一些其他无关紧要的事。我把这种称为轻态拖延，很可能你也是这样，它有以下“症状”：坐下来开始工作前，总是习惯先上微博或者浏览其他好玩的网站；总告诉自己说开工前有10分钟的让自己放松的时间；总会先去做那些很琐碎且不太重要的事，比如查邮箱等等。最后我就有了这个定式行为：坐在桌前，一般半小时或一个小时后才会真正开始工作。而一旦我真的开始了，就会发现没有什么能让我再分心，会顺利地完成工作。我开始意识到无论是写博客还是写代码我都会遵循这种行为模式。一旦我投入十五分钟，就能一直专心完成工作。于是15分钟法则就诞生了我决定做点小试验。下一次我开始工作时，强迫自己不像往常一样先去做类似查邮件那样琐碎的事，而是按下面的步骤：1.选出一件自己要做的正事(这会让你很明确地清楚目标)2.把所有干扰项都关掉15分钟，不要让它们在这个时间段打扰你3.没有干扰没有中断地做正事15分钟4.15分钟后，如果我坚持不住，那我就放弃或是做其他事情而结果是，我单线程地工作15分钟以后，我肯定就不想停下来。即便是那些我原先一点动力都没有的事，在沉浸了15分钟以后，我也变得乐意去完成它了。就像读完书的前几章，你就会渐渐入境，很想把后面的章节也读完。我也试过其他摆脱拖延提高效率的方法，它们对我就不是那么管用。对我来说，有以下几个问题：1.它们过于复杂，且要求100%投入(这入门可真高)2.它们一般只强调效率啊，任务优先级啊，而不说具体的流程3.它们总是假设人们都是那种可以一坐下来就开始专心工作的人(而这对我来说则很难)我也是那种热衷和推崇时间管理的人，那些建议确实不错，但它不适合我。我的生活每天日程其实很多项目都是确定的，我差不多都能了解我每天每个小时该做什么事情。这种情况下，我的问题就不是要挑出我要做什么事，而是怎样高效不拖延地做事。我上面的方法就很类似番茄工作法。我之前内心有点抵触它，因为觉得自己没有能力专注那么长时间(25分钟)，于是我就缩短了时间段，压成15分钟。为什么这个方法会奏效？我想最主要的原因是因为它让我有了一种积极的势头。也就是说当你连着15分钟做一件事后，就很难变向去其他道路。专注也是这15分钟法则的核心。分心好像就是人们的本性，就像你在读这篇文章时很可能中途会切换到其他标签页去看别的东西。于是我只能强迫自己在一定时间段内专注单件事情，将那个分心的小火苗掐灭。总之这个方法让我能够专注，不被其他事情干扰。而且它也不会让我有太多压力，我只知道我就工作15分钟，而不会给自己设定太多的进展要求。怎样运用这个方法1.在做事前关掉所有其他的干扰，比如说关掉无关的标签页或是关掉手机。2.关掉干扰还不够，你还得让自己专心3.立即动手，不要多想。我知道想也是“做”的一部分，但在你思考时思绪会随处飘荡。你可以先直接写出一个草稿，而不要想太多，后续再一版一版地迭代。4.如果你觉得你很难开始动手，那你可以用头脑风暴来替代“动手”。但必须是写出想法或是画思维导图的形式，而不是只有脑子在活动。5.如果15分钟以后你坚持不了，那就放弃。休息一会再回来。原文出处：JohnSonmez译文出处：36Kr链接： ,2015/1/9
432,解决Windows Server 2008R2系统出现的ocr识别问题,孙传金,http://180.168.156.212:2262/wecenter/?/article/8862,导入导出工具中使用到ocr识别功能，主要是针对pdf文件，在WindowsServer2008R2系统会出现不能识别的问题，即使使用的Office2007自带的“MicrosoftOfficeDocumentImaging”工具，依然不能识别，目前解决思路如下：1、将Office2007安装包升级到Office2007Update12、安装Office2007OCR修复包，修复了程序在调用modi功能模块进行ocr识别时导致的程序异常退出的问题3、修改dep权限，运行命令行：bcdedit.exe/set{current}nxAlwaysOff，主要解决无法识别pdf文件的问题，使用“MicrosoftOfficeDocumentImaging”工具也不能识别文本通过以上三步解决了WindowsServer2008R2系统会不能识别ocr的问题,2015/1/8
433,jdbc超时机制,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8858,jdbc超时机制2014年12月经验共享.docx,2015/1/6
434,你认为最有争议的编程观点是什么？,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8857,"今天看了个帖子《What’syourmostcontroversialprogrammingopinion?》，翻译成中文就是“你认为最有争议的编程观点是什么？”，不过，在400多个主回贴，以及上千个所有回贴中，好像并不是很有争议，而是令人相当的茅塞顿开，下面罗列一些我觉得很赞的观点1）Theonly“bestpractice”youshouldbeusingallthetimeis“UseYourBrain”唯一的“BestPractice”并不是使用各种各样被前人总结过的各种设计方法、模式、框架，那些著名的方法、模式、框架只代表赞同它们的人多，并不代表它们适合你，你应该更多地去使用你的大脑，独立地思考那些方法、模式、框架出现的原因和其背后的想法和思想，那才是“BestPractice”。事实上来说，那些所谓的“BestPractice”只不过是限制那些糟糕的程序员们的破坏力。2）Programmerswhodon’tcodeintheirsparetimeforfunwillneverbecomeasgoodasthosethatdo如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的娱乐方式去编程，那么你只不过是在应付你的工作，这样下来，就算是你是一个非常聪明，非常有才华的人，你也不会成为一个优秀的编程员，要么只会平平凡凡，要么只会整天扎在技术中成为书呆子。当然，这个观点是有争议，热情和能力的差距也是很大的。不过我们可以从中汲取其正面的观点。3）Mostcommentsincodeareinfactaperniciousformofcodeduplication注释应该是注释Why，而不是How和What，参看《惹恼程序员的十件事》，代码告诉你How，而注释应该告诉你Why。但大多数的程序并不知道什么是好的注释，那些注释其实和代码是重复的，毫无意义。4）XMLishighlyoverratedXML可能被高估了。XML对于Web上的应用是不错的，但是我们把其用到了各种地方，好像没有XML，我们都不会编程了。5）Notallprogrammersarecreatedequal这是那些junior经理爱犯的错，他们总是认为，DeveloperA==DeveloperB，只要他们的title一样，他们以为他们的能力、工作速度、解决问题的方法，掌握的技能等等都是一样的。更扯的是，在某些时候，就算是最差的程序员，他们也会认为其比别人强十倍。6）”Googlingit”isokay!Google只会给你知识，并不会教给你技能。那里只有“鱼”，没有“渔”，过度使用Google，只会让你越来越离不开它，你越来越不会自己去思考、探索、钻研。如果KFC快餐是垃圾食品对我们的身体没有好处，那么使用Google也一种快餐文化对我们的智力发展没有好处。7）Ifyouonlyknowonelanguage,nomatterhowwellyouknowit,you’renotagreatprogrammer如果你只懂一种语言，准确的说，如果你只懂一类语类，如：Java和C#，PHP和Perl，那么，你将会被局限起来，只有了解了各种各样的语言，了解了不同语言的不同方法，你才会有比较，只有了比较，你才会明白各种语言的长处和短处，才会让你有更为成熟的观点，而且不整天和别的程序在网上斗嘴争论是Windows好还是Unix好，是C好还是C++好，有这点工夫能干好多事了。世界因为不同而精彩，只知道事物的一面是有害的。8）Yourjobistoputyourselfoutofwork你的工作不应该保守，那种教会徒弟，饿死师父的想法，不但是相当短浅的，而且还是相当脑残的。因为，在计算机世界里，你掌握的老技术越多，你就越没用，因为技术更新的太快。你对工作越保守，这个工作就越来越离不开你，你就越不越不能抽身去学新的东西，你也就越来越OUT了。记住：Ifyoucan’tbereplacedthenyoucan’tbepromoted!9）Designpatternsarehurtinggooddesignmorethanthey’rehelpingit很多程序员把设计模式奉为天神，他们过度的追求设计模式以至都都忘了需求是什么，结果整个系统设计被设计模式搞得乱七八糟，我们叫这种编程为“设计模式驱动编程”，正如第一点所说，如果你不懂得用自己的大脑思考的话，知其然，不知所以然的话，那么你不但得不到其好处，反而受其所累。10）UnitTestingwon’thelpyouwritegoodcode准确地说，我们可以认为这是Test-Driven开发，其实，这种开发就是先写单元测试用例，这样的开发方式的主要目的是，为了防止你不会因为一个改动而引入Bug，但这并不会让你能写出更好的代码。这只会让你写出不会出错的代码。同第一点，这样的方法，只不过是防止糟糕的程序员，而并不是让程序员或代码质量更有长进。反而，UnitTest会成为程序员为自己代码做辩解的一种托辞。",2015/1/6
435,phoneGap搭建（android）,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8861,"关于phoneGap是什么怎么使用这里不做介绍，大家可以去网上看下，这里根据自己的经历介绍下怎样搭建phoneGap环境，其实我也是从官网上按部就班做的，为方便大家就简单介绍下；可以按照官网上介绍的步骤带大家进行；进入：www.phonegap.comGettingstartedGuides->theCommed-Lineinterface,进入之后，可以看到这里面详细介绍了怎么搭建一个phonegap了，因为都是英文的，我看了很费劲，英文不好啊，--!现在就开始做了：1.首先开始安装cordova，这个就是phoneGap的核心，里面封装的类就是phonegap能运行的原理；当然前提是先按上面步骤安装好：Node.js和gitclient,很快的，都很小，然后在gitBash内操作我们以下全部过程了；例如这里安装cordova：$sudonpminstall-gcordova2.当然是开始创建我们的实例了（App），例如：$cordovacreatehellocom.example.helloHelloWorld3.然后进入实例目录，创建我们的平台，例如：$cdhello，我们这里是android平台，所以：$cordovaplatformaddandroid即可；4.对一个项目可能用到很多功能，比如：网络，相机，通讯录，导航等等，这个时候就是安装插件了，很简单，也就是一行命令，例如网络插件就是：$cordovapluginaddorg.apache.cordova.network-information好了，基本搞定，现在去你实例创建的目录,例如：C：/user/hello,查看下是否存在，如果存在，这个时候我们导入我们的运行平台（需要jdk,sdk),这个时候就创建一个phoneGap的demo,如果我们想运行自己的项目，将www文件导入这个项目下的asset下的www即可；里面还有些细节东西没介绍，大家自己摸索；",2015/1/6
436,MyEclipse8.5优化,张建涛,http://180.168.156.212:2262/wecenter/?/article/8856,"第一步:取消自动validationvalidation有一堆，什么xml、jsp、jsf、js等等，我们没有必要全部都去自动校验一下，只是需要的时候才会手工校验一下！取消方法：windows–>perferences–>myeclipse–>validation除开Manual下面的复选框全部选中之外，其他全部不选手工验证方法：在要验证的文件上，单击鼠标右键–>myeclipse–>runvalidation第二步：取消Eclipse拼写检查1、拼写检查会给我们带来不少的麻烦，我们的方法命名都会是单词的缩写，他也会提示有错，所以最好去掉，没有多大的用处windows–>perferences–>general->editors->TextEditors->spelling第三步：取消myeclipse的启动项myeclipse会有很多的启动项，而其中很多我们都用不着，或者只用一两个，取消前面不用的就可以windows–>perferences–>general–>startupandshutdown启动项功能如下，可以根据自己的需要选择AutomaticUpdatesScheduler//自动升级调度MyEclipseQuickSetup//快速启动MyEclipseDerby//derby是一个开源数据库的名字MyEclipseEASIEGeronimo1//同色都是应用服务器的名字MyEclipseEASIEGeronimo2MyEclipseEASIEJBOSS2MyEclipseEASIEJBOSS3MyEclipseEASIEJBOSS4MyEclipseEASIEJBOSS5MyEclipseEASIEJBOSSMyEclipseEASIEJetty4MyEclipseEASIEJetty5MyEclipseEASIEJetty6MyEclipseEASIEJettyMyEclipseEASIEJOnAS3MyEclipseEASIEJOnAS4MyEclipseEASIEJOnASMyEclipseEASIEJRun4MyEclipseEASIEJRunMyEclipseEASIEOracle10ASMyEclipseEASIEOracle9ASMyEclipseEASIEOracleASMyEclipseEASIEOrion1MyEclipseEASIEOrion2MyEclipseEASIEResin2MyEclipseEASIEResin3MyEclipseEASIEResinMyEclipseEASIESun8.xMyEclipseEASIESun8MyEclipseEASIESun9MyEclipseEASIEGlassfish2MyEclipseEASIEGlassfish1MyEclipseEASIESunOneMyEclipseEASIEMyEclipseTomcat6ServerMyEclipseEASIETomcat4MyEclipseEASIETomcat5MyEclipseEASIETomcat6MyEclipseEASIETomcatMyEclipseEASIEWebLogic10MyEclipseEASIEWebLogic6MyEclipseEASIEWebLogic7MyEclipseEASIEWebLogic8MyEclipseEASIEWebLogic9MyEclipseEASIEWebLogicMyEclipseEASIEWebSphere5MyEclipseEASIEWebSphere6.1MyEclipseEASIEWebSphere6MyEclipseEASIEWebSphere4MyEclipseExamples//样例MyEclipseMemoryMonitor//内存监控MyEclipseTapestryIntegration//插件集成MyEclipseJSPDebugTooling//jsp调试插件MyEclipseFileCreationWizards//文件创建程序ICEfacesIntegrationforMyEclipse//基于Ajax的JSF开发框架()MyEclipseBackwardCompatibility//后台功能MyEclipsePerspectivePlug-in//透视图插件PluseCollaborationControlCenter//Eclipse的网页管理中心eclipse-cs4.x.x->5.0.0MigrationPlug-in//Eclipse插件兼容组件MozillaDebugUIPlug-in(Incubation)//Mozilla调试插件（Mozilla是一款浏览器)DynamicLanguagesToolKitCoreUI//对入PHP等动态语言支持的用户接口WTPWebserviceUIPlug-in//Web服务视图插件JavaServerFacesTools-Core//jsf工具核心包AutomaticUpdatesScheduler//自动更新Servicepolicy//Web提供的服务性能目标定义,自动管理AtfdebugPlug-in(Incubation)//动态语言的调试工具AuxiliaryWebModuleSupportforMeEclipse//辅助的Web模块支持.(可能是Struts等文件自动添加)JSFEditorPreviewSupportforMyEclipse//jsf编辑器第四步：更改jsp默认打开的方式安装了myeclipse后，编辑jsp页面，会打开他的编辑页面，同时也有预览页面，速度很慢，不适合开发。所以更改之windows–>perferences–>general–>editors->fileassociations选择*.jsp，把编译器改为默认启动MyEclipseJSPEdition（在下方选择一种编辑器，然后点击左边的default按钮）第五步:更改内存使用文件1、打开eclipse.ini-startup../Common/plugins/org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar--launcher.library../Common/plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.0.200.v20090519-installD:/Myeclipse8.5/Program-vmD:/Myeclipse8.5/Common/binary/com.sun.java.jdk.win32.x86_1.6.0.013/jre/bin/client/jvm.dll-configurationconfiguration-vmargs-Xmx512m-XX:MaxPermSize=1024m-XX:ReservedCodeCacheSize=128m把下面的那个-XX:MaxPermSize调大，比如-XX:MaxPermSize=1024M，再把-XX:PermSize调成跟-XX:MaxPermSize一样大原因：大家一定对这个画面很熟悉吧：几乎每次eclipse卡到当都是因为这个非堆内存不足造成的，把最大跟最小调成一样是因为不让myeclipse频繁的换内存区域大小注意：XX:MaxPermSize和Xmx的大小之和不能超过你的电脑内存大小第六步:取消Maven更新(启动更新)Window>Preferences>Myeclipse>Maven4Myeclipse>Maven>禁用Downloadrepositoryindexupdatesonstartup",2015/1/5
437,requestAnimationFrame-Web中写动画,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8860,"HTML5/CSS3时代，我们要在web里做动画选择其实已经很多了:可以用CSS3的animattion+keyframes;也可以用css3的transition;还可以用通过在canvas上作图来实现动画，也可以借助jQuery动画相关的API方便地实现;当然最原始的还可以使用window.setTimout()或者window.setInterval()通过不断更新元素的状态位置等来实现动画，前提是画面的更新频率要达到每秒60次才能让肉眼看到流畅的动画效果。现在又多了一种实现动画的方案，那就是window.requestAnimationFrame()方法。这个方法原理其实也就跟setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。requestAnimationFrame可以直接调用，也可以通过window来调用，接收一个函数作为回调，返回一个ID值，通过把这个ID值传给window.cancelAnimationFrame()可以取消该次动画。下面展示的效果是基于requestAnimationFrame的效果。0%<br/>window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;<br/>varstart=null;<br/>varele=document.getElementById(""test"");<br/>varprogress=0;<br/><br/>functionstep(timestamp){<br/>progress+=1;<br/>ele.style.width=progress+""%"";<br/>ele.innerHTML=progress+""%"";<br/>if(progress<100){<br/>requestAnimationFrame(step);<br/>}else<br/><br/>{ele.style.width=100+""%"";<br/>ele.innerHTML=100+""%"";<br/>}<br/>}<br/>requestAnimationFrame(step);<br/>functiona(){<br/>ele.style.width=""1px"";<br/>progress=0;<br/>requestAnimationFrame(step);<br/>}<br/>您的浏览器不支持HTML5!",2015/1/5
438,HTML meta标签常用属性整理,管俊,http://180.168.156.212:2262/wecenter/?/article/8855,概要标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他web服务。——W3School必要属性属性值描述contentsometext定义与http-equiv或name属性相关的元信息可选属性属性值描述http-equivcontent-type/expire/refresh/set-cookie把content属性关联到HTTP头部。nameauthor/description/keywords/generator/revised/others把content属性关联到一个名称。contentsometext定义用于翻译content属性值的格式。SEO优化参考文档●页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过874个字符。 /blog/c...07912,2015/1/4
439,Web性能优化：图片优化,管俊,http://180.168.156.212:2262/wecenter/?/article/8854,"HTTPArchieve有个统计，图片内容已经占到了互联网内容总量的62%，也就是说超过一半的流量和时间都用来下载图片。从性能优化的角度看，图片也绝对是优化的热点和重点之一，GooglePageSpeed或者Yahoo的14条性能优化规则无不把图片优化作为重要的优化手段，本文覆盖了Web图片优化的方方面面，从基本的图片格式选择、到尚未被广泛支持的响应式图片均有所提及。GoogleWebFundamentals的说法我很喜欢： 。这是目前几乎唯一能够批量处理APNG文件的工具，感兴趣的同学可以在那篇文章里得到更多地了解。自动优化前面说了太多关于如何优化各种不同格式图片的方法和工具，优化图片需要大量重复性的劳动，作为工程师显然不会忍受这一点，因此也产生出了很多工具对图片进行自动优化，这里主要介绍CDN、Grunt/Gulp、GooglePageSpeed三种方式。自动优化：CDN使用CDN对图片自动进行优化，我在国外的CDN提供商处很少见到这类服务，倒是国内的两大新秀CDN七牛和又拍在这方面都做了大量工作。其工作方式为，向CDN请求图片的URL参数中包含了图片处理的参数（格式、宽高等），CDN服务器根据请求生成所需的图片，发送到用户浏览器。七牛云存储的图片处理接口极其丰富，覆盖了图片的大部分基本操作，例如：●图片裁剪，支持多种裁剪方式（如按长边、短边、填充、拉伸等）●图片格式转换，支持JPG,GIF,PNG,WebP等，支持不同的图片压缩率●图片处理，支持图片水印、高斯模糊、重心处理等七牛云存储的图片处理接口使用并不复杂，例如下面这张原图：我们通过如下URL请求，裁剪正中部分，等比缩小生成200x200缩略图： ...h/200自动优化：Grunt/Gulp这里介绍用于图片优化的Grunt组件：grunt-image。前端工程师的重复性工作，例如合并静态资源、压缩JS和CSS文件、编译SASS等都可以使用Grunt等自动化工具批量完成，图片优化也是如此。grunt-image非常强大，按照作者的介绍，其内部加载的图片优化工具包括了pngquant,optipng,advpng,zopflipng,pngcrush,pngout,mozjpeg,jpegRecompress,jpegoptim,gifsicle和svgo。支持批量自动优化PNG,JPG,SVG和GIF，速度也不错，配置方式支持单图片优化和全目录优化： '}]}}});grunt.loadNpmTasks('grunt-image');};自动优化：GooglePageSpeedGoogle做事风格比较彻底，看见哪个软件不好用就拿来直接fork出新版本或者干脆重写，对于Web优化，Google发布了了GooglePageSpeed这个服务器模块，可以在apache或ngnix中加载，通过在服务器配置文件中进行设置来进行自动化的优化。对于图片格式转换、图片优化甚至图片LazyLoad都有相关选项。这部分展开会非常长，请感兴趣的同学参考Google的手册。",2015/1/4
440,不要忽视Web编程中的小细节,管俊,http://180.168.156.212:2262/wecenter/?/article/8853,"长时间以来，我们创造了某些在构造和范围内用以提升网站易用性的约定和实践。然后在我们进行web编程的时候总有一些疏忽和纰漏。这里总结了一些web编程时容易出现的小错误，并给出了相应的补救方法，希望可以帮助提高网站的可用性。只要避免下列这些错误，网站的用户体验度就会大大提升。错误一:表单标签没有与相应字段相关联利用""for""属性，使客户可以通过点击标签在表格内选择正确的输入字段。这对于复选框和单选字段来说就是要有更大的可点击区域。错误二:Logo图表没有链接到主页给logo添加到主页的链接是非常基本的一点。并且大多数用户都会自然而然的认为通过logo能够重返首页。logo最好放置在左上角。错误三:未显示链接的访问状态显示链接的访问状态时常被忽略掉。让客户能一眼看到这个链接是否被点击过是很重要的。错误四:未显示当前有效的表单域你可以运用""focus""选择或捆绑元素。但是最有用的方法还是运用输入和文本区来说明该字段是活跃的。包含一些CSS样式，比如，高亮边框，或者背景色有点小小变化。错误五:图片未添加描述除非是单纯的作修饰用的，ALT属性可不填写，否则的话要记得要给图片单独添加一个描述性语句。好处就是将图片当做链接，输入相应的描述语句搜索就会访问到该链接。错误六:没有背景色的背景图针对某部分内容运用背景图片是很常见的做法。值得一提的是，如果客户禁用背景图的话该部分文字就看不见了。所以最好还是设置一个背景色。错误七:界面设计风格不一致过度的创造有时候就是会画蛇添足呀！有的设计师就容易犯这样的错误，同一个网站里各个网页的设计都不一样。这对用户来说岂止是混乱，简直就是讨人厌啊！不管一个网站有多惊艳，如果整体风格不连贯就无法得到用户认同。建议：1.使用模板。2.关键还是要简洁。错误八:给非链接内容加下划线大家都知道的，带下划线或者加阴影的内容很可能是个链接。为了不误导用户，最好采用加粗或者其他强调标识来表示强调部分。",2015/1/4
441,Mybatis入门,管俊,http://180.168.156.212:2262/wecenter/?/article/8852,研发中心经验共享[201412]_管俊.doc,2015/1/4
442,如何编写高质量的Jquery代码（源文档见附件）,李海波,http://180.168.156.212:2262/wecenter/?/article/8851,"一、Jquery高效编码注意事项：定义jQuery变量的时候添加var关键字：不仅仅是jQuery，所有javascript开发过程中，都需要注意，请一定不要定义成如下：$loading=$('#loading');//这个是全局定义请使用一个var来定义变量，如果你使用多个变量的话，请如下方式定义：varpage=0,$loading=$('#loading'),$body=$('body');不要给每一个变量都添加一个var关键字，除非你有严重的强迫症。定义jQuery变量：如果你定义的是jQuery的变量，请添加一个$符号到变量前，如下：var$loading=$('#loading');这里定义成这样的好处在于，你可以有效的提示自己或者其它阅读你代码的用户，这是一个jQuery的变量。DOM操作请务必记住缓存：在jQuery代码开发中，我们常常需要操作DOM，DOM操作是非常消耗资源的一个过程，而往往很多人都喜欢这样使用jQuery：$('#loading').html('完毕');$('#loading').fadeOut();代码没有任何问题，你也可以正常运行出结果，但是这里注意你每次定义并且调用$('#loading')的时候，都实际创建了一个新的变量，如果你需要重用的话，记住一定要定义到一个变量里，这样可以有效的缓存变量内容，如下：var$loading=$('#loading');$loading.html('完毕');$loading.fadeOut();这样性能会更好。使用链式操作：上面那个例子，我们可以写的更简洁一些：var$loading=$('#loading');$loading.html('完毕').fadeOut();注意链式操作不要过多了，如果太多了，看着也混淆。精简jQuery代码：尽量把一些代码都整合到一起，请勿这样编码：$button.click(function(){$target.css('width','50%');$target.css('border','1pxsolid#202020');$target.css('color','#fff');});应该这样书写：$button.click(function(){$target.css({'width':'50%','border':'1pxsolid#202020','color':'#fff'});});避免使用全局类型的选择器：请勿如下书写：$('.something>*');这样书写更好：$('.something').children();不要叠加多个ID：请勿如下书写：$('#something#children');这样书写更好：$('#children');多用逻辑判断||或者&&来提速：请勿如下书写：if(!$something){$something=$('#something');}这样书写性能更好：$something=$something||$('#something');尽量使用更少的代码：if(string.length>0){..}if(string.length){..}尽量使用.on方法如果你使用比较新版本的jQuery类库的话，请使用.on，其它任何方法都是最终使用.on来实现的。尽量使用原生的Javascript：如果使用原生的Javascript也可以实现jQuery提供的功能的话，推荐使用原生的javascript来实现。二、Jquery书写规范：空格：使用tab进行缩进代码中多用点空格左花括号前面一定要有空格行内不要使用tab空行不要有空格行尾不要有空格等价判断：尽量使用严格的等价判断符===，尽量不用==。代码块：if/else/for/while/try要使用花括号，且要换行。代码块一定要用花括号括起来：不要把语句和判断条件放在同一行：else/elseif/catch要和花括号在同一行：例外：elseif的情况，else就不要加花括号了：不要使用三元操作符取代if/else语句。不要使用object&&object.method()取代if/else语句，除非在条件判断中。函数调用：参数两边要加一个空格例外：如果已经在函数调用中的话，里面的函数调用可以不加空格：例外：函数，对象，数组字面量，如果是唯一参数的话，可以紧贴括号：空函数调用不需要加空格：逗号和冒号后面一定要跟空格数组和对象：空对象和数组不需要填入空格：逗号和冒号后面一定要跟空格赋值：赋值语句一定要跟分号。分号后面一定要换行。类型检查：String:typeofobject===""string""Number:typeofobject===""number""Boolean:typeofobject===""boolean""Object:typeofobject===""object""PlainObject:jQuery.isPlainObject(object)Function:jQuery.isFunction(object)Array:jQuery.isArray(object)Element:object.nodeTypenull:object===nullnullorundefined:object==nullundefined:GlobalVariables:typeofvariable===""undefined""LocalVariables:variable===undefinedProperties:object.prop===undefined正则表达式：只准用.test()和.exec()。不准用""string"".match()。字符串：字符串一定要用双引号，不能用单引号。节点：使用.nodeName而非.tagName使用.nodeType来判断节点的类型（不要用.nodeName）不要手动往节点上挂自定义的属性，一定要使用.data()。Jquery编码须知与规范.doc",2015/1/4
443,不同版本IE浏览器下样式设置,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8850,不同版本IE浏览器下样式设置问题研发中心经验共享-毛璀玲[201412].doc,2015/1/4
444,值得一看的扁平式PPT,魏爱红,http://180.168.156.212:2262/wecenter/?/article/8849,这个是写PPT搜素材时搜到的，互联网我还没法理解，倒是这互联网达人的PPT让我佩服，可惜牛人也不给咱个方便，不提供原始模板全是截图，大伙凑合着看吧，拿来主义估计是不好使了......2014世界互联网大会PPT_免费下载.pptx,2014/12/31
445,最近几个工作笔记（比较乱）,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8848,"/*********************http通信方法*****************/关于http通信的其实自己也不是很懂，就是略微知道一些基本的通信方法httpUrlconnection方法1：DefaultHttpClienthttpclient=newDefaultHttpClient();//创建http客户端HttpGethttpget=newHttpGet(httpUrl);HttpResponseresponse=httpclient.execute(httpget);HttpEntityentity=response.getEntity();//得到http的内容response.getStatusLine().getStatusCode();//得到http的状态返回值result=EntityUtils.toString(response.getEntity());//得到具体的返回值，一般是xml文件entity.consumeContent();//如果entity不为空，则释放内存空间httpclient.getCookieStore();//得到cookishttpclient.getConnectionManager().shutdown();//关闭http客户端方法2：DefaultHttpClienthttpclient=newDefaultHttpClient();HttpPosthttpPost=newHttpPost(httpUrl);httpclient.setCookieStore(DataDefine.mCookieStore);HttpParamsparams=httpclient.getParams();//计算网络超时用HttpConnectionParams.setConnectionTimeout(params,5*1000);HttpConnectionParams.setSoTimeout(params,2*1000);httpPost.setHeader(""Content-Type"",""text/xml"");StringEntityhttpPostEntity=newStringEntity(base64,""UTF-8"");//base64是经过编码的字符串，可以理解为字符串//StringEntityhttpPostEntity=newStringEntity(""UTF-8"");httpPost.setEntity(httpPostEntity);HttpResponseresponse=httpclient.execute(httpPost);/********************异常提示（我们经常遇到一些必修药处理的异常而导致应用程序崩溃而采取）*********************/01.publicclassCrashHandlerimplementsUncaughtExceptionHandler{02.publicstaticfinalStringTAG=""CrashHandler"";03.privatestaticCrashHandlerINSTANCE=newCrashHandler();04.privateContextmContext;05.privateThread.UncaughtExceptionHandlermDefaultHandler;06.07.privateCrashHandler(){08.}09.10.publicstaticCrashHandlergetInstance(){11.returnINSTANCE;12.}13.14.publicvoidinit(Contextctx){15.mContext=ctx;16.mDefaultHandler=Thread.getDefaultUncaughtExceptionHandler();17.Thread.setDefaultUncaughtExceptionHandler(this);18.}19.20.@Override21.publicvoiduncaughtException(Threadthread,Throwableex){22.//if(!handleException(ex)&&mDefaultHandler!=null){23.//mDefaultHandler.uncaughtException(thread,ex);24.//}else{25.//android.os.Process.killProcess(android.os.Process.myPid());26.//System.exit(10);27.//}28.System.out.println(""uncaughtException"");29.30.newThread(){31.@Override32.publicvoidrun(){33.Looper.prepare();34.newAlertDialog.Builder(mContext).setTitle(""提示"").setCancelable(false)35..setMessage(""程序崩溃了..."").setNeutralButton(""我知道了"",newOnClickListener(){36.@Override37.publicvoidonClick(DialogInterfacedialog,intwhich){38.System.exit(0);39.}40.})41..create().show();42.Looper.loop();43.}44.}.start();45.}46.47./**48.*自定义错误处理,收集错误信息发送错误报告等操作均在此完成.开发者可以根据自己的情况来自定义异常处理逻辑49.*50.*@paramex51.*@returntrue:如果处理了该异常信息;否则返回false52.*/53.privatebooleanhandleException(Throwableex){54.if(ex==null){55.returntrue;56.}57.//newHandler(Looper.getMainLooper()).post(newRunnable(){58.//@Override59.//publicvoidrun(){60.//newAlertDialog.Builder(mContext).setTitle(""提示"")61.//.setMessage(""程序崩溃了..."").setNeutralButton(""我知道了"",null)62.//.create().show();63.//}64.//});65.66.returntrue;67.}68.}/*********************viewPager标题自定义*******************I/publicCharSequencegetPageTitle(intposition){//TODOAuto-generatedmethodstubSpannableStringBuildersb=newSpannableStringBuilder(""""+""Page#""+position);//spaceaddedbeforetextforconveniencetitle.get(position).setBounds(0,0,title.get(position).getIntrinsicWidth(),title.get(position).getIntrinsicHeight());ImageSpanspan=newImageSpan(title.get(position),ImageSpan.ALIGN_BASELINE);sb.setSpan(span,0,1,Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);returnsb;}***************************Linux下启动端口***************************/LINUX通过下面的命令可以开启允许对外访问的网络端口：/sbin/iptables-IINPUT-ptcp--dport8000-jACCEPT#开启8000端口/etc/rc.d/init.d/iptablessave#保存配置/etc/rc.d/init.d/iptablesrestart#重启服务查看端口是否已经开放/etc/init.d/iptablesstatus",2014/12/31
446,Linux基本命令,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8847,"最近修改android移动档案项目，牵涉到在Linux下调试服务器，想起了我已经快一年没在Linux系统下写项目了，记得第一次使用的是Ubuntu1.0,到现在很多Linux的东西都忘记了，现在想想还是和大家分享下Linux基本命令；系统信息arch显示机器的处理器架构(1)uname-m显示机器的处理器架构(2)uname-r显示正在使用的内核版本dmidecode-q显示硬件系统部件-(SMBIOS/DMI)hdparm-i/dev/hda罗列一个磁盘的架构特性hdparm-tT/dev/sda在磁盘上执行测试性读取操作cat/proc/cpuinfo显示CPUinfo的信息cat/proc/interrupts显示中断cat/proc/meminfo校验内存使用cat/proc/swaps显示哪些swap被使用cat/proc/version显示内核的版本cat/proc/net/dev显示网络适配器及统计cat/proc/mounts显示已加载的文件系统lspci-tv罗列PCI设备lsusb-tv显示USB设备date显示系统日期cal2007显示2007年的日历表date041217002007.00设置日期和时间-月日时分年.秒clock-w将时间修改保存到BIOS关机(系统的关机、重启以及登出)shutdown-hnow关闭系统(1)init0关闭系统(2)telinit0关闭系统(3)shutdown-hhours:minutes&按预定时间关闭系统shutdown-c取消按预定时间关闭系统shutdown-rnow重启(1)reboot重启(2)logout注销文件和目录cd/home进入'/home'目录'cd..返回上一级目录cd../..返回上两级目录cd进入个人的主目录cd~user1进入个人的主目录cd-返回上次所在的目录pwd显示工作路径ls查看目录中的文件ls-F查看目录中的文件ls-l显示文件和目录的详细资料ls-a显示隐藏文件ls*[0-9]*显示包含数字的文件名和目录名tree显示文件和目录由根目录开始的树形结构(1)lstree显示文件和目录由根目录开始的树形结构(2)mkdirdir1创建一个叫做'dir1'的目录'mkdirdir1dir2同时创建两个目录mkdir-p/tmp/dir1/dir2创建一个目录树rm-ffile1删除一个叫做'file1'的文件'rmdirdir1删除一个叫做'dir1'的目录'rm-rfdir1删除一个叫做'dir1'的目录并同时删除其内容rm-rfdir1dir2同时删除两个目录及它们的内容mvdir1new_dir重命名/移动一个目录cpfile1file2复制一个文件cpdir/*.复制一个目录下的所有文件到当前工作目录cp-a/tmp/dir1.复制一个目录到当前工作目录cp-adir1dir2复制一个目录ln-sfile1lnk1创建一个指向文件或目录的软链接lnfile1lnk1创建一个指向文件或目录的物理链接touch-t0712250000file1修改一个文件或目录的时间戳-(YYMMDDhhmm)filefile1outputsthemimetypeofthefileastexticonv-l列出已知的编码iconv-ffromEncoding-ttoEncodinginputFile>outputFilecreatesanewfromthegiveninputfilebyassumingitisencodedinfromEncodingandconvertingittotoEncoding.find.-maxdepth1-name*.jpg-print-execconvert""{}""-resize80x60""thumbs/{}""\;batchresizefilesinthecurrentdirectoryandsendthemtoathumbnailsdirectory(requiresconvertfromImagemagick)文件搜索find/-namefile1从'/'开始进入根文件系统搜索文件和目录find/-useruser1搜索属于用户'user1'的文件和目录find/home/user1-name\*.bin在目录'/home/user1'中搜索带有'.bin'结尾的文件find/usr/bin-typef-atime+100搜索在过去100天内未被使用过的执行文件find/usr/bin-typef-mtime-10搜索在10天内被创建或者修改过的文件find/-name\*.rpm-execchmod755'{}'\;搜索以'.rpm'结尾的文件并定义其权限find/-xdev-name\*.rpm搜索以'.rpm'结尾的文件，忽略光驱、捷盘等可移动设备locate\*.ps寻找以'.ps'结尾的文件-先运行'updatedb'命令whereishalt显示一个二进制文件、源码或man的位置whichhalt显示一个二进制文件或可执行文件的完整路径",2014/12/31
447,android语音识别功能（科大讯飞的API为例）,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8846,"Android系统本身其实提供有语音识别模块，在它的APIDemo里也有关于语音识别的sample，不过经过大多开发者的真机测试，发现很多真机并不能使用哪个sample，在网上查找了一下原因，大部分是因为开发者在刷机的时候，大部分的ROM都阉割掉了语音识别和语音合成TTS(TextToSpeech)部分，所以运行sample的时候会有异常抛出。如果不用google提供的语音识别，要怎么实现语音识别喃？科大讯飞的语音API就可以，下面我就用一个简单的实例来介绍一下它基本的使用：publicvoidonClick(Viewv){//根据不同View的id调用不同方法switch(v.getId()){caseR.id.bt_recognize://这是语言识别部分，最重要的实例化一个//RecognizerDialog并把你在官方网站申请的appid填入进去，非法id不能进行识别RecognizerDialogisrDialog=newRecognizerDialog(Voice1Activity.this,APPID);/**设置引擎目前支持五种”sms”：普通文本转写“poi”：地名搜索”vsearch”：热词搜索*”video”：视频音乐搜索”asr”：命令词识别*/isrDialog.setEngine(""sms"",null,null);isrDialog.setListener(recoListener);isrDialog.show();break;caseR.id.bt_speek://这是语言合成部分同样需要实例化一个SynthesizerDialog，并输入appidSynthesizerDialogsyn=newSynthesizerDialog(Voice1Activity.this,APPID);syn.setListener(newSynthesizerDialogListener(){@OverridepublicvoidonEnd(SpeechErrorarg0){}});//根据EditText里的内容实现语音合成syn.setText(et.getText().toString(),null);syn.show();break;caseR.id.bt_speek_bg://这是后台朗读，实例化一个SynthesizerPlayerSynthesizerPlayerplayer=SynthesizerPlayer.createSynthesizerPlayer(Voice1Activity.this,APPID);//设置语音朗读者，可以根据需要设置男女朗读，具体请看api文档和官方论坛player.setVoiceName(""vivixiaomei"");player.playText(et.getText().toString(),""ent=vivi21,bft=5"",null);break;default:break;}}//语言识别监听器，有两个方法RecognizerDialogListenerrecoListener=newRecognizerDialogListener(){@OverridepublicvoidonResults(ArrayList<RecognizerResult>results,booleanisLast){//服务器识别完成后会返回集合，我们这里就只得到最匹配的那一项text+=results.get(0).text;System.out.println(text);}@OverridepublicvoidonEnd(SpeechErrorerror){if(error==null){//完成后就把结果显示在EditText上et.setText(text);}}};最后别忘了把科大讯飞的jar包引入工程的buildPath里面。",2014/12/31
448,android流媒体播放功能简单实现,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8845,"Android当前支持两种协议来传输视频流一种是Http协议，另一种是RTSP协议Http协议最常用于视频下载等，但是目前还不支持边传输边播放的实时流媒体同时，在使用Http协议传输视频时，需要根据不同的网络方式来选择合适的编码方式，比如对于GPRS网络，其带宽只有20kbps,我们需要使视频流的传输速度在此范围内。比如，对于GPRS来说，如果多媒体的编码速度是400kbps，那么对于一秒钟的视频来说，就需要20秒的时间。这显然是无法忍受的Http下载时，在设备上进行缓存，只有当缓存到一定程度时，才能开始播放。所以，在不需要实时播放的场合，我们可以使用Http协议RTSP：RealTimeStreamingProtocal，实时流媒体传输控制协议。使用RTSP时，流媒体的格式需要是RTP。RTSP和RTP是结合使用的，RTP单独在Android中式无法使用的。RTSP和RTP就是为实时流媒体设计的，支持边传输边播放。同样的对于不同的网络类型（GPRS，3G等），RTSP的编码速度也相差很大。根据实际情况来使用前面介绍的三种方式，都可以播放网络上的视频，唯一不同的就是URI本例中使用VideoView来播放网络上的视频：代码：publicclassVideoViewPlayingActivityextendsActivityimplementsOnPreparedListener,OnCompletionListener,OnErrorListener,OnInfoListener,OnPlayingBufferCacheListener{privatefinalStringTAG=""VideoViewPlayingActivity"";/***您的ak*/privateStringAK=""2xLjKzwcG7EznhyuYPb8U33M"";/***//您的sk的前16位*/privateStringSK=""G3QWOpWYbcXBXbkMWBuPKSEEsShFDF3K"";privateStringmVideoSource=null;privateBVideoViewmVV=null;privateBMediaControllermVVCtl=null;privateRelativeLayoutmViewHolder=null;privateLinearLayoutmControllerHolder=null;privatebooleanmIsHwDecode=false;privateEventHandlermEventHandler;privateHandlerThreadmHandlerThread;privatefinalObjectSYNC_Playing=newObject();privatefinalintEVENT_PLAY=0;privateWakeLockmWakeLock=null;privatestaticfinalStringPOWER_LOCK=""VideoViewPlayingActivity"";/***播放状态*/privateenumPLAYER_STATUS{PLAYER_IDLE,PLAYER_PREPARING,PLAYER_PREPARED,}privatePLAYER_STATUSmPlayerStatus=PLAYER_STATUS.PLAYER_IDLE;/***记录播放位置*/privateintmLastPos=0;//addforsubtitle//privateButtonmSubtitleButton;//privateSubtitleSettingPopupWindowmSubtitleSettingWindow;//privateRelativeLayoutmRoot;//privateSubtitleManagermSubtitleManager;classEventHandlerextendsHandler{publicEventHandler(Looperlooper){super(looper);}@OverridepublicvoidhandleMessage(Messagemsg){switch(msg.what){caseEVENT_PLAY:/***如果已经播放了，等待上一次播放结束*/if(mPlayerStatus!=PLAYER_STATUS.PLAYER_IDLE){synchronized(SYNC_Playing){try{SYNC_Playing.wait();Log.v(TAG,""waitplayerstatustoidle"");}catch(InterruptedExceptione){//TODOAuto-generatedcatchblocke.printStackTrace();}}}/***设置播放url*/mVV.setVideoPath(mVideoSource);/***续播，如果需要如此*/if(mLastPos>0){mVV.seekTo(mLastPos);mLastPos=0;}/***显示或者隐藏缓冲提示*/mVV.showCacheInfo(true);/***开始播放*/mVV.start();mPlayerStatus=PLAYER_STATUS.PLAYER_PREPARING;break;default:break;}}}/***实现切换示例*/privateView.OnClickListenermPreListener=newView.OnClickListener(){@OverridepublicvoidonClick(Viewv){//TODOAuto-generatedmethodstubLog.v(TAG,""prebtnclicked"");/***如果已经开发播放，先停止播放*/if(mPlayerStatus!=PLAYER_STATUS.PLAYER_IDLE){mVV.stopPlayback();}/***发起一次新的播放任务*/if(mEventHandler.hasMessages(EVENT_PLAY))mEventHandler.removeMessages(EVENT_PLAY);mEventHandler.sendEmptyMessage(EVENT_PLAY);}};privateView.OnClickListenermNextListener=newView.OnClickListener(){@OverridepublicvoidonClick(Viewv){//TODOAuto-generatedmethodstubLog.v(TAG,""nextbtnclicked"");}};@OverrideprotectedvoidonCreate(BundlesavedInstanceState){super.onCreate(savedInstanceState);setContentView(R.layout.activity_videoplaying);PowerManagerpm=(PowerManager)getSystemService(Context.POWER_SERVICE);mWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK|PowerManager.ON_AFTER_RELEASE,POWER_LOCK);Log.i(""mWakeLock"",mWakeLock+"""");mIsHwDecode=getIntent().getBooleanExtra(""isHW"",false);UriuriPath=getIntent().getData();Log.i(""URIPath"",uriPath+"""");if(null!=uriPath){Stringscheme=uriPath.getScheme();Log.i(""scheme"",scheme);if(null!=scheme){mVideoSource=uriPath.toString();}else{mVideoSource=uriPath.getPath();}}initUI();/***开启后台事件处理线程*/mHandlerThread=newHandlerThread(""eventhandlerthread"",Process.THREAD_PRIORITY_BACKGROUND);mHandlerThread.start();mEventHandler=newEventHandler(mHandlerThread.getLooper());}/***初始化界面*/privatevoidinitUI(){mViewHolder=(RelativeLayout)findViewById(R.id.view_holder);mControllerHolder=(LinearLayout)findViewById(R.id.controller_holder);/***设置ak及sk的前16位*/BVideoView.setAKSK(AK,SK);/***创建BVideoView和BMediaController*/mVV=newBVideoView(this);mVVCtl=newBMediaController(this);mViewHolder.addView(mVV);mControllerHolder.addView(mVVCtl);/***注册listener*/mVV.setOnPreparedListener(this);mVV.setOnCompletionListener(this);mVV.setOnErrorListener(this);mVV.setOnInfoListener(this);mVVCtl.setPreNextListener(mPreListener,mNextListener);/***关联BMediaController*/mVV.setMediaController(mVVCtl);/***设置解码模式*/mVV.setDecodeMode(BVideoView.DECODE_SW);//initSubtitleSetting();}",2014/12/31
449,android 推送原理（简单）,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8844,PUSH是互联网上内容提供者和内容定制方之间的一种通信机制，利用在服务器端的程序把数据源源不断地推向客户端，大大提高客户机和服务器之间的交互性能。传统互联网上数据交互一般有poll和push两种方式。poll典型使用场景是浏览网页，是用户主动发起请求，向服务器获取数据；push刚好相反，通过服务器直接发送数据给客户端，用户被动接受消息，类似于更加及时的短信。Push的使用场景有以下两特点：时间不确定性、时效性，如发送团购信息，发送电子消费账单等。个推为第三方应用提供了跨手机平台一致的、稳定可靠的消息推送服务，实现服务端到客户端的消息主动推送。第三方应用可以实现针对单一目标地址的推送，也可以实现群发消息推送，还可以通过指定tag进行定向群组推送。个推除了为第三方提供基本的透明消息传输，还提供了一些消息展示方式，实现在客户端的通知提示、弹框操作等，帮助客户快速实现更为定制化的消息推送服务。个推目前支持Android、iOS手机平台。首先我们来看一下组成一个推送系统的几个要素1.个推SDK：以jar的方式出现，集成于第三方客户端，解析第三方下行的数据，并把结果透传给第三方客户端；也可以上行第三方定制的客户端信息。2.个推服务器：一侧负责维护与成千上万的个推SDK的长时连接，另一侧与第三方服务器对接，将第三方定制数据下行推送至个推SDK。3.第三方服务器：数据推送的发起者，通过对接个推服务器，将数据发送至第三方客户端。4.第三方客户端：第三方集成个推SDK的客户端，推送数据正真的接收者和展现者。我们用一个更加形象的方式来描述一下这个系统：淘宝购物相信很多人都体验过，就拿它举个例子。淘宝卖家——第三方服务器淘宝买家——第三方客户端快递公司（比如顺风）——个推服务器集淘宝买家中的地址管理、快递查收、包裹检验等一系列工作的集合——个推SDK（这个有点不形象，但是大概理解意思就好）。假设淘宝买家下了一单，首先需要填写寄件地址（假设不用默认的），这个相当于个推SDK根据客户端的信息，建立了一条通道（快递配送地址）。当买家付款成功后，卖家需要发货（第三方服务端要推送数据），当然先叫快递公司拿件（把推送数据发送给个推服务器），快递公司根据包裹上的地址（第三方客户端的身份信息，就是上面所说的ClientID）将包裹（数据）寄送到买家（第三方客户端），买家收货后，先验收一下货物是否有损坏（数据是否符合定制要求），获取到包裹内容（获得服务端推送的数据），并签单验收（个推SDK反馈数据发送成功）。与上面的例子相对应，我们再描述一遍整个推送过程的技术流程：1.第三方客户端集成个推SDK。2.第三方客户端启动的时候，调用SDK接口，启动推送服务，SDK后台运行并维护和个推服务端的长连接，实现SDK注册和登录。3.第三方服务端调用个推服务器的接口，将要发送的数据通过个推服务器发送到指定身份的个推SDK当中。4.个推SDK解析定制数据，并且把第三方服务器透传的数据发送给第三方客户端，第三方客户端根据服务器的数据做出相应的动作或者展现。,2014/12/31
450,android基本架构及之间关系,程庭飞,http://180.168.156.212:2262/wecenter/?/article/8843,简单点说，android的基本架构：Android=LinuxKernel+C/C++RuntimeFramework+DavikVirtualMachine+JavaRuntimeFramework+JavaSDK。下面我们再以APK的开发、编译、安装和运行来说明这些层次之间的关系。首先，我们是在PC上使用AndroidSDK提供的接口来开发APK，用的Java语言。开发完成之后，使用Java编译器将源代码编译成Java字节码，也就是带.class后缀的文件。接下来这些.class再被AndroidSDK提供的dx工具转化成Dex字节码，最后打包在APK里面的classes.dex文件中。接着，APK文件在手机上安装时，JavaRuntimeFramework里面的PacakgeManagerService就会对该APK文件进行解析，并且通过SocketIPC通知C/C++RuntimeFramework里面的installd守护进程对APK里面的classes.dex文件进行优化，得到另外一个classes.odex文件。APK安装完成之后，就可以运行了。我们以APK从桌面Launcher启动的过程为例说明它的运行过程。当我们从Launcher点击应用图标的时候，Launcher向JavaRuntimeFramework里面的ActivityManagerService发送一个启动应用的请求。ActivityManagerService又通过SocketIPC向C/C++RuntimeFramework里面的zygote守护进程请求创建一个应用程序进程。这个应用程序进程包含有一个Dalvik虚拟机。应用程序进程创建并且启动起来之后，就会通过它里面的Dalvik虚拟机加载前面提到的classes.odex文件。这样我们的应用程序就运行起来了。APK的运行过程是依赖于Dalvik虚拟机的。我们可以将它看成是将classes.odex里面的字节码解释成本地机器指令执行。例如，我们在APK里面通过FileInputStream或者FileOutputStream打开一个文件的时候，Dalvik虚拟机就会找到C/C++RuntimeFramework里面的C库bionic提供的系统接口open，并且通过它来打开指定的文件。我们再以应用程序界面的绘制和渲染过程来详细说明各个层次的关系。首先是应用程序通过SDK提供的UI类向JavaRuntimeFramework里面的WindowManagerService申请分配一块图形缓冲区。WindowManagerService又是通过BinderIPC向C/C++RuntimeFramework里面的SurfaceFlinger申请分配图形缓冲区的。图形缓冲区实际上不是由SurfaceFlinger分配的，而是由显示系统分配的，可能在显存里面，也有可能在GPU里面。这时候SurfaceFlinger就要通过HAL层次Gralloc模块向Kernel里面的显卡或者GPU驱动申请分配真正的图形缓冲区。HAL层可以看作是运行在C/C++RuntimeFramework中。应用程序得通过上述方式得到绘制UI所需要的图形缓冲区之后，就开始绘制自己的UI了。假设应用程序使用的是硬件绘制方式，也就是通过C/C++RuntimeFramework里面的OpenGL来绘制。这时候SDK的UI类的与绘制相关的函数调用通过Dalvik虚拟机都转化成了C/C++RuntimeFramework里面的OpenGL操作。应用程序UI绘制完成之后，结果就保存上述的图形缓冲区中。这时候如果要将该图形缓冲区渲染到手机屏幕上，那么还需要通过BinderIPC将该图形缓冲区发送给C/C++RuntimeFramework里面的SurfaceFlinger。SurfaceFlinger通过使用OpenGL或者HWComposer将所有请求要渲染到手机屏幕上的图形缓冲区合成之后，得到一个主图形缓冲区。最后这个图形缓冲区又会被SurfaceFlinger提交给Kernel的显卡驱动，并且在手机屏幕上进行显示。上面描述的就是Android系统各个层次的调用关系。总的来说，应用程序运行在Dalvik虚拟机上，并且通过SDK使用JavaRuntimeFramework里面的服务，而JavaRuntimeFramework里面的服务又通过C/C++RuntimeFramework里面的服务来实现自己的功能，最后C/C++RuntimeFramework里面的服务又会在需要的时候请求Kernel里面的模块或者驱动来为自己服务。,2014/12/31
451,表单自定义验证规则,张伟,http://180.168.156.212:2262/wecenter/?/article/8842,表单自定义验证规则研发中心经验共享_张伟[201405].docx,2014/12/31
452,IE开发调试利器,张伟,http://180.168.156.212:2262/wecenter/?/article/8841,IE开发调试利器，附件中含有相关插件研发中心经验共享_张伟[201404].zip,2014/12/31
453,Jqgrid中的联动和初始化,张伟,http://180.168.156.212:2262/wecenter/?/article/8840,Jqgrid中的联动和初始化，详细代码和效果在文件中研发中心经验共享_张伟[201402].doc,2014/12/31
454,转：form 表单元素中 readonly 和 disabled 的区别,李海波,http://180.168.156.212:2262/wecenter/?/article/8839,"Readonly和Disabled是用在表单中的两个属性，它们都能够做到使用户不能够更改表单域中的内容。但是它们之间有着微小的差别，总结如下：Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素都有效，包括select,radio,checkbox,button等。但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去（这种情况出现在我们将某个表单中的textarea元素设置为disabled或readonly，但是submitbutton却是可以使用的）。一般比较常用的情况是：如果说在这种情况下用readonly来代替disabled的话，若表单中只有input(text/password)和textarea元素，那还是可以的，如果存在其他发元素，比如select，用户可以在重新改写值后按回车键进行提交（回车是默认的submit触发按键）。在某个表单中为用户预填了某个唯一识别代码，不允许用户改动，但是在提交时需要传递该值，此时应该将它的属性设置为readonly。经常遇到当用户正式提交了表单后需要等待管理员的信息验证，这就不允许用户再更改表单中的数据，而是只能够查看，由于disabled的作用元素范围大，所以此时应该使用disabled，但同时应该注意的是要将submitbutton也disabled掉，否则只要用户按了这个按钮，如果在数据库操作页面中没有做完整性检测的话，数据库中的值就会被清除。我们常常在用户按了提交按钮后，利用javascript将提交按钮disabled掉，这样可以防止网络条件比较差的环境下，用户反复点提交按钮导致数据冗余地存入数据库。disabled和readonly这两个属性有一些共同之处，比如都设为true，则form属性将不能被编辑，往往在写js代码的时候容易混合使用这两个属性，其实他们之间是有一定区别的。如果一个输入项的disabled设为true，则该表单输入项不能获取焦点，用户的所有操作（鼠标点击和键盘输入等）对该输入项都无效，最重要的一点是当提交表单时，这个表单输入项将不会被提交。而readonly只是针对文本输入框这类可以输入文本的输入项，如果设为true，用户只是不能编辑对应的文本，但是仍然可以聚焦焦点，并且在提交表单的时候，该输入项会作为form的一项提交。小技巧：diabled可用readonly代替，background-color:#cccccc;加上灰色背景色就可以。<!DOCTYPEhtmlPUBLIC""-//W3C//DTDXHTML1.0Transitional//EN"""" html_ReadonlyAndDisabled.php",2014/12/31
455,Delphi组件开发入门,陈军志,http://180.168.156.212:2262/wecenter/?/article/8838,"在开讲之前，首先，我假设你了解什么是面向对象，什么是类。如果不了解的话，建议先去了解一下相关知识！在Delphi中，组件，我们可以将它理解为一个个的封装好了的功能对象库，使用这个库，就只用简单的几句代码，甚至仅仅简单的设置几个属性就能实现某些功能，我们可以将组件想象成日常生活中使用的某些工具，比如说收音机，我们不必了解其内部构造，只用在播放器上点一个收听按钮就能收听广播。其实这不仅仅是Delphi组件，Delphi的中的各种对象库都是如此，比如TStingList，只用简单几句代码就能实现一些功能，组件与对象库本质相同，唯一不同的就是组件通过Delphi的IDE接口注册到了IDE中，可以进行可视化的设计，而其他的对象库，需要我们手动创建，然后调用！上面简单阐述了一下Delphi的组件的某些特性以及与其他对象库的一些区别。下面，咱在说说Delphi的组件的构造层次，说到这个类的层次，有一个非常有名的Delphi对象层次图的（但是我不晓得在什么地方了，有兴趣的可以自己搜搜看，不看也不影响下面的讲解说明）。上面说了，Delphi的组件其实也是一个对象库，也就是一个类，在Delphi中所有对象的基类都是TObject，组件的最最最基类也是TObject，这里有一个来源于网络的不完整的类结构图这个结构中组件的类层次用黑色粗体标记出来了，也就是TObject---------->TPersistent------------>TComponent------------->TControlTControl又继续分支TPersistent这个类，这个类是一个可持续化的对象库，只要从这个类继承下来的，都自动具备了串行化的功能，可以非常方便的读入与写入到流，这个特性就方便了组件中的属性信息能非常方便的记录到窗体资源文件。TComponent这个就是所有Delphi组件的基类，所有想要注册到IDE直接进行可视化设计的对象库，都要从这个类继承。TComponent提供了必不可少的信息以使组件能够在Delphi的IDE上运作。然后TComponent下衍生出了TControl的类，这个类就是所有的在运行期间可视控件的基类，比如Label,Panel等，只要从TControl继承下来，就能实现运行期间可视化。如果直接从TComponent向下继承的话，那么在运行期间就不可见了，比如说TTimer等。TControl类，从图上可见，从他开始又有了分支了，分了TGraphicControl，TWinControl。先说TWinControl，TWincontrol就是Windows控件库的基类，这个类封装了大部分Windows的消息响应以及创建参数。再来看TGraphicControl，这个是个特殊的控件基类，也就是Label,Image等控件库的基类，其实，他本身不算是一个Windows的控件，而是依托于Windows控件之上的一块区域，所有的消息信息都由他所依托的Windows控件(也就是他的Parent)来响应，然后分派出来，之后他本身才响应这些消息（比如说，TImage控件创建的一个图片显示控件Image1，它的Parent是Form，那么他的MouseDown,MouseUp,MouseMove等消息的响应，实际上是当这个图片控件创建了之后，它的Parent就指定了一块区域是属于用来显示那个图片的，当鼠标在Form上移动，移动到那个区域的时候，就给TImage派发一个MouseMove消息，于是这个消息就响应了，鼠标按下与鼠标弹起消息也都是如此），从TGraphicControl继承过来的组件，它内部都有Canvas画布属性，其实，这个Canvas在大多数时刻实际上是用的它的Parent的Canvas，也就是说他的Canvas与GraphicControl.Parent.Canvas是同一个设备场景，那么为什么是大多数时刻，而不是任何时刻，且听我慢慢说来！其实也是在任意时刻都是Parent的canvas，不过那个任意时刻是有条件的，也就是在那个组件的实现内部，开放给用户使用的Canvas就未必是Parent的Canvas了，这个最典型的列子就是TImage这个控件了，TImage开放给我们使用的Canvas实际上是一个TBitmap的Canvas，而其内部的Canvas并未真正开放出来，而仅仅是作为将图片绘制到Parent的设备场景上使用。所以此时，我郑重指出，TGraphicControl实际上是一个虚拟的界面控件，本控件不具备句柄，切莫在未给它指定Parent的情况下，试图去使用引起控件重绘等消息的方法，比如Invalidate等。从TwinControl继承下来的控件，都是具备有控件句柄的，也就是在Windows内部具备有唯一标记，能动态索引找到的。TScrollingWinControl就是具备有滚动条的，Form就是来源于此。TcustomControl这个就是通常给咱使用来开发继承新的控件地。在创建组件之前，我们需要明确，这个组件是可视的组件（运行期间可见）还是非可视组件，如果是可视的组件，那么我们就要从TWincontrol或者TGraphicControl继承一个新的对象类来实现，如果是非可视的组件，那么我们就从TComponent继承来实现，至于为什么，上面已经说了。由于在开发组件的时候，各个人的水平层次不一样，然而创建一个新的组件，都需要创建一个新的对象类，所以此时各人根据各人的需求和能力做不同的构造，能力需求点不一样，创建方式也可能不同，一般新手，建议采用向导，找到菜单中的Component那个菜单，然后选择第一个菜单NewComponent，就能打开这个新建控件的向导，这个向导中列出来了Delphi的组件库中的所有组件，根据自己的需要选择一个你需要扩充的控件或者选择TComponent或者TCustomControl创建您的新组件。创建好了之后就能进行组件的扩充与编写了！",2014/12/31
456,Delphi为其他进程TRichEdit中添加格式化文本,陈军志,http://180.168.156.212:2262/wecenter/?/article/8837,"{*参数说明：hTarget:目标RichEdit的句柄sText:要添加的文字内容clrText:字体的颜色*}procedureSetRichEditContent(hTarget:THandle;sText:String;clrTxt:TColor=$FF);varcr:CHARRANGE;cf:CHARFORMAT2;hProc:THandle;lpFmt:Pointer;lpRgn:Pointer;dwBytesWrite:DWORD;beginif(notIsWindow(hTarget))thenexit;GetWindowThreadProcessId(hTarget,hProc);if(0=hProc)thenbeginApplication.MessageBox(PChar('获取进程句柄失败:'+IntToStr(GetLastError)),'提示',MB_OK+MB_ICONINFORMATION);exit;end;hProc:=OpenProcess(PROCESS_ALL_ACCESS,FALSE,hProc);if(0=hProc)thenbeginApplication.MessageBox(PChar('打开进程失败:'+IntToStr(GetLastError)),'提示',MB_OK+MB_ICONINFORMATION);exit;end;ZeroMemory(@cf,sizeof(CHARFORMAT2));cf.cbSize:=sizeof(CHARFORMAT2);cf.crTextColor:=clrTxt;//字体颜色cf.yHeight:=20*10;//字体大小cf.dwMask:=CFM_COLORorCFM_FACEorCFM_SIZEorCFM_PROTECTED;cf.dwEffects:=0;cf.bCharSet:=0;cf.bPitchAndFamily:=0;cf.szFaceName:='宋体';//这里可以设置插入的位置,-1,-1表示在尾部添加文字cr.cpMin:=-1;cr.cpMax:=-1;lpFmt:=VirtualAllocEx(hProc,nil,sizeof(cf),MEM_COMMIT,PAGE_READWRITE);lpRgn:=VirtualAllocEx(hProc,nil,SizeOf(cr),MEM_COMMIT,PAGE_READWRITE);WriteProcessMemory(hProc,lpFmt,@cf,sizeof(cf),dwBytesWrite);WriteProcessMemory(hProc,lpRgn,@cr,sizeof(cr),dwBytesWrite);SendMessage(hTarget,EM_SETCHARFORMAT,SCF_SELECTION,LPARAM(lpFmt));SendMessage(hTarget,EM_EXSETSEL,0,LPARAM(lpRgn));clipboard.AsText:=sText;SendMessage(hTarget,WM_PASTE,0,0);VirtualFreeEx(hProc,lpFmt,sizeof(cf),MEM_RELEASE);VirtualFreeEx(hProc,lpRgn,sizeof(cr),MEM_RELEASE);CloseHandle(hProc);end;",2014/12/31
457,Delphi实现窗体控件长按事件,陈军志,http://180.168.156.212:2262/wecenter/?/article/8836,"unitLongPressEvent;interfaceusesClasses,Controls,Messages,Windows,Forms,ExtCtrls;typeTLongPressEvent=procedure(Control:TControl)ofobject;TLongPressTracker=class(TComponent)privateFChild:TControl;FClickPos:TPoint;FForm:TCustomForm;FOldChildOnMouseUp:TMouseEvent;FOldFormWndProc:TFarProc;FOnLongPress:TLongPressEvent;FPrevActiveControl:TWinControl;FTimer:TTimer;procedureAttachForm;procedureDetachForm;functionGetDuration:Cardinal;procedureLongPressed(Sender:TObject);procedureNewChildMouseUp(Sender:TObject;Button:TMouseButton;Shift:TShiftState;X,Y:Integer);procedureNewFormWndProc(varMessage:TMessage);procedureSetDuration(Value:Cardinal);procedureSetForm(Value:TCustomForm);procedureStartTracking;protectedprocedureNotification(AComponent:TComponent;Operation:TOperation);override;publicconstructorCreate(AOwner:TComponent);override;destructorDestroy;override;propertyForm:TCustomFormreadFFormwriteSetForm;publishedpropertyDuration:CardinalreadGetDurationwriteSetDurationdefault1000;propertyOnLongPress:TLongPressEventreadFOnLongPresswriteFOnLongPress;end;procedureRegister;implementationprocedureRegister;beginRegisterComponents('Samples',[TLongPressTracker]);end;functionFindControlAtPos(Window:TWinControl;constScreenPos:TPoint):TControl;varI:Integer;C:TControl;beginforI:=Window.ControlCount-1downto0dobeginC:=Window.Controls[I];ifC.VisibleandPtInRect(C.ClientRect,C.ScreenToClient(ScreenPos))thenbeginifCisTWinControlthenResult:=FindControlAtPos(TWinControl(C),ScreenPos)elseResult:=C;Exit;end;end;Result:=Window;end;{TLongPressTracker}typeTControlAccess=class(TControl);procedureTLongPressTracker.AttachForm;beginifFForm<>nilthenbeginFForm.HandleNeeded;FOldFormWndProc:=Pointer(GetWindowLong(FForm.Handle,GWL_WNDPROC));SetWindowLong(FForm.Handle,GWL_WNDPROC,Integer(MakeObjectInstance(NewFormWndProc)));end;end;constructorTLongPressTracker.Create(AOwner:TComponent);begininheritedCreate(AOwner);FTimer:=TTimer.Create(Self);FTimer.Enabled:=False;FTimer.Interval:=1000;FTimer.OnTimer:=LongPressed;ifAOwnerisTCustomFormthenSetForm(TCustomForm(AOwner));end;destructorTLongPressTracker.Destroy;beginifFTimer.EnabledthenbeginFTimer.Enabled:=False;TControlAccess(FChild).OnMouseUp:=FOldChildOnMouseUp;end;DetachForm;inheritedDestroy;end;procedureTLongPressTracker.DetachForm;beginifFForm<>nilthenbeginifFForm.HandleAllocatedthenSetWindowLong(FForm.Handle,GWL_WNDPROC,Integer(FOldFormWndProc));FForm:=nil;end;end;functionTLongPressTracker.GetDuration:Cardinal;beginResult:=FTimer.Interval;end;procedureTLongPressTracker.LongPressed(Sender:TObject);beginFTimer.Enabled:=False;if(Abs(FClickPos.X-Mouse.CursorPos.X)<Mouse.DragThreshold)and(Abs(FClickPos.Y-Mouse.CursorPos.Y)<Mouse.DragThreshold)and(((FChildisTWinControl)andTWinControl(FChild).Focused)or(TControlAccess(FChild).MouseCaptureor(notFChild.Enabled)))thenbeginFForm.ActiveControl:=FPrevActiveControl;ifAssigned(FOnLongPress)thenFOnLongPress(FChild);end;TControlAccess(FChild).OnMouseUp:=FOldChildOnMouseUp;end;procedureTLongPressTracker.NewChildMouseUp(Sender:TObject;Button:TMouseButton;Shift:TShiftState;X,Y:Integer);beginFTimer.Enabled:=False;ifAssigned(FOldChildOnMouseUp)thenFOldChildOnMouseUp(Sender,Button,Shift,X,Y);TControlAccess(FChild).OnMouseUp:=FOldChildOnMouseUp;end;procedureTLongPressTracker.NewFormWndProc(varMessage:TMessage);begincaseMessage.MsgofWM_PARENTNOTIFY:ifTWMParentNotify(Message).Event=WM_LBUTTONDOWNthenStartTracking;WM_LBUTTONDOWN:StartTracking;end;withMessagedoResult:=CallWindowProc(FOldFormWndProc,FForm.Handle,Msg,WParam,LParam);end;procedureTLongPressTracker.Notification(AComponent:TComponent;Operation:TOperation);begininheritedNotification(AComponent,Operation);if(AComponent=FForm)and(Operation=opRemove)thenDetachForm;if(AComponent=FChild)and(Operation=opRemove)thenbeginFTimer.Enabled:=False;FChild:=nil;end;end;procedureTLongPressTracker.SetDuration(Value:Cardinal);beginFTimer.Interval:=Value;end;procedureTLongPressTracker.SetForm(Value:TCustomForm);beginifFForm<>ValuethenbeginDetachForm;FForm:=Value;FForm.FreeNotification(Self);AttachForm;end;end;procedureTLongPressTracker.StartTracking;beginFClickPos:=Mouse.CursorPos;FChild:=FindControlAtPos(FForm,FClickPos);FChild.FreeNotification(Self);FPrevActiveControl:=FForm.ActiveControl;FOldChildOnMouseUp:=TControlAccess(FChild).OnMouseUp;TControlAccess(FChild).OnMouseUp:=NewChildMouseUp;FTimer.Enabled:=True;end;end.调用范例：unitUnit12;interfaceusesWinapi.Windows,Winapi.Messages,System.SysUtils,System.Variants,System.Classes,Vcl.Graphics,Vcl.Controls,Vcl.Forms,Vcl.Dialogs,Vcl.StdCtrls;typeTForm12=class(TForm)Button1:TButton;Memo1:TMemo;Label1:TLabel;Button2:TButton;procedureFormCreate(Sender:TObject);private{Privatedeclarations}publicprocedureLongPress(Control:TControl);{Publicdeclarations}end;varForm12:TForm12;implementation{$R*.dfm}usesLongPressEvent;{TForm12}procedureTForm12.FormCreate(Sender:TObject);beginwithTLongPressTracker.Create(Self)doOnLongPress:=LongPress;end;procedureTForm12.LongPress(Control:TControl);beginCaption:='Longpressoccurredon:'+Control.ClassName;end;end.",2014/12/31
458,ActiveX控件打包cab时INF文件的编写,陈军志,http://180.168.156.212:2262/wecenter/?/article/8835,"在我们编写好ocx控件后只有在打包成CAB文件加入数字签名后才能正常发布，如果你用的是vc6，那么问题简单了，打包完成后不用考虑控件的运行库问题，现在的XP系统和将要淘汰的2kpro都已经有了这样的运行库。但是如果使用的是.net2005就会遇到有关运行库的问题，这些问题只能依靠CAB压缩包中的安装文件.inf来解决。首先看看基本的inf文件格式[version];区域设置signature=""$CHICAGO$""AdvancedINF=2.0[Add.Code];该项会指明该安装包中有哪些项，这里说明包中有ActiveX.ocx、msvcr80.dll、mfc80u.dll、msvcp80.dll四个项;这里一般会使用文件名和项名相同的方法，主要是便于维护ActiveX.ocx=ActiveX.ocxmsvcr80.dll=msvcr80.dllmfc80u.dll=mfc80u.dllmsvcp80.dll=msvcp80.dll[ActiveX.ocx];这就是Activex控件文件了file-win32-x86=thiscab;表示所需要的这个文件就在当前的安装包中，file-win32-x86表示该文件是一个win32系统下的文件clsid={A3B4C60F-24A7-40E8-A06B-1A5EFE5F0A43};这里是这个安装包的GUID这个值是在创建项目的时候系统生成在，一般存放在以项目名命名的idl文件中，使用项目的类信息的GUIDRegisterServer=yes;说明这个控件是需要注册的，;一般情况下只有编写的文件是需要注册的，运行库文件和系统中可能存在的DLL文件是不用注册的,如MFC70.dll等FileVersion=1,0,0,1;这个文件的版本，注意要用逗号隔开[msvcr80.dll];这是ocx控件的第一个依赖文件，有的地方说明依赖文件必须按照依赖顺序安装，可以用""所剩dll都依赖的文件最先安装”的规则来进行，但是我并没有在MSDN上看到什么地方有很明确的说明，并且在我自己的测试中也没有发现有关顺序的问题，并且很多地方都是将ocx控件写在最前面的，但是ocx文件是最依赖其他文件的，貌似按顺序写的做法有点“迷信”FileVersion=8,00,50727,42;这里是该dll文件的版本，这里注意下，这个版本可以在文件属性的版本选项卡中看到，不知道为什么这里显示的版本号有时会比最外面显示的版本号多一个0，注意，复制到inf文件后要将点分隔符改成逗号分隔符hook=mfc80installer;这个hook是个保留字，说明该项目被挂接到哪里，如果有则表示被挂接到目标项，hook不是一个必填项，这里表示该文件将被挂接到mfc80installer项[mfc80u.dll]FileVersion=8,00,50727,42hook=mfc80installer[msvcp80.dll]FileVersion=8,00,50727,42hook=mfc80installer;上面两项都跟[msvcr80.dll]一样，这里就不解释了[mfc80installer];挂接项file-win32-x86= /controls/vc/mfc42.cab上面的“VALUE=”是没有必要的，如果增加了该内容反而会让安装包无法下载。有了在依赖文件dll的项中有了挂接的hook的值后安装文件会到hook的位置去找需要下载安装的文件，这里我将/MicrosoftVisualStudio8/SDK/v2.0/BootStrapper/Packages/vcredist_x86/vcredist_x86.exe文件做成一个cab文件MFC80.cab，这个包里面只有一个vcredist_x86.exe文件，没有其他文件。按照上面的方法打包好mfc8的运行库并使用hook的方式将Dll和运行库文件挂接后就可以了。以上内容在没有安装任何软件的XP和2kpro上测都通过了，顺便说下，Activex控件，只要在控件测试的那个工具中跑成了就是好的，如果目标机器上出不来就是环境问题，inf是解决环境问题的唯一途径。",2014/12/31
459,delphi中获取控制台程序的输出结果,陈军志,http://180.168.156.212:2262/wecenter/?/article/8834,"前几日遇到的问题在各位的帮助下已经圆满解决，现在吧这段代码写出来，可能会有一点用处。procedureCheckResult(b:Boolean);beginifnotbthenRaiseException.Create(SysErrorMessage(GetLastError));end;functionRunDOS(constProg,CommandLine,Dir:String;varExitCode:DWORD):String;varHRead,HWrite:THandle;StartInfo:TStartupInfo;ProceInfo:TProcessInformation;b:Boolean;sa:TSecurityAttributes;inS:THandleStream;sRet:TStrings;beginResult:=;FillChar(sa,sizeof(sa),0);//设置允许继承，否则在NT和2000下无法取得输出结果sa.nLength:=sizeof(sa);sa.bInheritHandle:=True;sa.lpSecurityDescriptor:=nil;b:=CreatePipe(HRead,HWrite,@sa,0);CheckResult(b);FillChar(StartInfo,SizeOf(StartInfo),0);StartInfo.cb:=SizeOf(StartInfo);StartInfo.wShowWindow:=SW_HIDE;//使用指定的句柄作为标准输入输出的文件句柄,使用指定的显示方式StartInfo.dwFlags:=STARTF_USESTDHANDLES+STARTF_USESHOWWINDOW;StartInfo.hStdError:=HWrite;StartInfo.hStdInput:=GetStdHandle(STD_INPUT_HANDLE);//HRead;StartInfo.hStdOutput:=HWrite;b:=CreateProcess(PChar(Prog),//lpApplicationName:PCharPChar(CommandLine),//lpCommandLine:PCharnil,//lpProcessAttributes:PSecurityAttributesnil,//lpThreadAttributes:PSecurityAttributesTrue,//bInheritHandles:BOOLCREATE_NEW_CONSOLE,nil,PChar(Dir),StartInfo,ProceInfo);CheckResult(b);WaitForSingleObject(ProceInfo.hProcess,INFINITE);GetExitCodeProcess(ProceInfo.hProcess,ExitCode);inS:=THandleStream.Create(HRead);ifinS.Size>0thenbeginsRet:=TStringList.Create;sRet.LoadFromStream(inS);Result:=sRet.Text;sRet.Free;end;inS.Free;CloseHandle(HRead);CloseHandle(HWrite);end;",2014/12/31
460,Delphi制作水印效果图片[GDI+],陈军志,http://180.168.156.212:2262/wecenter/?/article/8833,"如何利用GDI+可以很方便的制作带水印效果的图片，源代码代码如下：unitMain;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,Gdiplus,StdCtrls;typeTMainForm=class(TForm)Button1:TButton;procedureFormPaint(Sender:TObject);procedureFormCreate(Sender:TObject);procedureFormDestroy(Sender:TObject);procedureButton1Click(Sender:TObject);private{Privatedeclarations}Photo:TGpImage;PhWidth:Integer;PhHeight:Integer;Watermark:TGpImage;WmWidth:Integer;WmHeight:Integer;Bmp:TGpBitmap;public{Publicdeclarations}end;varMainForm:TMainForm;implementationusesGdipTypes;{$R*.dfm}procedureTMainForm.Button1Click(Sender:TObject);varClsid:TGUID;Parameters:TEncoderParameters;Quality:Integer;begin//设置图像品质编码参数Parameters.Count:=1;Parameters.Parameter[0].Guid:=EncoderQuality;Parameters.Parameter[0].ValueType:=EncoderParameterValueTypeLong;Parameters.Parameter[0].NumberOfValues:=1;//设置参数的值：品质等级，最高为100，图像文件大小与品质成正比Quality:=100;Parameters.Parameter[0].Value:=@Quality;ifGetEncoderClsid('image/jpeg',Clsid)thenBmp.Save('WatermarkPhoto.jpg',Clsid,@Parameters);end;procedureTMainForm.FormCreate(Sender:TObject);constColorMatrix:TColorMatrix=((1.0,0.0,0.0,0.0,0.0),(0.0,1.0,0.0,0.0,0.0),(0.0,0.0,1.0,0.0,0.0),(0.0,0.0,0.0,0.3,0.0),(0.0,0.0,0.0,0.0,1.0));WorkingDirectory='....Media';copyright='Copyright?2008-Maozefa';vargp:TGpGraphics;imageAttr:TGpImageAttributes;strFormat:TGpStringFormat;font:TGpFont;x,y:Single;begin//读取原始图片Photo:=TGpImage.Create(WorkingDirectory+'100_0349.jpg');PhWidth:=Photo.Width;PhHeight:=Photo.Height;//读取水印图片Watermark:=TGpImage.Create(WorkingDirectory+'Watermark.bmp');WmWidth:=Watermark.Width;WmHeight:=Watermark.Height;//建立一个新的位图，分辨率为72Bmp:=TGpBitmap.Create(PhWidth,PhHeight,pf32bppArgb);Bmp.SetResolution(72,72);//建立新位图的画布，并设置图像显示质量和文本显示质量gp:=TGpGraphics.Create(Bmp);gp.SmoothingMode:=smAntiAlias;gp.TextRenderingHint:=thAntiAlias;//在画布上画原始图片gp.DrawImage(Photo,GpRect(0,0,PhWidth,PhHeight),0,0,PhWidth,PhHeight,utPixel);//建立图像显示辅助类imageAttr:=TGpImageAttributes.Create;//设置透明颜色为水印图片四角的底色，水印图显示为圆角图片imageAttr.SetColorKey($ff00ff00,$ff00ff00,ctBitmap);//设置水印图片不透明度为0.3imageAttr.SetColorMatrix(ColorMatrix,cfDefault,ctBitmap);//在画布左上角画水印图gp.DrawImage(Watermark,GpRect({PhWidth-WmWidth-}10,10,WmWidth,WmHeight),0,0,WmWidth,WmHeight,utPixel,imageAttr);//设置文本字体和显示格式font:=TGpFont.Create('arial',16,[fsBold]);strFormat:=TGpStringFormat.Create;strFormat.Alignment:=saCenter;//在画布下方居中显示阴影文本x:=PhWidth/2;y:=PhHeight-26;gp.DrawString(copyright,font,Brushs[$99000000],x+1,y+1,strFormat);gp.DrawString(copyright,font,Brushs[$99ffffff],x,y,strFormat);font.Free;strFormat.Free;imageAttr.Free;gp.Free;end;procedureTMainForm.FormDestroy(Sender:TObject);beginPhoto.Free;Watermark.Free;Bmp.Free;end;procedureTMainForm.FormPaint(Sender:TObject);varg:TGpGraphics;beging:=TGpGraphics.Create(Canvas.Handle);//显示原始图片g.DrawImage(Photo,0,0,PhWidth,PhHeight);//显示水印原始图片g.TranslateTransform(0,PhHeight+5);g.DrawImage(Watermark,0,0,WmWidth,WmHeight);//显示带水印和文本的图像g.TranslateTransform(PhWidth,-(PhHeight+5));g.DrawImage(Bmp,0,0,PhWidth,PhHeight);g.Free;end;end.",2014/12/31
461,XE5开发Android程序调用电话相关功能(短信息和电话),孙传金,http://180.168.156.212:2262/wecenter/?/article/8832,"其实都可以通过intent和URI调用系统功能.Windows程序员可以理解成是ShellExecute.这个是万金油.可以有调用各种功能.后面会介绍.1.短信息.很简单方法a.不使用Intent而是直接发短信.smsManager对应的Delphi代码应该是:usesAndroidapi.JNI.JavaTypes,Androidapi.JNI.Telephony;varj:JSmsManager;beginj:=tjsmsmanager.Create;j.sendTextMessage(stringtojstring('137114553XX'),nil,stringtojstring('测试短信'),nil,nil);end;至于双卡双待用哪个卡来发送这些我没有详细研究,有兴趣的朋友可以研究下.方法b.使用Intent启动系统的短信程序:我猜以后这种方式会和电话一样会合并到TPlatformServices中.usesAndroidapi.JNI.GraphicsContentViewText,FMX.Helpers.Android,Androidapi.JNI.Netvaruri:Jnet_Uri;Intent:JIntent;beginuri:=StrToJURI('smsto:137114553XX');Intent:=TJIntent.JavaClass.init(TJIntent.JavaClass.ACTION_SENDTO,uri);Intent.putExtra(StringToJString('sms_body'),StringToJString('测试短信'));SharedActivityContext.startActivity(Intent);end;2.电话usesFMX.Platform,FMX.PhoneDialer;varphone:IFMXPhoneDialerService;beginifTPlatformServices.Current.SupportsPlatformService(IFMXPhoneDialerService,IInterface(phone))thenbeginphone.Call('137114553XX');//监听电话请用phone.OnCallStateChanged事件end;end;这段代码适用于iOS和Android.Android平台上实际上电话的封装就是系统的Intent方式调用.扩展说一下,怎么使用Intent和Action.简单封装了一个函数.可以使用Intent调用各种系统程序.大家理解成Windows的ShellExecute即可.usesAndroidapi.JNI.GraphicsContentViewText,FMX.Helpers.Android,Androidapi.JNI.Net;//XE6的话要引用Androidapi.Helpers单元procedureCall_URI(constAAction:JString;constAURI:string);varuri:Jnet_Uri;Intent:JIntent;beginuri:=StrToJURI(AURI);Intent:=TJIntent.JavaClass.init(AAction,uri);{Intent.putExtra()如果是要发短信等复杂的应用,需要传递各种其他的参数.要用到Intent.putExtra()传递多个参数.这里只封装最简单的,具体Intent.putExtra()的用法,可以查询Java的资料.大把的}SharedActivityContext.startActivity(Intent);end;//使用例子://打电话Call_URI(TJIntent.JavaClass.ACTION_CALL,'tel:137114553XX');//打开地图显示某个坐标点Call_URI(TJIntent.JavaClass.ACTION_VIEW,'geo:38.899533,-77.036476');//发送电子邮件Call_URI(TJIntent.JavaClass.ACTION_SENDTO,'mailto:wr960204@126.com');//播放音乐Call_URI(TJIntent.JavaClass.ACTION_VIEW,'file:///sdcard/download/最炫民族风.mp3');最后别忘了配置权限.Android程序是需要权限的.另外补充一点,做Android开发最好还是有点java开发经验,这样对Android的体系可以有一个比较具体的了解,最起码知道调用的概念.其他平台同理.先了解多各个平台的概念,然后用XE5开发.XE5解决的是实际工作的时候为了一套代码多个平台使用.",2014/12/31
462,Delphi Android循环移位操作,孙传金,http://180.168.156.212:2262/wecenter/?/article/8831,"移位操作在X86计算机上很简单,直接内嵌汇编ror和rol指令就是循环移位.但是如果在Android的平台上,asm关键字是无效的.实现代码如下：functionror(constValue:DWORD;ShiftValue:Byte):DWORD;overload;beginResult:=(Valueshl(8*SizeOf(Value)–ShiftValue))or(ValueShrShiftValue);end;functionror(constValue:WORD;ShiftValue:Byte):DWORD;overload;beginResult:=(Valueshl(8*SizeOf(Value)–ShiftValue))or(ValueShrShiftValue);end;functionror(constValue:Byte;ShiftValue:Byte):DWORD;overload;beginResult:=(Valueshl(8*SizeOf(Value)–ShiftValue))or(ValueShrShiftValue);end;functionrol(constValue:DWORD;ShiftValue:Byte):DWORD;overload;beginResult:=(Valueshr(8*SizeOf(Value)–ShiftValue))or(ValueShlShiftValue);end;functionrol(constValue:WORD;ShiftValue:Byte):DWORD;overload;beginResult:=(Valueshr(8*SizeOf(Value)–ShiftValue))or(ValueShlShiftValue);end;functionrol(constValue:Byte;ShiftValue:Byte):DWORD;overload;beginResult:=(Valueshr(8*SizeOf(Value)–ShiftValue))or(ValueShlShiftValue);end;举例子:a:=ror(DWORD(1),1);注意第一个参数因为给的是常量1,如果不指明类型会按最小的来,也就是会被当成Byte的.如果是C++用模板不必重载写两个函数就够了.而象Delphi/C#/Java的泛型没法做到这个.因为C++的泛型是编译时替换的,完全没有类型信息.而后三种语言首先你要把T做移位就会编译不过.",2014/12/31
463,Delphi XE7结构体的扩展【自动初始化、反初始化、自定义拷贝函数】,孙传金,http://180.168.156.212:2262/wecenter/?/article/8830,"Delphi的record和c++的struct是有区别的.C++的struct可以看成是class的别名,可以有构造,析构,可以继承.Delphi的record几年前开始支持方法,支持操作符重载,美中不足之处在于不能自己写默认构造函数.Delphi的帮助文档说可以自己写有参数的constructor但是不能写不带参数的constructor/destructor.但是实际上除非是有引用类型变量,否则结构体不会被初始化.这就产生了一些问题,比如说要借助record的操作符重载,重载+,:=等操作符,自己实现一个stringrecord.但是这个record每次声明以后必须要手动初始化一下,否则里面的内容未被初始化,是随机值.TString=record</pre>len:Integer;//这个不会被自动初始化data:pchar;//这个不会被自动初始化classoperatorAdd(a,b:TString):TString;end;实现了一个结构体的初始化,反初始化,拷贝的自动调用单元.只要你的结构体引用了AutoRecord这个类型的变量,那么结构体就可以自动调用初始化,反初始化,拷贝.比如:TTest=record_:AutoRecord;procedureOperator_Initialize();//初始化procedureOperaor_Finalize();//反初始化procedureOperator_Assign(constsource:TTest);overload;//拷贝:=procedureOperator_Assign(constsource:TTest;defaultAssign:TDefaultAssign(*调用默认赋值的函数*));overload;//拷贝:=end;这样TTest在使用的时候就会自动调用varTest:TTest;TestArray:array[0..1]ofTTest;begin//Test.Operator_Initialize();TestArray[0].Operator_Initialize();TestArray[1].Operator_Initialize();........Test:=TestArray[0];//test.Operator_Assign(TestArray[0]);end;//Test.Operator_Finalize();TestArray[0].Operator_Finalize();TestArray[1].Operator_Finalize();注释中是自动被调用的代码.好玩吧.有了这几个功能,智能指针也可以做出来.不过还有几个限制,是受Delphi编译器的限制.没法实现.1.不能是全局变量.全局变量是编译器负责初始化的.数据直接写在PE文件的数据段.2.不能是类的成员变量.Delphi的TObject.InitInstance只是简单地FillChar(Instance^,InstanceSize,0);而不再理会里面的成员.3.不能是该类型的动态数组,动态数组的初始化也就仅仅是FillChar为0总之,编译器不支持的话就要受上面的限制,就当给大家玩玩.usesAutoRecords;typeTTest=record_:AutoRecord;i,j,k:Integer;len:Integer;P:PByte;procedureOperator_Initialize();//初始化procedureOperaor_Finalize();//反初始化procedureOperator_Assign(constsource:TTest);overload;//拷贝:=end;{TTest}procedureTTest.Operaor_Finalize;beginFreeMem(P);end;procedureTTest.Operator_Assign(constsource:TTest);beginMove(source.P^,P^,len);i:=source.i+100;j:=source.j*5;k:=source.k;end;procedureTTest.Operator_Initialize;begini:=0;j:=1;k:=2;len:=100;GetMem(P,len);end;procedureTForm5.Button1Click(Sender:TObject);vara:array[0..1]ofTTest;begin//会调用TTest.Operator_Initialize两次a[0]:=a[1];//会调用Operator_Assignend;//会调用TTest.Operaor_Finalize两次",2014/12/31
464,iphoen6界面适配-----UI设计人员也可以关注一下,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8829,from: treelessing2014.10.29关于iPhone6/6+适配问题一直有争议，今天小编专门为大家整理了相关的有效方案，希望对大伙儿有帮助！移动app开发中多种设备尺寸适配问题，过去只属于Android阵营的头疼事儿，只是很多设计师选择性地忽视android适配问题，只出一套iOS平台设计稿。随着苹果发布两种新尺寸的大屏iPhone6，iOS平台尺寸适配问题终于还是来了，移动设计全面进入“杂屏”时代。看看下面三款iPhone尺寸和分辨率数据就知道屏幕有多杂了。加上Android生态中纷繁复杂的各种奇葩尺寸，现在APP设计开发必须考虑适配大、中、小三种屏幕。所以如何做到交付一套设计稿解决适配大中小三屏的问题？设计和开发之间采用什么协作模式？一个基本思路是：1、选择一种尺寸作为设计和开发基准；2、定义一套适配规则，自动适配剩下两种尺寸；3、特殊适配效果给出设计效果。手机淘宝的iPhone6/iPhone6Plus适配版本即将提交Appstore审核。先晒一下我们采用的协作模式，再慢慢说明原委。第一步，视觉设计阶段，设计师按宽度750px（iPhone6）做设计稿，除图片外所有设计元素用矢量路径来做。设计定稿后在750px的设计稿上做标注，输出标注图。同时等比放大1.5倍生成宽度1125px的设计稿，在1125px的稿子里切图。第二步，输出两个交付物给开发工程师：一个是程序用到的@3x切图资源，另一个是宽度750px的设计标注图。第三步，开发工程师拿到750px标注图和@3x切图资源，完成iPhone6（375pt）的界面开发。此阶段不能用固定宽度的方式开发界面，得用自动布局（autolayout），方便后续适配到其它尺寸。第四步，适配调试阶段，基于iPhone6的界面效果，分别向上向下调试iPhone6plus（414pt）和iPhone5S及以下（320pt）的界面效果。由此完成大中小三屏适配。为什么选择iPhone6作为基准尺寸？当面对大中小三种屏幕需要适配的时候，很容易想到先做好一种屏幕，再去适配剩下两种屏幕。第一个决定是到底以哪种屏幕作为设计和开发的基准尺寸。我们选择中间尺寸的iPhone6（750px/375pt）作为基准，基于几个原因：1、从中间尺寸向上和向下适配的时候界面调整的幅度最小。375pt下的设计效果适配到414pt和320pt偏差不会太大。假设以414pt为基准做出很优雅的设计，到320pt可能元素之间比例就不是那么回事了，比如图片和文字之间视觉比例可能失调。2、iPhone6plus有两种显示模式，标准模式分辨率为1242×2208，放大模式分辨率为1125×2001（即iPhone6的1.5倍）。可见官方系统里iPhone6和iPhone6plus分辨率之间就存在1.5倍的倍率关系。很多情况下这两种尺寸可以用1.5倍直接等比适配。3、1242×2208这个奇葩的数值是苹果官方都不愿意公开宣传的一个分辨率，不便于记忆和计算栅格。640×1136虽然是广泛应用的一个分辨率，但是大屏时代依然以小尺寸为设计基准显然不合时宜，设计师会停留在小屏的视角做设计。所以，iPhone6的750×1334是最适合基准尺寸。只交付一套设计稿，默认用什么规则来适配？前文提到适配策略是先选择iPhone6作为基准设计尺寸，然后通过一套适配规则自动适配到另外两种尺寸。这套适配规则总结起来就一句话：文字流式，控件弹性，图片等比缩放。控件弹性指的是，navigation、cell、bar等适配过程中垂直方向上高度不变；水平方向宽度变化时，通过调整元素间距或元素右对齐的方式实现自适应。这样屏幕越大，在垂直方向上可以显示更多内容，发挥大屏幕的优势。按照上述默认适配规则，大中小三种屏幕显示效果均相同。有时候想在大屏幕显示更多内容，需要设计出特殊适配效果。比如Appstore首页焦点图，从iPhone6适配到iPhone6plus时焦点图尺寸和排版做了特殊处理。底下应用列表也从一排3+个变成一排4+个，真正实现了大屏幕显示更多内容的理念。这些就需要设计师给出相应设计稿。刘典，架构师：使用AutoLayout，只需要一个xib文件都可以应对所有尺寸的iPhone从iPhone6开始iOS的UI设计方式更像web而不是app，不同尺寸的iPhone上UI的结构是一样的，各UIView的位置尺寸会有所不同。比如同样的一段文本，iPhone5S上要显示5行，iPhone6Plus上可能只要三行，显示它们的UITextView的尺寸就会不同。苹果从iOS6开始提供了AutoLayout，（AutoLayoutGuide:Introduction），他的作用类似web中的CSS，可以用排版语言对UIView进行布局，我们只要表达出UIView应该靠左、靠右、居中、边距多少等信息，AutoLayout根据设备尺寸自动计算各UIView的frame。以前UI设计喜欢用绝对定位，因为iPhone6之前所有iPhone的宽度都是320points（注意，不是pixels），从iPhone6开始将有不同的尺寸（所以叫ResizeableiPhone），如果用绝对定位就需要针对每种设备做调整，设计师会骂娘的。还有就是app的LaunchImage，因为设备尺寸增多，再结合横屏竖屏，导致的结果是一个app要有n多个LaunchImage，iOS8开始提供了LaunchScreen的概念，现在可以用一个xib文件来作为LaunchScreen，然后用InterfaceBuilder对LaunchScreen进行设计，因为可以使用AutoLayout，所以我们只需要一个xib文件都可以应对所有尺寸的iPhone。以前一直觉得iOS的UI开发不如Android，通过手工计算frame位置来布局简直是石器时代的做法，现在iPhone虽然尺寸变多了，不过因为有了成熟的AutoLayout，UI的设计和开发变的反而比以前更容易。陈伟，设计师：最好用Sketch，输出1倍矢量图（pdf）程序完美适配1.换工具，最好用Sketch，其次推荐AI。放弃Photoshop吧，对矢量支持的太无力2.只用输出一倍的矢量图（PDF）就可以了我们再也不需要计算了，丧心病狂的苹果已经开始支持矢量图了，我们只需要给工程师输出一倍的矢量图就可以了，目前仅发现支持PDF格式。刚才已经和我们的工程师调试成功了，在iPhone6plus模拟器上的对比效果：矢量图支持的非常完美。刘炜，DineHQ.com：Photoshop支持用矢量（而且应该只用矢量）元素设计界面，只是无法输出矢量资源（可以通过脚本用AI输出SVG，但相对不那么方便）。陈伟答案中对Photoshop的看法有些误导。Photoshop支持用矢量（而且应该只用矢量）元素设计界面，只是无法输出矢量资源（可以通过脚本用AI输出SVG，但相对不那么方便）。最新的Photoshop是有跟Sketch一样的输出切图功能的（Generator），用2x的PSD输出3x的切图也可以。而且Photoshop配合Slicy输出切图比Sketch3快捷很多。Sketch相当棒，但目前（v3.1）还是有不少小问题，加上对中文支持不够好，在界面设计中还不能完全取代Photoshop。关于题目的问题，首先一份设计稿就不能适用于iOS各手机屏幕尺寸。以下是Bjango把目前各iOS手机屏幕还原为1x的对比图，可见在设计稿中四种屏幕尺寸宽高都不一样，不是简单地把iPhone5界面缩放一下就变成iPhone6的设计稿了。如何支持多个尺寸屏幕，这个要分情况讨论。对于常规界面我们可以偷个懒，只做iPhone5屏幕尺寸的设计稿，请开发在其它屏幕上自适应，最终检查实机效果没问题就行。苹果官网上屏幕对比页面里用到的都是常规界面：对于一些定制的界面我们应该根据不同屏幕重新适配，比如下面是个简单的profile页面示例，自动适配到大屏幕的效果挺糟糕的。此时设计师应该手动为大屏幕重新调整设计，像下图一样。在上图中可看出iPhone6Plus界面中部分切图尺寸比3x更大，要单独切图，所以不是说简单地给iPhone6Plus统一切3x图就OK的了。这时矢量切图在开发中优势很明显，只要把大屏幕中切图的尺寸告诉开发即可，无需针对非3x元素额外输出切图。*手机屏幕毕竟还是像素位图，像细线图标即使是矢量的在缩放后仍可能会出现虚化模糊的现象（类似HTML里的iconfont），理论上并非所有情况都适合用矢量切图。但是，iPhone6Plus屏幕本身又是downscale的，导致原本pixelperfect的切图也会在缩放后发虚，完全没有pixelperfect而言，究竟是不是iPhone6Plus屏幕已经优化的看不出像素点了，要等看到实机才能确定。切图方面用Sketch的话可以尽量试试PDF矢量切图（但要在实机上确认效果）。Photoshop就只能输出位图了，上面提到定制界面里的一些切图得单独输出，其他常规的用2x的PSD输出1-3x切图即可。另外，与Photoshop和Sketch相比，AI不适合做界面设计。勇于尝试Sketch是好的，但若Sketch各种毛病忍不了的话建议还是用Photoshop好些。*关于AI不适合做界面设计的看法，其实作为功能强大的矢量设计工具，AI当然可以用来设计界面，只是没那么方便（我一位客户给我的设计稿还是InDesign设计的）。Sketch吸收了不少AI与Fireworks的优点，比AI好很多，用惯AI的朋友不妨试用一下。————————————————————————————————————————————————————————————————————————————最后小结：小编认为方法都是为了简化工作提高效率，没有标准答案，只有适合自己习惯的方法；用心比什么都重要，方法也会随之出现；设计师随着技术的发展慢慢也需要兼顾扩宽自己的技术面，比方上边说的前端知识；希望更多的小伙伴一起将设计领域的内容分享，让知识沉淀下来帮助更多的人。以上内容来源： /question/...eated,2014/12/31
465,转:SpringMVC简单教程,陆志超,http://180.168.156.212:2262/wecenter/?/article/8828,RTSpringMvc.docx,2014/12/31
466,delphio中间层MIDAS/DATASNAP剖析,孙传金,http://180.168.156.212:2262/wecenter/?/article/8827,"第一个问题：如何支持大量用户同时请求连接？系统结构：TClientDataSet->TSocketServer->scktsrvr.exe->RemoteDataModule->UNIDAC要求：允许多个个客户端同时“请求”连接，服务器和客户端均不能死掉。现状：在现有的程序中，只要同时“请求”连接的客户端达到一个较大的数量，例如80或100，应用服务器就停止响应了。客户端尝试连接时，不但无法建立连接，甚至都无法获得一个“返回错误”，而是跟着一起停止响应。期望：能够允许500-1000个客户端同时发出连接请求、尝试连接。当然，可以限制并发工作数，哪怕限制到很小的数量；但是，超出这个数量的客户端在执行TSocketConnection.Open时，必须能立刻收到一个“连接数已满，拒绝连接”的返回信息；或者进入一个等待队列，重试指定次数或者重试指定时间；或者，哪怕仅仅抛出个异常。但不允许停止响应，不允许无声无息地死掉。第二个问题：基于Midas/Socket/Scktsrvr的三层程序，如何在连接环节限制连接数？架构：TSocketConnection->scktsrvr.exe->RemoteDataModule现状：大量客户端（如200个）同时发起连接请求，中间层或scktsrvr明明无法处理这么多的连接，却又不推辞，最终导致客户端、中间层和scktsrvr都死掉。期望：让scktsrvr限制Socket的数量，超过限度（如20个）之后的客户端可以向scktsrvr发出连接请求，但scktsrvr不分配给Socket，拒绝连接；客户端超时之后，弹出对话框提示用户。网上关于中间层的提问看似千奇百怪，其实集中起来，无非就是上面的俩个大问题（虽然上面的提问都是针对MIDAS的，但同样适合于ATASNAP）：1。让中间层支持大量并发而不会死掉；2.控制最大的连接数量，防止服务器因硬件资源被耗完而死掉。其实这俩个问题也可以说是等同一个问题。这俩个问题可以解决吗？答案是能。首先描述一下许多同仁写中间层的方法：1.中间层线程服务方式选择“SESSION”，这也是MIDAS/DATASNAP默认的线程方式，大家往往跟着默认；2.在远程数据模块上放一些诸如数据库连接控件、数据集控件。。。。。。无可否定，这样写中间层是最容易，也是许多教科书中介绍的方式。但正因为这样才导致了上面的问题。因为这样的方式对服务器端的资源消耗是重量级的：当一个客户端连接上来，服务端对应开一个线程为其服务，直至客户端终止连接才关闭这个线程。为什么说是重量级的呢？当线程开启后，会创建远程数据模块，然后远程数据模块里面的一大堆数据集对象、数据连接对象都会被创建，如此多的对象在客户端的连接周期内一直存在，且只能为一个客户连接提供服务。因为服务器的资源消耗是重量级的，一旦客户连接数量稍微一多，服务器的硬件资源很可能马上就消耗完。此时如果又没有做最大连接数量上限的控制，就只能任由服务器因资源耗尽而当机。这就是这种方式写中间层的弊端。即这种方式决定了中间层能够支持的客户端并发数量是非常有限的，因为每一个客户端对服务端的资源占用都是重量级的：一是占用时间长（客户端只要还保持着连接，服务端资源就一直被占着），二是服务端要创建一大堆对象给每一个客户连接服务。如何解决？1.化重量级对象占用为轻量级占用；2.化长时间占用为实时占用。于是对象池呼之欲出，对象池中的对象们能够为所有的客户连接服务，再不是某些对象资源只能为某一个客户连接服务。最关键的是改变服务端的线程服务方式：不能用默认的""session""线程方式，要改成线程池的方式。对于操作系统来说，能够创建线程的数量总是有限的，比如WINDOWS大概能够创建2000个左右的空线程对象。改为了线程池的方式以后，线程数量再不是限制。改造成线程池这是第一步，然后改造数据库连接对象池，数据集对象池。。。。。。这样实现有什么好处？对象池中的对象只是实时被占用，这个占用只发生在一个客户的一个事件动作发生的那一瞬间，当这个事件一完成，对象即归还对象池中（只是归还池中，并没有释放对象）。对象避免了频繁地创建和释放，减少了许多对象创建所消耗的时间（对象的创建是比较耗时的，何况是如此众多的对象的创建，这要消耗多少时间）。减少了因对象频繁地创建和释放所产生的内存碎片（对象的每一次创建和释放都会产生微量的内存碎片，看似微不足道。但你想过没有：服务器是7*24运行的，且频繁地创建和释放的对象数量是如此众多，这会产生多么大的内存碎片啊。内存碎片一是会影响服务器的执行性能，二个可能使服务器当机）。如何控制最大的客户连接数量？设置服务端线程池的上限（PoolSize）吧，控制了线程池最大创建线程的数量，就控制了最大的客户连接数量。这个上限设置多少合适？具体要看那台服务器的硬件配置情况了。实际进行压力测试才可得知。",2014/12/31
467,storyboard中，用代码实现界面跳转,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8826,"第一种:给segue标记个Identifier再用代码触发,要点:segue开始的那边都连在View界面上,不上连上button上,要不点到就会跳转,如下:再用代码这样触发这个跳转的segue,如:[selfperformSegueWithIdentifier:@""SegueName""sender:self];第二种:能过取得storyboard文件里的viewController再用常规方法跳转,先设置storyboard里viewController的标志StoryboardID,再用代码这样跳转://UIStoryboard*board=[UIStoryboardstoryboardWithName:@""MainStoryboard""bundle:nil];UIViewController*next=[[selfstoryboard]instantiateViewControllerWithIdentifier:@""IconView""];[selfpresentModalViewController:nextanimated:NO];注解的代码等同于[selfstoryboard],不过[selfstoryboard]是官方写好的sdk,如果你的Storyboard文件名字修改过就用上面的代码自己加载.",2014/12/31
468,iOS开发-----ios7屏幕旋转支持,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8825,"//Forios6,usesupportedInterfaceOrientations&shouldAutorotateinsteadofshouldAutorotateToInterfaceOrientation-(NSUInteger)supportedInterfaceOrientations{returnUIInterfaceOrientationMaskLandscape;}-(BOOL)shouldAutorotate{returnYES;}iOS6需在加上上面方法在iOS5.1和之前的版本中，我们通常利用shouldAutorotateToInterfaceOrientation:来单独控制某个UIViewController的旋屏方向支持，也就是说各个ViewController各自独立管理自己的旋转方向，跟其他ViewController或NavigationController没有关系，比如：-(BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation{//interfaceOrientation表示当前设备旋转到的方向，返回YES则表示界面也旋转到这个方向，NO则不return(interfaceOrientation==UIInterfaceOrientationPortrait);}但是在iOS6中，这个方法被废弃了，使用无效在IOS6中的每个ViewController中代替使用：-(BOOL)shouldAutorotate{returnNO;//YES支持旋转到supportedInterfaceOrientations函数所指定的方向NO则完全不支持旋转始终保持正屏（UIInterfaceOrientationMaskPortrait）}-(NSUInteger)supportedInterfaceOrientations{returnUIInterfaceOrientationMaskPortrait;//当shouldAutorotate函数返回YES指定的值才起作用}这里有一个问题，当是用UINavigationController管理ViewController时，在各个viewController中制定的这两个函数必须要一样，不然会崩，于是一般自定义UINavigationController，然后在这里面重写这两个方法，这样之后，在每个具体ViewController中的指定就不会起作用，这样便于统一各个界面的旋转风格，但不适合有界面旋转风格不同的情况forios4and5,如果没有重写shouldAutorotateToInterfaceOrientation，那么对于iphone来讲，bydefault是只支持portrait，不能旋转。forios6,如果没有重写shouldAutorotateandsupportedInterfaceOrientations,bydefault,iphone则是""可以旋转，支持非upsidedown的方向""，而ipad是""可以选择，支持所有方向""",2014/12/31
469,数字证书基础知识演讲稿,樊志强,http://180.168.156.212:2262/wecenter/?/article/8824,数字证书基础知识演讲稿数字证书基础知识演讲稿.ppt,2014/12/31
470,Oracle数据定时备份,樊志强,http://180.168.156.212:2262/wecenter/?/article/8823,Oracle数据定时备份Oracle数据定时备份.rar,2014/12/31
471,iOS开发--app icon,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8822,Icon.png57X5710px用户AppStore以及iPhone/iPod中显示必需Icon@2x.png114X11420px高清模式Icon_120.png120X12020px用于iPhone5的高清显示Icon-Small.png29X2920px用于设置以及Spotlight搜索Icon-Small@2x.png58X588px用于Icon-Small.png的高清模式Icon_80.png80X808px用于iPhone5在Spotlight搜索APP图标 18215275,2014/12/31
472,Websphere的安装与配置及应用发布,樊志强,http://180.168.156.212:2262/wecenter/?/article/8821,Websphere的安装与配置及应用发布Websphere的安装与配置应用服务器环境的安装配套置与发布.doc,2014/12/31
473,setTimeout 和 setInterval,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8820,"由于JavaScript是异步的，可以使用setTimeout和setInterval来计划执行函数。注意:定时处理不是ECMAScript的标准，它们在DOM(文档对象模型)被实现。functionfoo(){}varid=setTimeout(foo,1000);//返回一个大于零的数字当setTimeout被调用时，它会返回一个ID标识并且计划在将来大约1000毫秒后调用foo函数。foo函数只会被执行一次。基于JavaScript引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞此线程。因此没法确保函数会在setTimeout指定的时刻被调用。作为第一个参数的函数将会在全局作用域中执行，因此函数内的this将会指向这个全局对象。functionFoo(){this.value=42;this.method=function(){//this指向全局对象console.log(this.value);//输出：undefined};setTimeout(this.method,500);}newFoo();注意:setTimeout的第一个参数是函数对象，一个常犯的错误是这样的setTimeout(foo(),1000)，这里回调函数是foo的返回值，而不是foo本身。大部分情况下，这是一个潜在的错误，因为如果函数返回undefined，setTimeout也不会报错。setInterval的堆调用setTimeout只会执行回调函数一次，不过setInterval-正如名字建议的-会每隔X毫秒执行函数一次。但是却不鼓励使用这个函数。当回调函数的执行被阻塞时，setInterval仍然会发布更多的回调指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。functionfoo(){//阻塞执行1秒}setInterval(foo,100);上面代码中，foo会执行一次随后被阻塞了一秒钟。在foo被阻塞的时候，setInterval仍然在组织将来对回调函数的调用。因此，当第一次foo函数调用结束时，已经有10次函数调用在等待执行。处理可能的阻塞调用最简单也是最容易控制的方案，是在回调函数内部使用setTimeout函数。functionfoo(){//阻塞执行1秒setTimeout(foo,100);}foo();这样不仅封装了setTimeout回调函数，而且阻止了调用指令的堆积，可以有更多的控制。foo函数现在可以控制是否继续执行还是终止执行。手工清空定时器可以通过将定时时产生的ID标识传递给clearTimeout或者clearInterval函数来清除定时，至于使用哪个函数取决于调用的时候使用的是setTimeout还是setInterval。varid=setTimeout(foo,1000);clearTimeout(id);清除所有定时器由于没有内置的清除所有定时器的方法，可以采用一种暴力的方式来达到这一目的。//清空""所有""的定时器for(vari=1;i<1000;i++){clearTimeout(i);}可能还有些定时器不会在上面代码中被清除（译者注：如果定时器调用时返回的ID值大于1000），因此我们可以事先保存所有的定时器ID，然后一把清除。隐藏使用evalsetTimeout和setInterval也接受第一个参数为字符串的情况。这个特性绝对不要使用，因为它在内部使用了eval。注意:由于定时器函数不是ECMAScript的标准，如何解析字符串参数在不同的JavaScript引擎实现中可能不同。事实上，微软的JScript会使用Function构造函数来代替eval的使用。functionfoo(){//将会被调用}functionbar(){functionfoo(){//不会被调用}setTimeout('foo()',1000);}bar();由于eval在这种情况下不是被直接调用，因此传递到setTimeout的字符串会自全局作用域中执行；因此，上面的回调函数使用的不是定义在bar作用域中的局部变量foo。建议不要在调用定时器函数时，为了向回调函数传递参数而使用字符串的形式。functionfoo(a,b,c){}//不要这样做setTimeout('foo(1,2,3)',1000)//可以使用匿名函数完成相同功能setTimeout(function(){foo(1,2,3);},1000)注意:虽然也可以使用这样的语法setTimeout(foo,1000,1,2,3)，但是不推荐这么做，因为在使用对象的属性方法时可能会出错。（译者注：这里说的是属性方法内，this的指向错误）结论绝对不要使用字符串作为setTimeout或者setInterval的第一个参数，这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个匿名函数，在函数内执行真实的回调函数。另外，应该避免使用setInterval，因为它的定时执行不会被JavaScript阻塞。",2014/12/31
474,网站管理系统设计,樊志强,http://180.168.156.212:2262/wecenter/?/article/8819,网站管理系统设计目录网站管理系统设计.doc,2014/12/31
475,参与公司CMMI5级认证时的改进专题报告,王链玮,http://180.168.156.212:2262/wecenter/?/article/8818,评审过程优化改进10-评审过程优化改进方案(第十稿).xls,2014/12/31
476,条形码打印接口,樊志强,http://180.168.156.212:2262/wecenter/?/article/8817,条码打印驱动、集成开发样例TSCLIB.DLL-JSP-Example.rartsc.rartsc-driver.rar,2014/12/31
477,PhoneGap技术概要,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8816,附件主要介绍了PhoneGap技术特点、PhoneGap插件、实现原理以及JS框架相关知识。PhoneGap开发成果展示.pptx,2014/12/31
478,删除Oracle数据库中重复数据,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8815,"在对数据库进行操作过程中我们可能会遇到这种情况，表中的数据可能重复出现，使我们对数据库的操作过程中带来很多的不便，那么怎么删除这些重复没有用的数据呢?重复数据删除技术可以提供更大的备份容量，实现更长时间的数据保留，还能实现备份数据的持续验证，提高数据恢复服务水平，方便实现数据容灾等。重复的数据可能有这样两种情况，第一种时表中只有某些字段一样，第二种是两行记录完全一样。Oracle数据库重复数据删除技术有如下优势：更大的备份容量、数据能得到持续验证、有更高的数据恢复服务水平、方便实现备份数据的容灾。一、删除部分字段重复数据先来谈谈如何查询重复的数据吧。下面语句可以查询出那些数据是重复的：select字段1,字段2,count(*)from表名groupby字段1,字段2havingcount(*)>1将上面的>号改为=号就可以查询出没有重复的数据了。想要删除这些重复的数据，可以使用下面语句进行删除deletefrom表名awhere字段1,字段2in(select字段1,字段2,count(*)from表名groupby字段1,字段2havingcount(*)>1)上面的语句非常简单，就是将查询到的数据删除掉。不过这种删除执行的效率非常低，对于大数据量来说，可能会将数据库吊死。所以我建议先将查询到的重复的数据插入到一个临时表中，然后对进行删除，这样，执行删除的时候就不用再进行一次查询了。如下：CREATETABLE临时表AS(select字段1,字段2,count(*)from表名groupby字段1,字段2havingcount(*)>1)上面这句话就是建立了临时表，并将查询到的数据插入其中。下面就可以进行这样的删除操作了：deletefrom表名awhere字段1,字段2in(select字段1，字段2from临时表);这种先建临时表再进行删除的操作要比直接用一条语句进行删除要高效得多。这个时候，大家可能会跳出来说，什么?你叫我们执行这种语句，那不是把所有重复的全都删除吗?而我们想保留重复数据中最新的一条记录啊!大家不要急，下面我就讲一下如何进行这种操作。在oracle中，有个隐藏了自动rowid，里面给每条记录一个唯一的rowid，我们如果想保留最新的一条记录，我们就可以利用这个字段，保留重复数据中rowid最大的一条记录就可以了。下面是查询重复数据的一个例子：下面我就来讲解一下，上面括号中的语句是查询出重复数据中rowid最大的一条记录。而外面就是查询出除了rowid最大之外的其他重复的数据了。由此，我们要删除重复数据，只保留最新的一条数据，就可以这样写了：随便说一下，上面语句的执行效率是很低的，可以考虑建立临时表，讲需要判断重复的字段、rowid插入临时表中，然后删除的时候在进行比较。二、完全删除重复记录对于表中两行记录完全一样的情况，可以用下面语句获取到去掉重复数据后的记录：selectdistinct*from表名可以将查询的记录放到临时表中，然后再将原来的表记录删除，最后将临时表的数据导回原来的表中。如下：如果想删除一个表的重复数据，可以先建一个临时表，将去掉重复数据后的数据导入到临时表，然后在从临时表将数据导入正式表中，如下：三、怎样快速删除oracle数据库最快的方法就进入注册表在运行..里输入regedit.依次展开HKEY_LOCAL_MACHINESOFTWARE找到ORACLE节点。删除。然后删除ORACLE数据文件，安装的时候选的路径。最后删除oracle引导文件，在系统盘符的ProgramFiles里面删除oracle文件夹。",2014/12/31
479,关于如何使用TClientDataSet内存数据集变化部分数据生成sql,孙传金,http://180.168.156.212:2262/wecenter/?/article/8814,"TClientDataSet内存数据集是delphi开发人员在开发数据库程序中使用相当广泛的一个数据库控件，对于在内存中对数据进行处理带来了极大的便利，但是在大多数情况下，及时在三层架构的框架之下，我们也希望提交数据库的操作能够通过sql的方式直接进行处理，为了减少网络的压力，我们通常希望对变动的部分数据库进行提交，那么现在就给大家介绍一下如何将变动的数据（Delta）部分的数据库进行处理，代码如下：procedureTBaseService.ApplyUpdates(constDelta:OleVariant;TableName,KeyField:WideString);varFlag:Boolean;beginifVarIsNull(Delta)thenexit;with(FParentasTDataServer2)dobegincdsDelta.Close;cdsDelta.Data:=Delta;Flag:=cdsDelta.FindField('SYS_STATUS')<>nil;end;//withifFlagthenInnerApplyUpdates2(TableName,KeyField)elseInnerApplyUpdates(TableName,KeyField);end;functionvartosql(value:Variant):wideString;vartmp:widestring;beginif(varisnull(Value))or(varisempty(Value))thenResult:='NULL'elsecaseVartype(value)ofvarDate:begintmp:=formatDatetime('yyyy-mm-ddhh:mm:ss',VartoDatetime(Value));Result:=Quotedstr(tmp);end;varString,varOlestr:Result:=Quotedstr(Trim(Vartostr(Value)));varboolean:beginifValuethenResult:='1'elseResult:='0';end;varSmallint,varInteger,varDouble,varShortInt,varInt64,varLongWord,varCurrency:beginResult:=trim(Vartostr(Value));end;elseResult:=Quotedstr(Trim(Vartostr(Value)));end;end;procedureTBaseService.InnerApplyUpdates(TableName,KeyField:WideString);vari:integer;s1,s2:string;CmdStr:string;FieldList:TStringList;beginwith(FParentasTDataServer2)dobeginFieldList:=TStringList.Create;Connection.GetFieldNames(TableName,FieldList);ifnotcdsDelta.ActivethencdsDelta.Open;fori:=1toFieldList.CountdoifcdsDelta.FindField(FieldList[i-1])<>nilthencdsDelta.FindField(FieldList[i-1]).Tag:=1;FieldList.Free;ifcdsDelta.RecordCount>0thenbegincdsDelta.First;s1:='';s2:='';whilenotcdsDelta.EofdobeginCmdStr:='';casecdsDelta.UpdateStatusofusUnmodified:begins2:=VarToSql(cdsDelta[KeyField]);end;usModified:begins1:='';fori:=1tocdsDelta.FieldCountdo//if(notcdsDelta.Fields[i-1].IsNull)and(cdsDelta.Fields[i-1].Tag=1)thenif(cdsDelta.Fields[i-1].NewValue<>System.Variants.Unassignedand(cdsDelta.Fields[i-1].Tag=1)thenbeginifs1=''thens1:=Trim(cdsDelta.Fields[i-1].FieldName)+'='+VarToSql(cdsDelta.Fields[i-1].Value)elses1:=s1+','+Trim(cdsDelta.Fields[i-1].FieldName)+'='+VarToSql(cdsDelta.Fields[i-1].Value);end;ifs1<>''thenbeginCmdStr:='Update'+TableName+'Set'+s1+'Where'+KeyField+'='+s2;end;end;usInserted:begins1:='';s2:='';fori:=1tocdsDelta.FieldCountdoif(notcdsDelta.Fields[i-1].IsNull)and(cdsDelta.Fields[i-1].Tag=1)thenbeginifs1=''thenbegins1:=Trim(cdsDelta.Fields[i-1].FieldName);s2:=VarToSql(cdsDelta.Fields[i-1].Value);endelsebegins1:=s1+','+Trim(cdsDelta.Fields[i-1].FieldName);s2:=s2+','+VarToSql(cdsDelta.Fields[i-1].Value);end;end;ifs1<>''thenbeginCmdStr:='Insertinto'+TableName+'('+s1+')Values('+s2+')';end;end;usDeleted:begins2:=VarToSql(cdsDelta[KeyField]);CmdStr:='Delete'+TableName+'Where'+KeyField+'='+s2;end;end;ifCmdStr<>''thenCmd.Execute(CmdStr);cdsDelta.Next;end;cdsDelta.First;cdsDelta.EmptyDataSet;cdsDelta.Close;end;end;end;",2014/12/31
480,undefined 和 null,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8813,"JavaScript有两个表示‘空’的值，其中比较有用的是undefined。undefined的值undefined是一个值为undefined的类型。这个语言也定义了一个全局变量，它的值是undefined，这个变量也被称为undefined。但是这个变量不是一个常量，也不是一个关键字。这意味着它的值可以轻易被覆盖。ES5提示:在ECMAScript5的严格模式下，undefined不再是可写的了。但是它的名称仍然可以被隐藏，比如定义一个函数名为undefined。下面的情况会返回undefined值：访问未修改的全局变量undefined。由于没有定义return表达式的函数隐式返回。return表达式没有显式的返回任何内容。访问不存在的属性。函数参数没有被显式的传递值。任何被设置为undefined值的变量。处理undefined值的改变由于全局变量undefined只是保存了undefined类型实际值的副本，因此对它赋新值不会改变类型undefined的值。然而，为了方便其它变量和undefined做比较，我们需要事先获取类型undefined的值。为了避免可能对undefined值的改变，一个常用的技巧是使用一个传递到匿名包装器的额外参数。在调用时，这个参数不会获取任何值。varundefined=123;(function(something,foo,undefined){//局部作用域里的undefined变量重新获得了`undefined`值})('HelloWorld',42);另外一种达到相同目的方法是在函数内使用变量声明。varundefined=123;(function(something,foo){varundefined;...})('HelloWorld',42);这里唯一的区别是，在压缩后并且函数内没有其它需要使用var声明变量的情况下，这个版本的代码会多出4个字节的代码。译者注：这里有点绕口，其实很简单。如果此函数内没有其它需要声明的变量，那么var总共4个字符（包含一个空白字符）就是专门为undefined变量准备的，相比上个例子多出了4个字节。null的用处JavaScript中的undefined的使用场景类似于其它语言中的null，实际上JavaScript中的null是另外一种数据类型。它在JavaScript内部有一些使用场景（比如声明原型链的终结Foo.prototype=null），但是大多数情况下都可以使用undefined来代替。",2014/12/31
481,身份鉴别措施,樊志强,http://180.168.156.212:2262/wecenter/?/article/8812,想要源码可联系我身份鉴别措施.docx,2014/12/31
482,Clustrmaps，以图形化的方式优雅的统计你的web访问量,王链玮,http://180.168.156.212:2262/wecenter/?/article/8811," ';varx=document.getElementsByTagName('script')[0];x.parentNode.insertBefore(s,x);})();</script><noscript><ahref="" .cn-thumb.jpg""alt=""Locationsofvisitorstothispage""/></a></noscript>",2014/12/31
483,JavaScript  为什么不要使用 eval,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8810,"eval函数会在当前作用域中执行一段JavaScript代码字符串。varfoo=1;functiontest(){varfoo=2;eval('foo=3');returnfoo;}test();//3foo;//1但是eval只在被直接调用并且调用函数就是eval本身时，才在当前作用域中执行。varfoo=1;functiontest(){varfoo=2;varbar=eval;bar('foo=3');returnfoo;}test();//2foo;//3译者注：上面的代码等价于在全局作用域中调用eval，和下面两种写法效果一样：//写法一：直接调用全局作用域下的foo变量varfoo=1;functiontest(){varfoo=2;window.foo=3;returnfoo;}test();//2foo;//3//写法二：使用call函数修改eval执行的上下文为全局作用域varfoo=1;functiontest(){varfoo=2;eval.call(window,'foo=3');returnfoo;}test();//2foo;//3在任何情况下我们都应该避免使用eval函数。99.9%使用eval的场景都有不使用eval的解决方案。伪装的eval定时函数setTimeout和setInterval都可以接受字符串作为它们的第一个参数。这个字符串总是在全局作用域中执行，因此eval在这种情况下没有被直接调用。安全问题eval也存在安全问题，因为它会执行任意传给它的代码，在代码字符串未知或者是来自一个不信任的源时，绝对不要使用eval函数。结论绝对不要使用eval，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。如果一些情况必须使用到eval才能正常工作，首先它的设计会受到质疑，这不应该是首选的解决方案，一个更好的不使用eval的解决方案应该得到充分考虑并优先采用。",2014/12/31
484,Oracle 数据泵详解,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8809,"一、EXPDP和IMPDP使用说明OracleDatabase10g引入了最新的数据泵(DataDump)技术，数据泵导出导入(EXPDP和IMPDP)的作用1）实现逻辑备份和逻辑恢复.2）在数据库用户之间移动对象.3）在数据库之间移动对象4）实现表空间搬移.二、数据泵导出导入与传统导出导入的区别在10g之前,传统的导出和导入分别使用EXP工具和IMP工具,从10g开始,不仅保留了原有的EXP和IMP工具,还提供了数据泵导出导入工具EXPDP和IMPDP.使用EXPDP和IMPDP时应该注意的事项：1）EXP和IMP是客户端工具程序,它们既可以在可以客户端使用,也可以在服务端使用。2）EXPDP和IMPDP是服务端的工具程序,他们只能在ORACLE服务端使用,不能在客户端使用。3）IMP只适用于EXP导出文件,不适用于EXPDP导出文件;IMPDP只适用于EXPDP导出文件,而不适用于EXP导出文件。数据泵导出包括导出表,导出方案,导出表空间,导出数据库4种方式.三、Expdp参数EXPDP命令行选项，可通过expdphelp=y查看：E:\emp>expdphelp=yExport:Release10.2.0.1.0-Productionon星期日,035月,200917:54:49Copyright(c)2003,2005,Oracle.Allrightsreserved.数据泵导出实用程序提供了一种用于在Oracle数据库之间传输数据对象的机制。该实用程序可以使用以下命令进行调用:示例:expdpscott/tigerDIRECTORY=dmpdirDUMPFILE=scott.dmp您可以控制导出的运行方式。具体方法是:在'expdp'命令后输入各种参数。要指定各参数,请使用关键字:格式:expdpKEYWORD=value或KEYWORD=(value1,value2,...,valueN)示例:expdpscott/tigerDUMPFILE=scott.dmpDIRECTORY=dmpdirSCHEMAS=scott或TABLES=(T1:P1,T1:P2),如果T1是分区表USERID必须是命令行中的第一个参数。关键字说明(默认)------------------------------------------------------------------------------ATTACH连接到现有作业,例如ATTACH[=作业名]。COMPRESSION减小有效的转储文件内容的大小关键字值为:(METADATA_ONLY)和NONE。CONTENT指定要卸载的数据,其中有效关键字为:(ALL),DATA_ONLY和METADATA_ONLY。DIRECTORY供转储文件和日志文件使用的目录对象。DUMPFILE目标转储文件(expdat.dmp)的列表,例如DUMPFILE=scott1.dmp,scott2.dmp,dmpdir:scott3.dmp。ENCRYPTION_PASSWORD用于创建加密列数据的口令关键字。ESTIMATE计算作业估计值,其中有效关键字为:(BLOCKS)和STATISTICS。ESTIMATE_ONLY在不执行导出的情况下计算作业估计值。EXCLUDE排除特定的对象类型,例如EXCLUDE=TABLE:EMP。FILESIZE以字节为单位指定每个转储文件的大小。FLASHBACK_SCN用于将会话快照设置回以前状态的SCN。FLASHBACK_TIME用于获取最接近指定时间的SCN的时间。FULL导出整个数据库(N)。HELP显示帮助消息(N)。INCLUDE包括特定的对象类型,例如INCLUDE=TABLE_DATA。JOB_NAME要创建的导出作业的名称。LOGFILE日志文件名(export.log)。NETWORK_LINK链接到源系统的远程数据库的名称。NOLOGFILE不写入日志文件(N)。PARALLEL更改当前作业的活动worker的数目。PARFILE指定参数文件。QUERY用于导出表的子集的谓词子句。SAMPLE要导出的数据的百分比;SCHEMAS要导出的方案的列表(登录方案)。STATUS在默认值(0)将显示可用时的新状态的情况下,要监视的频率(以秒计)作业状态。TABLES标识要导出的表的列表-只有一个方案。TABLESPACES标识要导出的表空间的列表。TRANSPORT_FULL_CHECK验证所有表的存储段(N)。TRANSPORT_TABLESPACES要从中卸载元数据的表空间的列表。VERSION要导出的对象的版本,其中有效关键字为:(COMPATIBLE),LATEST或任何有效的数据库版本。下列命令在交互模式下有效。注:允许使用缩写命令说明------------------------------------------------------------------------------ADD_FILE向转储文件集中添加转储文件。CONTINUE_CLIENT返回到记录模式。如果处于空闲状态,将重新启动作业。EXIT_CLIENT退出客户机会话并使作业处于运行状态。FILESIZE后续ADD_FILE命令的默认文件大小(字节)。HELP总结交互命令。KILL_JOB分离和删除作业。PARALLEL更改当前作业的活动worker的数目。PARALLEL=<worker的数目>。START_JOB启动/恢复当前作业。STATUS在默认值(0)将显示可用时的新状态的情况下,要监视的频率(以秒计)作业状态。STATUS[=interval]STOP_JOB顺序关闭执行的作业并退出客户机。STOP_JOB=IMMEDIATE将立即关闭数据泵作业。1）ATTACH该选项用于在客户会话与已存在导出作用之间建立关联.语法如下ATTACH=[schema_name.]job_nameSchema_name用于指定方案名,job_name用于指定导出作业名.注意,如果使用ATTACH选项在命令行除了连接字符串和ATTACH选项外,不能指定任何其他选项,示例如下:Expdpscott/tigerATTACH=scott.export_job2）CONTENT该选项用于指定要导出的内容.默认值为ALLCONTENT={ALL|DATA_ONLY|METADATA_ONLY}当设置CONTENT为ALL时,将导出对象定义及其所有数据.为DATA_ONLY时,只导出对象数据,为METADATA_ONLY时,只导出对象定义Expdpscott/tigerDIRECTORY=dumpDUMPFILE=a.dumpCONTENT=METADATA_ONLY3）DIRECTORY指定转储文件和日志文件所在的目录DIRECTORY=directory_objectDirectory_object用于指定目录对象名称.需要注意,目录对象是使用CREATEDIRECTORY语句建立的对象,而不是OS目录Expdpscott/tigerDIRECTORY=dumpDUMPFILE=a.dump建立目录:SQL>createdirectorydump_diras'd:\dump';目录已创建。SQL>grantread,writeondirectorydump_dirtoscott;授权成功。查询创建了那些子目录:SELECT*FROMdba_directories;4）DUMPFILE用于指定转储文件的名称,默认名称为expdat.dmpDUMPFILE=[directory_object:]file_name[,….]Directory_object用于指定目录对象名,file_name用于指定转储文件名.需要注意,如果不指定directory_object,导出工具会自动使用DIRECTORY选项指定的目录对象Expdpscott/tigerDIRECTORY=dump1DUMPFILE=dump2:a.dmp5.）ESTIMATE指定估算被导出表所占用磁盘空间分方法.默认值是BLOCKSEXTIMATE={BLOCKS|STATISTICS}设置为BLOCKS时,oracle会按照目标对象所占用的数据块个数乘以数据块尺寸估算对象占用的空间,设置为STATISTICS时,根据最近统计值估算对象占用空间Expdpscott/tigerTABLES=empESTIMATE=STATISTICSDIRECTORY=dumpDUMPFILE=a.dump6.）EXTIMATE_ONLY指定是否只估算导出作业所占用的磁盘空间,默认值为NEXTIMATE_ONLY={Y|N}设置为Y时,导出作用只估算对象所占用的磁盘空间,而不会执行导出作业,为N时,不仅估算对象所占用的磁盘空间,还会执行导出操作.Expdpscott/tigerESTIMATE_ONLY=yNOLOGFILE=y7.）EXCLUDE该选项用于指定执行操作时释放要排除对象类型或相关对象EXCLUDE=object_type[:name_clause][,….]Object_type用于指定要排除的对象类型,name_clause用于指定要排除的具体对象.EXCLUDE和INCLUDE不能同时使用Expdpscott/tigerDIRECTORY=dumpDUMPFILE=a.dupEXCLUDE=VIEW8）FILESIZE指定导出文件的最大尺寸,默认为0,(表示文件尺寸没有限制)9.FLASHBACK_SCN指定导出特定SCN时刻的表数据FLASHBACK_SCN=scn_valueScn_value用于标识SCN值.FLASHBACK_SCN和FLASHBACK_TIME不能同时使用Expdpscott/tigerDIRECTORY=dumpDUMPFILE=a.dmpFLASHBACK_SCN=35852310）FLASHBACK_TIME指定导出特定时间点的表数据FLASHBACK_TIME=”TO_TIMESTAMP(time_value)”Expdpscott/tigerDIRECTORY=dumpDUMPFILE=a.dmpFLASHBACK_TIME=“TO_TIMESTAMP(’25-08-200414:35:00’,’DD-MM-YYYYHH24:MI:SS’)”11）FULL指定数据库模式导出,默认为NFULL={Y|N}为Y时,标识执行数据库导出.12）HELP指定是否显示EXPDP命令行选项的帮助信息,默认为N当设置为Y时,会显示导出选项的帮助信息.Expdphelp=y13）INCLUDE指定导出时要包含的对象类型及相关对象INCLUDE=object_type[:name_clause][,…]14）JOB_NAME指定要导出作用的名称,默认为SYS_XXXJOB_NAME=jobname_string15）LOGFILE指定导出日志文件文件的名称,默认名称为export.logLOGFILE=[directory_object:]file_nameDirectory_object用于指定目录对象名称,file_name用于指定导出日志文件名.如果不指定directory_object.导出作用会自动使用DIRECTORY的相应选项值.Expdpscott/tigerDIRECTORY=dumpDUMPFILE=a.dmplogfile=a.log16）NETWORK_LINK指定数据库链名,如果要将远程数据库对象导出到本地例程的转储文件中,必须设置该选项.17）NOLOGFILE该选项用于指定禁止生成导出日志文件,默认值为N.18）PARALLEL指定执行导出操作的并行进程个数,默认值为119）PARFILE指定导出参数文件的名称PARFILE=[directory_path]file_name20）QUERY用于指定过滤导出数据的where条件QUERY=[schema.][table_name:]query_clauseSchema用于指定方案名,table_name用于指定表名,query_clause用于指定条件限制子句.QUERY选项不能与CONNECT=METADATA_ONLY,EXTIMATE_ONLY,TRANSPORT_TABLESPACES等选项同时使用.Expdpscott/tigerdirectory=dumpdumpfiel=a.dmpTables=empquery=’WHEREdeptno=20’21）SCHEMAS该方案用于指定执行方案模式导出,默认为当前用户方案.22）STATUS指定显示导出作用进程的详细状态,默认值为023）TABLES指定表模式导出TABLES=[schema_name.]table_name[:partition_name][,…]Schema_name用于指定方案名,table_name用于指定导出的表名,partition_name用于指定要导出的分区名.24）TABLESPACES指定要导出表空间列表25）TRANSPORT_FULL_CHECK该选项用于指定被搬移表空间和未搬移表空间关联关系的检查方式,默认为N.当设置为Y时,导出作用会检查表空间直接的完整关联关系,如果表空间所在表空间或其索引所在的表空间只有一个表空间被搬移,将显示错误信息.当设置为N时,导出作用只检查单端依赖,如果搬移索引所在表空间,但未搬移表所在表空间,将显示出错信息,如果搬移表所在表空间,未搬移索引所在表空间,则不会显示错误信息.26）TRANSPORT_TABLESPACES指定执行表空间模式导出27）VERSION指定被导出对象的数据库版本,默认值为COMPATIBLE.VERSION={COMPATIBLE|LATEST|version_string}为COMPATIBLE时,会根据初始化参数COMPATIBLE生成对象元数据;为LATEST时,会根据数据库的实际版本生成对象元数据.version_string用于指定数据库版本字符串.四、EXPDP用法使用EXPDP工具时,其转储文件只能被存放在DIRECTORY对象对应的OS目录中,而不能直接指定转储文件所在的OS目录.因此,使用EXPDP工具时,必须首先建立DIRECTORY对象.并且需要为数据库用户授予使用DIRECTORY对象权限.CREATEDIRECTORYdump_dirAS‘c:\emp’;GRANTREAD,WRITEONDIRECTORYdump_dirTOscott;1、导出表Expdpscott/tigerDIRECTORY=dump_dirDUMPFILE=dept.dmpTABLES=dept注：在unix下要注意directory目录的读写权限问题，如：查看dump_dir所在的目录：用sys用户查看数据字典dba_directories更该该文件夹的权限：chown–Roracle:dba/exp,问题解决2、导出方案expdpscott/tigerdirectory=dump_dirdumpfile=schema.dmplogfile=schema.logschemas=system3、导出表空间expdpscott/tigerdirectory=dump_dirdumpfile=tb.dmplogfile=tb.logtablespaces=users4、导出数据库Expdpsystem/managerDIRECTORY=dump_dirDUMPFILE=full.dmpFULL=YExpdpscott/tigerDIRECTORY=dump_dirDUMPFILE=full.dmpFULL=Y注：提示scott用户没有相应的权限，给scott相应的权限或使用system来做全库导出。SQL>grantexp_full_databasetoscott;Grantsucceeded.然后在做全库的导出：五、IMPDP参数IMPDP与EXPDP的不同参数:1、REMAP_DATAFILE该选项用于将源数据文件名转变为目标数据文件名,在不同平台之间搬移表空间时可能需要该选项.REMAP_DATAFIEL=source_datafie:target_datafile2、REMAP_SCHEMA该选项用于将源方案的所有对象装载到目标方案中.REMAP_SCHEMA=source_schema:target_schema3、REMAP_TABLESPACE将源表空间的所有对象导入到目标表空间中REMAP_TABLESPACE=source_tablespace:target:tablespace4、REUSE_DATAFILES该选项指定建立表空间时是否覆盖已存在的数据文件.默认为NREUSE_DATAFIELS={Y|N}5、SKIP_UNUSABLE_INDEXES指定导入是是否跳过不可使用的索引,默认为N6、SQLFILE指定将导入要指定的索引DDL操作写入到SQL脚本中SQLFILE=[directory_object:]file_nameImpdpscott/tigerDIRECTORY=dumpDUMPFILE=tab.dmpSQLFILE=a.sql7、STREAMS_CONFIGURATION指定是否导入流元数据(StreamMatadata),默认值为Y.8、TABLE_EXISTS_ACTION该选项用于指定当表已经存在时导入作业要执行的操作,默认为SKIPTABBLE_EXISTS_ACTION={SKIP|APPEND|TRUNCATE|FRPLACE}当设置该选项为SKIP时,导入作业会跳过已存在表处理下一个对象;当设置为APPEND时,会追加数据,为TRUNCATE时,导入作业会截断表,然后为其追加新数据;当设置为REPLACE时,导入作业会删除已存在表,重建表并追加数据,注意,TRUNCATE选项不适用与簇表和NETWORK_LINK选项9、TRANSFORM该选项用于指定是否修改建立对象的DDL语句TRANSFORM=transform_name:value[:object_type]Transform_name用于指定转换名,其中SEGMENT_ATTRIBUTES用于标识段属性(物理属性,存储属性,表空间,日志等信息),STORAGE用于标识段存储性,VALUE用于指定是否包含段属性或段存储属性,object_type用于指定对象类型.Impdpscott/tigerdirectory=dumpdumpfile=tab.dmpTransform=segment_attributes:n:table10、TRANSPORT_DATAFILES该选项用于指定搬移空间时要被导入到目标数据库的数据文件TRANSPORT_DATAFILE=datafile_nameDatafile_name用于指定被复制到目标数据库的数据文件Impdpsystem/managerDIRECTORY=dumpDUMPFILE=tts.dmpTRANSPORT_DATAFILES=’/user01/data/tbs1.f’六、IMPDP用法1、导入表impdphsiufo/hsiufodirectory=dump_dirdumpfile=full.dmptables=scott.empremap_schema=scott:scott注：上图为为有一个全库的逻辑备份full.dmp，然后删除用户scott的emp表，在full.dmp中导入emp到用户scottimpdphsiufo/hsiufodirectory=dump_dirdumpfile=full.dmptables=scott.testremap_schema=scott:system第一种方法表示将EMP表导入到SCOTT方案中,第二种方法表示将test表导入的SYSTEM方案中.注意,如果要将表导入到其他方案中,必须指定REMAPSCHEMA选项.2、导入方案impdphsiufo/hsiufodirectory=dump_dirdumpfile=full.dmpschemas=scottImpdpsystem/managerDIRECTORY=dump_dirDUMPFILE=schema.dmpSCHEMAS=scottREMAP_SCHEMA=scott:system3、导入表空间Impdpsystem/managerDIRECTORY=dump_dirDUMPFILE=tablespace.dmpTABLESPACES=user014、导入数据库Impdpsystem/managerDIRECTORY=dump_dirDUMPFILE=full.dmpFULL=y",2014/12/31
485,spring注入问题,沈文进,http://180.168.156.212:2262/wecenter/?/article/8808,Spring注入问题接口注入（interfaceinjection）接口注入指的就是在接口中定义要注入的信息，并通过接口完成注入。结合前面的示例，其具体步骤如下。（1）编写一个接口IBusiness，各种数据库的注入将通过这个接口进行。IBusiness.java的示例代码如下：//*******IBusiness.java**************}（2）任何想要使用数据库实例的类都必须实现这个接口，业务逻辑类Business实现这个接口IBusiness。Business.java的示例代码如下：//*******Business.java**************this.db=db;}……//根据注入的数据库类，从×××数据库中获取数据publicvoidgetData(){……db.getData();……}}（3）编写测试类TestBusiness。TestBusiness.java的示例代码如下：//*******TestBusiness.java**************publicclassTestBusiness{privateBusinessbusiness=newBusiness();……//根据注入的数据库类，从Oracle数据库中获取数据publicvoidgetData(){……business.createDI(newOracleDataBase());business.getData();……}}如果要完成依赖关系注入的对象，必须实现IBusiness接口。23.2.2Set注入（setterinjection）Set注入指的就是在接受注入的类中定义一个Set方法，并在参数中定义需要注入的元素。为了让类Business接受DataBase的注入，需要为它定义一个Set方法来接受DataBase的注入。Business.java的示例代码如下：//*******Business.java**************publicclassBusiness{privateDataBasedb;publicvoidsetDataBase(DataBasedb){this.db=db;}……//根据注入的数据库类，从×××数据库中获取数据publicvoidgetData(){……db.getData();……}}更详细的代码，可以参看3.1节的第二个例子，采用的就是Set注入的方式。33.2.3构造注入（constructorinjection）构造注入指的就是在接受注入的类中定义一个构造方法，并在参数中定义需要注入的元素。为了让类Business接受DataBase的注入，需要为它定义一个构造方法，来接受DataBase的注入。Business.java的示例代码如下：//*******Business.java**************publicclassBusiness{privateDataBasedb;publicBusiness(DataBasedb){this.db=db;}……//根据注入的数据库类，从×××数据库中获取数据publicvoidgetData(){……db.getData();……}},2014/12/31
486,PhoneGap开发心得1之deviceready事件,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8806,"PhoneGap的deviceready事件相当于整个PG程序的入口。整个程序的业务或者UI都应该从这个地方开始。否则就会出现各种函数未定义的异常。简单例子如下：document.addEventListener(""deviceready"",onDeviceReady,false);functiononDeviceReady(){//NowsafetousedeviceAPIs}",2014/12/31
487,Struts中的拦截器,沈文进,http://180.168.156.212:2262/wecenter/?/article/8805,"Struts2的拦截器结构的设计，实际上是一个典型的责任链模式的应用。首先将整个执行划分成若干相同类型的元素，每个元素具备不同的逻辑责任，并将他们纳入到一个链式的数据结构中（我们可以把堆栈结构也看作是一个递归的链式结构），而每个元素又有责任负责链式结构中下一个元素的执行调用。Interceptor拦截类型整个拦截器的核心部分是invocation.invoke()这个函数的调用位置。事实上，我们也正式根据这句代码的调用位置，来进行拦截类型的区分的。在Struts2中，Interceptor的拦截类型，分成以下三类：1.beforebefore拦截，是指在拦截器中定义的代码，它们存在于invocation.invoke()代码执行之前。这些代码，将依照拦截器定义的顺序，顺序执行。2.afterafter拦截，是指在拦截器中定义的代码，它们存在于invocation.invoke()代码执行之后。这些代码，将一招拦截器定义的顺序，逆序执行。3.PreResultListener有的时候，before拦截和after拦截对我们来说是不够的，因为我们需要在Action执行完之后，但是还没有回到视图层之前，做一些事情。Struts2同样支持这样的拦截，这种拦截方式，是通过在拦截器中注册一个PreResultListener的接口来实现的。publicinterfacePreResultListener{/***ThiscallbackmethodwillbecalledaftertheActionexecutionandbeforetheResultexecution.**@paraminvocation*@paramresultCode*/voidbeforeResult(ActionInvocationinvocation,StringresultCode);}在这里，我们看到，Struts2能够支持如此多的拦截类型，与其本身的数据结构和整体设计有很大的关系。正如我在之前的文章中所提到的：downpour写道因为Action是一个普通的Java类，而不是一个Servlet类，完全脱离于Web容器，所以我们就能够更加方便地对Control层进行合理的层次设计，从而抽象出许多公共的逻辑，并将这些逻辑脱离出Action对象本身。我们可以看到，Struts2对于整个执行的划分，从Interceptor到Action一直到Result，每一层都职责明确。不仅如此，Struts2还为每一个层次之前都设立了恰如其分的插入点。使得整个Action层的扩展性得到了史无前例的提升。Interceptor执行顺序Interceptor的执行顺序或许是我们在整个过程中最最关心的部分。根据上面所提到的概念，我们实际上已经能够大致明白了Interceptor的执行机理。",2014/12/31
488,DATASNAP REST WEBSERVICES中间件如何跨平台使用,孙传金,http://180.168.156.212:2262/wecenter/?/article/8804,"DATASNAPREST中间件是delphi开发工具中XE2及以上版本中的提供的一种跨平台数据通讯架构，以后再移动平台上的开发不可不了解的技术框架。DATASNAPREST新型WEBSERVICES中间件使用的通信协议和数据封装格式：使用HTTP通信协议，HTTP协议哪个平台都支持；使用JSON作为数据的封装格式，几乎所有的开发语言都可以解析JSON数据。REST的目的就是通过简单的URL来完成对中间层远程方法的调用并返回JSON格式的数据，调用方解析JSON数据然后将数据秀出来。正是基于以上原因，DATASNAPREST中间件才可以为苹果和安卓的移动的NATIVEAPP提供数据服务；也可以为WINDOWS、LINUX、MAC等桌面型NATIVEAPP提供数据服务。1.根据DELPHI的向导生成DATASNAPREST中间件。2.在中间件远程方法里面增加一个方法：functionTServerMethods1.GetData(sql:string):tdataset;beginq.close;q.sql.clear;q.sql.text:=sql;q.Open;Result:=q;end;3.客户端调用，因为演示跨平台的原因，此处只介绍通过URL调用中间件的方法。procedureTForm1.Button1Click(Sender:TObject);vars:string;jo:ISuperObject;ja,jb,jc:TSuperArray;i,h:Integer;FieldList:TStringList;arr:arrayofarrayofstring;beginMemo1.Clear;FieldList:=TStringList.Create;trys:=idhttp1.Get(' 0';rest_exec(ClientDataSet1,url);end;end.",2014/12/31
489,PdmReader,樊志强,http://180.168.156.212:2262/wecenter/?/article/8803,数据库文档就靠它了PdmReader.rar,2014/12/31
490,java8的新日期包示例,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8807, /2800...ormat话说啥时候才能够用上java8啊。。,2014/12/31
491,解决unity3d web插件更新缓慢,王健敏,http://180.168.156.212:2262/wecenter/?/article/8802,"由于插件都是默认链接国外服务器进行更新的，所以更新非常缓慢解决办法：在加载插件的js属性中添加一下几行代码，改变下载源，指向国内的服务器地址baseDownloadUrl:"" /au...ot%3B,autoupdateURLSignature:""02a5f78b3066d7d31fb063186a2eec36fdf1205d49c6b0808eb37ef85ed9902e2e1904d87f599238a802ba0abbfe4f18aa82dd2eb5171e99ba839a5cea9e6ea9c1be9eae505937b56fe4a5fd254cffe08958d961f42d970136b5eab9e6c2cd08b81bc8a11e5ade57dc63dcfef2248d89689e4d4feed3cdfe7374c848fd57ebd4""",2014/12/31
492,深入理解JDBC的超时机制,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8801, ,2014/12/31
493,IOS App RunKeeper 公司CEO谈团队管理,王链玮,http://180.168.156.212:2262/wecenter/?/article/8800,个人运动健身AppRunKeeper致力于帮助人们养成自主的运动习惯，不断突破自己迈向新的健身目标。其创始人兼CEOJasonJacobs认为，这种自我激励的方式同样适用于团队管理。“如果你想造一条船，不要只想着如何鼓动他人来收集材料、划分任务、执行命令。取而代之的，是我们应该教会他们对浩瀚无边海洋的渴求！这就是我正在尝试的。”Jacobs说道，“当我们拥有了以结果为导向的企业文化，我会更多尝试激发人们对可能达到的结果的追求。”以下是Jacobs的五个具体建议。雇用有使命感的人，而不是唯利是图的RunKeeper的每一名成员，Jacobs都曾经面试过。因此，对于求职者的心态和入职动机，Jacobs都了如指掌。“对于人才，我们不应该只看重他的才能，他的动机更为关键。为什么选择我们公司？为什么这个时间跳槽？这些问题都是重要的分水岭。运作一家公司，有个情况是不可避免的：唯利是图者会不断追逐名利和下一个落脚点，而有使命感者会乐意与你同甘共苦，共同进退。”不要低估透明度的力量“人们常常说我们公司的雇员都是亲密如知己，有时候我们应该对高压政策有所保留。这我是不赞同的。”Jacobs认为，“我们对每一名雇员都是公平对待都看成是公司的主人，这样可确保信息的传递是畅通无阻的。在创业公司工作注定是艰苦的，如果对困难遮遮掩掩，这很难让团队达到最高的工作状态。与其不情愿地工作，还不如痛快分手。”充分信任团队如果遇到能帮助公司更进一步的机会，Jacobs不会做出最高指示，而是把权力下放到团队中。“这已经不仅仅是种文化了。‘真酷，我们现在有个绝佳的机会，但这可能会要求我们在周末加班甚至通宵作业。我把最后决定权交给你们。’而很多时候，人们最后都会乐意做出牺牲，换取团队的进步。这又回到招聘的话题了。有些人天生就有种基因，团队利益高于一切！”鼓励和引导良性竞争自2007年成立以来，RunKeeper与Nike+保持着齐头并进分庭抗礼的态势。此外，苹果公司也计划推出AppleWatch，从可穿戴设备市场中分一杯羹。然而，Jacobs并没有为此而感到懊恼，反而认为是进一步激发团队的好时机。“我不断提醒下属，如果我们切入的市场不能引起大型企业的兴趣，这个市场注定是不能做大做强的。”Jacobs回答说，“诚然，受人敬重的苹果等大型企业的介入会带来更激烈的竞争，但术业有专攻，大型企业业务庞杂，而小而美公司能更专注专业专攻，从而更有机会找准突破口，打造属于自己的特色形成品牌。”使用自己的产品“作为一家以销售产品为主的公司，如果我们自己都不经常使用，何况别人呢？我们团队都会尝试自己给自己制定个健身目标，例如每年步行2000英里，参加马拉松等，然后会互相分享其中的心得。这样一来，在完成自我激励的同时，也更能激发成员的工作激情。”本文作者JasonJacobs是运动健身类AppRunKeeper的创始人兼CEO，RunKeeper的特色是能跟踪用户运动量，透过耳机由内建语音教练告诉用户目前的记录和运动的过程。原文链接： /2014-12-03,2014/12/31
494,关于新架构Spring JDBC操作BUG修复,李宏辉,http://180.168.156.212:2262/wecenter/?/article/8799,"新架构中，如果在服务层方法中仅调用一次JDBCTemplate操作，不会存在问题，如果在服务层方法，多次调用JDBCTemplate操作不同业务时，如下：publicvoidoperate1(){jdbcTemplate.execute();}publicvoidoperate2(){jdbcTemplate.execute();}publicvoidoperate(){operate1();operate2();}操作operate()时，系统提示connectionisclosed异常此BUG为springbug,系统中使用的spring的版本为3.2.2,请将spring版本升级为3.2.4版本以上，即可解决该问题",2014/12/31
495,Mongodb集群部署以及集群维护命令,王健敏,http://180.168.156.212:2262/wecenter/?/article/8798,"MongoDB集群帮助手册一、Mongodb集群架构简介这是一种可以水平扩展的模式，在数据量很大时特给力，实际大规模应用一般会采用这种架构去构建monodb系统。要构建一个MongoDBShardingCluster，需要三种角色：lShardServer:mongod实例，用于存储实际的数据块，实际生产环境中一个shardserver角色可由几台机器组个一个relicaset承担，防止主机单点故障lConfigServer:mongod实例，存储了整个ClusterMetadata，其中包括chunk信息。lRouteServer:mongos实例，前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。1.分别在3台机器运行一个mongod实例（称为mongodshard11，mongodshard12，mongodshard13）组织replicaset1，作为cluster的shard12.分别在3台机器运行一个mongod实例（称为mongodshard21，mongodshard22，mongodshard23）组织replicaset2，作为cluster的shard23.每台机器运行一个mongod实例，作为3个configserver4.每台机器运行一个mongs进程，用于客户端连接主机IP端口信息Server110.1.1.1mongodshard11:27017mongodshard12:27018mongodconfig1:20000mongs1:30000Server210.1.1.2mongodshard12:27017mongodshard22:27018mongodconfig2:20000mongs2:30000Server310.1.1.3mongodshard13:27017mongodshard23:27018mongodconfig3:20000mongs3:30000二、集群配置2.1软件准备1.安装monodb软件su–mongodbtarzxvfmongodb-linux-x86_64-1.6.2.tar创建数据目录根据本例sharding架构图所示，在各台sever上创建shard数据文件目录Server1:su–monodbcd/monodbmkdir-pdata/shard11mkdir-pdata/shard21Server2:su–monodbcd/monodbmkdir-pdata/shard11mkdir-pdata/shard22Server3:su–monodbcd/monodbmkdir-pdata/shard13mkdir-pdata/shard232.2配置relicasets（复制集）1.配置shard1所用到的replicasets:Server1:cd/mongodb/mongodb-linux-x86_64-1.6.2/bin./mongod–shardsvr–replSetshard1–port27017–dbpath/mongodb/data/shard11–oplogSize100–logpath/mongodb/data/shard11.log–logappend–forkServer2:cd/mongodb/mongodb-linux-x86_64-1.6.2/bin./mongod–shardsvr–replSetshard1–port27017–dbpath/mongodb/data/shard12–oplogSize100–logpath/mongodb/data/shard12.log–logappend–forkServer3:cd/mongodb/mongodb-linux-x86_64-1.6.2/bin./mongod–shardsvr–replSetshard1–port27017–dbpath/mongodb/data/shard13–oplogSize100–logpath/mongodb/data/shard13.log–logappend–fork初始化replicaset用mongo连接其中一个mongod，执行:>config={_id:‘shard1′,members:[{_id:0,host:'10.1.1.1:27017'},{_id:1,host:'10.1.1.2:27017'},{_id:2,host:'10.1.1.3:27017'}]}>rs.initiate(config);同样方法，配置shard2用到的replicasets:server1:cd/mongodb/mongodb-linux-x86_64-1.6.2/bin./mongod–shardsvr–replSetshard2–port27018–dbpath/mongodb/data/shard21–oplogSize100–logpath/mongodb/data/shard21.log–logappend–forkserver2:cd/mongodb/mongodb-linux-x86_64-1.6.2/bin./mongod–shardsvr–replSetshard2–port27018–dbpath/mongodb/data/shard22–oplogSize100–logpath/mongodb/data/shard22.log–logappend–forkserver3:cd/mongodb/mongodb-linux-x86_64-1.6.2/bin./mongod–shardsvr–replSetshard2–port27018–dbpath/mongodb/data/shard23–oplogSize100–logpath/mongodb/data/shard23.log–logappend–fork初始化replicaset用mongo连接其中一个mongod，执行:>config={_id:‘shard2′,members:[{_id:0,host:'10.1.1.1:27018'},{_id:1,host:'10.1.1.2:27018'},{_id:2,host:'10.1.1.3:27018'}]}>rs.initiate(config);到此就配置好了二个replicasets，也就是准备好了二个shards2.3配置三台configserverServer1:mkdir-p/mongodb/data/config./mongod–configsvr–dbpath/mongodb/data/config–port20000–logpath/mongodb/data/config.log–logappend–fork#configserver也需要dbpathServer2:mkdir-p/mongodb/data/config./mongod–configsvr–dbpath/mongodb/data/config–port20000–logpath/mongodb/data/config.log–logappend–forkServer3:mkdir-p/mongodb/data/config./mongod–configsvr–dbpath/mongodb/data/config–port20000–logpath/mongodb/data/config.log–logappend–fork2.4配置mongs在server1,server2,server3上分别执行：./mongos–configdb10.1.1.1:20000,10.1.1.2:20000,10.1.1.3:20000–port30000–chunkSize5–logpath/mongodb/data/mongos.log–logappend–fork#mongs不需要dbpath2.5添加复制集连接到其中一个mongos进程，并切换到admin数据库做以下配置1.连接到mongs，并切换到admin./mongo10.1.1.1:30000/admin>dbAdmin2.加入shards如里shard是单台服务器，用>db.runCommand({addshard:“<serverhostname>[:<port>]”})这样的命令加入，如果shard是replicasets，用replicaSetName/<serverhostname>[:port][,serverhostname2[:port],…]这样的格式表示，例如本例执行：>db.runCommand({addshard:“shard1/10.1.1.1:27017,10.1.1.2:27017,10.1.1.3:27017″,name:”s1″,maxsize:20480});>db.runCommand({addshard:“shard2/10.1.1.1:27018,10.1.1.2:27018,10.1.1.3:27018″,name:”s2″,maxsize:20480});注意：在添加第二个shard时，出现error:testdatabase已经存在的错误，这里用mongo命令连接到第二个replicaset，用db.dropDatabase()命令把test数据库给删除然后就可加入3.可选参数Name:用于指定每个shard的名字，不指定的话系统将自动分配maxSize:指定各个shard可使用的最大磁盘空间，单位megabytes4.Listingshards>db.runCommand({listshards:1})如果列出了以上二个你加的shards，表示shards已经配置成功5.2.6数据库分片以及Collecton分片1、激活数据库分片命令：>db.runCommand({enablesharding:“<dbname>”});通过执行以上命令，可以让数据库跨shard，如果不执行这步，数据库只会存放在一个shard，一旦激活数据库分片，数据库中不同的collection将被存放在不同的shard上，但一个collection仍旧存放在同一个shard上，要使单个collection也分片，还需单独对collection作些操作2、Collection分片要使单个collection也分片存储，需要给collection指定一个分片key，通过以下命令操作：>db.runCommand({shardcollection:“<namespace>”,key:<shardkeypatternobject>});注：a.分片的collection系统会自动创建一个索引（也可用户提前创建好）b.分片的collection只能有一个在分片key上的唯一索引，其它唯一索引不被允许Onenote:ashardedcollectioncanhaveonlyoneuniqueindex,whichmustexistontheshardkey.Nootheruniqueindexescanexistonthecollection.2.7分片collection例子>db.runCommand({shardcollection:“test.c1″,key:{id:1}})>for(vari=1;i<=200003;i++)db.c1.save({id:i,value1:”1234567890″,value2:”1234567890″,value3:”1234567890″,value4:”1234567890″});>db.c1.stats()（该命令可以查看表的存储状态）2.8Mongodb运行时添加节点1、查看复制集节点配置./mongo192.168.1.207:27017rs0:PRIMARY>rs.conf();{""_id"":""rs0"",""version"":3,""members"":[{""_id"":0,""host"":""192.168.1.207:27017""},{""_id"":1,""host"":""192.168.1.207:27018""},]}2、添加节点添加新的数据目录mkdir–p/mongodb/data/shard4启动节点./mongod–shardsvr–replSetshard1–port27019–dbpath/mongodb/data/shard4–oplogSize100–logpath/mongodb/data/shard4.log–logappend–fork连接主节点mongo192.168.1.207:27017rs0:PRIMARY>rs.isMaster();{""setName"":""rs0"",""ismaster"":true,""secondary"":false,""hosts"":[""192.168.1.207:27017"",""192.168.1.207:27018""],""primary"":""192.168.1.207:27017"",""me"":""192.168.1.207:27018"",""maxBsonObjectSize"":16777216,""localTime"":ISODate(""2013-05-22T13:04:36.501Z""),""ok"":1}添加节点rs0:PRIMARY>rs.add(""192.168.1.207:27019"");{""ok"":1}3、再次查看状态rs0:PRIMARY>rs.conf();{""_id"":""rs0"",""version"":3,""members"":[{""_id"":0,""host"":""192.168.1.207:27017""},{""_id"":1,""host"":""192.168.1.207:27018""},{""_id"":1,""host"":""192.168.1.207:27019""},]}添加成功2.9Mongodb运行时移除节点其他步骤同上，其中只是将添加命令改为移除命令rs0:PRIMARY>rs.remove(""192.168.1.207:27019"");最后还需要关掉192.168.1.207:27019该服务Ps–ef|grepmongo查找该服务然后通过kill-9pid关闭服务。2.10Mongodb运行时移除分片1、连接mongos节点./mongo192.168.1.207:30000/admin2、运行db.runCommand({removeshard:""your_shard_name""}){msg:""drainingstartedsuccessfully"",state:""started"",shard:""mongodb0"",ok:1}3、查看状态，我们可以反复执行上面语句查看执行状态db.runCommand({removeshard:""your_shard_name""}){msg:""drainingongoing"",state:""ongoing"",remaining:{chunks:42,dbs:1},ok:1说明正在迁移中。4、移除非shard数据db.runCommand({movePrimary:""myapp"",to:""mongodb1""})这次就不是立即返回了，需要很久，然后会返回如下：{""primary"":""mongodb1"",""ok"":1}5、面步骤都完成后，还需要再执行一次RemoveShard，清理残余数据。db.runCommand({removeshard:""mongodb0""})显示completed后，就可以安心的关闭mongod的进程了。三、Mongodb问题以及解决方案3.1问题一：mongodb启动成功但远程无法连接问题描述：linux环境下mongodb启动充公但远程无法连接解决方案：最可能的原因是调试没有关闭iptables和selinux只需要执行命令：/etc/init.d/iptablesstop",2014/12/31
496,转：九连环的历史、玩法和它的数学问题,陆志超,http://180.168.156.212:2262/wecenter/?/article/8797,RT九连环的历史玩法和它的数学问题.doc,2014/12/31
497,如何给Eclipse提速,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/8796,如何给Eclipse提速，看到一篇博文，转来大家一起学习学习。。。给Eclipse提速.docx,2014/12/30
498,正则表达式,张建涛,http://180.168.156.212:2262/wecenter/?/article/8795,"模式匹配符\指出后面的字符为特殊字符^匹配的字符必须在最前面$匹配的字符必须在最后面*匹配前面的字符0次或n次+至少1次？0或1次.匹配除换行符之外的所有单个字符x|y匹配x或y(x)标记子表达式的起止位置{n}匹配前面的n个字符{n,}匹配前面的至少n个字符{n,m}匹配前面的n到m个字符[xyz]匹配列出的任意字符[^xyz]匹配列出的任意字符的补集，即匹配列出字符之外的其他任意字符[a-d]匹配abcd当中的任意字符[\b]匹配一个空格\b匹配一个单词的分界线，比如一个空格\B匹配一个单词的非分界线\d匹配一个数字，等价于[0-9]\D匹配一个非数字\f匹配一个表单符\n匹配一个换行符\r匹配一个回车符\s匹配一个空单符，包括空格、Tab、feed、form、换行符，等价于[\f\n\r\t\v]\S匹配一个制表符\w匹配所有的字母、数字及下划线，等价于[A-Za-z1-9_]\W匹配\w的补集贪婪匹配与非贪婪匹配正则表达式默认贪婪匹配，即使用最长匹配原则例要将“book”中匹配“bo?”的部分替换成“l”，替换结果为“lok”，而不是“look”当“?”紧跟在任何其他限定符（*、+、?、{n}、{n,m}）之后时，使用非贪婪模式例有字符串“booook”，“bo+?”只匹配“bo”部分，而“bo+”匹配“boooo”选择匹配符“|”的两个选项是两边尽可能最大的表达式例“abcd|efgh2”匹配的是“abcd”或“efgh”，而不是“abcd2”或“efgh2”，如要匹配“abcd2”或“efgh2”，应该创建“(abcd|efgh)2”特殊字符如果要匹配以下特殊字符的字面意思，需用“\”进行转义^$*+?.()[]{}|\/正则表达式的静态属性（1）index属性。是当前表达式模式首次匹配内容的开始位置，从0开始计数。其初始值为-1，每次成功匹配时，index属性都会随之改变。（2）input属性。返回当前所作用的字符串，可以简写为$_，初始值为空字符串""""。（3）lastIndex属性。是当前表达式模式首次匹配内容中最后一个字符的下一个位置，从0开始计数，常被作为继续搜索时的起始位置，初始值为-1，表示从起始位置开始搜索，每次成功匹配时，lastIndex属性值都会随之改变。（4）lastMatch属性。是当前表达式模式的最后一个匹配字符串，可以简写为$&。其初始值为空字符串""""。在每次成功匹配时，lastMatch属性值都会随之改变。（5）lastParen属性。如果表达式模式中有括起来的子匹配，是当前表达式模式中最后的子匹配所匹配到的子字符串，可以简写为$+。其初始值为空字符串""""。每次成功匹配时，lastParen属性值都会随之改变。（6）leftContext属性。是当前表达式模式最后一个匹配字符串左边的所有内容，可以简写为$`（其中“'”为键盘上“Esc”下边的反单引号）。初始值为空字符串""""。每次成功匹配时，其属性值都会随之改变。（7）rightContext属性。是当前表达式模式最后一个匹配字符串右边的所有内容，可以简写为$'。初始值为空字符串""""。每次成功匹配时，其属性值都会随之改变。（8）$1…$9属性。这些属性是只读的。如果表达式模式中有括起来的子匹配，$1…$9属性值分别是第1个到第9个子匹配所捕获到的内容。如果有超过9个以上的子匹配，$1…$9属性分别对应最后的9个子匹配。在一个表达式模式中，可以指定任意多个带括号的子匹配，但RegExp对象只能存储最后的9个子匹配的结果。在RegExp实例对象的一些方法所返回的结果数组中，可以获得所有圆括号内的子匹配结果。实例属性（1）global属性。返回创建RegExp对象实例时指定的global标志（g）的状态。如果创建RegExp对象实例时设置了g标志，该属性返回True，否则返回False，默认值为False。（2）ignoreCase属性。返回创建RegExp对象实例时指定的ignoreCase标志（i）的状态。如果创建RegExp对象实例时设置了i标志，该属性返回True，否则返回False，默认值为False。（3）multiLine属性。返回创建RegExp对象实例时指定的multiLine标志（m）的状态。如果创建RegExp对象实例时设置了m标志，该属性返回True，否则返回False，默认值为False。（4）source属性。返回创建RegExp对象实例时指定的表达式文本字符串。RegExp对象的方法test方法语法格式为test(str)。该方法检查一个字符串中是否存在创建RegExp对象实例时所指定的表达式模式，如果存在就返回True，否则返回False。如果找到匹配项，则会更新RegExp对象中的有关静态属性，以反映匹配情况。exec方法语法格式为exec(str)。该方法使用创建RegExp对象实例时所指定的表达式模式对一个字符串进行搜索，并返回一个包含搜索结果的数组。如果为正则表达式设置了全局标志（g），可以通过多次调用exec和test方法在字符串中进行连续搜索，每次都是从RegExp对象的lastIndex属性值指定的位置开始搜索字符串。如果没有设置全局标志（g），则exec和test方法忽略RegExp对象的lastIndex属性值，从字符串的起始位置开始搜索。如果exec方法没有找到匹配，返回值为null；如果找到匹配，则返回一个数组，并更新RegExp对象中有关静态属性以反映匹配情况。返回数组中的元素0包含了完整的匹配结果，而元素1～n依次是表达式模式中定义的各个子匹配的结果。exec方法返回的数组有3个属性，分别是input、index和lastIndex。input属性是整个被搜索的字符串。index属性是指匹配在整个被搜索字符串中的位置。lastIndex属性是指匹配的子字符串的最后一个字符的下一个字符位置。",2014/12/30
499,OA系统权限管理设计方案,甘名辉,http://180.168.156.212:2262/wecenter/?/article/8794,"现在做前期系统分析，目前遇到一个困难:权限设计方案。。在百度很快找到了解决方案，以下资料转载自网络:不同职责的人员，对于系统操作的权限应该是不同的。优秀的业务系统，这是最基本的功能。l可以对“组”进行权限分配。对于一个大企业的业务系统来说，如果要求管理员为其下员工逐一分配系统操作权限的话，是件耗时且不够方便的事情。所以，系统中就提出了对“组”进行操作的概念，将权限一致的人员编入同一组，然后对该组进行权限分配。l权限管理系统应该是可扩展的。它应该可以加入到任何带有权限管理功能的系统中。就像是组件一样的可以被不断的重用，而不是每开发一套管理系统，就要针对权限管理部分进行重新开发。l满足业务系统中的功能权限。传统业务系统中，存在着两种权限管理，其一是功能权限的管理，而另外一种则是资源权限的管理，在不同系统之间，功能权限是可以重用的，而资源权限则不能。针对OA系统的特点，权限说明：权限在系统中，权限通过模块+动作来产生，模块就是整个系统中的一个子模块，可能对应一个菜单，动作也就是整个模块中（在B/S系统中也就是一个页面的所有操作，比如“浏览、添加、修改、删除”等）。将模块与之组合可以产生此模块下的所有权限。权限组为了更方便的权限的管理，另将一个模块下的所有权限组合一起，组成一个“权限组”，也就是一个模块管理权限，包括所有基本权限操作。比如一个权限组（用户管理），包括用户的浏览、添加、删除、修改、审核等操作权限，一个权限组也是一个权限。角色权限的集合，角色与角色之间属于平级关系，可以将基本权限或权限组添加到一个角色中，用于方便权限的分配。用户组将某一类型的人、具有相同特征人组合一起的集合体。通过对组授予权限（角色），快速使一类人具有相同的权限，来简化对用户授予权限的繁琐性、耗时性。用户组的划分，可以按职位、项目或其它来实现。用户可以属于某一个组或多个组。通过给某个人赋予权限，有4种方式(参考飞思办公系统)A.通过职位a)在职位中，职位成员的权限继承当前所在职位的权限，对于下级职位拥有的权限不可继承。b)实例中：如前台这个职位，对于考勤查询有权限，则可以通过对前台这个职位设置考勤查询的浏览权，使他们有使用这个对象的权限，然后再设置个，考勤查询权（当然也可以不设置，默认能进此模块的就能查询），则所有前台人员都拥有考勤查询的权利。B.通过项目a)在项目中，项目成员的权限来自于所在项目的权限，他们同样不能继承下级项目的权限，而对于项目组长，他对项目有全权，对下级项目也一样。b)实例中：在项目中，项目成员可以对项目中上传文档，查看本项目的文档,可以通过对项目设置一个对于本项目的浏览权来实现进口，这样每个成员能访问这个项目了，再加上项目文档的上传权和查看文档权即可。c)对于组长，因为可以赋予组长一个组长权（组长权是个特殊的权限，它包含其他各种权限的一个权限包），所有组长对于本项目有全权，则项目组长可以对于项目文档查看，审批，删除，恢复等，这些权限对于本项目的下级项目依然有效。C.通过角色a)角色中的成员继承角色的权限，角色与角色没有上下级关系，他们是平行的。通过角色赋予权限，是指没办法按职位或项目的分类来赋予权限的另一种方式，如：系统管理员，资料备份员…b)实例中：对于本系统中，全体人员应该默认都有的模块，如我的邮件，我的文档，我的日志，我的考勤……，这些模块系统成员都应该有的，我们建立一个角色为系统默认角色，把所有默认访问的模块的浏览权加入到里面去，则系统成员都能访问这些模块。D.直接指定a)直接指定是通过对某个人具体指定一项权限，使其有使用这个权限的能力。直接指定是角色指定的一个简化版，为了是在建立像某个项目的组长这种角色时，省略创建角色这一个步骤，使角色不至于过多。b)实例中：指定某个项目的组长，把组长权指定给某个人。针对职位、项目组：如果用添加新员工，员工调换职位、项目组，满足了员工会自动继承所在职位、项目组的权限，不需要重新分配权限的功能。用户管理用户可以属于某一个或多个用户组，可以通过对用户组授权，来对组中的所有用户进行权限的授予。一个用户可以属于多个项目组，或担任多个职位。授权管理将一个基本权限或角色授予用户或用户组，使用户或用户组拥有授予权限的字符串，如果角色、职位、项目中存在相同的基本权限，则取其中的一个；如脱离角色、职位、项目组，只是取消用户或用户组的中此角色、职位、项目组所授予的权限。用户所拥有的权限是所有途径授予权限的集合。管理员用户可以查看每个用户的最终权限列表。权限管理基本操作权限与权限组（基本操作权限的集合）的管理。OA权限管理设计的实现物理数据模型图如下：物理数据模型图根据以上设计思想,权限管理总共需要以下基本表：tb_User：用户信息基本表；tb_Department：部门表；tb_Company：公司表；tb_Module：系统模块表；tb_Action：系统中所有操作的动作表；tb_Permit：由tb_Module与tb_Action两表结合产生的系统基本权限表；tb_Permit_Group：权限组表，将一模块的中的所有权限划分一个权限组中，可以通过权限组授予用户权限；tb_Role：角色表，基本权限的集合。无上级与下级之分；tb_Position：职位表，有上级与下级之分；tb_Project：项目组表，tb_Role_Permit：角色授权表；tb_Postion_Permit：职位授权表；tb_Project_Permit：项目授权表；tb_Project_User：项目成员表，IsLead字段代表此成员为项目组长；tb_Postion_User：职位成员表；tb_User_Permit：用户授权表，用户ID与角色、职位、项目及直接授予的权限串表；权限的产生：由tb_Module中的ModuleCode与tb_Action中的ActionCode组成权限代码PermitCode=ModuleCode+ActionCode。实例：ModuleCode=0101，ActionCode=01,则PermitCode=010101。权限值则有ModuleValue与ActionCode组合而成，采用下划线来连接。实例：ModuleValue=Sys_User,ActionValue=AdD，PermitValue=Sys_User_Add权限组：包括一组同一模块下的权限的组合，如管理用户包括基本的权限：添加、删除、修改、查看等，将这些组合起来构成一个用户组——“用户管理”权限组。其它类似。只是为了更方便的查看系统权限与权限的分配。实例：如管理用户的权限代码为010101à查看用户，010102à添加用户,010103à删除用户，010104à修改用户，010105à审核用户等，将这些基本权限组合起来一个集合而构成了“用户管理”权限组。角色、职位、项目：也就是按特定的需要划分一种权限的集合。使用角色授权表、职位授权表、项目授权表来实现。授权表中存放的是权限代码PermitCode,而不是权限组的GroupCode代码。用户授权：由用户授权表来实现，用户授权表中的RoleCode、PositionCode、ProjectCode分别是角色表中RoleCode组成的串、职位表PositionCode组成的串、ProjectCode组成的串。与角色授权表中的角色代码RoleCode、职位授权表中PositionCode、项目授权表中的ProjectCode不对应（不是主表与从表之间外键关系）。从而能够实现了一个用户可以拥有多个角色、多个职位、多个项目的情况。用户授权表中的PermitCode为直接授权的权限代码串，直接给用户分配权限。实例：用户ID为UserId=1的用户权限授权表的记录为：RoleCode=001,003PostionCode=001,002ProjectCode=001,005PermitCode=010101,020102表明此用户拥有两个角色，代码为001和003，并继承这两个角色的权限；担任两个职位，代码为001与002，并继承两个职位的权限；属于两个项目组中的成员，项目代码为001与005，并继承两个项目中的权限。直接指定给用户的权限为010101与010102这两个权限代码的权限用户权限字符串：根据用户授权表的角色代码、职位代码、项目代码得到权限字符串及表中直接分配的权限字符串组合成一个用户的所有权限字符串集合。",2014/12/30
500,JS返回页面并刷新的方法,余礼华,http://180.168.156.212:2262/wecenter/?/article/8783,"我们知道，history.back()可以返回当前页面的上一个页面，和浏览器的后退是一样，是利用了IE缓存来实现的！用回退的时候，回到的只是一个历史页面，数据也是你上次浏览的数据。有些情况下，我们需要返回上一个页面，但页面数据需要更新后的，怎么办呢？这时，可以使用以下方法实现：location.replace(document.referrer)说明：document.referrer：前一个页面的URLlocation.replace(URL)该方法通过指定URL替换当前缓存在历史里（客户端）的项目,因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。",2014/12/29
501,JavaScript糟粕和鸡肋,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8781,这是在网上看到一篇文章，主要是介绍js一些日常经常使用却很鸡肋的东西，也是平时写前端时大家应该注意的，能避免使用就不用，避免日后维护和扩展时引起性能等一些不必要的麻烦，同时也是自己感同身受的！JavaScript糟粕和鸡肋.doc,2014/12/29
502,微信背后的产品观（转）,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/8780,最近网上看到一些关于微信产品的东西，特地转来，给各位产品经理一起看看微信背后的产品观.pdf,2014/12/29
503,Redis使用连接池技术减少系统创建连接的开销,张殷豪,http://180.168.156.212:2262/wecenter/?/article/8782,"publicclassDBUtil{privatestaticJedisPoolpool=null;Gsongson=newGson();static{JedisPoolConfigconfig=newJedisPoolConfig();config.setMaxActive(500);config.setMaxIdle(10);config.setMaxWait(1000*100);config.setTestOnBorrow(true);pool=newJedisPool(config,""127.0.0.1"",6379);}publicstaticJedisgetJedis(){returnpool.getResource();}publicstaticvoidreturnResource(Jedisjedis){pool.returnResource(jedis);}@Testpublicvoidtestredis(){Jedisjedis=getJedis();SortingParamssortingParameters=newSortingParams();sortingParameters.get(""user_name_*"");sortingParameters.get(""user_age_*"");List<String>sort=jedis.sort(""uid"",sortingParameters);System.out.println(gson.toJson(sort));}}",2014/12/29
504,利用JAI将多个tif文件合并成单个多页的tif文件,张殷豪,http://180.168.156.212:2262/wecenter/?/article/8779,"publicstaticvoidmain(String[]args)throwsIOException{try{File[]files=newFile[10];//需要进行合并的tif图片.(均为单页)files[0]=newFile(""d:\\tif\\0001.tif"");files[1]=newFile(""d:\\tif\\0002.tif"");files[2]=newFile(""d:\\tif\\0003.tif"");files[3]=newFile(""d:\\tif\\0004.tif"");files[4]=newFile(""d:\\tif\\0005.tif"");files[5]=newFile(""d:\\tif\\0006.tif"");files[6]=newFile(""d:\\tif\\0007.tif"");files[7]=newFile(""d:\\tif\\0008.tif"");files[8]=newFile(""d:\\tif\\0009.tif"");files[9]=newFile(""d:\\tif\\0010.tif"");ArrayListpages=newArrayList(files.length-1);RenderedOpfirstPage=JAI.create(""fileload"",files[0].getCanonicalPath());for(inti=1;i<files.length;i++){RenderedOppage=JAI.create(""fileload"",files[i].getCanonicalPath());pages.add(page);}TIFFEncodeParamparam=newTIFFEncodeParam();//合并后生成的图片OutputStreamout=newFileOutputStream(""d:\\cc.tif"");ImageEncoderencoder=ImageCodec.createImageEncoder(""TIFF"",out,param);//param.setCompression(TIFFEncodeParam.COMPRESSION_JPEG_TTN2);param.setExtraImages(pages.iterator());encoder.encode(firstPage);firstPage.dispose();for(inti=0;i<pages.size();i++){((RenderedOp)pages.get(i)).dispose();}out.close();}catch(Exceptione){System.out.println(e.toString());}}需要的jar包.rar",2014/12/29
505,"利用开源jar,pdf转tif,jpg等图片格式",张殷豪,http://180.168.156.212:2262/wecenter/?/article/8778,"JAI将pdf转成tif，jpg等图片文件需要jai_codec.jar，jai_core.jar，jpedal_lgpl.jar实现可以查看代码ConvertPagesToImages.java文件在附件中。publicstaticvoidmain(String[]args){longstart=System.currentTimeMillis();StringpdfPath=""d:/test.pdf"";intscaling=-1;Stringformat=""tif"";Stringoutput_dir=""d:/"";Stringpassword=null;intpageCount=10;ConvertPagesToImagesconvertPagesToImages=newConvertPagesToImages();convertPagesToImages.init(pdfPath,scaling,format,output_dir,password,pageCount);System.out.println(""花费时间为=""+(System.currentTimeMillis()-start)/1000+""秒"");}pdfPath:pdf文件路径。Scaling：缩小比率。-1表示不缩小。Format：支持的转换格式，tif，jpg等都可以。output_dir：图片输出路径（是一个文件夹）。Password：pdf加密的话输入加密密码。pageCount：pdf文件的页数。在目录下会生成文件：如下；12.bmpConvertPagesToImages.java",2014/12/29
506,在线PS工具分享，无需安装画图工具,王链玮,http://180.168.156.212:2262/wecenter/?/article/8775,对于非美工专业，但平时时不时的会做些简单修图工作的，该工具比较合适 /,2014/12/29
507,基于企业服务总线的内容管理系统的研究应用,王链玮,http://180.168.156.212:2262/wecenter/?/article/8774,这段时间ESB的讨论较多，上传百度贴吧中的相关文章基于企业服务总线的内容管理系统的研究应用.pdf,2014/12/29
508,大公司的一个部门干不过小公司？ .,张建涛,http://180.168.156.212:2262/wecenter/?/article/8777,最近我和一批年轻的创业者去看了一部电影《鸣梁海战》，这部电影让我深受启发，《鸣梁海战》讲的是明朝的时候，朝鲜名将李舜臣率领12艘军舰，击败了300多艘日军水师的故事。以小博大，敌我力量如此悬殊，为什么能打赢？我认为有两个原因，一个是聚焦，一个就是创新。12条船如何打败300多条战船？如果在广阔的太平洋上，这个故事不可能发生。但李舜臣选择了一个最狭窄的海峡，敌人的船再多，一次只能放10条。如果不是狭窄的海峡，就算有神仙来指挥，300多艘船，压也把朝鲜海军压倒了，所以一定要聚焦。聚焦是创业者需要学习的一个很重要东西。因为巨头一定是强悍的，比你有钱，比你有人。和他们对抗的时候，你要选择一个聚焦的战场，你要聚焦在一个特别深的领域，聚焦的点要特别小，范围要特别窄。原来我的公司小的时候，我面对巨头也害怕。后来自己公司规模大了，我们发现一个问题，大公司的一个部门有时候干不过一个小公司，为什么？因为大公司业务太多了，每周开例会，某些部门的业务可能排不到前10名讨论。大公司内部也有勾心斗角，倾轧，像电影里面一样，他们互相不支援。一个大公司看起来钱多，人多，但是因为公司大了，所以更不敢赌。小公司最大的优势就是团队虽然小，但如果只干一件事，只干一个产品，只干一个功能，调动所有的人力，就能做到极致。电影中的朝鲜海军就是这么做的，非常聚焦。李舜臣在打仗之前，亲自去考察了地形，找到了最佳的决战地点。所以创业者也要比竞争对手更接地气，更了解用户的需求。比如今天很多的O2O项目，无论是互联网金融，还是租车、定餐，都不是纯粹的虚拟互联网，都是把互联网与很多产业结合起来。小公司可以像李舜臣一样，走访1000家餐馆，走访200个出租车司机，比大公司的总监、经理们了解的更深，就有胜算。小公司一定不要做平台，一定要寻求单点突破，做一个拿得出的好产品。这样你就可以成功的让自己的战场变成一个海峡。李舜臣最后取得胜利，无疑是用了一种不一样的打法。我相信李舜臣不是主动出击，实在是日本人打到家门口了，所以只能背水一战。这点和我的经历很像，我也不是有些人想象的那样，是斗士，是战神。没有人想主动打仗，都是被逼无奈。在互联网里，我经历过很多竞争，要想杀出来，一定要有所不一样。别人可能比你体量更大，比你船更多，但是你要有一个不一样的战法。所谓不一样的战法就是创新。在鸣梁海战中，最后是水帮了李舜臣很大的忙。互联网创新也是被迫的，如果太有钱，太有资源，你也不会创新；公司过的很舒服，闭着眼睛可以挣钱，你也不会创新。都是像朝鲜舰队一样，逼到无路可走的时候，要么失败，要么挖掘潜力。这时候你会想到很多不同寻常的办法，这些不同寻常的办法就是创新。,2014/12/29
509,项目维护心得,张建涛,http://180.168.156.212:2262/wecenter/?/article/8773,"一个实用系统的维护工作是漫长、琐碎的，所以要与客户经常保持沟通，这样可以及时掌握客户遇到的各种问题，维护人员也可对这些问题进行及时响应，经过前段时间的工作，个人认为做好维护工作，需注意以下几点：一、做好更新计划做好更新计划主要是涉及两方面的考虑：第一内部维护人员可以有一个详细的更新步骤以及任务安排；第二对客户来说也是一个很好的项目实施的结果展示。更新计划也可看成是项目的阶段性成果，作为与客户相互沟通的一部分文档资料。二、实时告诉客户每次的更新成果这个主要是为了将每次的更新成果实时的告诉客户，由于客户工作繁忙,很难做到随时了解到有关项目进展的详细情况,所以他会更加注重更新的结果。有时会出现这样的情况，我们的工作人员把系统进行了更新，但由于没告诉此次更新的具体内容，使客户对系统的更新情况不了解，这时最好的做法就是实时告诉客户每次工作的具体内容。让客户对项目整体运行情况有了很好的了解,做到真正以客户为第一服务对象的宗旨。三、实时从客户那里获取最新的意见这个主要是涉及到系统具体的功能，比如在跟客户交流的时候他说要实现某一功能，但是按照我们的思维去思考的话总是从技术角度出发去考虑，这样与客户交流回来后进行系统更新时就会出现偏差，导致进行了不必要的额外的工作，想要避免这样的情况，就要认真听取客户的意见，并把自己的理解讲给对方听，直到能够确实准确的把握客户的需求，这样每次做的工作才能满足客户的最大需求。维护工作本身也是学习的过程，在实践中总结经验，实时获取客户最新意见充分了解系统的优缺点，每次都做好更新计划和实时步骤以及更新成果，让琐碎的维护工作变得生动，有趣。",2014/12/29
510,遇到女神应该使用什么样的暗恋思维,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8776,此文章是从网上看的，个人感觉蛮有意思，故分享下。。。。。。这是一年前的回忆~~~~一个是隔壁邻居家儿子，一个是同事的儿子。前者很腼腆，后者很开朗。最近他们都遇到了同一个问题：暗恋上了班上的女生。（我很八卦，请原谅）不知道大家上学时候（我们从初中开始算吧，别告诉我小学大家就开始暗恋的节奏了）有没有这种情况。暗恋有什么特征，我来总结一下：1、对方如果就在你的小宇宙范围内，你会突然觉得自己很帅2、排队时会有意站对方很近，有时还会故意蹭她一下，简称“卡油”3、对方如果不小心余光扫到你，你立马会觉得对方“对你有意思”4、在楼道里不期而遇，你的心脏会猛跳几下，肾上腺素猛增0.5克5、晚上做梦会梦到她，然后你懂的。。。。。6、其他各种自我心理暗示、自以为是的感觉，不一一赘述。总之，上学时候有个暗恋对象还是很美好的，不一定要点破。往往会让你觉得这个世界有些朦朦胧胧的东西值得你去追求、值得你去为它放弃一切。很不幸，同事的儿子前段时间跟他的女神表白了，结果被直挺挺的拒绝，这厮沮丧出了翔。不过，没几天他就恢复了昔日的风采，他告诉我他正在做两手准备，1）找时机再次和女神表白一次，如果再被拒就算了，天涯何处无芳草2）他最近物色了另外一个女神做他的暗恋对象，等到时机成熟他打算向新女神表白，当然前提是要在“旧“女神没有拒绝他的情况下。再次很不辛的是邻居家的儿子对于“表白”二字想都不敢想，他经常做的就是“晚上和女神在梦境中相遇”，结果这厮身体一直很虚。我在QQ上问他”是否坚持下去？“，这厮在ＱＱ上给了我一个”雅蠛蝶“的表情，表示此生非女神不嫁。我为此做了一个无厘头的判定：邻居的儿子将来很可能成为一个优秀的技术人员；同事的儿子适合做项目总监。。。。。。我上学时也有个暗恋对象，女神长的并不特别好看，但是皮肤很白很滑、成绩拔尖、骑的自行车很新。所以有时我也搞不清楚“暗恋“的感觉到底是怎么产生的，人类就是一个奇怪的种族，很任性。当时老师经常要求我们作文：将来长大后要干什么？，这种命题的作文是我个人认为培养祖国花朵”学会诈骗“的来源，当时很多同学信誓旦旦说将来要成为：1、工程师2、科学家3、园丁4、工人5、教导主任6、为人类造福的企业家7、不收红包的医生8、以及其他各种只奉献不求回报的工种和岗位。我当时不知道是不是只有我一个人心里想的是：成为什么样的人不重要，重要的如何女神追到手。从此摆脱“暗恋“，以防夜长“梦”多。因为女神数学不怎么给力，而数学对我来说不是难事，我在原有基础上疯狂恶补数学、并时不时用大学高数知识来解题，使得在某一次考试中我以全校第一的成绩脱颖而出，然后在一次辅导女神做题的时候“略施小计“，竟然赢得了女神的“芳心“，注意，那个年代学校基本停留在”精神恋爱“，你懂得。（细节不表，由于篇幅）这里我总结一下：1、女神虽然各方面都很白、很滑、很新，但是她还是有软肋的，在那时就是她的数学。2、如果我直挺挺的向女神表白，恐怕99.9%被拒，然后接下来整天郁郁寡欢、以泪洗面，直至成为废物。3、任何一个女神、客户、还是老板或领导，有三要素很重要1）软肋2）同好3)布局，其中最后一个很重要，同时一个好的布局需要你以“超出常人“很多倍的努力来达到，这叫良性布局，而不是”坑蒙拐骗”。。。。。。。。。最后我再写下几个个人观点，不喜勿喷：1、如果你和我邻居家儿子类似，那么做一个“雅蠛蝶”的技术人员做到极致也是一条路2、如果你和我同事的儿子类似，那么你应该努力往商务人员上靠，“雅蠛蝶”不适合你。脚踏N船有时候也是一种模式，但注意要有顺序和前因后果，要有节操、要有思维。3、如果你和我一样，很可能你比较适合在职场中打拼，并最后以技术杀出一条道然后转型商务，这个过程靠的是耐心和自我包装。4、如果以上都不是，要么很可能未来的马云就是你，要么你就得拿出行动来，停留在“暗恋”这个层次很累、很虚，0.5克的肾上腺素真的维持不了多久。,2014/12/29
511,页面规范,孟帅,http://180.168.156.212:2262/wecenter/?/article/8772,很多时候，我们发现项目中书写的html代码都是杂乱无序的，可能是因为我们对这些规范不熟悉，或者说是我们队这些规范不够重视，但是在这个并不仅仅是ie浏览器一家独大的情况下我们需要对html的书写规范有足够的重视，下面就引用一段bootstrap的一些代码书写规范，分别在css、js、html等相关方面的一些规范和说明以下为链接： /#html-syntax,2014/12/29
512,页面布局,孟帅,http://180.168.156.212:2262/wecenter/?/article/8771,闲暇时间发现的一个非常好用的页面布局网站，能够实现基本css、组件、交互组件的拖拽和布局，是支持bootstrap组件的网站，做的确实不错，也给组件库带来了一些开发灵感支持bootstrap2和bootstrap3这里是bootstrap2的示例附上链接： /p/layoutit/,2014/12/29
513,Material Design,孟帅,http://180.168.156.212:2262/wecenter/?/article/8770,我们挑战自我，为用户创造了崭新的视觉设计语言。与此同时，新的设计语言除了遵循经典设计定则，还汲取了最新的科技，秉承了创新的设计理念。这就是原质化设计(MaterialDesign)。这份文档是动态更新的，将会随着我们对MaterialDesign的探索而不断迭代、升级。这是引自MaterialDesign的文档概述，是谷歌推出了全新的设计语言MaterialDesign。谷歌表示，这种设计语言旨在为手机、平板电脑、台式机和“其他平台”提供更一致、更广泛的“外观和感觉”MaterialDesign语言的一些重要功能包括系统字体Roboto的升级版本，同时颜色更鲜艳，动画效果更突出试想着，如果组件库能推出这么“一款”语言，愿景总是好的！谷歌浏览器支持此链接！非谷歌浏览器可能看不到目录 ,2014/12/29
514,js性能优化,孟帅,http://180.168.156.212:2262/wecenter/?/article/8767,"在我们开发互联网富应用（RIA）时，我们经常写一些javascript脚本来修改或者增加页面元素，这些工作最终是DOM——或者说文档对象模型——来完成的，而我们的实现方式会影响到应用的响应速度。DOM操作会导致浏览器重解析(reflow)，这是浏览器的一个决定页面元素如何展现的计算过程。直接修改DOM，修改元素的CSS样式，修改浏览器的窗口大小，都会触发重解析。读取元素的布局属性比如offsetHeithe或者offsetWidth也会触发重解析。重解析需要花费计算时间，因此重解析触发的越少，应用就会越快。DOM操作通常要不就是修改已经存在的页面上的元素，要不就是创建新的页面元素。下面的4种优化方案覆盖了修改和创建DOM节点两种方式，帮助你减少触发浏览器重解析的次数。方案一：通过CSS类名切换来修改DOM这个方案让我们可以一次性修改一个元素和它的子元素的多个样式属性而只触发一次重解析。需求：（emu注：原文作者写到这里的时候脑子显然短路了一下，把后面的Out-of-the-flowDOMManipulation模式要解决的问题给摆到这里来了，不过从示范代码中很容易明白作者真正想描述的问题，因此emu就不照翻原文了）我们现在需要写一个函数来修改一个超链接的几个样式规则。要实现很简单，把这几个规则对应的属性逐一改了就好了。但是带来的问题是，每修改一个样式属性，都会导致一次页面的重解析。functionselectAnchor(element){element.style.fontWeight='bold';element.style.textDecoration='none';element.style.color='#000';}解决方案：要解决这个问题，我们可以先创建一个样式名，并且把要修改的样式规则都放到这个类名上，然后我们给超链接添加上这个新类名，就可以实现添加几个样式规则而只触发一次重解析了。这个模式还有个好处是也实现了表现和逻辑相分离。.selectedAnchor{font-weight:bold;text-decoration:none;color:#000;}functionselectAnchor(element){element.className='selectedAnchor';}方案二：在非渲染区修改DOM（emu注：作者在这里再次脑子短路，把DocumentFragmentDOMGeneration模式的介绍提前到这里来了，emu只好再次发挥一下）上一个方案解决的是修改一个超链接的问题，当一次需要对很多个超链接进行相同修改的时候，这个方案就可以大显身手了。需求：需求是这样的，我们要写一个函数来修改一个指定元素的子元素中所有的超链接的样式名（className）属性。要实现很简单，我们可以通过遍历每个超链接并且修改它们的样式名来完成任务。但是带来的问题就是，每修改一个超链接都会导致一次重解析。functionupdateAllAnchors(element,anchorClass){varanchors=element.getElementsByTagName('a');for(vari=0,length=anchors.length;i<length;i++){anchors[i].className=anchorClass;}}解决方案：要解决这个问题，我们可以把被修改的指定元素从DOM里面移除，再修改所有的超链接，然后在把这个元素插入回到它原来的位置上。为了完成这个复杂的操作，我们可以先写一个可重用的函数，它不但移除了这个DOM节点，还返回了一个把元素插回到原来的位置的函数。/***Removeanelementandprovideafunctionthatinsertsitintoitsoriginalposition*@paramelement{Element}Theelementtobetemporarilyremoved*@return{Function}Afunctionthatinsertstheelementintoitsoriginalposition**/functionremoveToInsertLater(element){varparentNode=element.parentNode;varnextSibling=element.nextSibling;parentNode.removeChild(element);returnfunction(){if(nextSibling){parentNode.insertBefore(element,nextSibling);}else{parentNode.appendChild(element);}};}有了上面这个函数，现在我们就可以在一个不需要解析渲染的元素上面修改那些超链接了。这样只在移除和插入元素的时候各触发一次重解析。functionupdateAllAnchors(element,anchorClass){varinsertFunction=removeToInsertLater(element);varanchors=element.getElementsByTagName('a');for(vari=0,length=anchors.length;i<length;i++){anchors[i].className=anchorClass;}insertFunction();}方案三：一次性的DOM元素生成这个方案让我们创建一个元素的过程只触发一次重解析。在创建完元素以后，先进行所有需要的修改，最后才把它插入到DOM里面去就可以了需求：需求是这样的，实现一个函数，往一个指定的父元素上插入一个超链接元素。这个函数要同时可以设置这个超链接的显示文字和样式类。我们可以这样做：创建元素，插入到DOM里面，然后设置相应的属性。这就要触发3次重解析。functionaddAnchor(parentElement,anchorText,anchorClass){varelement=document.createElement('a');parentElement.appendChild(element);element.innerHTML=anchorText;element.className=anchorClass;}解决方案：很简单，我们只要把插入元素这个操作放到最后做，就可以只进行一次重解析了。functionaddAnchor(parentElement,anchorText,anchorClass){varelement=document.createElement('a');element.innerHTML=anchorText;element.className=anchorClass;parentElement.appendChild(element);}不过，要是我们想要插入很多个超链接到一个元素里面的话，那么这个做法还是有问题：每插入一个超链接还是要触发一次重解析。下一个方案可以解决这个问题。方案四：通过文档片段对象（DocumentFragment）创建一组元素这个方案允许我们创建并插入很多个元素而只触发一次重解析。要实现这点需要用到所谓的文档片段对象（DocumentFragment）。我们先在DOM之外创建一个文档片段对象（这样它也就不需要解析和渲染），然后我们在文档片段对象中创建很多个元素，最后我们把这个文档片段对象中所有的元素一次性放到DOM里面去，只触发一次重解析。需求：我们要写一个函数，往一个指定的元素上面增加10个超链接。如果我们简单的直接插入10个超链接到元素上面，就会触发10次重解析。functionaddAnchors(element){varanchor;for(vari=0;i<10;i++){anchor=document.createElement('a');anchor.innerHTML='test';element.appendChild(anchor);}}解决方案：要解决这个问题，我们要先创建一个文档片段对象，然后把每个新创建的超链接都插入到它里面去。当我们把文档片段对象用appendChild命令插入到指定的节点时，这个文档片段对象的所有子节点就一起被插入到指定的元素里面，而且只需要触发一次重解析。functionaddAnchors(element){varanchor,fragment=document.createDocumentFragment();for(vari=0;i<10;i++){anchor=document.createElement('a');anchor.innerHTML='test';fragment.appendChild(anchor);}element.appendChild(fragment);}",2014/12/29
515,Data URL,孟帅,http://180.168.156.212:2262/wecenter/?/article/8769,"DataURL给了我们一种很巧妙的将图片“嵌入”到HTML中的方法。跟传统的用img标记将服务器上的图片引用到页面中的方式不一样，在DataURL协议中，图片被转换成base64编码的字符串形式，并存储在URL中，冠以mime-type。本文中，我将介绍如何巧妙的使用DataURL优化网站加载速度和执行效率。DataURL基本原理为什么DataURL是个好东西在CSS里使用DataURL将图片转换成DataURL格式DataURL总结观看演示1.DataURL基本原理图片在网页中的使用方法通常是下面这种利用img标记的形式：<imgsrc=""images/myimage.gif"">这种方式中，img标记的src属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用DataURL技术，图片数据以base64字符串格式嵌入到了页面中，与HTML成为一体，它的形式如下：<imgsrc=""data:image/gif;base64,R0lGODlhMwAxAIAAAAAAAP///yH5BAAAAAAALAAAAAAzADEAAAK8jI+pBr0PowytzotTtbm/DTqQ6C3hGXElcraA9jIr66ozVpM3nseUvYP1UEHF0FUUHkNJxhLZfEJNvol06tzwrgdLbXsFZYmSMPnHLB+zNJFbq15+SOf50+6rG7lKOjwV1ibGdhHYRVYVJ9Wnk2HWtLdIWMSH9lfyODZoZTb4xdnpxQSEF9oyOWIqp6gaI9pI1Qo7BijbFZkoaAtEeiiLeKn72xM7vMZofJy8zJys2UxsCT3kO229LH1tXAAAOw=="">从上面的base64字符串中你看不出任何跟图片相关的东西，但下面，我们将传统的img写法和现在的DataURL用法左右对比显示，你就能看出它们是完全一样的效果。但实际上它们是不一样的，它们一个是引用了外部资源，一个是使用了DataURL。几乎所有的现代浏览器都支持DataURL格式，包括火狐浏览器，谷歌浏览器，Safari浏览器，opera浏览器。IE8也支持，但有部分限制，IE9完全支持。2.为什么DataURL是个好东西DataURL能用在很多场合，跟传统的外部资源引用方式相比，它有如下独到的用处：当访问外部资源很麻烦或受限时当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时。当图片的体积太小，占用一个HTTP会话不是很值得时。DataURL也有一些不适用的场合Base64编码的数据体积通常是原数据的体积4/3，也就是DataURL形式的图片会比二进制格式的图片体积大1/3。DataURL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。然而，DataURL这些不利的地方完全可以避免或转化。本文的重点就是要讨论这个问题。3.在CSS里使用DataURL当第一次看到DataURL的作用和用法时，你也许会很不疑惑，“为什么要麻烦的将图片转换成base64编码字符串，还要嵌入的网页中，将HTML代码弄的混乱不堪，甚至还会有性能上的问题。”诚然，无法否认缓存在浏览器性能中的重要作用——如何能将DataURL数据也放入浏览器缓存中呢？答案是：通过CSS样式文件。CSS中的url操作符是用来指定网页元素的背景图片的，而浏览器并不在意URL里写的是什么——只要能通过它获取需要的数据。所以，我们就有了可以将DataURL形式的图片存储在CSS样式表中的可能。而所有浏览器都会积极的缓存CSS文件来提高页面加载效率。假设我们的页面里有一个很小的div元素，我们想用一种灰色的斜纹图案做它的背景，这种背景在当今的网站设计者中非常流行。传统的方法是制作一个3×3像素的图片，保存成GIF或PNG格式，然后在CSS的background-image属性中引用它的地址。而DataURL则是一种更高效的替代方法，就像下面这样。下面是CSS代码：.striped_box{width:100px;height:100px;background-image:url(""data:image/gif;base64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7"");border:1pxsolidgray;padding:10px;}在我们的HTML里放入下面的代码：<divclass=""striped_box"">这是一个有条纹的方块</div>实际输出效果就是下面这样这是一个有条纹的方块在这个例子中，DataURL的使用是完全符合场景的。它避免了让这个小小的背景图片独自产生一次HTTP请求，而且，这个小图片还能同CSS文件一起被浏览器缓存起来，重复使用，不会每次使用时都加载一次。只要这个图片不是很大，而且不是在CSS文件里反复使用，就可以以DataURL方法呈现图片降低页面的加载时间，改善用户的浏览体验。观看演示4.将图片转换成DataURL格式的方法用DataURL来展示图片的例子以及它的好处我们说完了，下面我们转入下一个问题，如何将图片转换成Base64编码的字符串。其实网上有很多工具都可以使用，下面列举了几个。其中一个是在线工具，一个MacOSX桌面应用。DataURLMaker在线工具DataURLMakerMacOSX桌面DataURL总结IE6/7是不支持DataURL技术的，不幸的是在中国还有很多用户在使用这种古老的浏览器。希望各方面包括官方和民间都多做努力工作，让现代浏览器(谷歌浏览器，火狐浏览器，IE11+)尽快的占领市场，这是我们Web程序员最大的愿望。",2014/12/29
516,Hibernate的session管理,张建涛,http://180.168.156.212:2262/wecenter/?/article/8768,"在利用Hibernate开发DAO模块时，我们和Session打的交道最多，所以如何合理的管理Session，避免Session的频繁创建和销毁，对于提高系统的性能来说是非常重要的，以往是通过eclipse的插件来自动完成这些代码的，当然效果是不错的，但是总是觉得不爽(没有读懂那些冗长的代码)，所以现在打算自己实现Session管理的代码。我们知道Session是由SessionFactory负责创建的，而SessionFactory的实现是线程安全的，多个并发的线程可以同时访问一个SessionFactory并从中获取Session实例，那么Session是否是线程安全的呢？很遗憾，答案是否定的。Session中包含了数据库操作相关的状态信息，那么说如果多个线程同时使用一个Session实例进行CRUD，就很有可能导致数据存取的混乱，你能够想像那些你根本不能预测执行顺序的线程对你的一条记录进行操作的情形吗？在Session的众多管理方案中，我们今天来认识一种名ThreadLocal模式的解决方案。早在Java1.2推出之时，Java平台中就引入了一个新的支持：java.lang.ThreadLocal，给我们在编写多线程程序时提供了一种新的选择。ThreadLocal是什么呢？其实ThreadLocal并非是一个线程的本地实现版本，它并不是一个Thread，而是threadlocalvariable(线程局部变量)。也许把它命名为ThreadLocalVar更加合适。线程局部变量(ThreadLocal)其实的功用非常简单，就是为每一个使用某变量的线程都提供一个该变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有一个该变量。ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单，在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。比如下面的示例实现(为了简单，没有考虑集合的泛型)：publicclassThreadLocal{privateMapvalues=Collections.synchronizedMap(newHashMap());publicObjectget(){ThreadcurrentThread=Thread.currentThread();Objectresult=values.get(currentThread);if(result==null&&!values.containsKey(currentThread)){result=initialValue();values.put(currentThread,result);}returnresult;}publicvoidset(ObjectnewValue){values.put(Thread.currentThread(),newValue);}publicObjectinitialValue(){returnnull;}}那麽具体如何利用ThreadLocal来管理Session呢？Hibernate官方文档手册的示例之中，提供了一个通过ThreadLocal维护Session的好榜样：publicclassHibernateUtil{publicstaticfinalSessionFactorysessionFactory;static{try{sessionFactory=newConfiguration().configure().buildSessionFactory();}catch(Throwableex){thrownewExceptionInInitializerError(ex);}}publicstaticfinalThreadLocal<Session>session=newThreadLocal<Session>();publicstaticSessioncurrentSession()throwsHibernateException{Sessions=session.get();if(s==null){s=sessionFactory.openSession();session.set(s);}returns;}publicstaticvoidcloseSession()throwsHibernateException{Sessions=session.get();if(s!=null){s.close();}session.set(null);}}只要借助上面的工具类获取Session实例，我们就可以实现线程范围内的Session共享，从而避免了线程中频繁的创建和销毁Session实例。当然，不要忘记在用完后关闭Session。写到这里，想再多说一些，也许大多数时候我们的DAO并不会涉及到多线程的情形，比如我们不会将DAO的代码写在Servlet之中，那样不是良好的设计，我自己通常会在service层的代码里访问DAO的方法。",2014/12/29
517,IE 和 Firefox 的 Javascript兼容性总结,李海波,http://180.168.156.212:2262/wecenter/?/article/8766,"长久以来JavaScript兼容性一直是Web开发者的一个主要问题。在正式规范、事实标准以及各种实现之间的存在的差异让许多开发者日夜煎熬。为此，主要从以下几方面差异总结IE和Firefox的Javascript兼容性:一、函数和方法差异；二、样式访问和设置；三、DOM方法及对象引用；四、事件处理；五、其他差异的兼容处理。一、函数和方法差异1.getYear()方法【分析说明】先看一下以下代码：varyear=newDate().getYear();document.write(year);在IE中得到的日期是""2010""，在Firefox中看到的日期是""110""，主要是因为在Firefox里面getYear返回的是""当前年份-1900""的值。【兼容处理】加上对年份的判断，如:varyear=newDate().getYear();year=(year<1900?(1900+year):year);document.write(year);也可以通过getFullYeargetUTCFullYear去调用:varyear=newDate().getFullYear();document.write(year);2.eval()函数【分析说明】在IE中，可以使用eval(""idName"")或getElementById(""idName"")来取得id为idName的HTML对象；Firefox下只能使用getElementById(""idName"")来取得id为idName的HTML对象。【兼容处理】统一用getElementById(""idName"")来取得id为idName的HTML对象。3.const声明【分析说明】在IE中不能使用const关键字。如：constconstVar=32;在IE中这是语法错误。【兼容处理】不使用const，以var代替。4.var【分析说明】请看以下代码：echo=function(str){document.write(str);}pre>这个函数在IE上运行正常，Firefox下却报错了。【兼容处理】而在echo前加上var就正常了，这个就是我们提到var的目的。5.const问题【分析说明】在IE中不能使用const关键字。如constconstVar=32;在IE中这是语法错误。【解决方法】不使用const，以var代替。二、样式访问和设置1.CSS的""float""属性【分析说明】Javascript访问一个给定CSS值的最基本句法是：object.style.property，但部分CSS属性跟Javascript中的保留字命名相同，如""float""，""for""，""class""等，不同浏览器写法不同。在IE中这样写：document.getElementById(""header"").style.styleFloat=""left"";在Firefox中这样写：document.getElementById(""header"").style.cssFloat=""left"";【兼容处理】在写之前加一个判断，判断浏览器是否是IE：if(document.all){document.getElementById(""header"").style.styleFloat=""left"";}else{document.getElementById(""header"").style.cssFloat=""left"";}2.访问<label>标签中的""for""【分析说明】和""float""属性一样，同样需要使用不现的句法区分来访问<label>标签中的""for""。在IE中这样写：varmyObject=document.getElementById(""myLabel"");varmyAttribute=myObject.getAttribute(""htmlFor"");在Firefox中这样写：varmyObject=document.getElementById(""myLabel"");varmyAttribute=myObject.getAttribute(""for"");【兼容处理】解决的方法也是先判断浏览器类型。3.访问和设置class属性【分析说明】同样由于class是Javascript保留字的原因，这两种浏览器使用不同的JavaScript方法来获取这个属性。IE8.0之前的所有IE版本的写法：varmyObject=document.getElementById(""header"");varmyAttribute=myObject.getAttribute(""className"");适用于IE8.0以及firefox的写法：varmyObject=document.getElementById(""header"");varmyAttribute=myObject.getAttribute(""class"");另外，在使用setAttribute()设置Class属性的时候，两种浏览器也存在同样的差异。setAttribute(""className"",value);这种写法适用于IE8.0之前的所有IE版本，注意：IE8.0也不支持""className""属性了。setAttribute(""class"",value);适用于IE8.0以及firefox。【兼容处理】方法一，两种都写上：varmyObject=document.getElementById(""header"");myObject.setAttribute(""class"",""classValue"");myObject.setAttribute(""className"",""classValue"");//设置header的class为classValue方法二，IE和FF都支持object.className，所以可以这样写：varmyObject=document.getElementById(""header"");myObject.className=""classValue"";//设置header的class为classValue方法三，先判断浏览器类型，再根据浏览器类型采用对应的写法。4.对象宽高赋值问题【分析说明】FireFox中类似obj.style.height=imgObj.height的语句无效。【兼容处理】统一使用obj.style.height=imgObj.height+‘px’;三、DOM方法及对象引用1.getElementById【分析说明】先来看一组代码：<!--input对象访问1--><inputid=""id""type=""button""value=""clickme""ōnclick=""alert(id.value)""/>在Firefox中，按钮没反应，在IE中，就可以，因为对于IE来说，一个HTML元素的ID可以直接在脚本中当作变量名来使用，而Firefox中不可以。【兼容处理】尽量采用W3CDOM的写法，访问对象的时候，用document.getElementById(""id"")以ID来访问对象，且一个ID在页面中必须是唯一的，同样在以标签名来访问对象的时候，用document.getElementsByTagName(""div"")[0]。该方式得到较多浏览器的支持。<!--input对象访问2--><inputid=""id""type=""button""value=""clickme""onclick=""alert(document.getElementById('id').value)""/>2.集合类对象访问【分析说明】IE下，可以使用()或[]获取集合类对象；Firefox下，只能使用[]获取集合类对象。如：document.write(document.forms(""formName"").src);//该写法在IE下能访问到Form对象的scrc属性【兼容处理】将document.forms(""formName"")改为document.forms[""formName""]。统一使用[]获取集合类对象。3.frame的引用【分析说明】IE可以通过id或者name访问这个frame对应的window对象，而Firefox只可以通过name来访问这个frame对应的window对象。例如如果上述frame标签写在最上层的window里面的htm里面，那么可以这样访问：IE：window.top.frameId或者window.top.frameName来访问这个window对象；Firefox：只能这样window.top.frameName来访问这个window对象。【兼容处理】使用frame的name来访问frame对象，另外，在IE和Firefox中都可以使用window.document.getElementById(”frameId”)来访问这个frame对象。4.parentElement【分析说明】IE中支持使用parentElement和parentNode获取父节点。而Firefox只可以使用parentNode。【兼容处理】因为firefox与IE都支持DOM，因此统一使用parentNode来访问父节点。5.table操作【分析说明】IE下table中无论是用innerHTML还是appendChild插入<tr>都没有效果，而其他浏览器却显示正常。【兼容处理】解决的方法是，将<tr>加到table的<tbody>元素中，如下面所示：varrow=document.createElement(""tr"");varcell=document.createElement(""td"");varcell_text=document.createTextNode(""插入的内容"");cell.appendChild(cell_text);row.appendChild(cell);document.getElementsByTagName(""tbody"")[0].appendChild(row);6.移除节点removeNode()和removeChild()【分析说明】appendNode在IE和Firefox下都能正常使用，但是removeNode只能在IE下用。removeNode方法的功能是删除一个节点，语法为node.removeNode（false）或者node.removeNode（true），返回值是被删除的节点。removeNode（false）表示仅仅删除指定节点，然后这个节点的原孩子节点提升为原双亲节点的孩子节点。removeNode（true）表示删除指定节点及其所有下属节点。被删除的节点成为了孤立节点，不再具有有孩子节点和双亲节点。【兼容处理】Firefox中节点没有removeNode方法，只能用removeChild方法代替，先回到父节点，在从父节点上移除要移除的节点。node.parentNode.removeChild(node);//为了在ie和firefox下都能正常使用，取上一层的父结点，然后remove。7.childNodes获取的节点【分析说明】childNodes的下标的含义在IE和Firefox中不同，看一下下面的代码：<ulid=""main""><li>1</li><li>2</li><li>3</li></ul><inputtype=buttonvalue=""clickme!""onclick=""alert(document.getElementById('main').childNodes.length)"">分别用IE和Firefox运行，IE的结果是3，而Firefox则是7。Firefox使用DOM规范，""#text""表示文本（实际是无意义的空格和换行等）在Firefox里也会被解析成一个节点，在IE里只有有实际意义的文本才会解析成""#text""。【兼容处理】方法一，获取子节点时，可以通过node.getElementsByTagName()来回避这个问题。但是getElementsByTagName对复杂的DOM结构遍历明显不如用childNodes，因为childNodes能更好的处理DOM的层次结构。方法二，在实际运用中，Firefox在遍历子节点时，不妨在for循环里加上：if(childNode.nodeName==""#text"")continue;//或者使用nodeType==1。这样可以跳过一些文本节点。延伸阅读《IE和FireFox中的childNodes区别》8.Firefox不能对innerText支持【分析说明】Firefox不支持innerText，它支持textContent来实现innerText，不过textContent没有像innerText一样考虑元素的display方式，所以不完全与IE兼容。如果不用textContent，字符串里面不包含HTML代码也可以用innerHTML代替。也可以用js写个方法实现，可参考《为firefox实现innerText属性》一文。【兼容处理】通过判断浏览器类型来兼容：if(document.all){document.getElementById('element').innerText=""mytext"";}else{document.getElementById('element').textContent=""mytext"";}四、事件处理如果在使用javascript的时候涉及到event处理，就需要知道event在不同的浏览器中的差异，主要的JavaScript的事件模型有三种（参考《SupportingThreeEventModelsatOnce》），它们分别是NN4、IE4+和W3C/Safar。1.window.event【分析说明】先看一段代码functionet(){alert(event);//IE:[object]}以上代码在IE运行的结果是[object]，而在Firefox无法运行。因为在IE中event作为window对象的一个属性可以直接使用，但是在Firefox中却使用了W3C的模型，它是通过传参的方法来传播事件的，也就是说你需要为你的函数提供一个事件响应的接口。【兼容处理】添加对event判断，根据浏览器的不同来得到正确的event：functionet(){evt=evt?evt:(window.event?window.event:null);//兼容IE和Firefoxalert(evt);}2.键盘值的取得【分析说明】IE和Firefox获取键盘值的方法不同，可以理解，Firefox下的event.which与IE下的event.keyCode相当。关于彼此不同，可参考《键盘事件中keyCode、which和charCode的兼容性测试》【兼容处理】functionmyKeyPress(evt){//兼容IE和Firefox获得keyBoardEvent对象evt=(evt)?evt:((window.event)?window.event:"""")//兼容IE和Firefox获得keyBoardEvent对象的键值varkey=evt.keyCode?evt.keyCode:evt.which;if(evt.ctrlKey&&(key==13||key==10)){//同时按下了Ctrl和回车键//dosomething;}}3.事件源的获取【分析说明】在使用事件委托的时候，通过事件源获取来判断事件到底来自哪个元素，但是，在IE下，event对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。【兼容处理】ele=function(evt){//捕获当前事件作用的对象evt=evt||window.event;return(obj=event.srcElement?event.srcElement:event.target;);}4.事件监听【分析说明】在事件监听处理方面，IE提供了attachEvent和detachEvent两个接口，而Firefox提供的是addEventListener和removeEventListener。【兼容处理】最简单的兼容性处理就是封装这两套接口：functionaddEvent(elem,eventName,handler){if(elem.attachEvent){elem.attachEvent(""on""+eventName,function(){handler.call(elem)});//此处使用回调函数call()，让this指向elem}elseif(elem.addEventListener){elem.addEventListener(eventName,handler,false);}}functionremoveEvent(elem,eventName,handler){if(elem.detachEvent){elem.detachEvent(""on""+eventName,function(){handler.call(elem)});//此处使用回调函数call()，让this指向elem}elseif(elem.removeEventListener){elem.removeEventListener(eventName,handler,false);}}需要特别注意，Firefox下，事件处理函数中的this指向被监听元素本身，而在IE下则不然,可使用回调函数call，让当前上下文指向监听的元素。5.鼠标位置【分析说明】IE下，even对象有x，y属性，但是没有pageX，pageY属性；Firefox下，even对象有pageX，pageY属性，但是没有x，y属性。【兼容处理】使用mX(mX=event.x?event.x:event.pageX;)来代替IE下的event.x或者Firefox下的event.pageX。复杂点还要考虑绝对位置。functiongetAbsPoint(e){varx=e.offsetLeft,y=e.offsetTop;while(e=e.offsetParent){x+=e.offsetLeft;y+=e.offsetTop;}alert(""x:""+x+"",""+""y:""+y);}五、其他差异的兼容处理1.XMLHttpRequest【分析说明】newActiveXObject(""Microsoft.XMLHTTP"");只在IE中起作用，Firefox不支持，但支持XMLHttpRequest。【兼容处理】functioncreateXHR(){varxhr=null;if(window.XMLHttpRequest){xhr=newActiveXObject(""Msxml2.XMLHTTP"");}else{try{xhr=newActiveXObject(""Microsoft.XMLHTTP"");}catch(){xhr=null;}}if(!xhr)return;returnxhr;}2.模态和非模态窗口【分析说明】IE中可以通过showModalDialog和showModelessDialog打开模态和非模态窗口，但是Firefox不支持。【解决办法】直接使用window.open(pageURL,name,parameters)方式打开新窗口。如果需要传递参数，可以使用frame或者iframe。3.input.type属性问题IE下input.type属性为只读，但是Firefox下可以修改4.对select元素的option操作设置options，IE和Firefox写法不同：Firefox:可直接设置option.text='foooooooo';IE:只能设置option.innerHTML='fooooooo';删除一个select的option的方法：Firefox:可以select.options.remove(selectedIndex);IE7:可以用select.options=null;IE6:需要写select.options.outerHTML=null;5.img对象alt和title的解析【分析说明】img对象有alt和title两个属性，区别在于，alt：当照片不存在或者load错误时的提示。title：照片的tip说明,在IE中如果没有定义title，alt也可以作为img的tip使用，但是在Firefox中，两者完全按照标准中的定义使用在定义img对象时。【兼容处理】最好将alt和title对象都写全，保证在各种浏览器中都能正常使用。6.img的src刷新问题【分析说明】先看一下代码：<imgid=""pic""onclick=""this.src='a.jpg'""src=""aa.jpg""style=""cursor:pointer""/>在IE下，这段代码可以用来刷新图片，但在FireFox下不行。主要是缓存问题。【兼容处理】在地址后面加个随机数就解决了:<imgid=""pic""onclick=""javascript:this.src=this.src+'?'+Math.random()""src=""a.jpg""style=""cursor:pointer""/>",2014/12/29
518,JavaScript 拼音搜索引擎,李海波,http://180.168.156.212:2262/wecenter/?/article/8765,"一、遇到问题在组件库4.0维护当中，有一个需求是，tree组件支持拼音搜索过滤。一般的拼音搜索，是对本地缓存数据进行拼音匹配，用户在输入拼音关键字，以便找到匹配的项。这个功能，相信在很多项目中都会用到，因此共享给大家一个解决方案思路。二、分析问题具体的需求，就是，在输入框中输入拼音关键字，如“jiedian11”，则能匹配类如“节点11，节点111”等节点，并将之过滤出来，而不能匹配的节点则隐藏。三、搜索解决方案按照这个需求，以及分析所要求的解决问题，在网上搜索关键字“拼音搜索”，则搜索到一个拼音搜索引擎框架。pinyinEngine0.1.zip附件可供了解更多。下面介绍这个拼音搜索引擎的具体用法。四、拼音搜索引擎使用方法引入js文件：<scriptsrc=""pinyinData.js""></script><scriptsrc=""pinyinEngine.js""></script>初始化引擎：varengine=newpinyinEngine();创建索引缓存：vardata=[{id:”001”,content:”数据1”},{id:”002”,content:”数据2”},{…}];for(variindata){//@param{Array}标签//@param{Any}被索引的内容engine.setCache([data[i].id],data[i]);};关键字匹配，搜索匹配项结果集：varstrResult=“”;engine.search(keyword,function(data){str+=data.id+data.content+“\n”;});alert(strResult);五、项目引用时抽象成api上述是基本的用法，可以根据实际开发对其进行适当的抽象，以便更好地服务项目。比如，我们在开发时将之抽象成一个个api，开发的时候，只需要调用api，就可以实现。//初始化搜索引擎：_pinyinEngine:function(){returnnewpinyinEngine();}//创建key索引缓存，可循环创建不同key的索引，重复调用：_pinyinSetCache:function(engine,key,dataArr){for(variindataArr){//@param{Array}标签//@param{Any}被索引的内容engine.setCache([dataArr[i][key]],dataArr[i]);}returnengine;}//拼音搜索方法，获取匹配结果集：_pinyinSearch:function(engine,keyword,callback){vardataResult=[];engine.search(keyword,function(data){dataResult.push(data);});callback(dataResult);}//调用api：that._pinyinSearch(engine,keyword,function(dataFilter){//dataFilter为过滤后的结果集that.showNodes(dataFilter,{showParents:true});});pinyinEngine0.1.zip",2014/12/29
519,Mybatis的数据类型对应数据库字段类型的对应表,管俊,http://180.168.156.212:2262/wecenter/?/article/8764,"Mybatis中的parameterType或resultType经常需要给定一个数据类型的完整包路径.其实一些常用的数据类型我们是可以用简写的.例如java.lang.Integer可以简写为int,附件是各种字段类型的对应表.MyBatis类型.png",2014/12/28
520,将java.util.Date转为java.sql.Date,管俊,http://180.168.156.212:2262/wecenter/?/article/8763,"在数据库里使用datetime类型或timestamp类型的字段,那么在java里对应使用java.sql.Date是最合适的.可是我们在java里有时候得到的经常是java.util.Date,那么如何将java.util.Date转换为java.sql.Date呢?以下的信息将会帮到你１、将java.util.Date转换为java.sql.Datejava.util.DateutilDate=newjava.util.Date();java.sql.DatesqlDate=newjava.sql.Date(utilDate.getTime());２、若要插入到数据库并且相应的字段为Date类型可使用PreparedStatement.setDate(int,java.sql.Date)方法其中的java.sql.Date可以用上面的方法得到也可以用数据库提供TO_DATE函数比如现有udTO_DATE(newSimpleDateFormat().format(ud,""yyyy-MM-ddHH:mm:ss""),""YYYY-MM-DDHH24:MI:SS"")注意java中表示格式和数据库提供的格式的不同sql=""updatetablenamesettimer=to_date('""+x+""','yyyymmddhh24miss')where.....""这里的x为变量为类似:20080522131223３、如何将""yyyy-mm-dd""格式的字符串转换为java.sql.Date方法１SimpleDateFormatbartDateFormat=newSimpleDateFormat(""yyyy-MM-dd"");StringdateStringToParse=""2007-7-12"";try{java.util.Datedate=bartDateFormat.parse(dateStringToParse);java.sql.DatesqlDate=newjava.sql.Date(date.getTime());System.out.println(sqlDate.getTime());}catch(Exceptionex){System.out.println(ex.getMessage());}",2014/12/28
521,自写: Java实现sqlServer中的datediff函数(计算两个时间的差),管俊,http://180.168.156.212:2262/wecenter/?/article/8762,"众所周知,SqlServer中的datediff函数非常好用,在计算两个时间的差时,只要调用该函数就可以得到两个时间的差,还能按照需要返回小时数/分钟数/秒数/天数/月数等.而JDK中没有自带那么好的函数,不过我们可以自写一个.下面是源代码.需要用到时直接copy走即可./***计算两个时间的相差值,可以计算相差的天数,年数,月份数,分钟数,秒数**@paramdateType计算时间差的类型:*{y:""年数"",M:""月数"",d:""天数"",h:""小时数"",m:""分钟数"",""s"":秒数}*也可写成双写的形式,例如yy,MM.注意:月份的M必须大写,分钟数的m必须小写.其余不区分大小写.*@paramstartDate开始时间*@paramendDate结束时间*@return(结束时间-开始时间)之间的dateType值*/publicstaticintdatediff(StringdateType,DatestartDate,DateendDate){/*求startDate与endDate之间相差的年数*/if(""y"".equalsIgnoreCase(dateType)||""yy"".equalsIgnoreCase(dateType)){Calendarcalendar=Calendar.getInstance();calendar.setTime(startDate);intstartYear=calendar.get(Calendar.YEAR);//当前年的年份calendar.setTime(endDate);intendYear=calendar.get(Calendar.YEAR);returnendYear-startYear;}/*求startDate与endDate之间相差的月份数*/if(""M"".equals(dateType)||""MM"".equals(dateType)){Calendarcalendar=Calendar.getInstance();calendar.setTime(startDate);intstartMonth=calendar.get(Calendar.MONTH)+calendar.get(Calendar.YEAR)*12;//月份=当前年的年份*12+当前年的月份,下同calendar.setTime(endDate);intendMonth=calendar.get(Calendar.MONTH)+calendar.get(Calendar.YEAR)*12;returnendMonth-startMonth;}/*求startDate与endDate之间相差的天数*/if(""d"".equalsIgnoreCase(dateType)||""dd"".equalsIgnoreCase(dateType)){longstartTime=startDate.getTime();longendTime=endDate.getTime();return(int)((endTime-startTime)/1000/60/60/24);//天数=(结束时间-开始时间)之间的毫秒数/(一天拥有的毫秒数)}/*求startDate与endDate之间相差的小时数*/if(""h"".equalsIgnoreCase(dateType)||""hh"".equalsIgnoreCase(dateType)){longstartTime=startDate.getTime();longendTime=endDate.getTime();return(int)((endTime-startTime)/1000/60/60);}/*求startDate与endDate之间相差的分钟数*/if(""m"".equals(dateType)||""mm"".equals(dateType)){longstartTime=startDate.getTime();longendTime=endDate.getTime();return(int)((endTime-startTime)/1000/60);}/*求startDate与endDate之间相差的秒数*/if(""s"".equalsIgnoreCase(dateType)||""ss"".equalsIgnoreCase(dateType)){longstartTime=startDate.getTime();longendTime=endDate.getTime();return(int)((endTime-startTime)/1000);}return0;}测试代码:importjava.util.Calendar;importjava.util.Date;publicclassTestDateDiff{publicstaticvoidmain(String[]args){Calendarcalendar=Calendar.getInstance();calendar.set(2014,Calendar.DECEMBER,25);DatestartDate=calendar.getTime();DateendDate=newDate();inthours=TestDateDiff.datediff(""h"",startDate,endDate);System.out.println(startDate);//2014-12-25System.out.println(endDate);//2014-12-26System.out.println(hours);}}测试结果:ThuDec2521:28:48CST2014FriDec2621:28:48CST201424",2014/12/26
522,SVN check out 和export的区别,陈博,http://180.168.156.212:2262/wecenter/?/article/8761,1.checkout跟checkin对应，export跟import对应2.checkout导出后的文件仍处于SVN版本控制，与版本库保持关联，这样就可以进行SVN的update和commit操作，在checkout导出的文件下有个.svn的隐藏文件夹，存储这个一些版本的信息3.import导出一个简单的版本数据，导出后不受SVN控制，修改后无法进行update和commit操作，导出的文件夹下面没有.svn的隐藏的文件夹,2014/12/26
523,POI文档操作总结,陈博,http://180.168.156.212:2262/wecenter/?/article/8760,POI文档操作方法POI文档操作总结.docx,2014/12/26
524,Scrum过程简单介绍PPT,钱江,http://180.168.156.212:2262/wecenter/?/article/8759,PPTScrum过程.ppt,2014/12/26
525,一本不错的linux书籍推荐给大家,钱江,http://180.168.156.212:2262/wecenter/?/article/8758,一本不错的Linux书籍推荐给大家tlcl-en-cn.pdf,2014/12/26
526,出现乱码的解决方法,陈博,http://180.168.156.212:2262/wecenter/?/article/8757,对于乱码的解决方法出现乱码的方法.docx,2014/12/26
527,tongweb优化下,沈文进,http://180.168.156.212:2262/wecenter/?/article/8756,Tongweb优化四步骤（以东方通5.0为例）：1:Java虚拟机jvm内存配置，分配更多的内存给tongweb使用在服务器环境变量中增加系统变量JAVA_OPTS参数名：JAVA_OPTS参数值：-Xms128m-Xmx256m2：修改tongserver.cmd文件，分配更多的内存给tongweb使用在东方通的安装目录TongWeb4.6\bin目录下参数配置setsetMEM_OPTS=-Xms256m-Xmx4096m-XX:PermSize=256m-XX:MaxPermSize=4096m3：修改teas.Properties文件，清楚tongweb启动时的多余服务，以达到tongweb启动加快，节省服务器内存和cpu占有率的目的在东方通安装目录TongWeb4.6\conf\ejb下参数名：teas.services保留服务jmxsecurityjtmdbm；其余的视情况可以删掉4：teas-web.xml，修改最大并发数，使应用可以适应一定数量的并发在目录TongWeb4.6\installed\temp\项目的war包名\WEB-INF下参数名：参数值：1200,2014/12/26
528,spring 的 和 的区别,陈博,http://180.168.156.212:2262/wecenter/?/article/8755,Spring的<context:annotation-config>和<context:component-scan>spring的contextannotation-config和contextcomponent-scan的区别.docx,2014/12/26
529,关于js的跨域访问问题,周敏,http://180.168.156.212:2262/wecenter/?/article/8754,js的跨域访问问题及解决方法技术经验共享201405_周敏.doc,2014/12/26
530,关于使用console来调试JavaScript,周敏,http://180.168.156.212:2262/wecenter/?/article/8753,1.什么是Console2.为什么不直接使用alert3.如何使用Console技术经验共享201406_周敏.doc,2014/12/26
531,基于目前公司传统的三种页面动态刷新的开发方式比较,周敏,http://180.168.156.212:2262/wecenter/?/article/8752,一、使用iframe嵌套jsp方式二、使用ajax异步加载jsp方式三、使用js加载前台组件技术经验共享201407_周敏.doc,2014/12/26
532,端口被占用的解决处理办法,钱江,http://180.168.156.212:2262/wecenter/?/article/8751,"经常，我们在启动应用的时候发现系统需要的端口被别的程序占用，如何知道谁占有了我们需要的端口，很多人都比较头疼，下面就介绍一种非常简单的方法，希望对大家有用假如我们需要确定谁占用了我们的9050端口1、Windows平台在windows命令行窗口下执行：1.查看所有的端口占用情况C:\>netstat-ano协议本地地址外部地址状态PIDTCP127.0.0.1:14340.0.0.0:0LISTENING3236TCP127.0.0.1:56790.0.0.0:0LISTENING4168TCP127.0.0.1:74380.0.0.0:0LISTENING4168TCP127.0.0.1:80150.0.0.0:0LISTENING1456TCP192.168.3.230:1390.0.0.0:0LISTENING4TCP192.168.3.230:1957220.181.31.225:443ESTABLISHED3068TCP192.168.3.230:2020183.62.96.189:1522ESTABLISHED1456TCP192.168.3.230:2927117.79.91.18:80ESTABLISHED4732TCP192.168.3.230:2929117.79.91.18:80ESTABLISHED4732TCP192.168.3.230:2930117.79.91.18:80ESTABLISHED4732TCP192.168.3.230:2931117.79.91.18:80ESTABLISHED47322.查看指定端口的占用情况C:\>netstat-aon|findstr""9050""协议本地地址外部地址状态PIDTCP127.0.0.1:90500.0.0.0:0LISTENING2016P:看到了吗，端口被进程号为2016的进程占用，继续执行下面命令：（也可以去任务管理器中查看pid对应的进程）3.查看PID对应的进程C:\>tasklist|findstr""2016""映像名称PID会话名会话#内存使用=================================================tor.exe2016Console016,064KP:很清楚吧，tor占用了你的端口。4.结束该进程C:\>taskkill/f/t/imtor.exe",2014/12/26
533,oracle分页和like模糊查询优化,陈博,http://180.168.156.212:2262/wecenter/?/article/8750,"表：test_table起始位置：start=10，终止位置：end=20；分页优化：普通写法：select*from(selectt1.*,rownumrnfromtest_tablet1)t2wheret2.rn>startandt2.rn优化后写法：使用row_number()OVER(ORDERBYnull)函数编序号select*from(selectt1.*,row_number()OVER(ORDERBYnull)rn)t2)wheret2.rn>startandrownum<10;LIKE优化SELECT*FROMtest_tablewherenameLIKE'张';等价于：SELECT*FROMtest_tableWHEREname='张';SELECT*fromtest_tablewherenameLIKE'%张%';等价于：SELECT*FROMtest_tablewhereinstr(name,'张')>0;--更高效SELECT*FROMtest_tablewherenameLIKE'%张';等价于SELECT*FROMtest_tableWHEREinstr(name,'张')=0;--更高效",2014/12/26
534,SVN库的备份与恢复,钱江,http://180.168.156.212:2262/wecenter/?/article/8749,"遇到SVN服务器，没有及时备份文件的情况，如何恢复呢？建立版本库运行Subversion服务器需要首先要建立一个版本库（Repository），可以看作服务器上存放数据的数据库，在安装了Subversion服务器之后，运行：svnadmincreateX:/xxxx/xxxx就会在目录X:/xxxx/xxxx下创建一个版本库;建立的路径应与原服务器上的路径一致。还原数据及权限将权限文件与原库文件拷贝到新建的库运行独立服务器在任意目录下运行：svnserve-d-rE:/svndemo/repository我们的服务器程序就已经启动了。注意不要关闭命令行窗口，关闭窗口也会把svnserve停止。在windows服务里运行：sccreatesvnservicebinPath=""D:/ProgramFiles/Subversion/bin/svnserve.exe--service-rX:/xxxx/xxxx""DisplayName=""SvnService""depend=Tcpipstart=auto",2014/12/26
535,构建开发流程,张伟,http://180.168.156.212:2262/wecenter/?/article/8748,"按钮构件开发流程先按正常流程开发controllerservicedaopublicObjectunpackArchive(){try{StringtableId=getParameter(""tableId"");Stringids=getParameter(""ids"");//tableId=""4028b9814887c048014887c4641f0063"";//ids=""402881ef48abdfe20148abe2a4b7001e"";list=getDataModel(getModelTemplate());getService().unpackArchive(tableId,ids);setReturnData(MessageModel.falseInstance(""拆卷成功""));}catch(Exceptione){e.printStackTrace();setReturnData(MessageModel.falseInstance(""拆卷失败""));}returnnewDefaultHttpHeaders(SUCCESS).disableCaching();上面的参数传递是通过系统配置平台配置（刚开始调试的时候是写死参数的）开发完毕后，在进行按钮绑定将按钮构件进行打包和上传构件上传张伟-9月经验共享.docx",2014/12/26
536,Eclipse中的web项目无法导入的解决之道,沈文进,http://180.168.156.212:2262/wecenter/?/article/8747,"Eclipse下Web工程导入Myeclipse不能被识别，无法发布等问题。打开你的web工程目录，删除.metadata，从你的任意myeclipse下的web工程内复制"".myetadata""和"".project""两个文件到当前目录，然后修改"".myetadata“内容如下：<?xmlversion=""1.0""encoding=""UTF-8""?><project-moduletype=""WEB""name=""工程名""id=""myeclipse.1291450194218context-root=""/工程名""j2ee-spec=""5.0""archive=""工程名.war""><attributes><attributename=""webrootdir""value=""应用目录（默认WebRoot）""/></attributes></project-module>3、另外，在你的web工程目录内找到.classpath文件并编辑，修改<classpath></classpath>标签内的最后一行<classpathentrykind=""output""path=""context/WEB-INF/classes""/>，这是编译后的class文件存放地点。4、打开myeclipse，import这个工程，然后部署完成ok！",2014/12/26
537,一些常用的linux命令,钱江,http://180.168.156.212:2262/wecenter/?/article/8746,查看磁盘剩余空间的数量df显示空闲内存的数量free新建目录：mkdiraa复制文件cpaa.txtbb.txt移动或重命名文件mvaa.txtbb.txt删除：rmaa.txt（删除文件）rm-raa/（删除目录）硬链接lnaa.txtbb.txt符号链接ln-saa.txtbb.txt查找命令的位置whichls建立别名aliasfoo='cd/usr;ls;cd-'改变权限：chmod666aa.txt帮助命令：manls查询/关键字下一个n退出q进程命令psauxkill4300重定向>输出重定向>>添加内容2>错误重定向&>输出重定向+错误重定向<输入重定向管道线catfile.txt|uniq|greptxt|sort安装软件：sudodpkg-iXXX.debsudoapt-get-yinstallvim,2014/12/26
538,Spring一两点,沈文进,http://180.168.156.212:2262/wecenter/?/article/8745,"Spring注解：当候选Bean数目不为1时应对方法在默认情况下使用@Autowired注释进行自动注入时，Spring容器中匹配的候选Bean数目必须有且仅有一个。当找不到一个匹配的Bean时，Spring容器将抛出BeanCreationException异常，并指出必须至少拥有一个匹配的Bean。候选Bean数目为0时<?xmlversion=""1.0""encoding=""UTF-8""?><beansxmlns="" bean>…我们在Spring容器中配置了两个类型为Office类型的Bean，当对Boss的office成员变量进行自动注入时，Spring容器将无法确定到底要用哪一个Bean，因此异常发生了。Spring允许我们通过@Qualifier注释指定注入Bean的名称，这样歧义就消除了，可以通过下面的方法解决异常：使用@Qualifier注释指定注入Bean的名称@AutowiredpublicvoidsetOffice(@Qualifier(""office"")Officeoffice){this.office=office;}@Qualifier(""office"")中的office是Bean的名称，所以@Autowired和@Qualifier结合使用时，自动注入的策略就从byType转变成byName了。@Autowired可以对成员变量、方法以及构造函数进行注释，而@Qualifier的标注对象是成员变量、方法入参、构造函数入参。正是由于注释对象的不同，所以Spring不将@Autowired和@Qualifier统一成一个注释类。下面是对成员变量和构造函数入参进行注释的代码：对成员变量进行注释：对成员变量使用@Qualifier注释publicclassBoss{@AutowiredprivateCarcar;@Autowired@Qualifier(""office"")privateOfficeoffice;}对构造函数入参进行注释：对构造函数变量使用@Qualifier注释publicclassBoss{privateCarcar;privateOfficeoffice;@AutowiredpublicBoss(Carcar,@Qualifier(""office"")Officeoffice){this.car=car;this.office=office;}}@Qualifier只能和@Autowired结合使用，是对@Autowired有益的补充。一般来讲，@Qualifier对方法签名中入参进行注释会降低代码的可读性，而对成员变量注释则相对好一些。",2014/12/26
539,对编辑框textarea回车和EXC键反应,陈博,http://180.168.156.212:2262/wecenter/?/article/8744,"keypress是jquery提供的一个事件//增加输入框回车保存$(function(){$(""#textarea"").keypress(function(e){if(e.ctrlKey&&e.which==13||e.which==10||e.which==13){addWords();e.preventDefault();//屏蔽enter对系统作用。按后增加\r\n等换行}elseif(e.which==27){addWordsClose();}})});--$(function(){});等同于$(document).ready(function{});--e.ctrlKey表示点击ctrl键--e.ctrlKey&&e.which==10表示同时点击ctrl和enter--e.preventDefault()//屏蔽掉enter对系统的作用，防止换行--e.which==27表示点击EXC键",2014/12/26
540,dhtmlxTree使用XML加载数据,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8743,"<script>tree=newdhtmlXTreeObject('treeBox',""l00%"",""l00%"",0);tree.setXMLAutoLoading("" script>",2014/12/26
541,dhtmlx API,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8742,dhtmlxapi.....dhtmlx35.chm,2014/12/26
542,EhCache缓存介绍及基本使用方法,周敏,http://180.168.156.212:2262/wecenter/?/article/8741,EhCache缓存介绍及基本使用方法技术经验共享201409_周敏.doc,2014/12/26
543,使用系统配置平台心得（一）,周敏,http://180.168.156.212:2262/wecenter/?/article/8740,使用系统配置平台开发一个构件技术经验共享201410_周敏.doc,2014/12/26
544,dhtmlxTree序列化树状元件,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8739,"序列化可将树状元件转换成XML格式。不同等级序列化会定义不同的参数个数，会在XML呈现不同的结果。<script>tree.setSerializationLevel(userDataFl,itemDetailsFl);varmyXmlStr=tree.serializeTree();</script>没有参数-id,open,select,text,childuserDataFltrue-userdataitemDetailsFltrue-im0,iml,im2,acolor,scolor,checked,open节点提示有三个方式可以设定节点提示：把节点的显示文字直接当作提示，呼叫enableAutoTooltips(mode)带入参数。预设为false。使用节点的tooltip属性(如果有设定此属性时，会以这个属性优先)。setItemText(itemId,newLabel,newTooltip)，第三个参数。节点的移动要用程序来移动节点的方式如下：往上／下／左移动tree.moveItem(nodeId,mode)mode参数值如下列所示：""down""-在节点的串行中往下移动(不考虑阶层)。""up""-在节点的串行中往上移动。""left""-在节点的阶层中往上移动。直接移动到某个位置(同一棵树)：tree.moveItem(nodeId,mode,targetId)mode参数值如下列所示：""item_child""-移动的节点做为第三个参数的子节点。""item_sibling""-移动的节点做为第三个参数的旁系节点。targetId-目标节点的识别码直接移动到某个位置(不同树之间)：tree.moveItem(nodeId,mode,targetId,targetTree)mode参数值如上述：targetId-目标节点的识别码(目标树)。targetTree-目标树。复制贴上的方式利用doCut()及doPaste(id)函式-只作用在被选取的节点上。开发者亦可先删除节点后在其它地方新增节点。开发员可以透过拖放的方式来移动节点。子节点的笔数子节点的笔数可以在节点的标记后面显示子节点的笔数。要启用这个功能请参考下述：<script>tree.setChildCalcMode(mode);</script>可能的模式为:""child""-显示本层所有子节点个数""leafs""-显示本层无子节点的子节点个数""childrec""-显示所有子节点个数""leafsrec""-显示无子节点的子节点个数""disabled""-不显示其它相关的函式：_getChildCounterValue(itemId)-取得目前节点的子节点个数setChildCalcHTML(before,after)-更改显示方式如果需要动幠加载文件时，请在XML中使用child属性设定子节点个数。智能型XML解译智能型XML解译原理－在客户端显示树状元件时会载入整棵树的结构数据，但实际上开发员只会看到展开的节点。可以减少加载时间及增加对巨量数据的效能。除此之外，对于动幠加载，智能型XML解译可以提供Script的方式对整棵树做操作，例如对未展开的节点做搜寻。要启用智能型XML解译可用以下函式:<script>tree.enableSmartXMLParsing(true);//falsetodisable</script>不过，在全展开的树状元件中，智能型XML解译的功能无法使用。树的选取盒选取盒支持二或三种状幠。三幠即是选取／未选取／部分选取。要启用三幠的选取盒请使用下列的函式：<script>tree.enableThreeStateCheckboxes(true)//falsetodisable</script>欲使用三幠的选取盒搭配智能型XML解译，需尝动指定选取盒状幠(checked=""-l"")：<itemchecked=""-l""...><itemchecked=""l"".../><item.../></item>可以停用选取盒-disableCheckbox(id,state)节点可以隐藏选取盒-showItemCheckbox(id,state)(nocheckboxxml属性)从l.4版之后，showItemCheckbox可以应用在整棵树上(使用0或null为第一个参数)树的单选按钮dhtmlxTree支持单选按钮。开启整棵树的单选按钮：<script>tree.enableRadiobuttons(true);</script>开启特定节点的单选按钮（取代选取盒）：<script>tree.enableCheckboxes(true);tree.enableRadiobuttons(nodeId,true);</script>在预设的情况下，单选按钮依照阶层分为群组，不过l.4版之后可以应用至整棵树：tree.enableRadiobuttons(true)与选取盒相关的API和XML属性跟选取盒类似(考虑到单选按钮的特殊功能性)。拖放功能拖放有三种模式(利用setDragBehavior(mode)设定):拖放成子节点-""child""拖放成旁系节点-""sibling""复杂模式(包含上述两种模式)-""complex""再加上以下两种模式：共享拖放拖放复制-tree.enableMercyDrag(1/0)所有模式都可以动幠修改。事件处理拖放时，当欲处理拖的动作时可以覆写onDrag函式-attachEvent(""onDrag"",func)。如果函式没有回传true，放的动作将取消。在放发生之后紧接着触发-onDrop-使用attachEvent(""onDrop"",func)覆写。以上两个事件处理函式有五个参数：要拖的节点ID目标节点的ID目标节点前的ID(如果是拖放成旁系节点)来源树目标树9.2.15跨iframe的拖放预设启用跨iframe的拖放状幠。额外需要做的就是当没有树加载之前，要加入以下程序代码：<scriptsrc=""codebase/dhtmlxcommon.js""></script><script>newdhtmlDragAndDropObject();</script>",2014/12/26
545,win7下安装SQL2005(SQL Server 2005)图文教程,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8738,详细介绍见附件！win7下安装SQL2005(SQLServer2005)图文教程.mht,2014/12/26
546,系统配置平台使用心得（二）,周敏,http://180.168.156.212:2262/wecenter/?/article/8737,使用系统配置平台在一个页面基础构件中使用另一个已有基础构件技术经验共享201411_周敏.doc,2014/12/26
547,dhtmlxGrid弹跳式选单(基于dhtmlxMenu),邱金炜,http://180.168.156.212:2262/wecenter/?/article/8736,"请参阅以下程序代码：<scriptsrc=""../codebase/dhtmlxcommon.js""></script><scriptsrc=""../codebase/dhtmlxgrid.js""></script><scriptsrc=""../codebase/dhtmlxgridcell.js""></script><scriptlanguage=""JavaScript""src=""../codebase/dhtmlxprotobar.js""></script><scriptlanguage=""JavaScript""src=""../codebase/dhtmlxmenubar.js""></script><scriptlanguage=""JavaScript""src=""../codebase/dhtmlxmenubar_cp.js""></script><script>//createfunctionforprocessingmenucommandsfunctiononButtonClick(menuitemId,gridItemId){//getarray,firstelementofwhichisrowID,second–cellindexvardata=gridItemId.split(""_"");//rowId_colInd//useinputdatatoperformanyactionyoulikemygrid.setRowTextStyle(data[0],""background-color:""+menuitemId.split(""_"")[l]);}//CreatemenuaMenu=newdhtmlXContextMenuObject('l20',0,""../codebase/imgs/"");aMenu.menu.loadXML(""menu/_context.xml"");aMenu.setContextMenuHandler(onButtonClick);//initializegridandattachmenutoitmygrid=newdhtmlXGridObject('gridbox');...mygrid.enableContextMenu(aMenu);mygrid.init();mygrid.loadXML(""grid_links.xml"");</script>第二个参数的格式包含以底线分隔的字符串，底线前面是数据列识别码、底线后面是字段索尙，目的是用来处理选单命令。HTTPS兼容性为达成HTTPS的兼容性，我们多加了两个参数在弹跳式选单的建构式中：图示的网址空白网页的网址(网址是要设定成iframe的来源网址，这个iframe会用来放置在选取节点的下方，使弹跳式选单可以在IE下可以兼容HTTPS)<script>//initmenucompatiblewithHTTPsaMenu=newdhtmlXContextMenuObject('l20',0,""../codebase/imgs/"",""empty.html"");...</script>选取盒与单选按钮dhtmlxGrid支持选取盒与单选按钮。只要在初始化时指订字段的型幠即可，详情请参阅使用编辑器(eXcell)。<script>mygrid.setColTypes(""ra,ch"");</script>增加效能考虑到DHTML的效能问题，我们导入四种加载巨量数据的方式：l.分布式解译2.智能型XML解译(适合巨大的数据量)3.分页4.""FAST""模式分布式解译为了缩短显示时间，可以启用分布式解译。在此模式下，元件会在第一部分已经解译好的情形下马上显示并且继续以非同步的方式解译其它部分。你可以更改解译的笔数以及延迟的时间来改善加载的速度。mygrid.enableDistributedParsing(true/false,record-per-portion,delay-time);多行的资料列允许数据列以多行的方式显示(Mozilla会以此为预设模式)或使用单行模式(只适用于IE)。启用此功能的程序代码如下：mygrid.enableMultiline(true/false);多选模式启用此功能的程序代码如下：mygrid.enableMultiselect(true/false);使用[Shift/Ctrl]来决定单选或多选。拖放功能启用此功能的程序代码如下：mygrid.enableDragAndDrop(true/false);拖放有两种模式，利用setDragBehavior(mode)设定的参数如下:""child""-拖放成子节点""sibling""-拖放成旁系节点""complex""–同时启用上述两种模式模式可在任意时间切换。延伸的拖放模式延伸的拖放模式让使用者可看到拖放的多列及欲放置的位置。欲启用此模式需在网页上加入dhtmlx_extdrag.js并且设定欲拖放的对象类型：mygrid.setDragText(""product"");当""s""结尾不适用时请使用第二个参数来定义复数形。复制型拖放使用""mercydrag""从来源数据方格复制到任一个数据方格或在同一数据方格中复制：mygrid.enableMercyDrag(true);",2014/12/26
548,Oracle验证数据字段连续性的例子！,沈文进,http://180.168.156.212:2262/wecenter/?/article/8735,"问题：如何通过多个字段分组排序后进行字段连续性的检测？？？关于连续检测的总结：第一步：查询T_AR_WSLJ_FOLDER对应的数据（截取部分字段数据），如下：select*fromT_AR_WSLJ_FOLDERforupdate第二步：按照FONDS_CODE，INCEPT_USER，INCEPT_DEPT，IS_ASSOCIATED字段进行分组排序，如下：selectt.STATUS,t.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPT,t.IS_ASSOCIATEDcurr,lag(t.IS_ASSOCIATED,1)over(partitionbyt.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPTorderbyt.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPT,IS_ASSOCIATED)lastfromT_AR_WSLJ_FOLDERtwheret.STATUS='0'Andt.FONDS_CODEin('zx','sss','zy')第三步：通过错位的方式实现缺少流水值得处理，如下：selectz.STATUS,z.FONDS_CODE,z.INCEPT_USER,z.INCEPT_DEPT,z.curr,z.last,z.curr-z.last-1confrom(selectt.STATUS,t.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPT,t.IS_ASSOCIATEDcurr,lag(t.IS_ASSOCIATED,1)over(partitionbyt.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPTorderbyt.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPT,IS_ASSOCIATED)lastfromT_AR_WSLJ_FOLDERtwheret.STATUS='0'Andt.FONDS_CODEin('zx','sss','zy'))z结果显示：第四步：实现查询缺少起始流水号和终止流水号的功能，如下：selectx.last+1c1,x.curr-1c2,x.STATUSc3,FONDS_CODEc5,conc7,'INCEPT_USER,INCEPT_DEPT','IS_ASSOCIATED'from(selectz.STATUS,z.FONDS_CODE,z.INCEPT_USER,z.INCEPT_DEPT,z.curr,z.last,z.curr-z.last-1con//错位值from(selectt.STATUS,t.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPT,t.IS_ASSOCIATEDcurr,lag(t.IS_ASSOCIATED,1)over(partitionbyt.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPTorderbyt.FONDS_CODE,t.INCEPT_USER,t.INCEPT_DEPT,IS_ASSOCIATED)lastfromT_AR_WSLJ_FOLDERtwheret.STATUS='0'Andt.FONDS_CODEin('zx','sss','zy'))zwherez.curr>z.last+1)x结果显示：问题:为空检测的总结？？对于要查询多列数据的一个分页查询语句，可以在内部的Oracle查询rownum时，不查询出所有要需要的列，而是查询一个rowid，再用一个表连接的方式，来查询所需要的列，这样就不会使用太多的*来查询，Oracle的sql语句解析器也就不会在解析sql语句时，消耗更多的资源，如下：一般的查询分页查询方式是：SELECT*FROM(SELECTa.*,ROWNUMrn--取得rownum值FROM(SELECTt.*FROMdepttORDERBYt.deptno)aWHEREROWNUM<20)--对rownum大于20的进行过滤WHERErn>2--对rownum大于2的进行过滤另外一种做法是：SELECTt.*FROMdeptt,--表连接，关联查询(SELECTrd--取得所有的rowidFROM(SELECTrd,rnFROM(SELECTROWIDrd,ROWNUMrnFROMdeptORDERBYdeptno)--查询整表rowid和rownum，并按进行排序WHERErn<20)WHERErn>2)t1WHEREt.ROWID=t1.rd",2014/12/26
549,coral40控件使用方法,张伟,http://180.168.156.212:2262/wecenter/?/article/8734,"1.获取表格中选中的行以及某一行和一列varrowId=$(""#organizeGrid${idSuffix}"").grid(""option"",""selarrrow"");if(rowId==""""){$.alert(""请选择需要修改的记录！"");return;}if(rowId.toString().indexOf("","")!=-1){$.alert(""只能选择一条数据进行操作！"");return;}varorganizeId=$(""#organizeGrid${idSuffix}"").grid(""getRowData"",rowId).id;2.树的刷新reloadTree:function(){varnodes=$(""#organizeTree${idSuffix}"").tree(""getNodes"");$(""#organizeTree${idSuffix}"").tree(""reAsyncChildNodes"",nodes[0],""refresh"");}3.获取树的数据Stringturl=path+""/org!treeOforg.json?E_frame_name=coral&E_model_name=tree&F_in=name,id&P_Id=id"";第一个参数会当作树的内容显示出来4.表格的重新加载varurl=""<%=path%>/org!gridSearch.json?E_frame_name=coral&E_model_name=jqgrid&F_in=organizeName,organizeTypeID,organizeDescribe"";$(""#organizeGrid${idSuffix}"").grid(""setGridParam"",{url:url,""postData"":postData}).grid(""reload"");5.表单的初始化$.get(""<%=path%>/org!getOrgById.json?id=""+organizeID,function(data){$(""#organizeForm${idSuffix}"").form(""loadData"",data);});6.表单的清空$(""#organizeForm${idSuffix}"").form(""clear”);张伟——7月经验共享.docx",2014/12/26
550,使用coral4.0版本时，使用JQUERY remove()时出现的性能问题,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8733,详细介绍见附件！研发一部_邱初烧[201411].doc,2014/12/26
551,dhtmlxGrid 开发小记,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8732,"在网页上初始化组件<linkrel=""STYLESHEET""type=""text/css""href=""../codebase/dhtmlxgrid.css""><scriptsrc=""../codebase/dhtmlxcommon.js""></script><scriptsrc=""../codebase/dhtmlxgrid.js""></script><scriptsrc=""../codebase/dhtmlxgridcell.js""></script><divid=""gridbox""style=""width:200;height:200""></div><script>mygrid=newdhtmlXGridObject('gridbox');mygrid.imgURL=""img/"";mygrid.setHeader(""ColumnA,ColumnB"");mygrid.setInitWidths(""l00,250"")mygrid.setColAlign(""right,left"")mygrid.setColTypes(""ro,ed"");mygrid.setColSorting(""int,str"")mygrid.init();mygrid.loadXML(""grid.xml"");</script>建构式的参数如下所示：要附挂到数据方格的组件(要比数据方格先加载)。如果没有对象，你可以使用attachToObject函式附挂数据方格到其它对象上。指定额外的参数：imgURL-指定图标位置setHeader(""ColumnA,ColumnB"")-设定字段的表头文字setInitWidths(""l00,l50"")-设定字段的宽度，以点数为单位(*-表示尽可能填满的值)setColTypes(""ro,ed"")-设定字段的类型(与编辑器有关，详情请参阅文件)setColAlign(""right,left"")-设定字段文字的排列位置setColSorting(""int,str"")-设定字段的排序方式loadXML(""grid.xml"")-从XML加载数据事件处理函式从l.4版的dhtmlxTree/TreeGrid支持设定事件处理函式的新方法-使用attachEvent函式。在设定事件处理函式时，你必须知道事件名称以及定义好处理函式。事件名称表列于附件。<divid=""treeBox""style=""width:200;height:200""></div><script>functiondoOnRowSelected(id){...}functiondoOnCellEdit(stage,rowId,cellInd){if(stage==0){...returntrue;}elseif(stage==l){...}elseif(stage==2){...}}functiondoOnEnter(rowId,cellInd){...}functiondoOnEnter(rowId,cellInd){...}mygrid=newdhtmlXGridObject('gridbox');...mygrid.attachEvent(""onRowSelect"",doOnRowSelected);mygrid.attachEvent(""onEditCell"",doOnCellEdit);mygrid.attachEvent(""onEnter"",doOnEnter);mygrid.attachEvent(""onCheckbox"",doOnCheck);...mygrid.init();mygrid.loadXML(""../grid.xml"");</script>在大部分的情况下，处理函式会需要相关的参数。详细的参数请参考事件文件。在事件处理函式中，可以使用this来参照资料方格。",2014/12/26
552,JavaScript严格模式: ”use strict”介绍,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8731,详细介绍见附件！研发一部_邱初烧[201405].doc,2014/12/26
553,JQuery.data使用注意事项,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8730,详细介绍见附件！研发一部_邱初烧[201404].doc,2014/12/26
554,Myeclipse多工程编码问题,王雷2,http://180.168.156.212:2262/wecenter/?/article/8729,详见附件Myeclipse多工程编码问题.doc,2014/12/26
555,MyEclipse性能优化,王雷2,http://180.168.156.212:2262/wecenter/?/article/8728,详见附件MyEclipse性能优化.doc,2014/12/26
556,DHTMLX的Tree构造方法小记,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8727,总结了近期使用的DHTMLX的一些心得，和大家分享一下关于DHTMLX中tree的构造.docx,2014/12/26
557,MyEclipse6.5配置Tomcat7.x,王雷2,http://180.168.156.212:2262/wecenter/?/article/8726,详见附件MyEclipse6.5配置Tomcat7.x.doc,2014/12/26
558,关于权限管理中的三权分立,甘名辉,http://180.168.156.212:2262/wecenter/?/article/8725,"目前我们的系统管理平台中已经集成了三权分立的功能,但是对于那种大集团,多单位的客户来说,常规型的三权分立已经明显满足不了需求了,因此提出了一个单位三权的概念,即在超级三权下规划三个单位三权的子类,将超级三权的权限下放,单位三权集权控制本单位,这样将使权限控制更加严格,流程审批更加精细,各角色各司其职,互不影响.附件为单位三权的需求分析,如大家有好的意见,对三权有更多的见解,请一起讨论,集思广益,把产品做的更好.系统管理平台-三权分立设计2014-final.doc",2014/12/26
559,uploadfiy 3.2参数详解,何文,http://180.168.156.212:2262/wecenter/?/article/8724,"根据要求，限定上传的大小、格式，传参，显示错误提示框等，在网上找了一下的uploadfiy3.2的参数：UploadifyVersion3.2Options选项设置auto选择文件后自动上传buttonClass给“浏览按钮”加css的class样式buttonCursor鼠标移上去形状：arrow箭头、hand手型（默认）buttonImage鼠标移上去变换图片buttonText按钮文字checkExisting在目录中检查文件是否已上传成功（1ture,0false）debug是否显示调试框（默认不显示false）fileObjName设置一个名字，在服务器处理程序中根据该名字来取上传文件的数据。默认为Filedata，$tempFile=$_FILES['Filedata']['tmp_name']fileSizeLimit设置允许上传文件最大值B,KB,MB,GB比如：'fileSizeLimit':'20MB'fileTypeDesc选择的文件的描述。这个字符串出现在浏览文件对话框中文件类型下拉框处。默认：AllFilesfileTypeExts允许上传的文件类型。格式：'fileTypeExts':'*.gif;*.jpg;*.png'formData附带值，需要通过getorpost传递的额外数据，需要结合onUploadStart事件一起使用height“浏览按钮”高度pxitemTemplate<itemTemplate>节点表示显示的内容。这些内容中也可以包含绑定到控件DataSource属性中元素集合的数据。method上传方式。默认：postmulti选择文件时是否可以【选择多个】。默认：可以trueoverrideEvents不执行默认的onSelect事件preventCaching随机缓存值默认true，可选true和false.如果选true,那么在上传时会加入一个随机数来使每次的URL都不同,以防止缓存.但是可能与正常URL产生冲突progressData进度条上显示的进度:有百分比percentage和速度speed。默认百分比queueID给“进度条”加背景css的ID样式。文件选择后的容器IDqueueSizeLimit允许多文件上传的数量。默认：999removeCompleted上传完成后队列是否自动消失。默认：trueremoveTimeout上传完成后队列多长时间后消失。默认3秒需要：'removeCompleted':true,时使用requeueErrors队列上传出错，是否继续回滚队列，即反复尝试上传。默认：falsesuccessTimeout上传超时时间。文件上传完成后,等待服务器返回信息的时间(秒).超过时间没有返回的话,插件认为返回了成功。默认：30秒swfswf文件的路径,本文件是插件自带的,不可用其它的代替.本参数不可省略uploader上传处理程序URL，本参数不可省略uploadLimit限制总上传文件数,默认是999。指同一时间，如果关闭浏览器后重新打开又可上传。width“浏览按钮”宽度pxEvents事件onCancel当取消一个上传队列中的文件时触发,删除时触发onClearQueue清除队列。当'cancel'方法带着*参数时,也就是说一次全部取消的时候触发.queueItemCount是被取消的文件个数（另外的按钮）onDestroy取消所有的上传队列（另外的按钮）onDialogClose当选择文件对话框关闭时触发,不论是点的'确定'还是'取消'都会触发.如果本事件被添加进了'overrideEvents'参数中,那么如果在选择文件时产生了错误,不会有错误提示框弹出onDialogOpen当选择文件框被打开时触发,没有传过来的参数onDisable关闭上传onEnable开启上传onFallback检测FLASH失败调用onInit每次初始化一个队列时触发onQueueComplete当队列中的所有文件上传完成时触发onSelect当文件从浏览框被添加到队列中时触发onSelectError选择文件出错时触发onSWFReadyflash准备好时触发onUploadComplete当一个文件上传完成时触发onUploadError当文件上传完成但是返回错误时触发onUploadProgress上传汇总onUploadStart一个文件上传之间触发onUploadSuccess每个上传完成并成功的文件都会触发本事件Methods方法cancel取消一个上传队列destroy取消所有上传队列disable禁止点击“浏览按钮”settings返回或修改一个uploadify实例的settings值stop停止当前的上传并重新添加到队列中去upload上传指定的文件或者所有队列中的文件",2014/12/26
560,hibernate 该如何强制刷新2级缓存,甘名辉,http://180.168.156.212:2262/wecenter/?/article/8723,"目前如果采取jdbc操作之后是无法hibernate实时更新的,那该如果强制刷新2级缓存勒?详情请看附件.研发中心经验共享_甘名辉[201410].doc",2014/12/26
561,spring 的 和 的区别,陈博,http://180.168.156.212:2262/wecenter/?/article/8722,"是用于激活那些已经在spring容器里注册过的bean（无论是通过xml的方式还是通过packagesanning（包扫描）的方式）上面的注解。除了具有的功能（即激活那些已经在spring容器里面注册过的bean）之外，还可以在指定的package下扫描以及注册javabean。下面我们通过例子来详细查看他们的区别，有三个classA,B,C,并且B,C的对象被注入到A中.packagecom.xxx;publicclassB{publicB(){System.out.println(""creatingbeanB:""+this);}}packagecom.xxx;publicclassC{publicC(){System.out.println(""creatingbeanC:""+this);}}packagecom.yyy;importcom.xxx.B;importcom.xxx.A;publicclassA{privateBbbb;privateCccc;publicA(){System.out.println(""creatingbeanA:""+this);}publicvoidsetBbb(Bbbb){System.out.println(""settingbeana.bbb:""+this);this.bbb=bbb;}publicvoidsetCcc(Cccc){System.out.println(""settingbeana.ccc:""+this);this.ccc=ccc;}}在spring配置文件applicationContext.xml中加入加载applicationContext.xml配置文件，将得到下面的结果:creatingbeanB:com.xxx.B@c2ff5creatingbeanC:com.xxx.C@1e8a1f6creatingbeanA:com.yyy.A@1e152c5settingA.bbbwithcom.xxx.B@c2ff5settingA.cccwithcom.xxx.C@1e8a1f6这个结果没什么好说的，完全通过xml配置完成的，太过时了，下面通过注解的方式完成。首先，我们使用autowire的方式将对象bbb和ccc注入到A中：packagecom.yyy;importorg.springframework.beans.factory.annotation.Autowired;importcom.xxx.B;importcom.xxx.C;publicclassA{privateBbbb;privateCccc;publicA(){System.out.println(""creatingbeanA:""+this);}@AutowiredpublicvoidsetBbb(Bbbb){System.out.println(""settingA.bbbwith""+bbb);this.bbb=bbb;}@AutowiredpublicvoidsetCcc(Cccc){System.out.println(""settingA.cccwith""+ccc);this.ccc=ccc;}}然后，对applicationContext.xml进行配置加载applicationContext.xml文件，结果creatingbeanB:com.xxx.B@5e5a50creatingbeanC:com.xxx.C@54a328creatingbeanA:com.yyy.A@a3d4cf结果不正确，属性没有被注册进去，是因为注解本身没有任何作用，需要借助注解处理工具将属性注册进去这就是做的事情，将applicationContext.xml修改为：加载applicationContext.xml文件，creatingbeanB:com.xxx.B@15663a2creatingbeanC:com.xxx.C@cd5f8bcreatingbeanA:com.yyy.A@157aa53settingA.bbbwithcom.xxx.B@15663a2settingA.cccwithcom.xxx.C@cd5f8b得到两个一个正确的结果。但是如果我们将代码作如下修改：packagecom.xxx;importorg.springframework.beans.factory.annotation.Autowired;@ComponentpublicclassB{publicB(){System.out.println(""creatingbeanB:""+this);}}packagecom.xxx;importorg.springframework.beans.factory.annotation.Autowired;@ComponentpublicclassC{publicC(){System.out.println(""creatingbeanC:""+this);}}packagecom.yyy;importcom.xxx.B;importcom.xxx.A;importorg.springframework.beans.factory.annotation.Autowired;@ComponentpublicclassA{privateBbbb;privateCccc;publicA(){System.out.println(""creatingbeanA:""+this);}@AutowiredpublicvoidsetBbb(Bbbb){System.out.println(""settingbeana.bbb:""+this);this.bbb=bbb;}@AutowiredpublicvoidsetCcc(Cccc){System.out.println(""settingbeana.ccc:""+this);this.ccc=ccc;}}对applicationContext.xml进行配置加载applicationContext.xml文件，发现什么都没打印，原因是只能对已经注册进入spring容器中的bean进行处理，对于没有在spring容器里面注册的类，注解是不起作用的，除了具有的功能之外，还具有自动将带有@component,@service,@Repository等注解的对象注册到spring容器中的功能。将applicationContext.xml修改成如下加载applicationContext.xml文件，结果：creatingbeanB:com.xxx.B@1be0f0acreatingbeanC:com.xxx.C@80d1ff结果只是加载了B和C没有加载A，因为只对com.xxx包下的类进行扫描，而A在com.yyy包下，因此没有被扫描进去，修改applicationContext.xml文件:加载applicationContext.xml配置文件，得到结果creatingbeanB:com.xxx.B@cd5f8bcreatingbeanC:com.xxx.C@15ac3c9creatingbeanA:com.yyy.A@ec4a87settingA.bbbwithcom.xxx.B@cd5f8bsettingA.cccwithcom.xxx.C@15ac3c9正确的结果。如果对applicationContext.xml修改成?执行applicationContext.xml文件，也会得到一个正确的结果，对以上代码可以简写成总结：1，是处理属性注解的，而且只对已经注册过了的bean的注解有效，对于没有注册进入spring容器的类的属性的注解没有效果。2，?能够处理类注解和属性注解，能够对base-package包下的类进行扫描，并将有注解的类和属性注册到spring容器里。3，和同时存在的时候，前者会被忽略。也就是那些@autowire，@resource等注入注解只会被注入一次，即便手动的注册了多个处理器，spring仍然只会处理一次。4，除了具有的功能之外，还具有自动将带有@component,@service,@Repository等注解的对象注册到spring容器中的功能。",2014/12/26
562,[转]一篇关于zookeeper的基本介绍,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8721,"ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。Zookeeper是hadoop的一个子项目，其发展历程无需赘述。在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。本文简单分析zookeeper的工作原理，对于如何使用zookeeper不是本文讨论的重点。1Zookeeper的基本概念1.1角色Zookeeper中的角色主要有以下三类，如下表所示：系统模型如图所示：1.2设计目的1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。2.可靠性：具有简单、健壮、良好的性能，如果消息m被到一台服务器接受，那么它将被所有的服务器接受。3.实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4.等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。5.原子性：更新只能成功或者失败，没有中间状态。6.顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。2ZooKeeper的工作原理Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。每个Server在工作过程中有三种状态：LOOKING：当前Server不知道leader是谁，正在搜寻LEADING：当前Server即为选举出来的leaderFOLLOWING：leader已经选举出来，当前Server与之同步2.1选主流程当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basicpaxos实现的，另外一种是基于fastpaxos算法实现的。系统默认的选举算法为fastpaxos。先介绍basicpaxos流程：1.选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；2.选举线程首先向所有Server发起一次询问(包括自己)；3.选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；4.收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；5.线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2+1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：fastpaxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：2.2同步流程选完leader以后，zk就进入状态同步过程。1.leader等待server连接；2.Follower连接leader，将最大的zxid发送给leader；3.Leader根据follower的zxid确定同步点；4.完成同步后通知follower已经成为uptodate状态；5.Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。流程图如下所示：2.3工作流程2.3.1Leader工作流程Leader主要有三个功能：1.恢复数据；2.维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；3.Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。2.3.2Follower工作流程Follower主要有四个功能：1.向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；2.接收Leader消息并进行处理；3.接收Client的请求，如果为写请求，发送给Leader进行投票；4.返回Client结果。Follower的消息循环处理如下几种来自Leader的消息：1.PING消息：心跳消息；2.PROPOSAL消息：Leader发起的提案，要求Follower投票；3.COMMIT消息：服务器端最新一次提案的信息；4.UPTODATE消息：表明同步完成；5.REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；6.SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。对于observer的流程不再叙述，observer流程和Follower的唯一不同的地方就是observer不会参加leader发起的投票。主流应用场景：Zookeeper的主流应用场景实现思路（除去官方示例）(1)配置管理集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。Zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(""/APP1"",true)),并且实现回调方法Watcher，那么在zookeeper上/APP1znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(""/APP1"",false,null));以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。(2)集群管理应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch/APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。另外有一个应用场景就是集群选master,一旦master挂掉能够马上能从slave中选出一个master,实现步骤和前者一样，只是机器在启动的时候在APP1SERVERS创建的节点类型变为EPHEMERAL_SEQUENTIAL类型，这样每个节点会自动被编号我们默认规定编号最小的为master,所以当我们对/APP1SERVERS节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为master，那么master就被选出，而这个master宕机的时候，相应的znode会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为master，这样就做到动态master选举。Zookeeper监视（Watches）简介ZookeeperCAPI的声明和描述在include/zookeeper.h中可以找到，另外大部分的ZookeeperCAPI常量、结构体声明也在zookeeper.h中，如果如果你在使用CAPI是遇到不明白的地方，最好看看zookeeper.h，或者自己使用doxygen生成ZookeeperCAPI的帮助文档。Zookeeper中最有特色且最不容易理解的是监视(Watches)。Zookeeper所有的读操作——getData(),getChildren(),和exists()都可以设置监视(watch)，监视事件可以理解为一次性的触发器，官方定义如下：awatcheventisone-timetrigger,senttotheclientthatsetthewatch,whichoccurswhenthedataforwhichthewatchwassetchanges。对此需要作出如下理解：（一次性触发）One-timetrigger当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了getData(""/znode1"",true)并且稍后/znode1节点上的数据发生了改变或者被删除了，客户端将会获取到/znode1发生变化的监视事件，而如果/znode1再一次发生了变化，除非客户端再次对/znode1设置监视，否则客户端不会收到事件通知。（发送至客户端）SenttotheclientZookeeper客户端和服务端是通过socket进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper本身提供了保序性(orderingguarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的znode发生了变化(aclientwillneverseeachangeforwhichithassetawatchuntilitfirstseesthewatchevent).网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。（被设置watch的数据）Thedataforwhichthewatchwasset这意味着znode节点本身具有不同的改变方式。你也可以想象Zookeeper维护了两条监视链表：数据监视和子节点监视(datawatchesandchildwatches)getData()andexists()设置数据监视，getChildren()设置子节点监视。或者，你也可以想象Zookeeper设置的不同监视返回不同的数据，getData()和exists()返回znode节点的相关信息，而getChildren()返回子节点列表。因此，setData()会触发设置在某一节点上所设置的数据监视(假定数据设置成功)，而一次成功的create()操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的delete()操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的childwatch。Zookeeper中的监视是轻量级的，因此容易设置、维护和分发。当客户端与Zookeeper服务器端失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说这通常是透明的。只有一种情况会导致监视事件的丢失，即：通过exists()设置了某个znode节点的监视，但是如果某个客户端在此znode节点被创建和删除的时间间隔内与zookeeper服务器失去了联系，该客户端即使稍后重新连接zookeeper服务器后也得不到事件通知。ZookeeperCAPI常量与部分结构(struct)介绍与ACL相关的结构与常量：structId结构为：structId{char*scheme;char*id;};structACL结构为：structACL{int32_tperms;structIdid;};structACL_vector结构为：structACL_vector{int32_tcount;structACL*data;};与znode访问权限有关的常量constintZOO_PERM_READ;//允许客户端读取znode节点的值以及子节点列表。constintZOO_PERM_WRITE;//允许客户端设置znode节点的值。constintZOO_PERM_CREATE;//允许客户端在该znode节点下创建子节点。constintZOO_PERM_DELETE;//允许客户端删除子节点。constintZOO_PERM_ADMIN;//允许客户端执行set_acl()。constintZOO_PERM_ALL;//允许客户端执行所有操作，等价与上述所有标志的或(OR)。与ACLIDs相关的常量structIdZOO_ANYONE_ID_UNSAFE;//(‘world’,’anyone’)structIdZOO_AUTH_IDS;//(‘auth’,’’)三种标准的ACLstructACL_vectorZOO_OPEN_ACL_UNSAFE;//(ZOO_PERM_ALL,ZOO_ANYONE_ID_UNSAFE)structACL_vectorZOO_READ_ACL_UNSAFE;//(ZOO_PERM_READ,ZOO_ANYONE_ID_UNSAFE)structACL_vectorZOO_CREATOR_ALL_ACL;//(ZOO_PERM_ALL,ZOO_AUTH_IDS)与Interest相关的常量：ZOOKEEPER_WRITE,ZOOKEEPER_READ这两个常量用于标识感兴趣的事件并通知zookeeper发生了哪些事件。Interest常量可以进行组合或（OR）来标识多种兴趣(multipleinterests:write,read)，这两个常量一般用于zookeeper_interest()和zookeeper_process()两个函数中。与节点创建相关的常量：ZOO_EPHEMERAL,ZOO_SEQUENCEzoo_create函数标志，ZOO_EPHEMERAL用来标识创建临时节点，ZOO_SEQUENCE用来标识节点命名具有递增的后缀序号(一般是节点名称后填充10位字符的序号，如/xyz0000000000,/xyz0000000001,/xyz0000000002,...)，同样地，ZOO_EPHEMERAL,ZOO_SEQUENCE可以组合。与连接状态Stat相关的常量以下常量均与Zookeeper连接状态有关，他们通常用作监视器回调函数的参数。ZOOAPIconstintZOO_EXPIRED_SESSION_STATEZOOAPIconstintZOO_AUTH_FAILED_STATEZOOAPIconstintZOO_CONNECTING_STATEZOOAPIconstintZOO_ASSOCIATING_STATEZOOAPIconstintZOO_CONNECTED_STATE与监视类型(WatchTypes)相关的常量以下常量标识监视事件的类型，他们通常用作监视器回调函数的第一个参数。ZOO_CREATED_EVENT;//节点被创建(此前该节点不存在)，通过zoo_exists()设置监视。ZOO_DELETED_EVENT;//节点被删除，通过zoo_exists()和zoo_get()设置监视。ZOO_CHANGED_EVENT;//节点发生变化，通过zoo_exists()和zoo_get()设置监视。ZOO_CHILD_EVENT;//子节点事件，通过zoo_get_children()和zoo_get_children2()设置监视。ZOO_SESSION_EVENT;//会话丢失ZOO_NOTWATCHING_EVENT;//监视被移除。ZookeeperCAPI错误码介绍ZOO_ERRORSZOK正常返回ZSYSTEMERROR系统或服务器端错误(Systemandserver-sideerrors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，即大于该错误值，且小于ZAPIERROR都是系统错误。ZRUNTIMEINCONSISTENCY运行时非一致性错误。ZDATAINCONSISTENCY数据非一致性错误。ZCONNECTIONLOSSZookeeper客户端与服务器端失去连接ZMARSHALLINGERROR在marshalling和unmarshalling数据时出现错误(Errorwhilemarshallingorunmarshallingdata)ZUNIMPLEMENTED该操作未实现(Operationisunimplemented)ZOPERATIONTIMEOUT该操作超时(Operationtimeout)ZBADARGUMENTS非法参数错误(Invalidarguments)ZINVALIDSTATE非法句柄状态(Invliadzhandlestate)ZAPIERRORAPI错误(APIerrors)，服务器不会抛出该错误，该错误也只是用来标识错误范围的，错误值大于该值的标识API错误，而小于该值的标识ZSYSTEMERROR。ZNONODE节点不存在(Nodedoesnotexist)ZNOAUTH没有经过授权(Notauthenticated)ZBADVERSION版本冲突(Versionconflict)ZNOCHILDRENFOREPHEMERALS临时节点不能拥有子节点(Ephemeralnodesmaynothavechildren)ZNODEEXISTS节点已经存在(Thenodealreadyexists)ZNOTEMPTY该节点具有自身的子节点(Thenodehaschildren)ZSESSIONEXPIRED会话过期(Thesessionhasbeenexpiredbytheserver)ZINVALIDCALLBACK非法的回调函数(Invalidcallbackspecified)ZINVALIDACL非法的ACL(InvalidACLspecified)ZAUTHFAILED客户端授权失败(Clientauthenticationfailed)ZCLOSINGZookeeper连接关闭(ZooKeeperisclosing)ZNOTHING并非错误，客户端不需要处理服务器的响应(noterror,noserverresponsestoprocess)ZSESSIONMOVED会话转移至其他服务器，所以操作被忽略(sessionmovedtoanotherserver,sooperationisignored)Watch事件类型：ZOO_CREATED_EVENT：节点创建事件，需要watch一个不存在的节点，当节点被创建时触发，此watch通过zoo_exists()设置ZOO_DELETED_EVENT：节点删除事件，此watch通过zoo_exists()或zoo_get()设置ZOO_CHANGED_EVENT：节点数据改变事件，此watch通过zoo_exists()或zoo_get()设置ZOO_CHILD_EVENT：子节点列表改变事件，此watch通过zoo_get_children()或zoo_get_children2()设置ZOO_SESSION_EVENT：会话失效事件，客户端与服务端断开或重连时触发ZOO_NOTWATCHING_EVENT：watch移除事件，服务端出于某些原因不再为客户端watch节点时触发",2014/12/26
563,java压缩对象 与 对象的序列化,丁凯,http://180.168.156.212:2262/wecenter/?/article/8720,"一．概述gzip是目前广泛应用的一种压缩方式,它具有很高的压缩比和压缩效率.在sun公司发布的jdk中包含了java.util.zip包,对gzip提供了直接支持.使用java语言可以很方便的实现gzip压缩和解压缩.非面向对象语言要实现保存工作数据(如一个绘图程序保存一幅画面的定义),往往需要一个程序将数据格式转换为外部文件格式存储,工作时再反向转换的过程.实现起来比较麻烦,而且编程不透明.而java语言是一种面向对象的语言,使用它的对象序列化特性,就可实现将工作对象直接写入硬盘,需要时再直接再读入内存,不需任何额外操作.实现非常方便.但由于写出对象为java类格式,因此数据冗余度较大.当数据量很大时,往往造成存储文件很大.过多的磁盘操作也导致数据读入花费了更多时间,占有了大量内存.采用gzip压缩存储对象是解决此类问题的有效手段.java程序开发网络应用程序是它的最大优势,但在某些低速网络情况下.网络往往造成传输瓶颈,影响应用效果,对于实时性要求高的应用影响更大.采用压缩可以有效改善通信效果.二．示例代码由上述可见,在java下的对象gzip压缩有着广泛的应用价值.以下是一个简单示例程序.1、序列化的对象文件importjava.io.*;importjava.util.zip.*;publicclassPersonimplementsSerializable{Stringname=""测试"";Stringsex=""男"";intage=25;}解压缩工具类publicclassGzipUtil{/***压缩序列化对象,返回字节数组,压缩后的对象数组可写入文件保存*或用于网络传输*/publicstaticbyte[]compressObject(Objectobj){byte[]data_=null;try{//建立字节数组输出流ByteArrayOutputStreamo=newByteArrayOutputStream();//建立gzip压缩输出流GZIPOutputStreamgzout=newGZIPOutputStream(o);//建立对象序列化输出流ObjectOutputStreamout=newObjectOutputStream(gzout);out.writeObject(obj);out.flush();out.close();gzout.close();//返回压缩字节流data_=o.toByteArray();o.close();}catch(IOExceptione){System.out.println(e);}returndata_;}/***将压缩字节数组还原为数据对象(解压缩)*/publicstaticObjectunCompressObject(byte[]data_){Objectobject_=null;try{//建立字节数组输入流ByteArrayInputStreami=newByteArrayInputStream(data_);//建立gzip解压输入流GZIPInputStreamgzin=newGZIPInputStream(i);//建立对象序列化输入流ObjectInputStreamin=newObjectInputStream(gzin);//按制定类型还原对象object_=(Object)in.readObject();i.close();gzin.close();in.close();}catch(IOExceptione){System.out.println(e);}returnobject_;}}测试主程序importjava.io.*;importjava.util.zip.*;publicclassTest{publicstaticvoidmain(String[]args){Personperson=newPerson();//未压缩数据对象内容System.out.println(""name=""+person.name+""sex=""+person.sex+""age=""+person.age);//压缩byte[]bytes=GzipUtil.compressObject(person);/***可执行保存或网络传输,需要时还原或在对端还原*///解压缩Personp=(Person)GzipUtil.unCompressObject(bytes);//解压缩后对象内容System.out.println(""name=""+p.name+""sex=""+p.sex+""age=""+p.age);}}",2014/12/26
564,JVM（java 虚拟机）内存设置,丁凯,http://180.168.156.212:2262/wecenter/?/article/8719,设置JVM内存1、设置JVM内存的参数有四个：-XmxJava堆最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；-XmsJava堆初始值，Server端JVM最好将-Xms和-Xmx设为相同值，以避免每次垃圾回收完成后JVM重新分配内存。开发测试机JVM可以保留默认值；-XmnJava堆年轻代大小，不熟悉最好保留默认值；-Xss每个线程的Stack大小，不熟悉最好保留默认值；JDK5.0以后默认1m。2、如何设置JVM内存分配：(1)当在命令提示符下启动并使用JVM时（只对当前运行的类Test生效）：java–Xmx512m–Xms512m-Xmn32m–Xss5mTest(2)当在集成开发环境下（如eclipse）启动并使用JVM时：a.在eclipse根目录下打开eclipse.ini，默认内容为（这里设置的是运行当前开发工具的JVM内存分配）：1.-vmargs2.-Xms40m3.-Xmx256m-vmargs表示以下为虚拟机设置参数，可修改其中的参数值，也可添加-Xmn，-Xss，另外，eclipse.ini内还可以设置非堆内存，如：-XX:PermSize=56m，-XX:MaxPermSize=128m。b.打开eclipse－窗口－首选项－Java－已安装的JRE（对在当前开发环境中运行的java程序皆生效）编辑当前使用的JRE，在缺省VM参数中输入：-Xmx128m-Xms64m-Xmn32m-Xss16mc.在运行配置中（只对所设置的java类生效）选定需设置内存分配的类－自变量，在VM自变量中输入：-Xmx128m-Xms64m-Xmn32m-Xss16m注：如果在同一开发环境中同时进行了b和c设置，则b设置生效，c设置无效，如：开发环境的设置为：-Xmx256m，而类Test的设置为：-Xmx128m-Xms64m，则运行Test时生效的设置为：-Xmx256m-Xms64m(3)当在服务器环境下（如Tomcat）启动并使用JVM时（对当前服务器环境下有Java程序生效）：a.设置环境变量：变量名：CATALINA_OPTS变量值：-Xmx128m-Xms64m-Xmn32m-Xss16mb.打开Tomcat根目录下的bin文件夹，编辑catalina.bat，将其中的%CATALINA_OPTS%（共有四处）替换换为：-Xmx128m-Xms64m-Xmn32m-Xss16m,2014/12/26
565,[转]Hadoop生态上几个技术的关系与区别：hive、pig、hbase 关系与区别,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8718,"初接触Hadoop技术的朋友肯定会对它体系下寄生的个个开源项目糊涂了，我敢保证Hive,Pig,HBase这些开源技术会把你搞的有些糊涂，不要紧糊涂的不止你一个，如某个菜鸟的帖子的疑问，whentouseHbaseandwhentouseHive？....请教了^_^没关系这里我帮大家理清每个技术的原理和思路。Pig一种操作hadoop的轻量级脚本语言，最初又雅虎公司推出，不过现在正在走下坡路了。当初雅虎自己慢慢退出pig的维护之后将它开源贡献到开源社区由所有爱好者来维护。不过现在还是有些公司在用，不过我认为与其使用pig不如使用hive。：）Pig是一种数据流语言，用来快速轻松的处理巨大的数据。Pig包含两个部分：PigInterface,PigLatin。Pig可以非常方便的处理HDFS和HBase的数据，和Hive一样,Pig可以非常高效的处理其需要做的，通过直接操作Pig查询可以节省大量的劳动和时间。当你想在你的数据上做一些转换，并且不想编写MapReducejobs就可以用Pig.Hive不想用程序语言开发MapReduce的朋友比如DB们，熟悉SQL的朋友可以使用Hive开离线的进行数据处理与分析工作。注意Hive现在适合在离线下进行数据的操作，就是说不适合在挂在真实的生产环境中进行实时的在线查询或操作，因为一个字“慢”。相反起源于FaceBook,Hive在Hadoop中扮演数据仓库的角色。建立在Hadoop集群的最顶层，对存储在Hadoop群上的数据提供类SQL的接口进行操作。你可以用HiveQL进行select,join,等等操作。如果你有数据仓库的需求并且你擅长写SQL并且不想写MapReducejobs就可以用Hive代替。HBaseHBase作为面向列的数据库运行在HDFS之上，HDFS缺乏随即读写操作，HBase正是为此而出现。HBase以GoogleBigTable为蓝本，以键值对的形式存储。项目的目标就是快速在主机内数十亿行数据中定位所需的数据并访问它。HBase是一个数据库，一个NoSql的数据库，像其他数据库一样提供随即读写功能，Hadoop不能满足实时需要，HBase正可以满足。如果你需要实时访问一些数据，就把它存入HBase。你可以用Hadoop作为静态数据仓库，HBase作为数据存储，放那些进行一些操作会改变的数据。PigVSHiveHive更适合于数据仓库的任务，Hive主要用于静态的结构以及需要经常分析的工作。Hive与SQL相似促使其成为Hadoop与其他BI工具结合的理想交集。Pig赋予开发人员在大数据集领域更多的灵活性，并允许开发简洁的脚本用于转换数据流以便嵌入到较大的应用程序。Pig相比Hive相对轻量，它主要的优势是相比于直接使用HadoopJavaAPIs可大幅削减代码量。正因为如此，Pig仍然是吸引大量的软件开发人员。Hive和Pig都可以与HBase组合使用，Hive和Pig还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单HiveVSHBaseHive是建立在Hadoop之上为了减少MapReducejobs编写工作的批处理系统，HBase是为了支持弥补Hadoop对实时操作的缺陷的项目。想象你在操作RMDB数据库，如果是全表扫描，就用Hive+Hadoop,如果是索引访问，就用HBase+Hadoop。Hivequery就是MapReducejobs可以从5分钟到数小时不止，HBase是非常高效的，肯定比Hive高效的多。",2014/12/26
566,[转]HDFS+MapReduce+Hbase+Hive内部机理详解,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8717,"通过这一阶段的调研总结，从内部机理的角度详细分析，HDFS、MapReduce、Hbase、Hive是如何运行，以及基于Hadoop数据仓库的构建和分布式数据库内部具体实现。如有不足，后续及时修改。HDFS的体系架构整个Hadoop的体系结构主要是通过HDFS来实现对分布式存储的底层支持，并通过MR来实现对分布式并行任务处理的程序支持。HDFS采用主从（Master/Slave）结构模型，一个HDFS集群是由一个NameNode和若干个DataNode组成的（在最新的Hadoop2.2版本已经实现多个NameNode的配置-这也是一些大公司通过修改hadoop源代码实现的功能，在最新的版本中就已经实现了）。NameNode作为主服务器，管理文件系统命名空间和客户端对文件的访问操作。DataNode管理存储的数据。HDFS支持文件形式的数据。从内部来看，文件被分成若干个数据块，这若干个数据块存放在一组DataNode上。NameNode执行文件系统的命名空间，如打开、关闭、重命名文件或目录等，也负责数据块到具体DataNode的映射。DataNode负责处理文件系统客户端的文件读写，并在NameNode的统一调度下进行数据库的创建、删除和复制工作。NameNode是所有HDFS元数据的管理者，用户数据永远不会经过NameNode。如图：HDFS体系结构图图中涉及三个角色：NameNode、DataNode、Client。NameNode是管理者，DataNode是文件存储者、Client是需要获取分布式文件系统的应用程序。文件写入：1）Client向NameNode发起文件写入的请求。2）NameNode根据文件大小和文件块配置情况，返回给Client它管理的DataNode的信息。3）Client将文件划分为多个block，根据DataNode的地址，按顺序将block写入DataNode块中。文件读取：1）Client向NameNode发起读取文件的请求。2）NameNode返回文件存储的DataNode信息。3）Client读取文件信息。HDFS作为分布式文件系统在数据管理方面可借鉴点：文件块的放置：一个Block会有三份备份，一份在NameNode指定的DateNode上，一份放在与指定的DataNode不在同一台机器的DataNode上，一根在于指定的DataNode在同一Rack上的DataNode上。备份的目的是为了数据安全，采用这种方式是为了考虑到同一Rack失败的情况，以及不同数据拷贝带来的性能的问题。MapReduce体系架构MR框架是由一个单独运行在主节点上的JobTracker和运行在每个集群从节点上的TaskTracker共同组成。主节点负责调度构成一个作业的所有任务，这些任务分布在不同的不同的从节点上。主节点监视它们的执行情况，并重新执行之前失败的任务。从节点仅负责由主节点指派的任务。当一个Job被提交时，JobTracker接受到提交作业和配置信息之后，就会将配置信息等分发给从节点，同时调度任务并监控TaskTracker的执行。JobTracker可以运行于集群中的任意一台计算机上。TaskTracker负责执行任务，它必须运行在DataNode上，DataNode既是数据存储节点，也是计算节点。JobTracker将map任务和reduce任务分发给空闲的TaskTracker，这些任务并行运行，并监控任务运行的情况。如果JobTracker出了故障，JobTracker会把任务转交给另一个空闲的TaskTracker重新运行。HDFS和MR共同组成Hadoop分布式系统体系结构的核心。HDFS在集群上实现了分布式文件系统，MR在集群上实现了分布式计算和任务处理。HDFS在MR任务处理过程中提供了文件操作和存储等支持，MR在HDFS的基础上实现了任务的分发、跟踪、执行等工作，并收集结果，二者相互作用，完成分布式集群的主要任务。Hadoop上的并行应用程序开发是基于MR编程框架。MR编程模型原理：利用一个输入的key-value对集合来产生一个输出的key-value对集合。MR库通过Map和Reduce两个函数来实现这个框架。用户自定义的map函数接受一个输入的key-value对，然后产生一个中间的key-value对的集合。MR把所有具有相同的key值的value结合在一起，然后传递个reduce函数。Reduce函数接受key和相关的value结合，reduce函数合并这些value值，形成一个较小的value集合。通常我们通过一个迭代器把中间的value值提供给reduce函数（迭代器的作用就是收集这些value值），这样就可以处理无法全部放在内存中的大量的value值集合了。说明：（第三幅图为同伴自己画的）流程简而言之，大数据集被分成众多小的数据集块，若干个数据集被分在集群中的一个节点进行处理并产生中间结果。单节点上的任务，map函数一行行读取数据获得数据的（k1,v1），数据进入缓存，通过map函数执行map（基于key-value）排序（框架会对map的输出进行排序）执行后输入（k2,v2）。每一台机器都执行同样的操作。不同机器上的（k2,v2）通过merge排序的过程（shuffle的过程可以理解成reduce前的一个过程），最后reduce合并得到，（k3,v3），输出到HDFS文件中。谈到reduce，在reduce之前，可以先对中间数据进行数据合并（Combine），即将中间有相同的key的<key,value>对合并。Combine的过程与reduce的过程类似，但Combine是作为map任务的一部分，在执行完map函数后仅接着执行。Combine能减少中间结果key-value对的数目，从而降低网络流量。Map任务的中间结果在做完Combine和Partition后，以文件的形式存于本地磁盘上。中间结果文件的位置会通知主控JobTracker，JobTracker再通知reduce任务到哪一个DataNode上去取中间结果。所有的map任务产生的中间结果均按其key值按hash函数划分成R份，R个reduce任务各自负责一段key区间。每个reduce需要向许多个map任务节点取的落在其负责的key区间内的中间结果，然后执行reduce函数，最后形成一个最终结果。有R个reduce任务，就会有R个最终结果，很多情况下这R个最终结果并不需要合并成一个最终结果，因为这R个最终结果可以作为另一个计算任务的输入，开始另一个并行计算任务。这就形成了上面图中多个输出数据片段（HDFS副本）。Hbase数据管理Hbase就是Hadoopdatabase。与传统的mysql、oracle究竟有什么差别。即列式数据与行式数据由什么区别。NoSql数据库与传统关系型数据由什么区别：HbaseVSOracle1、Hbase适合大量插入同时又有读的情况。输入一个Key获取一个value或输入一些key获得一些value。2、Hbase的瓶颈是硬盘传输速度。Hbase的操作，它可以往数据里面insert，也可以update一些数据，但update的实际上也是insert，只是插入一个新的时间戳的一行。Delete数据，也是insert，只是insert一行带有delete标记的一行。Hbase的所有操作都是追加插入操作。Hbase是一种日志集数据库。它的存储方式，像是日志文件一样。它是批量大量的往硬盘中写，通常都是以文件形式的读写。这个读写速度，就取决于硬盘与机器之间的传输有多快。而Oracle的瓶颈是硬盘寻道时间。它经常的操作时随机读写。要update一个数据，先要在硬盘中找到这个block，然后把它读入内存，在内存中的缓存中修改，过段时间再回写回去。由于你寻找的block不同，这就存在一个随机的读。硬盘的寻道时间主要由转速来决定的。而寻道时间，技术基本没有改变，这就形成了寻道时间瓶颈。3、Hbase中数据可以保存许多不同时间戳的版本（即同一数据可以复制许多不同的版本，准许数据冗余，也是优势）。数据按时间排序，因此Hbase特别适合寻找按照时间排序寻找Topn的场景。找出某个人最近浏览的消息，最近写的N篇博客，N种行为等等，因此Hbase在互联网应用非常多。4、Hbase的局限。只能做很简单的Key-value查询。它适合有高速插入，同时又有大量读的操作场景。而这种场景又很极端，并不是每一个公司都有这种需求。在一些公司，就是普通的OLTP（联机事务处理）随机读写。在这种情况下，Oracle的可靠性，系统的负责程度又比Hbase低一些。而且Hbase局限还在于它只有主键索引，因此在建模的时候就遇到了问题。比如，在一张表中，很多的列我都想做某种条件的查询。但却只能在主键上建快速查询。所以说，不能笼统的说那种技术有优势。5、Oracle是行式数据库，而Hbase是列式数据库。列式数据库的优势在于数据分析这种场景。数据分析与传统的OLTP的区别。数据分析，经常是以某个列作为查询条件，返回的结果也经常是某一些列，不是全部的列。在这种情况下，行式数据库反应的性能就很低效。行式数据库：Oracle为例，数据文件的基本组成单位：块/页。块中数据是按照一行行写入的。这就存在一个问题，当我们要读一个块中的某些列的时候，不能只读这些列，必须把这个块整个的读入内存中，再把这些列的内容读出来。换句话就是：为了读表中的某些列，必须要把整个表的行全部读完，才能读到这些列。这就是行数据库最糟糕的地方。列式数据库：是以列作为元素存储的。同一个列的元素会挤在一个块。当要读某些列，只需要把相关的列块读到内存中，这样读的IO量就会少很多。通常，同一个列的数据元素通常格式都是相近的。这就意味着，当数据格式相近的时候，数据就可以做大幅度的压缩。所以，列式数据库在数据压缩方面有很大的优势，压缩不仅节省了存储空间，同时也节省了IO。（这一点，可利用在当数据达到百万、千万级别以后，数据查询之间的优化，提高性能，示场景而定）Hive数据管理Hive是建立在Hadoop上的数据仓库基础架构。它提供了一系列的工具，用来进行数据提取、转换、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据机制。可以把Hadoop下结构化数据文件映射为一张成Hive中的表，并提供类sql查询功能，除了不支持更新、索引和事务，sql其它功能都支持。可以将sql语句转换为MapReduce任务进行运行，作为sql到MapReduce的映射器。提供shell、JDBC/ODBC、Thrift、Web等接口。优点：成本低可以通过类sql语句快速实现简单的MapReduce统计。作为一个数据仓库，Hive的数据管理按照使用层次可以从元数据存储、数据存储和数据交换三个方面介绍。（1）元数据存储Hive将元数据存储在RDBMS中，有三种方式可以连接到数据库：·内嵌模式：元数据保持在内嵌数据库的Derby，一般用于单元测试，只允许一个会话连接·多用户模式：在本地安装Mysql，把元数据放到Mysql内·远程模式：元数据放置在远程的Mysql数据库（2）数据存储首先，Hive没有专门的数据存储格式，也没有为数据建立索引，用于可以非常自由的组织Hive中的表，只需要在创建表的时候告诉Hive数据中的列分隔符和行分隔符，这就可以解析数据了。其次，Hive中所有的数据都存储在HDFS中，Hive中包含4中数据模型：Tabel、ExternalTable、Partition、Bucket。Table：类似与传统数据库中的Table，每一个Table在Hive中都有一个相应的目录来存储数据。例如：一个表zz，它在HDFS中的路径为：/wh/zz，其中wh是在hive-site.xml中由${hive.metastore.warehouse.dir}指定的数据仓库的目录，所有的Table数据（不含ExternalTable）都保存在这个目录中。Partition：类似于传统数据库中划分列的索引。在Hive中，表中的一个Partition对应于表下的一个目录，所有的Partition数据都存储在对应的目录中。例如：zz表中包含ds和city两个Partition，则对应于ds=20140214，city=beijing的HDFS子目录为：/wh/zz/ds=20140214/city=Beijing;Buckets：对指定列计算的hash，根据hash值切分数据，目的是为了便于并行，每一个Buckets对应一个文件。将user列分数至32个Bucket上，首先对user列的值计算hash，比如，对应hash=0的HDFS目录为：/wh/zz/ds=20140214/city=Beijing/part-00000;对应hash=20的，目录为：/wh/zz/ds=20140214/city=Beijing/part-00020。ExternalTable指向已存在HDFS中的数据，可创建Partition。和Table在元数据组织结构相同，在实际存储上有较大差异。Table创建和数据加载过程，可以用统一语句实现，实际数据被转移到数据仓库目录中，之后对数据的访问将会直接在数据仓库的目录中完成。删除表时，表中的数据和元数据都会删除。ExternalTable只有一个过程，因为加载数据和创建表是同时完成。世界数据是存储在Location后面指定的HDFS路径中的，并不会移动到数据仓库中。（3）数据交换·用户接口：包括客户端、Web界面和数据库接口·元数据存储：通常是存储在关系数据库中的，如Mysql，Derby等·Hadoop：用HDFS进行存储，利用MapReduce进行计算。关键点：Hive将元数据存储在数据库中，如Mysql、Derby中。Hive中的元数据包括表的名字、表的列和分区及其属性、表的属性（是否为外部表）、表数据所在的目录等。Hive的数据存储在HDFS中，大部分的查询由MapReduce完成。总结：通过对Hadoop分布式计算平台最核心的分布式文件系统HDFS、MapReduce处理过程，以及数据仓库工具Hive和分布式数据库Hbase的介绍。基本涵盖了Hadoop分布式平台的所有技术核心。从体系架构到数据定义到数据存储再到数据处理，从宏观到微观的系统介绍，为Hadoop平台上大规模的数据存储和任务处理打下基础。",2014/12/26
567,JAVA中IO流总结,张建涛,http://180.168.156.212:2262/wecenter/?/article/8716,我想你对JAVA的IO流有所了解，平时使用的也比较的多，但是对于其具体分类和继承体系可能知道的并不多，可能也很少去看相关的API文档，找出其中的关系和各自的应用情形。本文简单对常用的IO流进行分类整理，并简单举例说明其应用。希望本文对你有所帮助。（A）IO流大致分为两种：（1）字节流：对应抽象类为InputStream（输入流）和OutputStream（输出流）。（2）字符流：对应抽象类为Reader（输入流）和Writer（输出流）。（B）具体实现如下：（1）字节流：（常用的）FileInputStream实现了InputStream。（常用的）OutputStream实现了FileOutputStream。（2）字符流：（常用的）BufferedReader、InputStreamReader、StringReader实现了Reader，FileReader继承了InputStreamReader。（常用的）BufferedWriter、OutputStreamWriter、StringWriter实现了Writer，FileWriter继承了OutputStreamWriter。（C）实现类详情及使用情况如下：输出流：（1）OutputStreamWriter是字符流通向字节流的桥梁：使用指定的charset将要向其写入的字符编码为字节。它使用的字符集可以由名称指定或显式给定，否则可能接受平台默认的字符集。每次调用write()方法都会针对给定的字符（或字符集）调用编码转换器。在写入基础输出流之前，得到的这些字节会在缓冲区累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。为了达到最高效率，可考虑将OutputStreamWriter包装到BufferedWriter中以避免频繁调用转换器。例如：BufferedWriterout=newBufferedWriter(newOutputStreamWriter(System.out));（2）FileReader用来读取字符文件的便捷类，用于读取字符流。（3）BufferedReader具有缓冲区，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。（4）StringReader一个字符串的字符输入流。（5）FileInputStream要读取原始字节流。常用于读二进制文件，如图片、声音、影像等文件。输入流：（1）InputStreamReader是字节流通向字符流的桥梁：它使用指定的charset读取字节并将其解码为字符。每次调用其一个read()方法都会导致从基础输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从基础流读取更多的字节，使其超过满足当前读取操作所需的字节。为了达到最高效率，可要考虑在BufferedReader内包装InputStreamReader。例如：BufferedReaderin=newBufferedReader(newInputStreamReader(System.in));（2）FileWriter用来写入字符文件的便捷类。（3）BufferedWriter具有缓冲区，将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。（4）StringWriter一个字符串的字符输出流，可以用其回收在字符串缓冲区中的输出来构造字符串。（5）FileOutputStream写入原始字节流。常用于读二进制文件，如图片、声音、影像等文件。,2014/12/26
568,Jquery选择器的性能问题,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8715,"Jquery选择器的性能问题$('#id')在jQuery中最快的选择器是ID选择器$('#id').因为它直接映射为JavaScript的getElementById()方法。$(p)，$(div)在jQuery中第二快的选择器就是Tag选择器$(p).而这是因为它直接映射到JavaScript的getElementsByTagName()方法。$(.class)在jQuery里Class选择器是最慢的一个选择器;在IE中它循环整个DOM。在ie9以上或者比较新的浏览器中支持getElementsByClassName()方法，性能会有所提升。$(""[attribute=value]"")多数是使用DOM搜索的方式来实现的，在很多现代浏览器中支持querySelectorAll()方法，总得来说，性能并不是特别理想。总结：1.尽量使用id选择器。2.尽量给选择器指定上下文。",2014/12/25
569,Eclipse误删除文件的恢复,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8714,Eclipse误删除文件的恢复Eclipse误删除文件的恢复.doc,2014/12/25
570,2013版框架之Struts 2.1新增的REST支持,方俊新,http://180.168.156.212:2262/wecenter/?/article/8713,"Struts2.1增加了REST插件，通过REST插件提供REST支持。REST插件以Convention插件为基础，因此无需使用XML进行配置管理。Struts2.1通过REST插件完全可以提供让人和机器客户端共同使用的资源，并支持RubyOnRails风格的URL。RestActionMapper简介从本质上来看，Struts2依然是一个MVC框架，最初设计Struts2时并没有按REST架构进行设计，因此Struts2本质上并不是一个REST框架。但因为Struts2提供了良好的可扩展性，因此允许通过REST插件将其扩展成支持REST的框架。REST插件的核心是RestActionMapper，它负责将Rails风格的URL转换为传统请求的URL。用WinRAR打开struts2-rest-plugin-2.1.6文件，看到该文件里包含一个struts-plugin.xml文件，该文件中包含如下一行：<!--定义支持REST的ActionMapper--><beantype=""org.apache.struts2.dispatcher.mapper.ActionMapper""name=""rest""class=""org.apache.struts2.rest.RestActionMapper""/>通过查看RestActionMapper的API说明，我们发现它可接受如下几个参数：struts.mapper.idParameterName：用于设置ID请求参数的参数名，该属性值默认是id。struts.mapper.indexMethodName：设置不带id请求参数的GET请求调用Action的哪个方法。该属性值默认是index。struts.mapper.getMethodName：设置带id请求参数的GET请求调用Action的哪个方法。该属性值默认是show。struts.mapper.postMethodName：设置不带id请求参数的POST请求调用Action的哪个方法。该属性值默认是create。struts.mapper.putMethodName：设置带id请求参数的PUT请求调用Action的哪个方法。该属性值默认是update。struts.mapper.deleteMethodName：设置带id请求参数的DELETE请求调用Action的哪个方法。该属性值默认是destroy。struts.mapper.editMethodName：设置带id请求参数、且指定操作edit资源的GET请求调用Action的哪个方法。该属性值默认是edit。struts.mapper.newMethodName：设置不带id请求参数、且指定操作edit资源的GET请求调用Action的哪个方法。该属性值默认是editNew。提示：在RestActionMapper的方法列表中，我们看到setIdParameterName、setIndexMethodName、setGetMethodName、setPostMethodName、setPutMethodName、setDeleteMethodName、setEditMethodName、setNewMethodName等方法，这些方法对应为上面列出的方法提供setter支持。通常情况下，我们没有必要改变RestActionMapper的参数，直接使用这些参数的默认值就可支持Rails风格的REST。根据前面介绍可以看出：支持REST风格的Action至少包含如下7个方法：index：处理不带id请求参数的GET请求。show：处理带id请求参数的GET请求。create：处理不带id请求参数的POST请求。update：处理带id请求参数的PUT请求。destroy：处理带id请求参数的DELETE请求。edit：处理带id请求参数，且指定操作edit资源的GET请求。editNew：处理不带id请求参数，且指定操作edit资源的GET请求。如果请求需要向服务器发送id请求参数，直接将请求参数的值附加在URL中即可。表12.3显示了RestActionMapper对不同HTTP请求的处理结果：RestActionMapper对HTTP请求的处理HTTP方法URI调用Action的方法请求参数GET/bookindexPOST/bookcreatePUT/book/2updateid=2DELETE/book/2destroyid=2GET/book/2/showid=2GET/book/2/editeditid=2GET/book/neweditNew不幸的是，标准HTML语言目前根本不支持PUT和DELETE两个操作，为了弥补这种不足，REST插件允许开发者提交请求时额外增加一个_method请求参数，该参数值可以为PUT或DELETE，用于模拟HTTP协议的PUT和DELETE操作。2.参数配置//Action的类名以Controller为后缀<constantname=""struts.convention.action.suffix""value=""Controller""/>//Action中没有@Action注解也创建映射<constantname=""struts.convention.action.mapAllMatches""value=""true""/><constantname=""struts.convention.default.parent.package""value=""rest-default""/>//Action类所在的包<constantname=""struts.convention.action.packages""value=""com.st.web""/>//搜索以web为结尾的包<constantname=""struts.convention.package.locators""value=""web""/>",2014/12/25
571,4个对sql查询性能优化的知识,管俊,http://180.168.156.212:2262/wecenter/?/article/8711,"“SQL性能优化是一种黑魔法就像炼金术一样：各种配方难解晦涩，只有一小部分圈内人才能理解。”这是一种误解，SQL数据库使用的是大家公知的算法来实现可以预期的执行性能。然而，问题是，人们很容易写出不能发挥最高效算法的SQL查询语句，因而也容易产生无法预期的性能结果。下面是5个关于SQL性能优化的demo，这些demo也许会让你坚信SQL优化就是一种黑魔法。但答案中提供的解释说明会随即让你明白，这些所谓的黑魔法其实是纯粹的科学。本demo中使用的SQL是基于Oracle数据库。1.查询出年是2012的所有行：CREATEINDEXtb1_idxONtb1(date_column);SELECTtext,date_columnFROMtb1WHERETO_CHAR(date_column,'YYYY')='2012';这样写会有重大的性能问题,当表字段放到函数里执行查询时，索引将不起作用，效率更高的写法如下：SELECTtext,date_columnFROMtb1WHEREdate_column>=TO_DATE('2012-01-01','YYYY-MM-DD'ANDdate_column<TO_DATE('2013-01-01','YYYY-MM-DD');2.查询一个字符串:CREATEINDEXtb1_idxONtb1(text);SELECTid,textFROMtb1WHEREtextLIKE'%TERM%'这样写可能会产生重大的性能问题,因为like对应的查询字符如果是以通配符开头的，索引将无法发挥效能。也没有一个简单的方法来优化这种SQL3.如果从百万行数据中查询出几千行时，我们使用：CREATEINDEXtab_idxONtb1(a,date_column);SELECTdate_column,count(*)FROMtb1WHEREa=?GROUPBYdate_column;而当我们只需要从百万航数据中查询出10行时,把SQL改成这样:SELECTdate_column,count(*)FROMtb1WHEREa=?ANDb=?GROUPBYdate_column;修改后SQL执行效率至少会慢10%左右.在前一种查询中，索引覆盖了所有的查询字段，执行效能会非常高，而修改后的SQL，虽然返回的数据变少了，但新增的B字段并没有索引。4.查询num为null的ID>:SELECTidFROMtb1WHEREnumisnull应避免使用!=或＜＞、ISNULL或ISNOTNULL、IN，NOTIN等这样的操作符,因为这会使系统无法使用索引,而只能直接搜索表中的数据。可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：SELECTidFROMtb1WHEREnum=0其他的优化查询的方式还有很多,例如in和not尽量应用exists和notexists取代;能用unionall尽量不要用union;能够用between就不要用in;能用数值型的字段不要用varchar;利用建视图的方式来加速查询等等..有空再细说吧..",2014/12/24
572,软件工程思想,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8710,软件工程思想软件工程思想.pdf,2014/12/24
573,访问Controller时，无法找到方法，并将ID 当成了 方法名,李宏辉,http://180.168.156.212:2262/wecenter/?/article/8712,"新架构中在执行Action方法时，报无法找到方法，并将ID当成了方法名的异常如果是，可能同时存在namespace名称与该Controller访问名同名，如：/namespace/actionname=/abc/user如果你不小心定义了一个Action叫AbcController,并且修改ID=3的页面，那它访问的路径也为/abc/3/edit,那它此时无法获悉/abc是namespace还是actionName提供一款Struts2查看namespace和action名字的插件为了看到struts2应用里的Action等各种资源的影射情况，struts2提供了ConfigBrowser插件。使用方法，将struts2-config-browser-plugin-2.1.6.jar文件复制到struts2应用的WEB-INF/lib目录中。打开首页地址： actionNames.action这里可以看到ConfigBrowser插件的首页。注意：这里不管开发者是否使用struts.xml文件进行配置，一样可以看到struts的配置信息。",2014/12/24
574,"关于struts实现ModelDriven模型驱动后,部分属性参数值无法获取",李宏辉,http://180.168.156.212:2262/wecenter/?/article/8709,在用新架构开发的大多数项目中，都使用了HttpServletRequestrequest=ServletActionContext.getRequest();强行从Struts2环境中获取HTTP的Request对象，从而获取到Request对象里面的参数。通过断点调试，发现大伙这样写是有原因的，因为设置断点调试时，有些参数Struts根本就不执行它对应的Set方法，所有只能使用这种土办法实现参数获取。起初以为实现了模型驱动后，属性模式获取就失效，后发现并未如此，应为有些参数是调用Set方法进行参数设值的，经过分析，不能获取的参数是因为对应的模型对象属性里面已经含有该属性名，Struts2优先选择模型的属性设值，从而忽略了单独属性的Set方法。如果属性已经在模型对象里，请通过model的属性GET方法获得，从而减少Request对象的使用,2014/12/24
575,java性能优化之for循环,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8708,"完成同样的功能，用不同的代码来实现，性能上可能会有比较大的差别，所以对于一些性能敏感的模块来说，对代码进行一定的优化还是很有必要的。今天就来说一下java代码优化的事情，今天主要聊一下对于for（while等同理）循环的优化。作为三大结构之一的循环，在我们编写代码的时候会经常用到。循环结构让我们操作数组、集合和其他一些有规律的事物变得更加的方便，但是如果我们在实际开发当中运用不合理，可能会给程序的性能带来很大的影响。所以我们还是需要掌握一些技巧来优化我们的代码的。嵌套循环stratTime=System.nanoTime();for(inti=0;i<10000000;i++){for(intj=0;j<10;j++){}}endTime=System.nanoTime();System.out.println(""外大内小耗时：""+(endTime-stratTime));应改为：stratTime=System.nanoTime();for(inti=0;i<10;i++){for(intj=0;j<10000000;j++){}}endTime=System.nanoTime();System.out.println(""外小内大耗时：""+(endTime-stratTime));两者耗时对比：外大内小耗时：200192114外小内大耗时：97995997由以上对比可知，优化后性能提升了一倍，嵌套循环应该遵循“外小内大”的原则，这就好比你复制很多个小文件和复制几个大文件的区别。提取与循环无关的表达式fstratTime=System.nanoTime();for(inti=0;i<10000000;i++){i=i*a*b;}endTime=System.nanoTime();System.out.println(""未提取耗时：""+(endTime-stratTime));应改为：stratTime=System.nanoTime();c=a*b;for(inti=0;i<10000000;i++){i=i*c;}endTime=System.nanoTime();System.out.println(""已提取耗时：""+(endTime-stratTime));两者耗时对比：未提取耗时：45973050已提取耗时：1955代码中a+b与我们的循环无关，所以应该把它放到外面，避免重复计算，可以看出，优化后性能提升了好几个数量级，这些是不容忽视的。消除循环终止判断时的方法调用stratTime=System.nanoTime();for(inti=0;i<list.size();i++){}endTime=System.nanoTime();System.out.println(""未优化list耗时：""+(endTime-stratTime));应改为：stratTime=System.nanoTime();intsize=list.size();for(inti=0;i<size;i++){}endTime=System.nanoTime();System.out.println(""优化list耗时：""+(endTime-stratTime));两者耗时对比：未优化list耗时：27375优化list耗时：2444list.size()每次循环都会被执行一次，这无疑会影响程序的性能，所以应该将其放到循环外面，用一个变量来代替，优化前后的对比也很明显。异常捕获stratTime=System.nanoTime();for(inti=0;i<10000000;i++){try{}catch(Exceptione){}}endTime=System.nanoTime();System.out.println(""在内部捕获异常耗时：""+(endTime-stratTime));应改为：stratTime=System.nanoTime();try{for(inti=0;i<10000000;i++){}}catch(Exceptione){}endTime=System.nanoTime();System.out.println(""在外部捕获异常耗时：""+(endTime-stratTime));两者耗时对比：在内部捕获异常耗时：12150142在外部捕获异常耗时：1955大家都知道，捕获异常是很耗资源的，所以不要讲trycatch放到循环内部，优化后同样有好几个数量级的提升。性能优化的内容有很多，代码优化只是其中一小部分，我们在日常开发中应养成良好的编码习惯。接下来会跟大家探讨更多关于性能优化的内容，希望大家积极交流指导。",2014/12/23
576,Log4j 配置最全说明,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8707,看了几个log4j文档，还是这个最全面。在开发过程中大家对日志的输出都不是很重视。尤其是系统上线运行，出现bug不容易复现。大家在开发的过程中可以顺手把日志输出，在调试中和之后的系统维护，可以减少不少的工作量。Log4j配置最全说明.docx,2014/12/23
577,Java虚拟机（JVM）中的内存设置详解,张建涛,http://180.168.156.212:2262/wecenter/?/article/8706,"在一些规模稍大的应用中，Java虚拟机（JVM）的内存设置尤为重要，想在项目中取得好的效率，GC（垃圾回收）的设置是第一步。PermGenspace：全称是PermanentGenerationspace.就是说是永久保存的区域,用于存放Class和Meta信息,Class在被Load的时候被放入该区域Heapspace：存放Instance。GC(GarbageCollection)应该不会对PermGenspace进行清理,所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGenspace错误JavaHeap分为3个区1.Young2.Old3.PermanentYoung保存刚实例化的对象。当该区被填满时，GC会将对象移到Old区。Permanent区则负责保存反射对象，本文不讨论该区。JVM的Heap分配可以使用-X参数设定，-Xms初始Heap大小-Xmxjavaheap最大值-Xmnyounggeneration的heap大小JVM有2个GC线程第一个线程负责回收Heap的Young区第二个线程在Heap不足时，遍历Heap，将Young区升级为Older区Older区的大小等于-Xmx减去-Xmn，不能将-Xms的值设的过大，因为第二个线程被迫运行会降低JVM的性能。为什么一些程序频繁发生GC？有如下原因：1.程序内调用了System.gc()或Runtime.gc()。2.一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。3.Java的Heap太小，一般默认的Heap值都很小。4.频繁实例化对象，Release对象此时尽量保存并重用对象，例如使用StringBuffer()和String()。如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态,许多Server端的Java程序每次GC后最好能有65%的剩余空间经验之谈：1．Server端JVM最好将-Xms和-Xmx设为相同值。为了优化GC，最好让-Xmn值约等于-Xmx的1/3。2．一个GUI程序最好是每10到20秒间运行一次GC，每次在半秒之内完成。注意：1．增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。2．Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等。Stack的设定每个线程都有他自己的Stack。-Xss每个线程的Stack大小Stack的大小限制着线程的数量。如果Stack过大就好导致内存溢漏。-Xss参数决定Stack大小，例如-Xss1024K。如果Stack太小，也会导致Stack溢漏。硬件环境硬件环境也影响GC的效率，例如机器的种类，内存，swap空间，和CPU的数量。如果你的程序需要频繁创建很多transient对象，会导致JVM频繁GC。这种情况你可以增加机器的内存，来减少Swap空间的使用。4种GC1、第一种为单线程GC，也是默认的GC，该GC适用于单CPU机器。2、第二种为ThroughputGC，是多线程的GC，适用于多CPU，使用大量线程的程序。第二种GC与第一种GC相似，不同在于GC在收集Young区是多线程的，但在Old区和第一种一样，仍然采用单线程。-XX:+UseParallelGC参数启动该GC。3、第三种为ConcurrentLowPauseGC，类似于第一种，适用于多CPU，并要求缩短因GC造成程序停滞的时间。这种GC可以在Old区的回收同时，运行应用程序。-XX:+UseConcMarkSweepGC参数启动该GC。4、第四种为IncrementalLowPauseGC，适用于要求缩短因GC造成程序停滞的时间。这种GC可以在Young区回收的同时，回收一部分Old区对象。-Xincgc参数启动该GC。单文件的JVM内存进行设置默认的java虚拟机的大小比较小，在对大数据进行处理时java就会报错：java.lang.OutOfMemoryError。设置jvm内存的方法，对于单独的.class，可以用下面的方法对Test运行时的jvm内存进行设置。java-Xms64m-Xmx256mTest-Xms是设置内存初始化的大小-Xmx是设置最大能够使用内存的大小（最好不要超过物理内存大小）tomcat启动jvm内存设置Linux：在/usr/local/apache-tomcat-5.5.23/bin目录下的catalina.sh添加：JAVA_OPTS='-Xms512m-Xmx1024m'要加“m”说明是MB，否则就是KB了，在启动tomcat时会报内存不足。-Xms：初始值-Xmx：最大值-Xmn：最小值Windows在catalina.bat最前面加入setJAVA_OPTS=-Xms128m-Xmx350m如果用startup.bat启动tomcat,OK设置生效.够成功的分配200M内存.但是如果不是执行startup.bat启动tomcat而是利用windows的系统服务启动tomcat服务,上面的设置就不生效了,就是说setJAVA_OPTS=-Xms128m-Xmx350m没起作用.上面分配200M内存就OOM了..windows服务执行的是bin\tomcat.exe.他读取注册表中的值,而不是catalina.bat的设置.解决办法:修改注册表HKEY_LOCAL_MACHINE\SOFTWARE\ApacheSoftwareFoundation\TomcatServiceManager\Tomcat5\Parameters\JavaOptions原值为-Dcatalina.home=""C:\ApacheGroup\Tomcat5.0""-Djava.endorsed.dirs=""C:\ApacheGroup\Tomcat5.0\common\endorsed""-Xrs加入-Xms300m-Xmx350m重起tomcat服务,设置生效weblogic启动jvm内存设置在weblogic中，可以在startweblogic.cmd中对每个domain虚拟内存的大小进行设置，默认的设置是在commEnv.cmd里面。JBoss默认可以使用的内存为64MB$JBOSSDIR$/bin/run.configJAVA_OPTS=""-server-Xms128-Xmx512""Eclipse在所在目录下，键入eclipse.exe-vmargs-Xms256m-Xmx512m256m表示JVM堆内存最小值512m表示JVM堆内存最大Websphere进入控制台去设置：应用程序服务器>server1>进程定义>Java虚拟机",2014/12/23
578,web.xml详细介绍,丁凯,http://180.168.156.212:2262/wecenter/?/article/8705,"1、启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取<listener>和<context-param>两个结点。2、紧急着，容创建一个ServletContext（servlet上下文），这个web项目的所有部分都将共享这个上下文。3、容器将<context-param>转换为键值对，并交给servletContext。4、容器创建<listener>中的类实例，创建监听器。二Load-on-startupLoad-on-startup元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候，加载这个servlet。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。在servlet的配置当中，<load-on-startup>5</load-on-startup>的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。三加载顺序首先可以肯定的是，加载顺序与它们在web.xml文件中的先后顺序无关。即不会因为filter写在listener的前面而会先加载filter。最终得出的结论是：ServletContext->listener->filter->servlet同时还存在着这样一种配置节：context-param，它用于向ServletContext提供键值对，即应用程序上下文信息。我们的listener,filter等在初始化时会用到这些上下文中的信息，那么context-param配置节是不是应该写在listener配置节前呢？实际上context-param配置节可写在任意位置，因此真正的加载顺序为：context-param->listener->filter->servlet对于某类配置节而言，与它们出现的顺序是有关的。以filter为例，web.xml中当然可以定义多个filter，与filter相关的一个配置节是filter-mapping，这里一定要注意，对于拥有相同filter-name的filter和filter-mapping配置节而言，filter-mapping必须出现在filter之后，否则当解析到filter-mapping时，它所对应的filter-name还未定义。web容器启动时初始化每个filter时，是按照filter配置节出现的顺序来初始化的，当请求资源匹配多个filter-mapping时，filter拦截资源是按照filter-mapping配置节出现的顺序来依次调用doFilter()方法的。servlet同filter类似，此处不再赘述。由此，可以看出，web.xml的加载顺序是：ServletContext->context-param->listener->filter->servlet，而同个类型之间的实际程序调用的时候的顺序是根据对应的mapping的顺序进行调用的。四web.xml文件详解我将自己知道的web.xml的元素整理了一下：web.xml首先是肯定要包含它的schema.<web-appxmlns="" </welcome-file></welcome-file-list>11、配置错误页面一、通过错误码来配置error-page<error-page><error-code>404</error-code><location>/NotFound.jsp</location></error-page>上面配置了当系统发生404错误时，跳转到错误处理页面NotFound.jsp。二、通过异常的类型配置error-page<error-page><exception-type>java.lang.NullException</exception-type><location>/error.jsp</location></error-page>上面配置了当系统发生java.lang.NullException（即空指针异常）时，跳转到错误处理页面error.jsp12、TLD配置<taglib><taglib-uri> p</url-pattern></filter-mapping><filter-mapping><filter-name>SecurityFilter</filter-name><url-pattern>*.do</url-pattern></filter-mapping>",2014/12/19
579,Win7 操作系统日常使用遇到的问题及解决方案,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8704,win7系统下，IE8，IE9浏览器经常出现程序未响应的问题解决方案。打开“Internet选项”对话框。单击“高级”选项卡，在“重置InternetExplorer设置”下，单击“重置”在“重置InternetExplorer设置”对话框下，再次单击“设置”。（你也可以勾选“删除个性化设置”，以相应的个性化信息重置为默认设置。）InternetExplorer完成重置设置后，单击“重置InternetExplorer设置”对话框中的关闭再次启动InternetExplorer，一般这个问题就会得到解决。2.win7系统下IE8下载软件或者打开部分网页时提示一个当前安全设置会使计算机有风险提示，总提示修复IE解决方法。点击-->开始-->运行-->输入gpedit.msc-->打开组策略编辑器-->计算机配置-->管理模板-->Windows组件-->点击InternetExplorer-->在右边找到“关闭安全设置检查功能”-->双击“关闭安全设置检查功能”进行设置，选择“已启用”点击确定。关闭所有的IE窗口，重新运行就不会显示“当前安全设置会使就算几有风险提示.....”的提示了。3.win7怎样禁止进入待机?在电源选项里的更改计划设置里使计算机进入睡眠状态改为从不。4.win7怎样自动登录用户？在运行里输入controluserpasswords2然后去掉那个勾后，应用，输入密码，重启后就自动登陆了。5.win7忘记登录密码？最简单的办法就是：开机到欢迎界面时，出现输入用户名密码的提示框，按Ctrl+Alt+Delete，跳出帐号窗口，输入用户名：administrator，回车即可。如果这个administrator帐号也有密码，那么可以这样：在win7系统启动时按F8，选“带命令行的安全模式”，然后选“Administrator”跳出“CommandPrompt”窗口增加用户：netuserasd/add升管理员：netlocalgroupadministratorsasd/add重启，选asd进入控制面板----用户帐号----忘记密码的用户--删除密码即可6.win7启动服务时出现提示，提示无法启用解决方法。在开始菜单的搜索框中输入“regedit”并回车打开注册表编辑器，然后定位到“HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/SessionManager/MemoryManagement/PrefetchParameters”。在将右侧的“EnableSuperfetch”键值改为3，在重新启动服务即可。,2014/12/19
580,可以用的google,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/8703,最近直接输入google网址无法使用，找了一下后直接输入 就可以用了,2014/12/19
581,祝我们敬爱的总裁张曙华生日快乐,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8702,12月29日是我们敬爱的总裁张曙华的生辰，请作为中信人的您为他送一份最诚挚的祝福，你的美好祝愿会通过这个平台第一时间传达到他的心里，温暖点燃整个公司，感谢您！,2014/12/17
582,端口查看器,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8699,共享一个我常用的解决端口冲突的软件1.可以显示当前所有TCP/UDP的端口使用情况。2.可以根据端口结束程序。3.可以关闭正在使用指定的端口的连接。4.可以标记正在被不明程序使用的端口。5.可以显示连接的状态，例如“正在监听”，“等待关闭”等。6.可以使用过滤器进行列表过滤，只显示指定的信息。7.可以很简单地拖动鼠标到指定程序，查看该程序正在使用的端口。8.可以记录日志文件，和把列表导出为网页文件。端口查看.rar,2014/12/17
583,JS Touch事件,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8701,touchstart:当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。touchmove:当手指在屏幕上滑动时连续的触发。在这个事件发生期间，调用preventDefault()可阻止滚动。touchend:当手指从屏幕上移开时触发。touchcancel:当系统停止跟踪触摸时触发。touches:表示当前跟踪的触摸操作的Touch对象的数组。targetTouches:特定于事件目标的Touch对象的数组。changeTouches:表示自上次触摸以来发生了什么改变的Touch对象的数组。每个Touch对象包含下列属性clientX:触摸目标在视口中的X坐标。clientY:触摸目标在视口中的Y坐标。identifier：表示触摸的唯一ID。pageX：触摸目标在页面中的x坐标。pageY：触摸目标在页面中的y坐标。screenX:触摸目标在屏幕中的x坐标。screenY:触摸目标在屏幕中的y坐标。target:触摸的DOM节点坐标。gesturestart:当一个手指已经按在屏幕上面另一个手指有触摸屏幕时触发。gesturechange:当触摸屏幕的任何一个手指的位置发生变化时触发。gestureend:当任何一个手指从屏幕上面移开时触发。,2014/12/17
584,Google的WEB开发最佳实践,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8698, /web/fundamentals/Google的开发人员写的，构建美妙的多设备web体验，推荐给大家看看。,2014/12/16
585,SWT内Browser组件的一些问题,张殷豪,http://180.168.156.212:2262/wecenter/?/article/8697,内容见附件包括：1、SWT内的Browser组建调用系统内安装的最高版本IE2、SWT调用firefox内核，并使用个性化配置3、在SWT内进行html和JS调试2014年11月经验分享.docx,2014/12/16
586,nodql之redis初探,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8696,内容见附件研发中心经验共享_张殷豪[201411].docx,2014/12/15
587,前端性能优化——使用工具分析并移除未使用的CSS选择器,王雷2,http://180.168.156.212:2262/wecenter/?/article/8693,使用工具分析并移除未使用的CSS选择器使用工具分析并移除未使用的CSS选择器.docx,2014/12/12
588,Arrays.asList后的list新增删除操作时报java.lang.UnsupportedOperationException,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8695,详见附件Arrays.asList后的list新增删除操作时报java.lang.UnsupportedOperationException.docx,2014/12/12
589,IE11下javascript脚本不执行的问题,袁嘉新,http://180.168.156.212:2262/wecenter/?/article/8694,"项目反馈一个问题：通用浏览器打开全文页面，显示高度不全$(document).ready(function(){$(""#ContentFrame"").height($(window).height()-20);});不执行相应的脚本，该如何解决呢？如何检测用户浏览器是否禁用了javascript？肯定不能用js来判断，因为在禁用js的情况下任何js都无法执行。我们可以用noscript标签来判断，如下代码：如果在浏览器中禁用了javascript，那么就会导致网页显示不正常，放多视频或者带有弹出窗口的网页就会显示不出来，禁用通常是某些软件或者病毒通过设置的原因，我们可以在IE浏览器中还原这个更改。请首先检查一下浏览器是否禁用了javascript,一种解决方案是设定网站服务器以指定预设兼容性模式如果服务器是自己的话，可以在服务器上定义一个自订标头来为它们的网站预设一个特定的文件兼容性模式。这个特定的方法取决于你的网站服务器。录入，下列的web.config文件使MicrosoftInternetInformationServices(IIS)能定义一个自订标头以自动使用IE7mode来编译所有网页。在你网站的web.config中配置IE的兼容模式：还有一种方式是在页面中添加以下meta：可以在一个公用的页面里面加:然后每个页面进行引用，内容如下：<%response.setHeader(""X-UA-Compatible"",""IE=EmulateIE7"");%>在JSP中引用：response.setHeader(""X-UA-Compatible"",""IE=EmulateIE7"");",2014/12/12
590,IE11的一些特性,王雷2,http://180.168.156.212:2262/wecenter/?/article/8692,详见附件IE11的一些特性.docx,2014/12/12
591,谷歌浏览器中的onload问题,庄恒沧,http://180.168.156.212:2262/wecenter/?/article/8700,"最近在使用html5的canvas展示三维模型时碰到一个问题，在火狐下对模型操作，正常显示，在chrome下模型就不见了。后经查找，发现在chrome中，当img.src重复设置为相同的值的时候，img.onload不会重复执行，图片就没有显示了，火狐下不存在这个问题。为了让img.onload每次都能运行，只能让img.src每次都改变。原始代码：functiondraw(){img.onload=function(){clean();imgh=img.height;imgw=img.width;HB.drawImage(img,-imgw*myCanvas.height/imgh/2,-myCanvas.height/2,imgw*myCanvas.height/imgh,myCanvas.height);};img.src=""0/size=0&v=""+numV+""&h=""+num+"".jpg"";}解决方案：functiondraw(){img.onload=null;img.src="""";img.onload=function(){clean();imgh=img.height;imgw=img.width;HB.drawImage(img,-imgw*myCanvas.height/imgh/2,-myCanvas.height/2,imgw*myCanvas.height/imgh,myCanvas.height);};img.src=""0/size=0&v=""+numV+""&h=""+num+"".jpg"";}通过增加img.onload=null;img.src="""";这2行代码，chrome正常工作了。",2014/12/10
592,IE7下jqgrid问题,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8691,IE7下jqgrid问题研发中心经验共享-毛璀玲[201411].doc,2014/12/9
593,传教士与食人魔如何安全过河？？？,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8690,"这是我帮同学做的一个小问题（她的课题）！大家在茶余饭后休息时可以拿出来开发开发自己的大脑！附件是这个问题的解法！点击jar包就可以运行程序啦！得到正确答案，前提是你电脑里需要安装jdk哦！传教士与食人魔过河问题：有N个传教士和M个食人魔渡河，现在有一艘船只能承载K个人（包括食人魔），K<N,在任何时刻，如果有食人魔和传教士在一起，必须要求传教士必须多余或者等于食人魔的数量，不然食人魔将会吃掉传教士，渡河失败！那么加入传教士有3人，食人魔有两2人，船最多载客2人，求传教士和食人魔的正确渡河方案？如下：一共需要11步:食人魔2人从左岸到右岸食人魔1人从右岸到左岸传教士1人从左岸到右岸食人魔1人从右岸到左岸传教士1人食人魔1人从左岸到右岸传教士1人从右岸到左岸传教士1人食人魔1人从左岸到右岸食人魔1人从右岸到左岸传教士1人从左岸到右岸食人魔1人从右岸到左岸食人魔2人从左岸到右岸搜索结束那么你可以自己任意组合，看旁边的同事能不能得到好的方案哦！（步骤越少越好！）食人魔过河.rar",2014/12/8
594,64位环境下的DBF导入问题,张建涛,http://180.168.156.212:2262/wecenter/?/article/8689,"虚拟档案室的档案收集模块，DBF导入功能，客户反映在进行导入的时候，前台显示一直在处理中，后台报错。我在我本机做测试，能正常导入，没有复现错误。最后确定是因为客户是server200864位的系统，而我的则是XP32位。找到原因了，下面看一下虚拟档案室在读取dbf文件时的代码的写法。这种方法是把DBF文件当做一个库，然后拿到一个connection去读取出现这个错误的原因是因为64位系统已不支持jdbc-odbc,网上有的说可以配置，即使可以配置，这种写法在系统兼容方面不通用下面是纯java读取以流的方式使用一个javadbf的jar包publicstaticvoidreadDBF(Stringpath){InputStreamfis=null;try{//读取文件的输入流fis=newFileInputStream(path);//根据输入流初始化一个DBFReader实例，用来读取DBF文件信息DBFReaderreader=newDBFReader(fis);//调用DBFReader对实例方法得到path文件中字段的个数intfieldsCount=reader.getFieldCount();System.out.println(""字段数:""+fieldsCount);//取出字段信息for(inti=0;i<fieldsCount;i++){DBFFieldfield=reader.getField(i);System.out.println(field.getName());}Object[]rowValues;//一条条取出path文件中记录while((rowValues=reader.nextRecord())!=null){for(inti=0;i<rowValues.length;i++){System.out.println(rowValues[i]);}}}catch(Exceptione){e.printStackTrace();}finally{try{fis.close();}catch(Exceptione){}}}",2014/12/8
595,JDK中MessageFormat,甘名辉,http://180.168.156.212:2262/wecenter/?/article/8688,"主要说明在属性文件中占位符解析,以及一些注意事项.研发中心经验共享_甘名辉[201411].doc",2014/12/8
596,经验共享之hibernate规则总结一,丁凯,http://180.168.156.212:2262/wecenter/?/article/8687,经验共享之hibernate规则总结一研发中心经验共享[201411]_丁凯.doc,2014/12/8
597,客户档案全文索引部署,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8686,solrCloud在客户档案中的应用客户档案全文索引部署.docx,2014/12/5
598,十一月经验共享之权限按钮控制,何文,http://180.168.156.212:2262/wecenter/?/article/8685,这是我在十一月份修改的一个bug权限按钮控制修改.docx,2014/12/5
599,第五届中国电子文件管理论坛,路斌,http://180.168.156.212:2262/wecenter/?/article/8684,上周参加了中国人民大学举行的第五届中国电子文件管理论坛--电子文件管理学术派的会议。会议材料参见附件：推荐：1、陈永生《电子政务系统中的档案管理：问题与思考》很接地气。2、刘越男《电子文件管理系统建设指南简介》为人大正在编制的指南。与《电子文件管理系统通用功能要求》（GB/T29194-2012）相配套。两者侧重点pdf里面也介绍了。第五届中国电子文件管理论坛讲座材料（30日）.zip第五届中国电子文件管理论坛讲座材料（29日）.zip,2014/12/2
600,十一月经验共享之iconfont浅谈,孟帅,http://180.168.156.212:2262/wecenter/?/article/8683,这里主要介绍下国内的阿里巴巴吧！1.1平台简介Iconfont.cn是由阿里巴巴UX部门推出的矢量图标管理网站，也是国内首家推广Webfont形式图标的平台。网站涵盖了1000多个常用图标并还在持续更新中，Iconfont平台为用户提供在线图标搜索、图标分捡下载、在线储存、矢量格式转换、个人图标库管理及项目图标管理等基础功能。同时iconfont.cn平台作为矢量图标倡导者，积极在线分享矢量图标制作经验、前端应用说明，及应用中常见的一些问题。1.2网页矢量图标在线生成工具Iconfont.cn为解决设计师制作字体图标困难的问题，为用户提供了在线矢量格式转换的功能。设计师只要将设计好的图标上传至平台，平台将会将图标存储在平台上，并转换成多种格式文件。具体步骤大家可参照阿里巴巴的iconfont的详细介绍这里附上链接 ,2014/12/2
601,国务院办公厅关于加强政府网站信息内容建设的意见(国办发[2014]57号),杨安荣,http://180.168.156.212:2262/wecenter/?/article/8682,值此我司信息发布平台5.0立项启动研发之际，国务院办公厅关于加强政府网站信息内容建设的意见(国办发[2014]57号)新鲜出炉！国务院办公厅关于加强政府网站信息内容建设的意见(国办发[2014]57号).mht,2014/12/2
602,偷懒的时候！就是挖坑的时候！,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8681,这种情况发生在自己身上已经不是第一次了，特此发帖来警示一下自己，同时也提醒一下同仁。在开发项目中，一个已经发布的项目，在后续的功能修改或者扩展的过程中，尤其是扩展功能的时候，很容易会忽视一些不起眼的地方，其实明明觉得不测试的话，指不定就会出错，但是觉得换一两行代码而已，应该不会出错，结果：就是BUG的来临。记得之前参加过一个项目，测试工具，主要用来统计项目覆盖率的，普遍认为，测试覆盖率越高当然越好，但是对于开发人员而已，同时坚固开发也同时保证测试的全面性，有时候人是懒惰的，往往在懒惰的时候，这样的危险就来临了，期望大家/自己在今后的开发中，在已经猜想到的问题，就应该及时去处理，不应该存侥幸心理，这样自己做出来的东西，才会越来越健壮。,2014/12/1
603,2015年会主题征集啦~~~有人力资源部独家送出的神秘大奖哦~,朱晓,http://180.168.156.212:2262/wecenter/?/article/8680,各位亲，一年一度的年会即将隆重登场了~~~~~请各位集思广益，激发无限创意。于2014年12月10日下班前，将你们的创意通过邮件或者留言形式反馈给我，被采纳者，将获得人力资源部独家送出的神秘大奖哦~~~~作品征集.jpg,2014/12/1
604,产品经理需要克服哪些陋习？,刘恒亮,http://180.168.156.212:2262/wecenter/?/article/8677,人非圣贤，孰能无过？做产品如做人，难免会犯一些错误，养成一些陋习，甚至走上歧途。那么在做产品的过程中，我们会犯哪些错误？会不自觉养成哪些陋习呢？我们又该如何去避免和改正呢？希望本文能让你有所收获！产品经理需要克服哪些陋习.docx,2014/11/28
605,Lucene_3.0_原理与代码分析,余礼华,http://180.168.156.212:2262/wecenter/?/article/8676,最近在学Lucene的使用，从网上搜到了这个教程，看了后觉得很不错，将Lucene的原理讲得深入浅出，并有对代码的分析和解释，特分享出来。有兴趣的同事可以看看。Lucene_3.0_原理与代码分析.pdf,2014/11/28
606,简单爬虫原理及实现,陆志超,http://180.168.156.212:2262/wecenter/?/article/8675,RT简单爬虫实现.pptx,2014/11/28
607,Css框架之SASS,陆志超,http://180.168.156.212:2262/wecenter/?/article/8679,"学过CSS的人都知道，它不是一种编程语言。你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。很自然地，有人就开始为CSS加入编程元素，这被叫做""CSS预处理器""（csspreprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。SASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。附件收录了官方文档及中文翻译文档。SASS-API（中、英）.zip",2014/11/28
608,Oracle与Sql Server数据库中修改字段默认值比较,余礼华,http://180.168.156.212:2262/wecenter/?/article/8678,"前段时间，我们小组对数字档案馆产品V2.X进行升级至2.3，主要的工作是支持SqlServer数据库的修改。Oralce和SqlServer数据库的DDL语言有很多不同，现把其中的修改字段默认值的不同列出进行比较。--Oraclealtertable表名modify字段名default默认值;（对一个字段新增默认值也是同样的语句）--SqlServerSqlServer中不能直接修改默认值需要先删除默认值约束---1.先查询指定列的默认值是否存在，默认值约束的名称是什么SELECTSD.definitionAS""DEFAULT_VALUE"",SD.[name]AS""CONSTRAINT_NAME""FROMsys.tablesSTINNERJOINsys.syscolumnsSCONST.[object_id]=SC.[id]INNERJOINsys.default_constraintsSDONST.[object_id]=SD.[parent_object_id]ANDSC.colid=SD.parent_column_idANDST.name=表名ANDSC.name=字段名---2.先把原来的默认值drop掉，再添加新的默认值---如果原来有默认值，现在要更改默认值，则需要先把原来的默认值drop掉，再添加新的默认值altertable表名dropconstraint默认值约束的名称---添加新的默认值altertable表名adddefault新默认值for字段名",2014/11/27
609,《JavaScript 高级程序设计》读书笔记<2>.数据类型,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8674,ECMAScript中有5种基本数据类型：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的键值对组成的。《JavaScript高级程序设计》读书笔记2.数据类型.docx,2014/11/25
610,Jquery版本共存,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8673,如何在一个页面上让多个jQuery版本共存JQuery版本共存.doc,2014/11/25
611,Oracle数据库的备份方法,张建涛,http://180.168.156.212:2262/wecenter/?/article/8672,"1、引言Oracle数据库的备份方法很多，无论使用那种备份方法，备份的目的都是为了在出现故障后能够以尽可能小的时间和代价恢复系统。比如使用export实用程序导出数据库对象、使用Oracle备份数据库、使用Oracle对称复制、使用Oracle并行服务器、使用Oracle冷备份、使用Oracle热备份等各种备份方法都有其优缺点、适用的场合和相应的软硬件要求。本文主要就用export实用程序导出数据库对象、Oracle冷备份、Oracle热备份这三种最基本的备份方法进行详细的探讨，分析各自的优缺点和适用的场合，并给出自动执行这些备份方案的脚本文件。2、三种备份方案的比较冷备份冷备份是Oracle最简单的一种备份；执行冷备份前必须关闭数据库；然后使用操作系统实用工具或者第三方工具备份所有相关的数据库文件。优点:能简单快速地备份。能简单快速地恢复。执行简单。缺点:必须关闭数据库，不能进行点恢复。热备份热备份是当数据库正在运行时进行数据备份的过程。执行热备份的前提是：数据库运行在可归档日志模式。适用于24X7不间断运行的关键应用系统。优点:备份时数据库可以是打开的。热备份可以用来进行点恢复。初始化参数文件、归档日志在数据库正常运行时是关闭的，可用操作系统命令拷贝。缺点:执行过程复杂。由于数据库不间断运行，测试比较困难。不能用操作系统实用工具拷贝打开的文件。必须使用Oracle提供的ocopy工具来拷贝打开的文件。热备份可能造成CPU、I/O过载，应在数据库不太忙时进行。Export导出数据库对象冷备份和热备份都备份物理数据库文件，因而被称为物理备份。而export备份的是数据库对象，因此被称为逻辑备份。优点:能执行对象或者行恢复。备份和恢复速度更快。能够跨操作系统平台迁移数据库。数据库可一直运行。缺点:export并不是冷备份和热备份的替代工具。冷、热备份可保护介质失效。export备份可保护用户或应用错误。3、冷备份方案的实施3.1冷备份数据库的步骤（1）关闭数据库；（2）备份所有相关的数据库文件：初始化参数文件、控制文件（可用selectnamefromv$controlfile;列出所有控制文件）、数据文件（可用selectnamefromv$datafile;列出所有数据文件）、Redo日志（可用selectmemberfromv$logfile;列出所有redo日志文件）、归档的Redo日志（可用selectsequence#,first_timefromv$loghist;列出所有归档redo日志文件的顺序号和产生时间）。3.2冷备份数据库的脚本文件coldbackup.bat4、热备份方案的实施4.1热备份数据库的前提条件：数据库运行在归档模式Oracle数据库的redo日志记录在数据库上进行的所有活动。LGWR后台进程以一种循环方式写这些日志文件，从第一个redo日志到下一个，直到该组的最后一个，然后由从第一个日志写起。在非归档模式下，当循环写到最后一个日志文件后，就重写第一个日志。因此，非归档模式下唯一的数据库恢复办法就是使用冷备份。在归档模式下，当redo日志满时，一个ARCH后台进程就读取全部redo日志，然后将其写到归档日志。因此，可以使用热备份和点恢复。在归档日志模式下，如果归档日志目的空间已满，数据库活动将暂时停止，只有释放一些空间后，数据库才能继续运行。通常，background_dump_destination将产生一个跟踪文件来显示归档方面的问题。Oracle数据库安装默认运行在非归档模式，通过以下步骤可以从非归档模式转换为归档模式：（1）编辑参数文件init.ora，设置以下参数#设置数据库自动归档log_archive_start=true#设置归档日志文件的目录，该目录必须事先已建立，并有大量可利用的空间log_archive_dest_1=""location=%oracle_base%\oradata\%oracle_sid%\archive""#设置归档日志文件名的格式。%s表示顺序号，%t表示线程号。log_archive_format=""%oracle_sid%%T%S.ARC""（2）在sqlplus上运行以下命令sqlplus>;connectsys/qazwsxassysdbasqlplus>;shutdownimmediate;sqlplus>;startupmountexclusive;sqlplus>;alterdatabasearchivelog;sqlplus>;alterdatabaseopen;sqlplus>;shutdownimmediate;（3）执行数据库冷备份当数据库运行在归档模式下，数据库恢复过程要求使用冷备份时，归档日志是必需的。（4）正常启动数据库，并确认数据库运行在归档模式sqlplus>;startup;sqlplus>;select*fromv$database;其log_mode会显示数据库是否归档模式sqlplus>;archiveloglist;也会显示数据库是否归档模式如果Oracle数据库运行在归档模式，当进行数据库维护时，可能需要暂停数据库的归档，在完成维护后，再重新启动归档模式。通过以下步骤可以从归档模式转换为非归档模式：sqlplus>;connectsys/qazwsxassysdbasqlplus>;shutdownimmediate;sqlplus>;startupmountexclusive;sqlplus>;alterdatabasenoarchivelog;sqlplus>;alterdatabaseopen;sqlplus>;select*fromv$database;其log_mode会显示数据库是否归档模式sqlplus>;archiveloglist;也会显示数据库是否归档模式4.2热备份数据库的步骤（1）拷贝init.ora文件到备份目录（参数文件在数据库启动后处于关闭状态）。（2）将需要备份的某个表空间置于开始备份模式。（3）使用ocopy.exe拷贝表空间，然后将该表空间置于结束备份模式中（ocopy.exe不能用于直接拷贝联机的数据库文件）。（4）对数据库中的每个表空间执行步骤2和3（可以通过视图dba_tablespaces和v$datafile查看数据库中有哪些表空间和数据文件）。（5）通过在sqlplus上执行archiveloglist命令获取当前的日志顺序号，从oldestonlinelogsequence开始到currentlogsequence的联机redo日志应该是热备份的一部分。（6）在sqlplus上执行altersystemswitchlogfile;命令来强迫日志切换，以便所有的日志都被归档。（7）使用alterdatabasebackupcontrolfiletotrace;命令获得控制文件的一个备份，可以到%oracle_base%\admin\%oracle_sid%\udump目录中寻找最新的跟踪文件，其中有重建控制文件的全部命令。（8）使用windowsnt的命令从%log_archive_dest%中拷贝归档的日志文件到备份目录。4.3热备份数据库的脚本文件hotbackup.bat5、使用export作为备份策略5.1export的命令选项说明Oracle数据库的exp工具提供tables、users、fulldatabase、tablespace四种级别的导出方式，把指定的数据库内容导出到一个或者多个oracle二进制文件中，该文件只允许用imp工具来读取，imp的命令选项可用imphelp=y来查阅。您可以通过输入EXP命令以及各种自变量来控制“导出”的运行方式。要指定参数，您可以使用关键字：格式：EXPKEYWORD=value或KEYWORD=(value1,value2,...,valueN)实例：EXPSCOTT/TIGERGRANTS=YTABLES=(EMP,DEPT,MGR)或TABLES=(T11,T12)，如果T1是分区表USERID必须是命令行中的第一个参数。下列关键字仅用于可传输的表空间TRANSPORT_TABLESPACE导出可传输的表空间元数据(N)TABLESPACES将传输的表空间列表5.2export备份数据库的脚本文件expbackup.bat6、各种备份策略的自动执行方法不管是冷备份、热备份，还是export备份；不管是unix平台，还是windows平台，都可以利用at命令来定时、自动执行上述备份策略。AT命令安排在特定日期和时间运行命令和程序，在windowsnt平台上必须首先运行调度服务（schedule），才能使用at命令。AT命令用法如下：AT[\\computername][[id][/DELETE]|/DELETE[/YES]]AT[\\computername]time[/INTERACTIVE][/EVERY:date[,...]|/NEXT:date[,...]]""command""\\computername指定远程计算机。如果省略这个参数，会计划在本地计算机上运行命令。id指定给已计划命令的识别号。/delete删除某个已计划的命令。如果省略id，计算机上所有已计划的命令都会被删除。/yes不需要进一步确认时，跟删除所有作业的命令一起使用。time指定运行命令的时间。/interactive允许作业在运行时，与当时登录的用户桌面进行交互。/every:date[,...]每个月或每个星期在指定的日期运行命令。如果省略日期，则默认为在每月的本日运行。/next:date[,...]指定在下一个指定日期(如下周四)运行命令。如果省略日期，则默认为在每月的本日运行。""command""准备运行的WindowsNT命令或批处理程序。举例如下：(1)每周五19:00执行冷备份at19:00/every:F""coldbak.cmd""(2)每周二20:00执行热备份at20:00/every:T""coldbak.cmd""(3)每周一、二、三、四、五21:00执行export备份at20:00/every:M,T,W,Th,F""expbak.cmd""",2014/11/24
612,日常学习 - MyBatis 简介一,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8671,"MyBatis是什么?MyBatis是一款一流的支持自定义SQL、存储过程和高级映射的持久化框架。MyBatis几乎消除了所有的JDBC代码，也基本不需要手工去设置参数和获取检索结果。MyBatis能够使用简单的XML格式或者注解进行来配置，能够映射基本数据元素、Map接口和POJOs（普通java对象）到数据库中的记录。准备开始所有的MyBatis应用都以SqlSessionFactory实例为中心。SqlSessionFactory实例通过SqlSessionFactoryBuilder来获得，SqlSessionFactoryBuilder能够从XML配置文件或者通过自定义编写的配置类（Configurationclass），来创建一个SqlSessionFactory实例。从XML中创建SqlSessionFactory实例从XML中创建SqlSessionFactory实例非常简单。建议您使用类资源路径（classpathresource）来加载配置文件，但是您也能够使用任何方式，包括文本文件路径或者以file://开头URL的方式。MyBatis包括一个叫做Resources的工具类（utilityclass），其中包含了一系列方法，使之能简单地从classpath或其它地方加载配置文件。Stringresource=""org/mybatis/example/Configuration.xml"";Readerreader=Resources.getResourceAsReader(resource);sqlMapper=newSqlSessionFactoryBuilder().build(reader);XML配置文件包含MyBatis框架的核心设置，包括获取数据库连接的DataSource实例，和包括决定事务作用域范围和控制的事务管理等。您将能够在后面的章节中找到详细的XML配置，在这里我们先展示一个简单的例子：<?xmlversion=""1.0""encoding=""UTF-8""?><!DOCTYPEconfigurationPUBLIC""-//mybatis.org//DTDConfig3.0//EN"""" configuration>虽然XML配置文件中还有很多其它的配置细节，但是，上面的示例显示了最重要的部分。注意XML配置文件的头部，会使用DTD验证文档来验证该XML配置文件。body部分的environment元素，包含了事务管理和连接池配置。Mappers元素指定了映射配置文件--包含SQL语句和映射定义的XML文件。如何不使用XML来创建SqlSessionFactory如果您喜欢直接通过java代码而不是通过XML创建配置选项，或者想创建您自己的配置生成器。MyBatis提供了一个完整的配置类（Configurationclass），它提供了与XML文件相同的配置选项。TransactionFactorytransactionFactory=newJdbcTransactionFactory();Environmentenvironment=newEnvironment(""development"",transactionFactory,dataSource);Configurationconfiguration=newConfiguration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactorysqlSessionFactory=newSqlSessionFactoryBuilder().build(configuration);请注意，这种方式下的配置添加一个映射类（mapperclass）。映射类是包含SQL映射注解的Java类，从而避免了使用XML。但是，由于注解的一些局限性以及MyBatis映射的复杂性，XML仍然是一些高级的映射功能（如嵌套连接映射，NestedJoinMapping）所必须的方式。基于这个原因，如果存在XML文件，MyBatis自动寻找并加载这个XML文件。在这种情况下，BlogMapper.xml将会被类路径下名称为BlogMapper.class的类加载。详述请见后面章节。从SqlSessionFactory获取SqlSession现在您已经创建了一个SqlSessionFactory（指上面的sqlMapper），正如它名字暗示那样，您可以通过它来创建一个SqlSession实例。SqlSession包含了所有执行数据库SQL语句的方法。您能够直接地通过SqlSession实例执行映射SQL语句。例如：SqlSessionsession=sqlMapper.openSession();try{Blogblog=(Blog)session.selectOne(""org.mybatis.example.BlogMapper.selectBlog"",101);}finally{session.close();}虽然这种方法很有效，MyBatis以前版本的用户对此也可能很熟悉，但现在有一个更简便的方式，那就是对给定的映射语句，使用一个正确描述参数与返回值的接口（如BlogMapper.class），您就能更清晰地执行类型安全的代码，从而避免错误和异常。如：SqlSessionsession=sqlSessionFactory.openSession();try{BlogMappermapper=session.getMapper(BlogMapper.class);Blogblog=mapper.selectBlog(101);}finally{session.close();}下次，再让我们一起探索它们究竟是如何执行的。",2014/11/24
613,关于“Virtual Store”文件夹--应用程序开发需要注意。,丁凯,http://180.168.156.212:2262/wecenter/?/article/8670,wotalk在win7及以上系统时，程序的配置文件以及聊天记录有时在安装目录找不到反而在一个叫做“VirtualStore”的文件夹下找到了：这是因为权限问题造成的，当权限不够时，为了保证程序正常运行不会报错采用的兼容性做法。比如往programfiles或某些系统目录要写入东西，会保存配置文件，权限不够，就会被重定向到这里。比如往programfiles安装软件，一般安装程序会触发UAC提升权限，当然不会有问题。但每次运行programfiles中安装的程序都触发UAC时不现实的，太烦人了，大多数程序运行时并不会触发UAC，处于受限模式，但往往很多软件运行后又会往自己目录下保存写配置，临时文件之类的，肯定没权限写入programfiles，所以为了运行不出错就被重定向了，骗过软件认为自己成功写入了，不至于出错。你可以发现，这里保存的文件大多数是程序运行过后的一些配置或临时文件之类的。而本来的目录下可能无法找到这些文件，但会出现一个兼容性文件夹，点了就可以跳到VirtualStore中的对应目录，一般开UAC的才会遇到这个，刚装好就关闭UAC就不会出现了。这属于98开始，2000虽然有完善的权限级别，可惜习惯了人人管理员，等于摆设。UAC逼开发者规范下，避免往系统目录写东西，配置最好放用户自己的appdata目录，尽量避免普通应用程序以管理员身份运行，除非程序的安装和修改一些系统配置才需要授权，这样才能根本上解决很多安全问题，否者人人管理员间谍流氓简直就是畅通无阻啊，随时可以对系统为所欲为，防不胜防。不过为了兼容以前无数不规范的软件，才搞出个这么个东西。,2014/11/21
614,利用zxing2.1.jar生成二维码,邱初烧,http://180.168.156.212:2262/wecenter/?/article/8669,"1利用zxing2.1生成二维码代码publicvoidencode(Stringcontent,StringfilePath){try{MultiFormatWritermultiFormatWriter=newMultiFormatWriter();Maphints=newHashMap();hints.put(EncodeHintType.CHARACTER_SET,""UTF-8"");//将文字转换成二维矩阵，并设置矩阵大小，这里的矩阵大小就是后面生成的图片像素大小BitMatrixbitMatrix=multiFormatWriter.encode(content,BarcodeFormat.QR_CODE,400,400,hints);Filefile=newFile(filePath);MatrixToImageWriter.writeToFile(bitMatrix,""jpg"",file);}catch(Exceptione){e.printStackTrace();}}2.利用zxing解析二维码图片publicvoiddecode(StringfilePath){try{MultiFormatReaderformatReader=newMultiFormatReader();Filefile=newFile(filePath);BufferedImageimage=ImageIO.read(file);LuminanceSourcesource=newBufferedImageLuminanceSource(image);Binarizerbinarizer=newHybridBinarizer(source);BinaryBitmapbinaryBitmap=newBinaryBitmap(binarizer);Maphints=newHashMap();hints.put(EncodeHintType.CHARACTER_SET,""UTF-8"");Resultresult=formatReader.decode(binaryBitmap,hints);System.out.println(""result=""+result.toString());System.out.println(""resultFormat=""+result.getBarcodeFormat());System.out.println(""resultText=""+result.getText());}catch(Exceptione){e.printStackTrace();}}zxing.rar扫描件.jpg拍照件.JPG",2014/11/20
615,ImgAreaSelect框架,李海波,http://180.168.156.212:2262/wecenter/?/article/8668,ImgAreaSelect是一款让用户从大图中剪裁出一个矩形区域的JQuery插件。提供的接口很丰富，使用起来也很方便，很适合比如裁剪头像之类的功能。官网： /?p=529imgAreaSelectJs框架.doc,2014/11/20
616,文件上传下载之传输速度,丁凯,http://180.168.156.212:2262/wecenter/?/article/8667,文件上传下载之传输速度demo源码.zip研发中心经验共享[201406]_丁凯.doc,2014/11/19
617,dhtmlx与ie11的兼容问题,邱金炜,http://180.168.156.212:2262/wecenter/?/article/8666,ie11废除了ie原本的一些特性方法，致使isie方法无法适用于ie11的判断，该压缩包整理了dhtmlx源JS中对版本判断的修改，解压后对照方法重写即可解决ie11的兼容问题。dhtmlx_hf_ie11_131023.rar,2014/11/18
618,"JDBC和Hibernate共存,刷新二级缓存。",甘名辉,http://180.168.156.212:2262/wecenter/?/article/8665,"在目前的系统管理平台中实现jdbc操作数据库,二级缓存强制刷新。研发中心经验共享_甘名辉[201410].doc",2014/11/18
619,系统配置平台中的页面嵌入和导航功能,王雷2,http://180.168.156.212:2262/wecenter/?/article/8664,详情见附件系统配置平台中的页面嵌入和导航功能.rar,2014/11/18
620,在IE下flash插件使用不当会导致内存泄漏,方俊新,http://180.168.156.212:2262/wecenter/?/article/8663,详情查看附件在IE下flash插件使用不当会导致内存泄漏.docx,2014/11/17
621,端口经常被占用，如何查看端口占用情况,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8662,端口经常被占用，如何查看端口占用情况查看端口占用情况.txt,2014/11/14
622,SWT Browser无法调用高版本IE的解决方法,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8661,1、使用最新的SWT2、删除注册表项HKEY_CURRENT_USER\Software\Microsoft\InternetExplorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION底下的子项3、重启项目即可调用系统最高版本的IEPS只升级SWT可能无法解决问题，必须删除注册表让SWT重新生成另可使用-Dorg.eclipse.swt.browser.IEVersion=11000启动参数来指定调用IE的版本,2014/11/14
623,POI读取Excel行数的问题,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8660,如题POI读取Excel行数的问题.doc,2014/11/14
624,好用的前台模板插件-jtemplates,黄翔宇,http://180.168.156.212:2262/wecenter/?/article/8659,基于JQueryjtemplates.docx,2014/11/14
625,sql优化,张殷豪,http://180.168.156.212:2262/wecenter/?/article/8658,sql优化sql优化.rar,2014/11/14
626,guava初探,张殷豪,http://180.168.156.212:2262/wecenter/?/article/8657,Guava是一个Google的基于java1.6的类库集合的扩展项目，提供了些高质量的API可以使你的java代码更加优雅，更加简洁，让你工作更加轻松愉悦。Google的官方地址： /p/guava-libraries/Guava初探.rar,2014/11/14
627,JavaScript中parseInt的使用,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8656,如题JavaScript中parseInt的使用.doc,2014/11/14
628,java如何获取注册表信息,岑沛龙,http://180.168.156.212:2262/wecenter/?/article/8655,java如何获取注册表信息获取注册表信息.docx,2014/11/14
629,在线office文件浏览：点聚office和pageoffice比较,张二伟,http://180.168.156.212:2262/wecenter/?/article/8654,由于工作原因，重点了解了这两款office文件在线浏览工具，参看附件点聚office和pageoffice比较.docx,2014/11/13
630,使用系统配置平台开发的一些经验分享,周敏,http://180.168.156.212:2262/wecenter/?/article/8653,使用系统配置平台开发一个普通的页面构件经验之谈.doc,2014/11/13
631,ElasticSearch 分布式搜索引擎,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8651,ElasticSearch是一个开源的分布式搜索引擎，具备高可靠性，支持非常多的企业级搜索用例。像Solr4一样，是基于Lucene构建的。支持时间时间索引和全文检索。分布式（Distributed）elasticsearch的一个最主要的功能就是对分布式的支持，索引能够分拆为多个分片，每个分片可以有0个或者多个副本，集群中的每个数据节点，都可以承载一个或者多个分片，并且充当协调和处理各种操作分发到合适的分片上去。再平衡（Rebalancing）和路由（routing）这一切都是自动进行的。ElasticSearch分布式搜索引擎.doc,2014/11/13
632,【转】光“大”是不行的，开放才能实现大数据的深发展,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8650,围墙里的大数据注定成为死数据。大数据需要开放式创新，从数据的开放、共享和交易，到价值提取能力的开放，再到基础处理和分析平台的开放，让数据如同血液在数据社会的躯体中长流，滋润数据经济，让更多的长尾企业和数据思维创新者产生多姿多彩的化学作用，才能创造大数据的黄金时代。我的大数据研究轨迹我做了4-5年的移动架构和Java虚拟机，4-5年的众核架构和并行编程系统，最近4-5年也在追时髦，先是投入物联网，最近几年一直在做大数据。我们团队的大数据研究轨迹如下图所示：2010-2012年，主要关注数据和机器的关系：水平扩展、容错、一致性、软硬件协同设计，同时厘清各种计算模式，从批处理（MapReduce）到流处理、BigSQL/adhocquery、图计算、机器学习等等。事实上，我们的团队只是英特尔大数据研发力量的一部分，上海的团队是英特尔Hadoop发行版的主力军，现在英特尔成了Cloudera的最大股东，自己不做发行版了，但是平台优化、开源支持和垂直领域的解决方案仍然是英特尔大数据研发的重心。从2013年开始关注数据与人的关系：对于数据科学家怎么做好分布式机器学习、特征工程与非监督学习，对于领域专家来说怎么做好交互式分析工具，对于终端用户怎么做好交互式可视化工具。英特尔研究院在美国卡内基梅隆大学支持的科研中心做了GraphLab、StaleSynchronousParallelism，在MIT的科研中心做了交互式可视化和SciDB上的大数据分析，而中国主要做了SparkSQL和MLlib（机器学习库），现在也涉及到深度学习算法和基础设施。2014年重点分析数据和数据的关系：我们原来的工作重心是开源，后来发现开源只是开放式创新的一个部分，做大数据的开放式创新还要做数据的开放、大数据基础设施的开放以及价值提取能力的开放。数据的暗黑之海与外部效应下面是一张非常有意思的图，黄色部分是化石级的，即没有联网、没有数字化的数据，而绝大多数的数据是在这片海里面。只有海平面的这些数据（有人把它称作SurfaceWeb）才是真正大家能访问到的数据，爬虫能爬到、搜索引擎能检索到的数据，而绝大多数的数据是在暗黑之海里面（相应地叫做DarkWeb），据说这一部分占数据总量的85%以上，它们在一些孤岛里面，在一些企业、政府里面躺在地板上睡大觉。数据之于数据社会，就如同水之于城市或者血液之于身体一样。城市因为河流而诞生也受其滋养，血液一旦停滞身体也就危在旦夕。所以，对于号称数据化生存的社会来说，我们一定要让数据流动起来，不然这个社会将会丧失诸多重要功能。所以，我们希望数据能够像“金风玉露一相逢”那样产生化学作用。马化腾先生提出了一个internet+的概念，英特尔也有一个大数据X，相当于大数据乘以各行各业。如下图所示，乘法效应之外，数据有个非常奇妙的效应叫做外部效应（externality），比如这个数据对我没用但对TA很有用，所谓我之毒药彼之蜜糖。比如，金融数据和电商数据碰撞在一起，就产生了像小微贷款那样的互联网金融；电信数据和政府数据相遇，可以产生人口统计学方面的价值，帮助城市规划人们居住、工作、娱乐的场所；金融数据和医学数据在一起，麦肯锡列举了很多应用，比如可以发现骗保；物流数据和电商数据凑在一块，可以了解各个经济子领域的运行情况；物流数据和金融数据产生供应链金融，而金融数据和农业数据也能发生一些化学作用。比如Googleanalytics出来的几个人，利用美国开放气象数据，在每一块农田上建立微气象模型，可以预测灾害，帮助农民保险和理赔。所以，要走数据开放之路，让不同领域的数据真正流动起来、融合起来，才能释放大数据的价值。三个关于开放的概念1、数据开放首先是狭义的数据开放。数据开放的主体是政府和科研机构，把非涉密的政府数据及科研数据开放出来。现在也有一些企业愿意开放数据，像Netflix和一些电信运营商，来帮助他们的数据价值化，建构生态系统。但是数据开放不等于信息公开。首先，数据不等于信息，信息是从数据里面提炼出来的东西。我们希望，首先要开放原始的数据（rawdata），其次，它是一种主动和免费的开放，我们现在经常听说要申请信息公开，那是被动的开放。TimBernersLee提出了数据开放的五星标准，以保证数据质量：一星是开放授权的格式，比如说PDF；其次是结构化，把数据从文件变成了像excel这样的表；三星是开放格式，如CSV；四星是能够通过URI找到每一个数据项；五星代表能够和其它数据链接，形成一个开放的数据图谱。现在主流的数据开放门户，像data.dov或data.gov.uk，都是基于开源软件。英特尔在MIT的大数据科研中心也做了一种形态，叫Datahub：吉祥物很有趣，一半是大象，代表数据库技术，一半是章鱼，取自github的吉祥物章鱼猫。它提供更多的功能比如易管理性，提供结构化数据服务和访问控制，对数据共享进行管理，同时可以在原地做可视化和分析。广义的数据开放还有数据的共享及交易，比如点对点进行数据共享或在多边平台上做数据交易。马克思说生产资料所有制是经济的基础，但是现在大家可以发现，生产资料的租赁制变成了一种主流（参考《LeanStartup》），在数据的场景下，我不一定拥有数据，甚至不用整个数据集，但可以租赁。租赁的过程中要保证数据的权利。首先，我可以做到数据给你用，但不可以给你看见。姚期智老先生82年提出“millionaires’dilemma（百万富翁的窘境）”，两个百万富翁比富谁都不愿意说出自己有多少钱，这就是典型的“可用但不可见”场景。在实际生活中的例子很多，比如美国国土安全部有恐怖分子名单（数据1），航空公司有乘客飞行记录（数据2），国土安全部向航空公司要乘客飞行记录，航空公司不给，因为涉及隐私，他反过来向国土安全部要恐怖分子名单，也不行，因为是国家机密。双方都有发现恐怖分子的意愿，但都不愿给出数据，有没有办法让数据1和数据2放一起扫一下，但又保障数据安全呢？其次，在数据使用过程中要有审计，万一那个扫描程序偷偷把数据藏起来送回去怎么办？再者，需要数据定价机制，双方数据的价值一定不对等，产生的洞察对各方的用途也不一样，因此要有个定价机制，比大锅饭式的数据共享更有激励性。从点对点的共享，走到多边的数据交易，从一对多的数据服务到多对多的数据市场，再到数据交易所。如果说现在的数据市场更多是对数据集进行买卖的话，那么数据交易所就是一个基于市场进行价值发现和定价的，像股票交易所那样的、小批量、高频率的数据交易。我们支持了不少研究来实现刚才所说的这些功能，比如说可用而不可见。案例一是通过加密数据库CryptDB/Monomi实现，在数据拥有方甲方这边的数据库是完全加密的，这事实上也防止了现在出现的很多数据泄露问题，大家已经听到，比如说某互联网服务提供商的员工偷偷把数据拿出来卖，你的数据一旦加密了他拿出来也没用。其次，这个加密数据库可以运行乙方的普通SQL程序，因为它采用了同态加密技术和洋葱加密法，SQL的一些语义在密文上也可以执行。针对“百万富翁的窘境”，我们做了另一种可用但不可见的技术，叫做数据咖啡馆。大家知道咖啡馆是让人和人进行思想碰撞的地方，这个数据咖啡馆就是让数据和数据能够碰撞而产生新的价值。比如两个电商，一个是卖衣服的，一个是卖化妆品的，他们对于客户的洞察都是相对有限的，如果两边的数据放在一起做一次分析，那么就能够获得全面的用户画像。再如，癌症是一类长尾病症，有太多的基因突变，每个研究机构的基因组样本都相对有限，这在某种程度上解释了为什么过去50年癌症的治愈率仅仅提升了8%。那么，多个研究机构的数据在咖啡馆碰一碰，也能够加速癌症的研究。在咖啡馆的底层是多方安全计算的技术，基于英特尔和伯克利的一个联合研究。在上面是安全、可信的Spark，基于“datalineage”的使用审计，根据各方数据对结果的贡献进行定价。2、大数据基础设施的开放现在有的是有大数据思维的人，但他们很捉急，玩不起、玩不会大数据，他不懂怎么存储、怎么处理这些大数据，这就需要云计算。基础设施的开放还是传统的PlatformasaService，比如AmazonAWS里有MapReduce，Google有BigQuery。这些大数据的基础处理和分析平台可以降低数据思维者的门槛，释放他们的创造力。比如decide.com，每天爬几十万的数据，对价格信息（结构化的和非结构化的）进行分析，然后告诉你买什么牌子、什么时候买最好。只有四个PhD搞算法，其他的靠AWS。另一家公司Prismatic，也利用了AWS，这是一家做个性化阅读推荐的，我专门研究过它的计算图、存储和高性能库，用LISP的一个变种Clojure写的非常漂亮，真正做技术的只有三个学生。所以当这些基础设施社会化以后，大数据思维者的春天很快就要到来。3、价值提取能力的开放现在的模式一般是一大一小或一对多。比如Tesco和Dunnhumby，后者刚开始是很小的公司，找到Tesco给它做客户忠诚度计划，一做就做了几十年，这样的长期战略合作优于短期的数据分析服务，决策更注重长期性。当然，Dunnhumby现在已经不是小公司了，也为其他大公司提供数据分析服务。再如沃尔玛和另外一家小公司合作，做数据分析，最后他把这家小公司买下来了，成了它的WalmartLabs。一对多的模式，典型的是Palantir——PeterThiel和斯坦福的几个教授成立的公司，目前还是私有的，但估值近百亿了，它很擅长给各类政府和金融机构提供数据价值提取服务。真正把这种能力开放的是Kaggle，它的双边，一边是10多万的分析师，另一边是需求方企业，企业在Kaggle上发标，分析师竞标，获得业务。这可能是真正解决长尾公司价值提取能力的办法。当然，如果能和我们的数据咖啡馆结合，就更好了。,2014/11/12
633,电子文件检测工具 2.0 产品介绍,王链玮,http://180.168.156.212:2262/wecenter/?/article/8649,电子文件检测工具2.0目前还在集成测试阶段，预计2014年年底发布如有任何问题或建议，请联系研发二部王链玮18621562088Coral4Inside！ComingSoon！电子文件检测工具2.0-产品介绍.pptx,2014/11/10
634,""" 信息发布平台V5.0 ”前传",魏爱红,http://180.168.156.212:2262/wecenter/?/article/8648,信息平台5.0是公司使用新技术、新架构、新思想全新打造的新一代信息平台产品，是信息平台产品的一次全面改革。产品将于明年3月份与大家见面，敬请期待！信息发布平台5.0产品工作汇报.ppt,2014/11/10
635,java多线程-ThreadLocal变量,张二伟,http://180.168.156.212:2262/wecenter/?/article/8647,java多线程-ThreadLocal变量加深对多线程开发的认识参看附件java多线程-ThreadLocal变量.docx,2014/11/7
636,线程终止的方法-使用中断(Interrupt)取消线程,张二伟,http://180.168.156.212:2262/wecenter/?/article/8645,"使用中断(Interrupt)取消线程,参看附件线程终止的方法.docx",2014/11/7
637,10月经验共享,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8644,附件是介绍一个js自动刷新插件，主要是针对前端技术相对薄弱的同志，还有自己对于clear样式的理解研发中心经验共享_谢霞琴[2014010].docx,2014/11/7
638,国产操作系统逆袭难题：对手实在太强大,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8643,出处：中国青年报不久前，中国工程院院士倪光南在一个论坛上表示，多个政府部委机构正在推进操作系统国产化替代工作，并且有时间表和路线图，这将给国产操作系统厂商带来很好的发展机遇。有人评说国产操作系统的春天来了。那么现实到底怎样，国产操作系统能否实现逆袭？国家大力支持国产操作系统“信息化是‘一把手工程’”。国家信息化专家咨询委员会常务副主任周宏仁说，一把手要对其在国家信息化推进中所扮演的角色有清晰的认识，还要采取相关举措支持软件国产化战略、政策的制定，推动国家信息化发展的决心必须来自国家的最高层。周宏仁表示，未来一个时期中国国家网络安全和信息化的总体目标，即：建设网络强国的战略部署要与“两个一百年”奋斗目标同步推进，向着网络基础设施基本普及、自主创新能力显著增强、信息经济全面发展、网络安全保障有力的目标不断前进。中国网络空间和信息化的发展进入了一个新的历史阶段，其内涵和重点都将较之过去十余年有较大的发展和变化。发展国产操作系统是国家网络安全和信息化总体目标的大局中，不可或缺的一步棋。今年5月16日，中国政府采购网发布《关于进行信息类协议供货强制节能产品补充招标的通知》，规范政府采购行为。通知要求所有计算机类产品不允许安装Windows8操作系统。早在2011年，中国人民大学就开始建立电子文件系统测试中心，该中心执行主任、质量负责人薛四新告诉中国青年报记者，这一系统旨在将文件档案电子化，形成可追溯的审查机制，“目前，国家正在大力推进企业建立这个系统，要求企业内部要建立起来，并且配备相关的人员管理”。在此系统的测试中心，薛四新和她的同事们要求送来测试的系统必须能在国产操作系统上运行。电子文件系统作为一种应用系统要建立在操作系统和技术支撑平台上。过去，类似于地基的操作系统大多来自国外，在这个地基上建立的一切信息如果被拿去做大数据分析，将对国家信息安全造成冲击。“下一步按照国家信息安全的总体战略要求，我们要从各个方面支持国产操作系统。从浪潮的服务器到思普的操作系统，再到国内自主知识产权的金仓数据库，平台要能兼容这些国产品牌。”薛四新说，“只有使用才能发现问题。国产操作系统对比国外，肯定存在漏洞和缺点，形成一个使用的循环之后，能倒逼国产操作体系改革创新，不然他们很难自己发现问题。”国产操作系统曲折发展史事实上，国家对国产操作系统的扶持，从上世纪末就已经开始。1999年8月10日，红旗Linux诞生。红旗操作系统的起势与10多年前中国政府机关的信息化建设几乎同步，其间的典型案例，是在2001年北京市政府桌面操作系统产品正版软件采购竞标中成功中标，将竞争对手微软挤下擂台。此役让红旗操作系统一战成名。一直以来，由于政府采购、央企用的都是正版软件，倪光南估算，如果按照向微软支付100~600元中的最低标准100元计算，中国每年就要向微软支付一笔百亿级的巨款。他认为，“如果把这笔钱全部用在国产软件身上，足以养活那些优秀的国产操作系统公司”。2001年以后，红旗的操作系统频频中标原国家经贸委、国家邮政局、国家外汇管理局、海关总署、国家烟草专卖局等政府机关的正版软件采购项目。但在普通用户中，红旗并未走红。业内人士说，在电脑上预装国产操作系统也没有用，大部分使用者，对预装红旗Linux的电脑第一件事就是格式化电脑然后重装Windows操作系统。不只是红旗Linux，预装其他国产操作系统也是这样的结局。今年2月10日，中科红旗贴出公司清算公告。中科红旗的解散清算，被认为是过度依赖政府资金、没有造血能力的国产软件企业失败典型。过度依赖政府采购的直接结果是，包括中科红旗在内的所有国内操作系统都没能搭建出操作系统做大做强需要的最基本条件——应用生态圈，一旦国家补贴和政府采购市场生变，自身造血能力不足的问题就显露无遗。一位前中科红旗高管感叹，如果中科红旗最终成为国产操作系统黎明到来前的失败注脚，希望它能为有志于振兴国产操作系统的后来者提供借鉴和警醒。“逆袭”难在哪里“目前的桌面电脑、移动设备等智能终端都要用到操作系统，操作系统作为一个基础软件，所有的信息都要通过它进行处理和管理。”倪光南说，“在大数据时代，操作系统能取得重要信息，每个人的财务、联系人、活动、爱好……这些信息作为大数据有很大的价值，从根本上来讲，基础设施核心技术方面需要加强。”但是国产操作系统“逆袭”的难度很大。“全世界来讲，操作系统做得最好的是微软windows、谷歌安卓和苹果。三家巨头瓜分世界市场，形成垄断。”倪光南说，在这个领域竞争，面对的是全球最强的竞争对手，但是从网络安全方面考虑，我们迟早要解决这个难题。但客观的现实是，因为垄断性强、国外操作系统起步早，而尽管最近几年我国很重视国产操作系统，但距离国际大企业仍有相当大的差距。倪光南表示，我们应清醒地认识到，这种差距并不是技术上的简单竞争，而是生态系统和生态环境的竞争。操作系统上会有很多应用软件，操作系统本身的强弱是一方面，更为重要的是以操作系统为核心的生态环境有没有打造出来，也就是说，在这个“地基”上是否有足够的“家具用品”供用户使用。苹果和安卓的商店里有上百万个APP，这是微软、谷歌和苹果几十年引领周边的厂商在发展。国产操作系统本身可能不错，但原来的文件不能用，有些设备装不上，存在兼容问题。“严格地说，这可能不是操作系统本身的问题，而是它的生态系统不够强大。”倪光南说。该如何弥补差距？倪光南强调，要产学研用相结合，把资源整合起来，为了一个目标“抱团”。他希望通过产业链的方式，把各方面的力量整合起来，每一家公司单打独斗可能都打不过三大巨头，但联合起来也许能有与之抗衡的能力。整合资源需要一个统一的标准，每一家国内企业都应该在统一的生态系统中运转。倪光南建议，可以学习苹果和谷歌，把应用商店的模式学来。建立一个足够庞大的下游应用软件开发者群体。当应用丰富起来的时候，也会促进消费者接受国产操作系统。,2014/11/6
639,国家档案局发布《全国档案事业统计年报制度（2014版）》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8642,原先的档案年报统计格式需要参照修改。全国档案事业统计年报制度（2014版）.doc,2014/11/6
640,国家档案局发布2014年度优秀科技成果奖励拟授奖项目，我司获得二等奖和三等奖各一项,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8646,2014-2-3电子公文归档应用技术与方法研究天津市档案局、上海中信信息发展股份有限公司方昀、杨安荣、仇伟海、王颖、冯英、梁欣、王琳天津市档案局4-3-7基于县域的档案信息资源共享工程推进机制研究浙江省档案局、海盐县档案局、浙江大学、上海中信信息发展股份有限公司王茂法、夏红平、傅荣校、王惠华、汪肖华浙江省档案局 2014年度国家档案局优秀科技成果奖励拟授奖项目.mht,2014/11/6
641,ERP，我们在慢慢改变。。。。,叶剑挺,http://180.168.156.212:2262/wecenter/?/article/8641,最近换岗，从原来的项目经理换到了现在的IT部门，正好工作主要内容之一是ERP流程的梳理和改进工作，深有感触。1.感触一：从公司的ERP系统用户变身为系统设计者，发现解决问题，远远比提出问题要来的更为复杂。可能单独的一个小问题，牵扯到全局的改变。2.感触二：工作界限无法再那么明确，从对用户的工作界限清晰划分到内部的工作界限无法明确界定。增加需求的同时要再三考虑开发人员的工作量，巧妇难为无米之炊呀。3.感触三：会听到各个层面，来自于不同类型的公司人员的不同需求。整理，梳理，转化变为主要工作。从ERP在公司目前的推广程度来看，个人感觉在产生变化的有：1.数字开始说话了，各个部门都需要用数据来展现自己的工作，有数据生成，可以让高层通过信息数据了解公司的经营运作情况。2.流程开始变化了，原有的很多旧的流程随着，ERP的推进，在实际工作上不再有效率，甚至会阻碍工作的进展。3.岗位职责变化了，很多旧有的岗位不再被迫切需要，或者有些岗位需要变更工作职责。说了感触和变化，那么来看看带来的好处：随着流程的规范化，公司的业务被数字化和数据化后:1.流程上的有效和规范，避免在流程上就出现信息传递的错误或者延误，降低了风险的发生率。2.风险早发现，早处理，通过得到的及时数据报表，可以明确知道在什么节点，业务运作出现了问题，避免了信息不对称，不及时问题。3.随着数字和数据的越来越规范和准确，以及多重比对，避免信息不准确所带来的运营风险。.其实就是信息提前性，及时性，准确性的三大特征的体现。既然ERP那么好，为什么很多公司却无法正常运作呢，还有失败的？1.现有流程和系统流程的剧烈碰撞要上ERP，必然改变公司流程，流程改变必然带来机制的一系列改变。这将是巨大的碰撞点。2.审核机制的缺失ERP流程上最担心的问题就是源头数据的错误，因为ERP遵循的是“一次数据，多次复用”的概念，如果源头数据出错，带来的将是灾难。所以一定需要有有效的审核机制。3.公司员工的接受程度ERP是套系统，还是需要有人在用，如果不用，那么这套系统存在的意义就为零，员工能否接受ERP，改变工作方式，也会对ERP的推进造成巨大的困扰。公司上ERP，是个发展的过程，很多流程困扰到了各位同仁，但是请相信，我们在慢慢改变，在向更好的地方前进。让我们一起改变～～～,2014/11/5
642,光典4.5在was8.5下问题汇总,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8635,Was8.5分为linux版本和windows版本，jdk为1.7版本，为ibm专有j9的jdk。由于was功能众多且复杂，自身包含众多jar包，容易与光典系统发生冲突。另外一方面，光典系统ssh架构版本较早，在新的版本was下也会有些兼容性上的问题。本文给予正在与was坚持不懈斗争的各位童鞋一个精神上的抚慰，同时也避免各位在同样的问题上再次重蹈覆辙，前赴后继。研发中心经验共享_郭晶晶[201410].rar,2014/11/3
643,研发中心java经验共享之2011-2012,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8640,凝聚着研发中心2年的宝贵财富，无私奉献，希望大家从中受益。经验共享汇编.rar,2014/11/3
644,经验之谈 - oracle恢复误删数据,马玉荣,http://180.168.156.212:2262/wecenter/?/article/8639,Oracle闪回的功能:Oracle对数据的删除之后将相关的信息保存在表空间里面，其表空间在保存删除信息的时候有一定的时间限制，当我们误删数据时，可以根据时间点从该表空间获取数据，从而恢复数据！研发中心经验共享_马玉荣[201410].doc,2014/11/3
645,CSS3 —— 之面包屑导航，以及 CSS 设计之我见,李海波,http://180.168.156.212:2262/wecenter/?/article/8638,面包屑导航的作用有很多，比如，让用户能够了解页面在网站中的位置，导航明确；可以提供返回各个层级的入口，方便用户浏览或者及时返回；另外，Google已经将面包屑导航整合到搜索结果里面，优化面包屑导航的关键字，可以实现SEO优化的效果。另外，CSS的设计，其实只要掌握了基本的思路，其实并不难。就好像从0~无穷大，0~1，其实占到50%，我们掌握了其规律，基本就掌握了0~1，那么1~无穷大，也就是复合，叠加，累积的过程了。文章中，我对CSS的基本设计思路给出了自己的一些建议和想法，供大家参考。研发一部-李海波-经验分享-20141101.doccrumbs.zip,2014/11/3
646,强大的矢量图形库---Raphael.js,丁凯,http://180.168.156.212:2262/wecenter/?/article/8637,见附件研发中心经验共享[201410]_丁凯.doc,2014/11/3
647,Oracle和sqlserver,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8636,Oracle与sqlserver差异研发中心经验共享-毛璀玲[201410].doc,2014/11/2
648,产品经理能力框架图,路斌,http://180.168.156.212:2262/wecenter/?/article/8634,本图描述了产品经理应该具备的能力及完成的工作。我司最匹配的岗位是产品PDT经理。产品团队中的产品经理、系统分析员、开发经理应该擅长其中部分的能力。产品经理能力框架图.pdf,2014/10/25
649,什么是扁平化设计 (Flat Design)，扁平化设计是未来的趋势吗？,傅旭巍,http://180.168.156.212:2262/wecenter/?/article/8633,(引编辑于2014-09-22）本文好几个月前写的，现在看看写的还不够全面……现在想想，UI设计扁平化的还有个很大的驱动力是项目进度需求和responsivedesign的维护效率需求，这是眼前的趋势。-------------------------------------------------------------------------------前言实际上是这一两年，我们可以发现越来越多的程序的GUI变得平面化了：google、Microsoft、facebook、甚至apple的首席设计师JonyIve也说过苹果会开始适当扁平化一点，WWDC2013的新logo也能看出这个暗示了。于是很多人都问，为什么会有这样的趋势了？我认为扁平化是一个必然趋势。并不是单纯的因为审美疲劳导致的为了变化而变化，而主要是因为数码化程度越来越高的日常生活中导致的。随着时代的变化，一方面是拟物化作用越来越少而退出主流，另一方面是扁平化更适应新时代的需求。About首先要明确的是：扁平化设计并不是为了拍扁而拍扁，它是一种设计理念，色块是它的外在表现形式。同样的，拟物化也是不应该是为了拟物而拟物，立体是它的外在表现形式。这个应该争论不多。本文将主要从拟物/扁平设的出发点讨论他们的时代特点，而不是外在形式，请读者们牢记在心以免不必要的误解。其次要明确的，也是很有争论的是：拟物和扁平到底是不是对立的？如果说扁平是一种极端，那另一个极端是什么？虽然这两者的出发点是不同但不完全相反，但似乎除了拟物没有更适合当扁平化的假想敌了，至少从实际流行度变化来看也确实是这样的。当然，我这篇文章也得基于「拟物和扁平是对立的」这个假设来写。不然就没观点，也没下文了。而至于字面上的反义词立体设计/浮雕效果，那又是没人去谈的。有人说计算器的例子，win8的计算器拍扁了，但也是依然是拟物化，布局和实体计算器一个样，所以拟物和扁平是可以共存。初看是有道理的，但细想的话我觉得这个例子没有说服力。其实数字计算机本身就是个扁平化的计算器。就算不去想实体计算器，按照信息构架从0开始设计一个计算器，很有可能也会是那么类似的结果。更不用说数字计算器光字面上就是个有UI的计算机了，只不过这个UI很简单略复古和现在的UI的概念略有差别而不一定能被我们马上意识到是UI而已。有没有人记得算盘？一个珠子代表一或五的算盘，那估计算是拟物化设计的计算器了。而至于用色块画个温度计、用色块画个模拟时钟什么的，要我说那本质依然是拟物。而不是所谓共存。---------------------（引）我非常支持扁平化的趋势，准确地说，我认为目前的趋势是抽象化，扁平化只是抽象化的一种典型形式。1.拟物化的局限所谓拟物，必须是现实世界中已经有的物体，而且是人们日常的生活中经常使用的物品。但遗憾的是，人们生活中使用过的东西是非常有限的，相机、指南针、时钟、收音机、录音机……我们每个人都熟识并且会使用的“设备”不超过100件，而且这仅仅是对于70后80后而言。对于00后出生人来说，他们从出生就没见过磁带录音机，拨盘电话，收音机，红白游戏机，BP机，大哥大等这些已经被淘汰的设备，我们有理由相信，未来我们的孩子，可能连鼠标、指南针、随身听都不会认识，因为这些设备都被一部手机所代替，甚至手机有一天也会被代替。那么，当我们熟识的设备越来越少，而手机应用所要实现的功能越来越创新的时候，这个矛盾就出现了。应用的功能太创新，根本找不到一个现实生活中的物来拟。所以，拟物的风格会限制住创新应用的发展。2.拟物的极限iOS6之前的版本，其实已经把拟物推到了一个非常高的高度，视觉上每一处的纹理、阴影、质感，每一个细节都经过精雕细琢，堪称完美。这个时候想要有所超越，尤其是想要在拟物这条路上有所超越，已经非常困难。同时，我们发现，市场上非常多相机应用都找一个相机来做拟物，音乐应用都找一个老式唱片机来拟物，所有的指南针应用打开都是一个指南针。拟物化带来高度的同质化。更遗憾的是，由于指南针、唱片机、收音机这样的产品其实都是已经被淘汰的设备，而这些设备早已停止了创新停止了改进，是死的。但是应用是活的，要继续改进发展。假如沿着拟物化这条路走下去，10年20年50年之后，这些应用打开来还是老样子。你不觉得悲哀么？3.从拟物到抽象其实我非常反对从拟物到扁平这种提法，我认为现在的趋势并不是扁平化，而是抽象化，扁平只是抽象的一种视觉形式，抽象化其实有更多的可能性。回顾历史，我们会发现从拟物到抽象是历史的必然，举文字的演变和绘画的发展作为例子：几乎所有的文字一开始都是象形文字，用拟物的方式来描绘现实世界中的东西，但是随着人类社会的日趋复杂，越来越多抽象的概念涌现出来，人们发现无法用拟物的方式来表达，于是开始放弃拟物，采用表音的方式来记录语言。即使是汉字中，比重最大是形声字，纯粹的象形字也屈指可数。类似的，绘画一直到摄影术发明之前都是在追求写实，极致的写实。但是摄影术发明之后，人们发现写实的绘画已经走到了尽头，已经无法再超越，唯一的方法就是另辟蹊径，用抽象的方式去绘画。于是当代的艺术，越来越抽象，彻底摆脱了现实世界的束缚。纵观艺术史，我们都可以看出，一开始人们都努力去还原现实世界，在技法日趋完善的同时，人们开始意识到了“还原现实”的局限性，而开始冲破现实的束缚，走向抽象。即使现在，仍然有相当多的普通人无法理解抽象艺术(有兴趣推荐大家去看一下MOMA艺术馆的藏品)，但是已经没有哪个艺术家愿意再回到之前的艺术时代了。类比手机的拟物化，我们有理由相信，在未来相当长的时间里，拟物化的视觉风格将仍然受到大多数普通用户的推崇，但是作为一个设计师，应该有这个高度看到抽象化的意义。4.拟物和极简的冲突拟物就需要对物体的高度模拟，需要丰富的细节，于是我们需要质感、需要层次、需要阴影，这些最终都需要通过视觉元素来实现。但实际上用户最后需要关注的只是信息本身，这些视觉元素或许在用户使用初期，是一个赏心悦目的装饰，但是久而久之，对用户来说就是一种干扰信息，用户需要的是更简单更直接地得到他想要的信息。再者说，接下来更多的随身设备，比如googleglass，iWatch，都需要将交互过程进一步简化，如果继续坚持拟物化，很难想象在iWatch这个狭小的屏幕上，如何呈现一个细节丰富的物体。所以说，拟物化其实和极简主义是背道而驰的。在形式追随功能的原则指导下，不得不放弃拟物，而实现功能最大化。5.扁平化!=iOS7很多人因为不喜欢iOS7的视觉风格，而反对扁平化。这其实犯了一个明显的逻辑错误，iOS7只是在扁平化这个方向上做出了自己的尝试，只是一个早期版本。实际上正在探索扁平化的，还有google，还有WP8，等等。不要把iOS7的不成熟看成是扁平化这个方向的错误。现在我们所处的时期，正是拟物化的体系日趋完善，抽象化的体系刚刚建立的时期。拿一个初生的婴儿去和发育完全的成年人相比，显然是不公平的。综上，我相信历史的车轮滚滚，抽象化的时代即将到来，纵使我们对拟物的时代有万般留恋，抽象化仍然不可避免。同时我们是幸运的，我们将会经历整个变革过程，我们是历史的亲历者。哦不，我们正在创造历史!擬物化的没落我们先来看一下为什么有拟物化这个东西：Jobs对界面设计的一个理想是，任何年龄的人，任何经历的人，都可以在拿到设备后的几分钟内轻松的掌握它的用法。于是apple通过利用人们的日常经验，做出拟物化的界面，从而降低用户的学习成本以及理解难度，正如《iOSHumanInterfaceGuidelines》里提到，「当你应用中的可视化对象和操作按照现实世界中的对象与操作仿造，用户就能快速领会如何使用它。」最早最常见的拟物化，或许就是按钮了，突起的表示可以按的，凹陷的表示已经被按了。确实易懂。拟物化在当时那个数码设备尚未十分普及的时代，毫无疑问是效果是不错的。但是，数码设备的普及+一个万能的手机，成了拟物化没落的起始点。不再需要降低学習成本前面也说了，在数码设备普及度不高的时代，拟物化是有效果的，我相信对于从未接触过数码设备的老人/小孩应该是尤其效果拔群的。但是在人人有电脑，人人有智能机，日常和学习/办公都离不开计算机，不会用计算机就像美国人没驾照一样奇怪的信息时代，我们还有必要去那么刻意地降低学习成本生怕用户不会用么？何况大多数软件的市场本身就不把老人/小孩考虑在内。一个先进的设备得通过模仿古老的东西让用户快速理解，是时代过渡中的一个不得已。在未来人眼中，一个温度计的app要特地设计成实体温度计的样子，一定傻/蛋疼透了。更进一步的，拟物≠高效，刻意的在交互上拟物，有时候反而降低了效率。随着数码的普及，人们对产品的要求也是在变的，后面的「数码渗入生活」章节会提到。失效当一个数码设备可以完成听音乐、写东西、看地图、打电话等一切任务的时候，传统的东西必然会失去竞争力而逐渐退出历史舞台。那时候，就算想拟物也没东西可以给你拟了。图标就是个很好的例子：代表「保存」的3.5英寸软盘、代表「留言」的磁带、书签……有些人年轻人甚至连话筒也不认识，认为所谓电话，就是iphone这样的一块金属。@负二说的(画个平的/立体的)闹钟在未来也会出现这样的问题，没人知道长者两个大耳朵的钟就是闹钟。我最后一次见到闹钟还是在迪斯尼动画里。在这样的趋势下，拟物化就算依然奏效，也得谨慎选择了。擬物化的濫用事实上很多拟物化设计并没有遵从拟物化设计的初衷。不给记事软件加封皮会影响用户理解吗？日历程序有个翻页动画帮助了用户理解程序用法吗？……「所以一个使用玻璃温度计图片的天气app就是拟物化：玻璃在原来（现实中的温度计）是必要的，而在新设计中变为完全的装饰。」~SachaGreif「在现实世界中，当一个按钮按下，你能感受到它的弹性和弹力，但是在手机或者屏幕上，有物理上反馈的先天不足。你的意识知道物理性的存在而拟物化没有。所以至少对我来说，它事实上没有达到预期和让我失望的时刻。」~AllanYu(svpply/eBay)连Wikipedia也说:「一个产品的设计元素模仿其在原始产品设计中是必要功能，但是在新的设计中变为装饰的设计元素」数碼渗入生活人们对数码产品的印象是随着普及度变化的。在计算机还是个普及度有限的东西，数码产品在一些人眼中是有点神秘的——「炫」「酷」「时尚」。记得十几年前看到一个逼真的金属外壳的播放器皮肤，真是觉得屌爆了！觉得计算机好帅气！于是也出现了很多向我一样的界面爱好者，着迷于华丽炫酷的界面；能画一手华丽的图标的，进一个IT大企业当个设计师也是十拿九稳的；也没人会去说一个画简洁图标的人好厉害。很多GUI设计在可以传递一种意识「这是计算机，与众不同」。那个时代，我们是「享受计算机」，精美的GUI也是享受的其中一环。但是现在数码产品广泛地渗入到大家的生活中后、成为日常生活不可分离的一部分后，数码产品对我们不再有神秘感。听歌得靠它、找资料得靠它、报名得靠它、找路得靠它、制定计划得靠它……计算机的使用频率如此之高，使得人们对计算机的印象慢慢转向效率、靠谱、万能。对于一个这样的生活必需品，我们需要很精致甚至华丽的外观吗？我相信随着普适计算的渗入，计算机对人们来说会变得越来越纯粹——执行必须的任务——执行完就关掉。计算机是个熟悉的不能再熟悉的东西了，一个记事程序对未来人们来说，或许就像一个（真）笔记本对于现在的我们：它的作用就应该是那么纯粹、简单。越来越多的人会觉得「一个打字程序而已为什么要做的那么复杂？」，就像现在的我们看到一个花里花俏的铅笔会觉得「为什么一个铅笔还要做的那么复杂？」未来的时代，人们的重心将会从「享受计算机」转变到「随心使用计算机」。GUI的设计也必然会慢慢会抛弃华丽的外皮，而专注于信息和任务本身。扁平化设计是非常适合这种需求的，当然也可以换过来说，拟物化设计在这种场景下是有点画蛇添足的。再想一下近未来的数码社会会是怎么样的吧。康宁和微软都向我们展示过了他们的近期展望——不管是AR还是屏幕，总之是一个充满了UI的生活。不仅仅是使用情景碎片化了，连界面也碎片化了。（感谢Woeh的意见）在随便望一眼都是很多UI的时代，你能想象充满了高光、阴影的GUI的话会是怎么样的场景吗？GUI的目标会从沉浸式转向碎片化，慢慢向平面设计、工业设计靠拢，而形成设计圈的大统一、生活「材质」的大统一。在更遥远的未来，或许按钮不叫按钮了，叫触发器之类更抽象的名字了，或者，干脆没有按钮这类东西了，因为操纵电脑不再需要手了，也许连GUI都不需要了，一切将会是信息流而已。審美疲勞审美疲劳虽然是次要因素，但也不可忽略。那个时代，GUI圈有着普遍的设计美学。Layervault的AllenGrinshtein在一篇发表于HackerNews的文章中，他说：「网页中广受欢迎的产品通常都有一些类似的设计美学，比如一些立体、内阴影、外阴影等。对设计师来说，他们会以实现这种“媚俗”的界面而感到自豪。」论天下设计，简久必繁，繁久必简。GUI也不例外，不管是制作方还是用户，都会审美疲劳。就算不疲劳，有些产品需要标新立异，与众不同，也必然会走向另外一个极端了。最後综上，随着时代的变迁，拟物化的「设计」属性越来越少，从而慢慢变成为一种「（视觉装饰）风格」。作为一种设计，拟物化的好处会越来越少，而随之带来的开发成本增加、审美疲劳等问题，使得用它的理由越来越少了。当然，拟物化不会在就此马上消失，风格这东西不存在好坏，总会有一部分人喜欢。在下次人机交互革命前，还会占有一席之地。而极简的设计，也会被人看腻而适当加入一些装饰元素。最后最后，未来科技发展的实际情况也没人知道，或许远远慢于我们的预期，也有可能远远快于我们的预期以至于UI设计还没第二个轮回就直接进入意识控制而不需要UI了。我也只是发表下自己观点。观点对或不对，现在没人能下定论，也不是本文的重点。希望本文中的一些观点对读者有所启发、刺激更进一步的思考。-----------（引）1.拟物化的局限所谓拟物，必须是现实世界中已经有的物体，而且是人们日常的生活中经常使用的物品。但遗憾的是，人们生活中使用过的东西是非常有限的，相机、指南针、时钟、收音机、录音机……我们每个人都熟识并且会使用的“设备”不超过100件，而且这仅仅是对于70后80后而言。对于00后出生人来说，他们从出生就没见过磁带录音机，拨盘电话，收音机，红白游戏机，BP机，大哥大等这些已经被淘汰的设备，我们有理由相信，未来我们的孩子，可能连鼠标、指南针、随身听都不会认识，因为这些设备都被一部手机所代替，甚至手机有一天也会被代替。那么，当我们熟识的设备越来越少，而手机应用所要实现的功能越来越创新的时候，这个矛盾就出现了。应用的功能太创新，根本找不到一个现实生活中的物来拟。所以，拟物的风格会限制住创新应用的发展。2.拟物的极限iOS6之前的版本，其实已经把拟物推到了一个非常高的高度，视觉上每一处的纹理、阴影、质感，每一个细节都经过精雕细琢，堪称完美。这个时候想要有所超越，尤其是想要在拟物这条路上有所超越，已经非常困难。同时，我们发现，市场上非常多相机应用都找一个相机来做拟物，音乐应用都找一个老式唱片机来拟物，所有的指南针应用打开都是一个指南针。拟物化带来高度的同质化。更遗憾的是，由于指南针、唱片机、收音机这样的产品其实都是已经被淘汰的设备，而这些设备早已停止了创新停止了改进，是死的。但是应用是活的，要继续改进发展。假如沿着拟物化这条路走下去，10年20年50年之后，这些应用打开来还是老样子。你不觉得悲哀么？3.从拟物到抽象其实我非常反对从拟物到扁平这种提法，我认为现在的趋势并不是扁平化，而是抽象化，扁平只是抽象的一种视觉形式，抽象化其实有更多的可能性。回顾历史，我们会发现从拟物到抽象是历史的必然，举文字的演变和绘画的发展作为例子：几乎所有的文字一开始都是象形文字，用拟物的方式来描绘现实世界中的东西，但是随着人类社会的日趋复杂，越来越多抽象的概念涌现出来，人们发现无法用拟物的方式来表达，于是开始放弃拟物，采用表音的方式来记录语言。即使是汉字中，比重最大是形声字，纯粹的象形字也屈指可数。类似的，绘画一直到摄影术发明之前都是在追求写实，极致的写实。但是摄影术发明之后，人们发现写实的绘画已经走到了尽头，已经无法再超越，唯一的方法就是另辟蹊径，用抽象的方式去绘画。于是当代的艺术，越来越抽象，彻底摆脱了现实世界的束缚。纵观艺术史，我们都可以看出，一开始人们都努力去还原现实世界，在技法日趋完善的同时，人们开始意识到了“还原现实”的局限性，而开始冲破现实的束缚，走向抽象。即使现在，仍然有相当多的普通人无法理解抽象艺术(有兴趣推荐大家去看一下MOMA艺术馆的藏品)，但是已经没有哪个艺术家愿意再回到之前的艺术时代了。类比手机的拟物化，我们有理由相信，在未来相当长的时间里，拟物化的视觉风格将仍然受到大多数普通用户的推崇，但是作为一个设计师，应该有这个高度看到抽象化的意义。4.拟物和极简的冲突拟物就需要对物体的高度模拟，需要丰富的细节，于是我们需要质感、需要层次、需要阴影，这些最终都需要通过视觉元素来实现。但实际上用户最后需要关注的只是信息本身，这些视觉元素或许在用户使用初期，是一个赏心悦目的装饰，但是久而久之，对用户来说就是一种干扰信息，用户需要的是更简单更直接地得到他想要的信息。再者说，接下来更多的随身设备，比如googleglass，iWatch，都需要将交互过程进一步简化，如果继续坚持拟物化，很难想象在iWatch这个狭小的屏幕上，如何呈现一个细节丰富的物体。所以说，拟物化其实和极简主义是背道而驰的。在形式追随功能的原则指导下，不得不放弃拟物，而实现功能最大化。5.扁平化!=iOS7很多人因为不喜欢iOS7的视觉风格，而反对扁平化。这其实犯了一个明显的逻辑错误，iOS7只是在扁平化这个方向上做出了自己的尝试，只是一个早期版本。实际上正在探索扁平化的，还有google，还有WP8，等等。不要把iOS7的不成熟看成是扁平化这个方向的错误。现在我们所处的时期，正是拟物化的体系日趋完善，抽象化的体系刚刚建立的时期。拿一个初生的婴儿去和发育完全的成年人相比，显然是不公平的。,2014/10/23
650,组件库4.0介绍,魏爱红,http://180.168.156.212:2262/wecenter/?/article/8632,面向公司广大技术人员的组件库最新版本CES-coral4.0正式出炉了，好不好说了不算，用了才知道，欢迎各位使用！组件库4.0V1.pptx,2014/10/16
651,中信论坛的XSS攻击BUG,张璠,http://180.168.156.212:2262/wecenter/?/article/8631,详细请查看 ,2014/10/16
652,移动开发设备共享,路斌,http://180.168.156.212:2262/wecenter/?/article/8630,近期，各部门的移动应用开发需求越来越多。为提高设备利用率，特共享一下研发中心目前的公共移动设备。其他部门如有公共移动设备建议也贴出来。1、三星平板电脑GALAXYGT-P621016G2、苹果ipodtouch48GBMC540CH/A3、苹果ipad2A139516G4、小米手机3移动版16GB如需要借的，请联系林资颖。,2014/10/13
653,CSS布局之强大的负边距,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8629,"css中的负边距(negativemargin)是布局中的一个常用技巧，只要运用得合理常常会有意想不到的效果。很多特殊的css布局方法都依赖于负边距。下面具体讲下3个应用场景1.左和右的负边距对元素宽度的影响。想要创建上图中黑框内的几个元素按顺序排下来，中间带些间隔的布局要怎么做？，当然最简单省事的方法就是利用浮动了。我们把黑框里面的子元素向左浮动，然后设一个合适的margin-right,是不是就办到了呢？但因为外边黑框的宽度是固定的，就是里面四个子元素的宽度加上三列间隔的宽度，所以靠近右边边界的子元素就不应该有正向的margin-right了，否则这一行就只能容纳三个子元素了。有人说那这还不简单，给靠近右边界的那些子元素加一个class，把它的margin-right设为0不就行了。这当然可以，但如果这些子元素是在模板中通过循环动态输出的，那在循环的时候还得判断哪些子元素是靠近右边边界的，如果是就加上一个class。这样做的话是不是就有点麻烦了？所以解决办法是加大子元素的父容器的宽度，让它能够容纳一行中有四个子元素加上四列间隔的宽度，然后最外面的的黑框的那个容器设一个overflow:hidden就行了。上面说了负的左右边距能加大元素的宽度，所以给子元素的父容器设一个合适的负的margin-right就可以了。当然你也可以直接在css中把子元素的父容器的宽度设宽一些，举这个例子只是为了说明负边距也是一种方法。看下完整的代码：<br/>body,ul,li{padding:0;margin:0;}<br/>ul,li{list-style:none;}<br/>.container{height:210px;width:460px;border:5pxsolid#000;}<br/>ul{height:210px;overflow:hidden;margin-right:-20px;}/*一个负的margin-right,相当于把ul的宽度增加了20px*/<br/>li{height:100px;width:100px;background:#09F;float:left;margin-right:20px;margin-bottom:10px;}<br/>子元素1子元素2子元素3子元素4子元素5子元素6子元素7子元素82.负边距对浮动元素的影响负边距对浮动元素的影响与负边距对文档流中元素的影响其实是差不多的。文档流中元素的位置由文档流的走向决定，浮动的元素也可以看成有一个“浮动流”存在，不过浮动流既可以向左，也可以向右。3.负边距对绝对定位元素的影响绝对定位的元素定义的top、right、bottom、left等值是元素自身的边界到最近的已定位的祖先元素的距离，这个元素自身的边界指的就是margin定义的边界，所以，如果margin为正的时候，那它的边界是向外扩的，如果margin为负的时候，则它的边界是向里收的。利用这点，就有了经典的利用绝对定位来居中的方法：看下效果：但该方法的缺点是必须要知道要居中元素的高度和宽度。",2014/10/13
654,杨冬权局长在2014年全国档案工作者年会上的讲话,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8628,稿子本身没有什么花头，但其中着重谈到了创新宣传的巨大作用和影响力，应该能引起技术部门的共鸣。我们的技术人员以及技术部门的管理人员基本上都是闷头干活的居多，能够把自己做的亮点的功能宣传推广出去乃至发扬光大的基本没有，这一点倒是和档案部门的人蛮像的。从这篇文章中大家可以看到，现在档案人也开始改变了，通过创新大幅度提升了档案部门的社会影响力乃至国际影响力，档案部门不再是一个可有可无的部门！那么，我们的技术部门呢？杨冬权在2014年全国档案工作者年会上的讲话.mht,2014/10/12
655,was8.5下奇异问题，页面输出过长报错,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8627,好好的程序在tomcat下都没有问题，在was下就出现稀奇古怪的问题。研发中心经验共享_郭晶晶[201409].doc,2014/10/11
656,css属性,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8626,tablelayout属性和whitespace属性简单介绍研发中心经验共享-毛璀玲[201409].doc,2014/10/11
657,Turn.js - 基于 HTML5，Jquery，CSS3 的制作电子杂志，电子书，电子相册的神器,李海波,http://180.168.156.212:2262/wecenter/?/article/8625,turn.js是轻量的jQuery杂志插件（10K），基于HTML5技术实现。可以实现电子书翻页特效，鼠标移到页脚，点击/拖动可以实现翻页，支持触摸屏设备，如Android，IPhone，Pad等。turn.js可以通过API来获取当前显示的页号，并提供选项来定制默认页号、加速器、阴影和延时。能够将HTML内容组织成看起来像一本真正的书籍或杂志，适合基于HTML5实现类似杂志，书籍，目录的效果。官网： /turnjs4.zip研发一部-李海波-经验分享-20141011-final-1.ppt,2014/10/11
658,软件构件化开发介绍,路斌,http://180.168.156.212:2262/wecenter/?/article/8624,软件构件化开发是我司正在探索推进的一种新的软件开发方式，附件为基础宣传材料。构件化开发模式介绍.exe,2014/10/6
659,内幕：一位Adobe中国区遭裁员工的“陈述”,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8623, article.php?storyid=108295内幕：一位Adobe中国区遭裁员工的“陈述”.docx,2014/9/30
660,如何优雅地进入这种系统,朱俊1,http://180.168.156.212:2262/wecenter/?/article/8622,大多不开放注册，有开放注册的也需要审核这种 /ztxxgl/pu...Login,2014/9/30
661,外出登记引发的血案。。。。,王蕊,http://180.168.156.212:2262/wecenter/?/article/8621,像我们经常外出的人，如何可以按照时间段填写外出登记？每次只能登记一张，实在伤不起啊。。。。,2014/9/30
662,国务院关于印发社会信用体系建设规划纲要（2014—2020年）的通知(国发〔2014〕21号),杨安荣,http://180.168.156.212:2262/wecenter/?/article/8620,全文总共16处提及“档案”，4处提及“食品”。国务院关于印发社会信用体系建设规划纲要（2014—2020年）的通知(国发〔2014〕21号).mht,2014/9/6
663,Sony ODA海量光盘数据存储系统，近线/离线存储的新选择？,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8619,日本鬼子的鸟东西，实在不想推荐，但貌似全球又没有同类技术。采用ODA代替磁带库，看上去很美，在电子档案长期保存领域应该有广阔的应用前景，实际是不是这样，还有待考证。 /2012/8/65283383.shtmlSonyODA海量光盘数据存储系统.docx,2014/9/6
664,jquery问题,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8618,1、jquery动态创建a标签onclick事件无效问题2、格式代码出现两次错误解决办法3、Jquery的html()方法问题研发中心经验共享-毛璀玲[201408].doc,2014/9/5
665,物联网要变成现实 还缺少什么？,张旭栋,http://180.168.156.212:2262/wecenter/?/article/8617,IoT被定义为与其他设备、物件、环境和基础设施进行交互和通信的智能设备，它会生成大量数据，并将其处理为可以“命令和控制事物”的有用操作，使人们的生活更方便。。。类似于20世纪70年代的卡通片《杰森一家》所设想的世界，甚至更美好。那么物联网要变为现实，还缺什么？文档是飞思卡尔半导体于2012年发表一篇文章，适合于售前、销售在于用户谈论所涉及该类型的业务时使用，文章中间的部分技术图表也好理解。Chinese_FS_Internet_of_Thing_Jan13.pdf,2014/9/2
666,超级强大的多媒体格式转换工具：格式工厂,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8616, /CN/经测试确实很强大，一个800M的RMVB文件转换成MP4格式，用时35分钟转换完成，在转换过程中机器可以正常工作，CPU占有率不超过40%。我司的文件格式转换工具和它相比那真是弱爆了！“灵器”工具团队，加油！！,2014/8/28
667,《电子文件管理系统通用功能要求》（GB/T 29194-2012）,路斌,http://180.168.156.212:2262/wecenter/?/article/8614,参见附件ERMS功能要求报批稿20120514.pdf,2014/8/26
668,办公楼宇智能 （基础普及版）,张旭栋,http://180.168.156.212:2262/wecenter/?/article/8615,从全球范围来看，人们越来越意识到了过度温室气体排放所带来的严重后果，因此降低电力消耗也越来越受到重视。最终，节能高效的建筑物不仅会树立更加积极的公众形象，而且也会激发电力成本上涨形势下的经济头脑。拥有“绿色、智能、舒适、高效”办公环境是未来办公楼宇智能发展的趋势。想要你的办公楼宇更加节能环保吗？想要降低你办公楼的运营成本吗？想要舒适的办公环境吗？想要你的办公楼更加可靠、安全吗？办公楼智能管理系统（基础普及版）.pdf,2014/8/26
669,重量级档案业务标准：档发[2014]4号《数字档案室建设指南》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8613,国家档案局2014年7月4日发布。请各档案室软件需求部门、研发部门、项目部门、实施部门、咨询部门、销售部门员工仔细研读，认真体会。特别是其中电子档案管理功能需求要求符合《电子文件管理系统通用功能要求》（GB/T29194-2012）的条款，是对我司的重大利好，我们的光典4.1-ERMS版软件通过了人大的权威测评，完全符合该标准，而量子伟业、东方飞扬、珠海泰坦等公司的软件都没有通过测评。档发[2014]4号《数字档案室建设指南》.pdf,2014/8/26
670,外行乱插嘴，这个是否会有市场？,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8612, 2016年国家将取消档案管理费，并逐步全国推广电子档案。是否有档案或者数字化加工的市场存在？,2014/8/15
671,基于jQuery的ajax调用有认证的apache cxf webservice,滕树宝,http://180.168.156.212:2262/wecenter/?/article/8611,基于jQuery的ajax调用有认证的apachecxfwebservice，有需要的可以参考下。研发中心技术共享7月份_滕树宝.docx,2014/8/6
672,HTML5 - Canvas API 、使用示例及框架介绍,李海波,http://180.168.156.212:2262/wecenter/?/article/8610,Canvas是HTML5中用来在网页上绘制图像的元素。HTML5的Canvas元素使用JavaScript在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。Canvas拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。总之，可以在页面上画图，算是HTML5的一个重要的特性，也为众多web应用开放者带来了福音，再也不用也很多代码来在页面上实现画图的功能了。canvasAPI&AnnotationTool.zip研发一部-李海波-经验分享-20140731.doc,2014/8/5
673,轻松赢500，你还等什么？,曹义敏,http://180.168.156.212:2262/wecenter/?/article/8609,"话说“一波还未平息，一波又来侵袭”，上期有奖征集究竟花落谁家还未揭晓，本期又500元悬赏多个产品或行业的名称及LOGO设计方案!具体如下：1、档案寄存中心征名档案寄存中心是针对不同企业的档案管理需求量身定制的，一类是基于互联网建立专门面向中小企业进行文档资料管理的“中小企业档案网”（即“档案云”），在相关档案管理部门的指导下，为中小企业提供文档资料管理的解决方案。另一类是在云计算框架下建立针对各个集团型企业多全宗档案管理的“私有云”，满足集团型企业自上而下、集中式全面档案信息资源管理的需求。LOGO设计已通过（可在公司外网查看），但名称“爱存档”还有待斟酌，现广泛征集更合适的名称。2、S1服务征集LOGO设计S1的定义是“一站式IT运维专家”，是中信信息的服务品牌。S1服务追求“保障第一（System）、规范第一(Standard)、态度第一(Smile)、安全第一(Safety)、速度第一(Speed)和服务第一(Service)”的服务宗旨,故取名S1。现广泛征集S1服务的LOGO设计。评选标准：1、公司会对征集的方案进行评选，对采纳的名称、LOGO的设计者公司将给予500元的奖励！2、参与者可分别提供名称、LOGO设计，也可提供全套设计；3、如遇提交的设计方案相同的情况，以第一时间提交者为准。参与方式：1、此次征集面向全司范围公开征集，参与者可在本活动文章页面内跟帖，按要求回复相关方案即表示参加；2、也可采用邮件、wortalk等任何你觉得合适的发送方式；3、评选结果将在OA上公示，并通知获奖者。联系人：市场营销中心——产品规划部：曹义敏公司核心技术.pptx食品追溯行业产品线.pngS1服务.pngces-产品vi待定品牌设计备选方案-.rars2.jpgces-产品vi.jpgS1.jpgQQ图片20140825101911.jpgQQ图片20140825101828.jpgQQ图片20140825101504.jpgQQ图片20140825101803.jpgQQ图片20140825101742.jpgQQ图片20140825101851.jpgces-s1VI.jpgces-s1VI.jpgs1ok.jpg",2014/7/28
674,使用Unity3D虚拟现实技术实现数字博物馆,杨木江,http://180.168.156.212:2262/wecenter/?/article/8608,给个连接： 没有RMB没有下载,2014/7/24
675,500元悬赏食品追溯网站域名、口号及LOGO设计,曹义敏,http://180.168.156.212:2262/wecenter/?/article/8607,500元悬赏食品追溯网站域名我司将推出食品追溯云平台门户网站，该网站着力于我司在食品流通追溯领域的业务知识积累和项目建设经验，拟建设一套涵盖食品追溯体系各个环节，保障追溯体系长效运营，实现追溯信息全面采集和服务的整体解决方案，并开发出系列软硬件产品，建成互联网上的追溯信息服务云平台，尽力成为全国食品追溯领域的数据中心和信息中心，面向政府、企业、社会公众等提供食品追溯信息的专业服务，为保障食品消费安全起到积极作用。现在全司范围内有奖征集网站域名、网站口号及LOGO设计。要求如下：域名设计要求：1、域名一定要以简洁、形象、易记为原则，能给访问者留下深刻的印象；2、域名要与公司名称及食品追溯相结合，或是它们的诠释，这样即使访客忘记了域名，但只要想起公司名称或产品也能联想起来；3、域名类型以符合一般惯例为原则，可选择.com、.cn、.com.cn、等，例如：www.food-trace.com。网站口号及LOGO设计要求：1、表达“信息技术、追溯与食品安全”之间的关系，并突出我司及网站特色；2、能够最大化规避其他竞争品牌；3、口号设计要求富有特点，没有歧义，语句凝练，简短易记，朗朗上口，例如：”食品追溯关系民生，信息服务提升质量“；4、LOGO设计要求有辨别性和独特性，要和”食品安全、追溯”的性质相关联，形成具备类似风格的造型；5、LOGO表现形式可以是图案、字母及合成文字等。评选标准：1、公司会对征集的方案进行评选，对采纳的域名、口号、LOGO的设计者公司将给予500元奖励！2、参与者可分别提供域名、口号及LOGO设计，也可提供全套设计；3、如遇提交的设计方案相同的情况，以第一时间提交者为准。参与方式：1、此次征集面向全司范围公开征集，参与者可在本活动文章页面内跟帖，按“参与要求”提供相关内容即表示参加；2、也可采用邮件、wortalk等任何你觉得合适的发送方式；3、评选结果将在OA上公示，并通知获奖者。联系人：市场营销中心——产品规划部：曹义敏发挥你的创造力，爆发你的小宇宙，赶快行动吧！惊喜多多，等你来拿！t1.pngf1.jpgsyb.jpgzs1.jpgsp2.jpgsp3.jpgcesTracevi.jpgces-食品追溯Logo.jpg,2014/7/15
676,云计算高级架构师培训,杨木江,http://180.168.156.212:2262/wecenter/?/article/8606,培训的PPT内容比较有用，可供参考云平台技术培训-1031-v2.pdf北京云计算高级架构师培训2014.3.20.pdf,2014/7/15
677,达梦数据所存在的问题及解决思路,张守伟,http://180.168.156.212:2262/wecenter/?/article/8605,达梦数据所存在的问题及解决思路我们的影像自动合并挂接工具，很多用户使用的都是达梦数据库，这种数据库使用ADO连接的时候有一个BUG，就是对数据表查询的次数达到一定的数量时，就会报一个错误（“未知的错误”）。为些我专门的写了一个测试程序，在我电脑上当第66次查询数据表的时候准会报这个错误，不同的电脑报错的查询次数是不一样的，后来我和达梦数据库的技术人员联系，确定这个BUG是存在的。后来经过测试，我发现用ODBC连接达梦数据没有这个问题。首先打开“控制面板”—>“管理工具”—>“OCDB数据源管理器”，然后添加一个连接达梦数据库的ODBC。然后把程序中的连接字符串改为AdoCon.ConnectionString:='Provider=MSDASQL.1;PersistSecurityInfo=False;DataSource='+ODBC名称;就行了。用这种方式测试了查询6000次都没有出现问题。,2014/7/4
678,在DLL中获取主进程窗口句柄,王孝本,http://180.168.156.212:2262/wecenter/?/article/8604,"在DLL中获取主进程窗口句柄BOOLCALLBACKEnumWindowsProc(HWNDhwnd,LPARAMlParam){DWORDdwCurProcessId=*((DWORD*)lParam);DWORDdwProcessId=0;GetWindowThreadProcessId(hwnd,&dwProcessId);if(dwProcessId==dwCurProcessId&&GetParent(hwnd)==NULL){*((HWND*)lParam)=hwnd;returnFALSE;}returnTRUE;}HWNDGetMainWindow(){DWORDdwCurrentProcessId=GetCurrentProcessId();if(!EnumWindows(EnumWindowsProc,(LPARAM)&dwCurrentProcessId)){return(HWND)dwCurrentProcessId;}returnNULL;}BOOLEANWINAPIDllMain(INHINSTANCEhDllHandle,INDWORDnReason,INLPVOIDReserved){BOOLEANbSuccess=TRUE;switch(nReason){caseDLL_PROCESS_ATTACH:MessageBox(GetMainWindow(),TEXT(""OMG~YouareAttacked!""),TEXT(""Warning""),MB_ICONWARNING);break;caseDLL_PROCESS_DETACH:break;}returnbSuccess;}",2014/7/4
679,国家开放档案信息资源共享利用平台正式上线,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8602, ，一个相当牛叉的域名。,2014/7/4
680,铁证如山：国家档案局网站公布日本战犯侵华罪证自供档案,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8603, 1945年8月14日，日本天皇裕仁发表停战诏书，宣布日本无条件投降。根据《波茨坦公告》，中、美、英、苏等11个国家组成远东国际军事法庭，对发动侵华战争和太平洋战争负有战争责任的东条英机等日本战犯进行了审判。新中国诞生后，接管和关押的日本侵华战犯达1109名，分别关押在抚顺、太原两地。1954年，中央人民政府最高人民检察署(后改称中华人民共和国最高人民检察院)负责对日本侵华战犯的侦查、起诉工作，对他们在侵略中国战争中侵夺中国主权，策划、推行侵略政策，进行特务间谍活动，制造细菌武器，施放毒气，屠杀、抓捕、奴役和毒化中国人民，强奸妇女，掠夺物资财物，毁灭城镇乡村，驱逐和平居民，违反国际准则和人道主义原则等各种罪行进行了审讯……[详细],2014/7/4
681,利用java、js、html客户端工具开发的两个新方法,张二伟,http://180.168.156.212:2262/wecenter/?/article/8601,本文基于客户端检测工具的现实需求，提出了两个利用java/web开发人员普遍熟悉的js、html、java技术，进行客户端工具开发的可行性方案，比较了优缺点，并有demo演示效果。参看附件。利用java、js、html客户端工具开发的两个新方法.pdf,2014/7/2
682,很有意思的一段图片检索代码，你们感受一下,王健敏,http://180.168.156.212:2262/wecenter/?/article/8600,古话说做技术探索上网找的不是资料，是寂寞，这话一点没错。古话又说做技术探索的经常能体会到绝处逢生、柳暗花明，这话更是没错。古话还说干TMT的就是网上找资料并copy&paste的，这话没错est。在尝试了opencv+kdtree和sift各种算法而各种碰壁（性能和检索效果不佳）后，居然不小心鼠标一抖，找到了一段简单、方便、性能、效果各方面都挺理想的解决方案。此程序不用调用任何第三方插件，集成简单方便。程序在附件中，不用任何说明大家就应该会用。代码说明都直接写在文件中了，不懂的直接问我。SimilarImageSearch.rar,2014/6/23
683,获取对象的 RTTI 属性与事件的函数,王孝本,http://180.168.156.212:2262/wecenter/?/article/8599,"unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls,xmldom,XMLIntf,XMLBrokr,msxmldom,XMLDoc;typeTForm1=class(TForm)Button1:TButton;Button2:TButton;Memo1:TMemo;Memo2:TMemo;XMLDocument1:TXMLDocument;procedureButton1Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}usesTypInfo;{获取类的信息,需要这个单元}//获取对象的RTTI属性与事件的函数functionGetPropertyAndEventList(obj:TObject;pList,eList:TStringList):Boolean;varClassTypeInfo:PTypeInfo;{类的信息结构指针}ClassDataInfo:PTypeData;{类的数据结构指针}propertyList:PPropList;{TPropInfo是属性的数据结构;PPropList是其指针;TPropList是属性结构指针的列表数组;PPropList是指向这个数组的指针}num:Integer;{记录属性的总数}size:Integer;{记录属性结构的大小}i:Integer;beginClassTypeInfo:=obj.ClassInfo;{先获取:类的信息结构指针}ClassDataInfo:=GetTypeData(ClassTypeInfo);{再获取:类的数据结构指针}num:=ClassDataInfo.PropCount;{属性总数}size:=SizeOf(TPropInfo);{属性结构大小}GetMem(propertyList,size*num);{给属性数组分配内存}GetPropInfos(ClassTypeInfo,propertyList);{获取属性列表}fori:=0tonum-1dobeginifpropertyList[i].PropType^.Kind=tkMethodthen{如果是事件;事件也是属性吗,给分出来}eList.Add(propertyList[i].Name)elsepList.Add(propertyList[i].Name);end;pList.Sort;eList.Sort;{排序}FreeMem(propertyList);{释放属性数组的内存}Result:=True;end;//测试procedureTForm1.Button1Click(Sender:TObject);varPL,EL:TStringList;beginPL:=TStringList.Create;EL:=TStringList.Create;Memo1.Clear;Memo2.Clear;GetPropertyAndEventList(Self,PL,EL);{调用函数,第一个参数是对象名}Memo1.Lines:=PL;Memo2.Lines:=EL;PL.Free;EL.Free;end;end.",2014/6/20
684,关于正则表达式TPerlRegEx的使用方法,孙传金,http://180.168.156.212:2262/wecenter/?/article/8597,"//查找是否存在varreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='CodeGearDelphi2007forWin32';reg.RegEx:='\d';ifreg.MatchthenShowMessage('找到了')elseShowMessage('没找到');FreeAndNil(reg);end;--------------------------------------------------------------------------------//查找是否存在(方法2)varreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='CodeGearDelphi2007forWin32';reg.RegEx:='\d';reg.Match;//执行查找ifreg.FoundMatchthen//布尔变量FoundMatch会告诉我们查找有没有结果ShowMessage('找到了')elseShowMessage('没找到');FreeAndNil(reg);end;--------------------------------------------------------------------------------//显示找到的第一个varreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='CodeGearDelphi2007forWin32';reg.RegEx:='\d';ifreg.MatchthenShowMessage(reg.MatchedExpression)//2elseShowMessage('没找到');FreeAndNil(reg);end;--------------------------------------------------------------------------------//分别显示找到的每一个和总数varreg:TPerlRegEx;num:Integer;//用num来计数beginreg:=TPerlRegEx.Create(nil);reg.Subject:='CodeGearDelphi2007forWin32';reg.RegEx:='\d';num:=0;whilereg.MatchAgaindo//MatchAgain是下一个beginShowMessage(reg.MatchedExpression);//将分别显示:200732Inc(num);end;ShowMessage(IntToStr(num));//6FreeAndNil(reg);end;--------------------------------------------------------------------------------//分别显示找到的每一个和总数(另一种写法)varreg:TPerlRegEx;num:Integer;//用num来计数beginreg:=TPerlRegEx.Create(nil);reg.Subject:='CodeGearDelphi2007forWin32';reg.RegEx:='\d';num:=0;ifreg.MatchthenbeginrepeatShowMessage(reg.MatchedExpression);//将分别显示:200732Inc(num);until(notreg.MatchAgain);end;ShowMessage(IntToStr(num));//6FreeAndNil(reg);end;--------------------------------------------------------------------------------//目标字符串的位置与长度varreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='CodeGearDelphi2007forWin32';reg.RegEx:='Delphi';whilereg.MatchAgaindo//很明显:本例只能找到一个结果beginShowMessage(reg.MatchedExpression);//找到的字符串:2007ShowMessage(IntToStr(reg.MatchedExpressionOffset));//它所在的位置:10ShowMessage(IntToStr(reg.MatchedExpressionLength));//它的长度:6end;FreeAndNil(reg);end;//MatchedExpression与SubExpressions[0]varreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='CodeGearDelphi2007';reg.RegEx:='Delphi';whilereg.MatchAgaindobeginShowMessage(reg.MatchedExpression);//Delphi;这是匹配到的内容ShowMessage(reg.SubExpressions[0]);//Delphi;也可以这样显示匹配到的内容end;{SubExpressions是一个数组:SubExpressions[1]储存第1个表达式匹配的内容;SubExpressions[2]储存第2个表达式匹配的内容;SubExpressions[n]储存第n个表达式匹配的内容;SubExpressions[0]储存整个表达式匹配的内容;MatchedExpression表示的不过是SubExpressions[0].}FreeAndNil(reg);end;--------------------------------------------------------------------------------//提取子表达式匹配到的内容varreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='abcA1111BB222CCC33DDDD4';reg.RegEx:='\b([A-D]+)([1-4]+)\b';//这个表达式有两个子表达式构成whilereg.MatchAgaindobeginShowMessage(reg.SubExpressions[0]);//将分别显示:A1111BB222CCC33DDDD4ShowMessage(reg.SubExpressions[1]);//将分别显示:ABBCCCDDDDShowMessage(reg.SubExpressions[2]);//将分别显示:1111222334{另外:reg.SubExpressionCount是子表达式的个数;reg.SubExpressionLengths[n]是第n个表达式返回的字符串的长度;reg.SubExpressionOffsets[n]是第n个表达式返回的字符串在源字符串中的位置}end;FreeAndNil(reg);end;--------------------------------------------------------------------------------//子表达式不能超过MAX_SUBEXPRESSIONS=99个,MAX_SUBEXPRESSIONS是TPerlRegEx的内置常数.--------------------------------------------------------------------------------//设定搜索范围:Start、Stopvarreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='ababab';reg.RegEx:='ab';reg.Replacement:='◆';reg.Start:=1;reg.Stop:=2;whilereg.MatchAgaindobeginreg.Replace;end;ShowMessage(reg.Subject);//返回:◆ababreg.Subject:='ababab';reg.Start:=3;reg.Stop:=4;whilereg.MatchAgaindobeginreg.Replace;end;ShowMessage(reg.Subject);//返回:ab◆abreg.Subject:='ababab';reg.Start:=5;reg.Stop:=6;whilereg.MatchAgaindobeginreg.Replace;end;ShowMessage(reg.Subject);//返回:abab◆FreeAndNil(reg);end;//Replacevarreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.RegEx:='ab';reg.Replacement:='◆';reg.Subject:='ababab';reg.ReplaceAll;ShowMessage(reg.Subject);//返回:◆◆◆reg.Subject:='ababab';//下面四行程序,相当于reg.ReplaceAll;whilereg.MatchAgaindobeginreg.Replace;end;ShowMessage(reg.Subject);//返回:◆◆◆FreeAndNil(reg);end;{ReplaceAll函数返回的是Boolean;Replace函数返回的是Replacement的值,当然是不能赋值的,它仅仅是返回值.}//Compile、Studyvarreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.RegEx:='ab';reg.Options:=[preCaseLess];reg.Compile;{编译表达式}reg.Study;{Study方法会检查是否编译,如果没有编译则执行Compile}reg.Replacement:='◆';reg.Subject:='abAbaB';reg.ReplaceAll;ShowMessage(reg.Subject);{返回:◆◆◆}FreeAndNil(reg);end;{编译表达式,会加快执行速度、降低启动速度;如果表达式比较复杂而又多次执行,应该先编译;编译内容包括表达式选项.}//EscapeRegExChars函数可以自动为特殊字符加转义符号\varreg:TPerlRegEx;beginreg:=TPerlRegEx.Create(nil);reg.Subject:='C++Builer';reg.RegEx:=reg.EscapeRegExChars('C+')+'{2}';{相当于'C\+{2}'}reg.Replacement:='◆';reg.ReplaceAll;ShowMessage(reg.Subject);{返回:◆Builer}FreeAndNil(reg);end;//字符串分割:Splitvarreg:TPerlRegEx;List:TStrings;beginList:=TStringList.Create;reg:=TPerlRegEx.Create(nil);reg.Subject:='aaa,bbb,ccc,ddd';reg.RegEx:=',';{这里可是运行相当复杂的分割符啊}reg.Split(List,MaxInt);{第一个参数读入的是Subject;第二个参数是分成多少份}{输入一个最大整数,表示能分多少就分多少}ShowMessage(List.Text);{返回:aaabbbcccddd}FreeAndNil(reg);List.Free;end;",2014/6/20
685,XE系列的IDE把OCX、DLL文件导入成控,张守伟,http://180.168.156.212:2262/wecenter/?/article/8596,XE系列的IDE把OCX、DLL文件导入成控我们都知道，把一个OCX或DLL注册后，在Delphi7导入已注册的类型库后，默认会生成对应的控件。而在XE2中导入已注册的类型库，默认不会生成对应的控件，这是我们把格式转换工具升级到XE2时所遇到的问题，编译不通过，报控件对应的类型不存在。经过一翻摸索，最终找到了原因，在XE2中导入类型库，当到如下图这个界面时，XE2默认是不选择生成组件的，如图红框圈住的地方：这时，我们要在PalettePage下拉框里选择一个面板，比如这里选择的是Active，此时GenerateComponentWrappers复框就会自动选中（如果我们是先选中GenerateComponentWrappers复选框的，那么PalettePage也会自动选择一个面板）。如下图：这样导入已注册的类型库就会生成对应的控件了。1.jpg2.jpg,2014/6/20
686,汪洋：中国将建立食品安全红黑名单制度,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8598,2014年全国食品安全宣传周（6.10~6.22）正在如火如荼的进行之中，开幕式上，国务院副总理汪洋表示，将在全国建立食品安全红、黑名单制度。汪洋说，要加快食品安全诚信体系建设，建立食品安全红、黑名单制度，形成守信者受益、失信者受损的激励约束机制。让不讲诚信者付出高昂的经济和声誉代价。“政府作为食品安全的主导力量，要用法律制度引导企业公平竞争，为尚德守法的食品企业提供广阔的发展空间。”汪洋部署，今年要完善食品安全信息公开制度，让消费者自主选择安全食品，实现食品安全行业的优胜劣汰。2013年上海市食品安全状况.pdf,2014/6/17
687,2014年上海市计算机技术及应用专业高级专业技术职务任职资格申报评审工作的通知,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8595,"关于开展2014年度上海市工程系列计算机技术及应用专业高级专业技术职务任职资格申报评审工作的通知发布日期:2014-06-03本市各企、事业单位：经上海市人力资源和社会保障局同意，现将2014年度上海市工程系列计算机技术及应用专业高级专业技术职务任职资格申报评审工作有关事宜通知如下：一、评审机构经上海市人力资源和社会保障局批准组建的上海市工程系列计算机技术及应用专业高级专业技术职务任职资格评审委员会(以下简称高评委)，负责本市工程系列计算机技术及应用专业高级专业技术职务任职资格的申报和评审工作。高评委挂靠长江计算机(集团)公司。二、申报范围㈠、在本市企、事业单位中，已经取得大学本科及以上（属于工学或理学类）计算机或与计算机相关专业学历，担任计算机研发、制造、维护、应用、技术服务和技术管理等工作，在计算机技术及应用专业技术岗位上工作的工程技术人员。计算机专业技术岗位可分为技术研发、生产制造、系统维护、系统集成、信息安全、应用技术、网络工程、物联网技术、互联网技术、数字媒体技术等。㈡、申报对象必须是本市户籍人员。外省市户籍在沪工作的在职专业技术人员申报，须符合国家和本市的相关申报规定，取得《上海市居住证》满一年以上，且在有效期内。㈢、当年已达到退休年龄者，不受理申报(按国家规定已办理延长退休手续的除外)。㈣、上一年度评审未通过人员的申报，须在本年度取得以下突出业绩和重大贡献之一，否则当年不予受理。1、取得国家级及省部级科技进步奖、自然科学奖、技术发明奖主要贡献者，具有个人证书；2、作为项目负责人完成了省部级以上重点攻关项目、产学研项目，或者作为项目负责人通过上海市高新技术成果转化A级认定的项目，须提交立项、项目完成及相关证明材料。3、独立撰写并公开出版专著。㈤、按市人力资源和社会保障局有关规定，事业单位应根据本单位专业技术岗位设置情况，按岗位缺额进行推荐申报，申报人员须提供事业单位推荐证明。三、申报条件㈠、政治条件热爱祖国，遵纪守法，具有良好的职业道德，热爱本职工作，积极为我国社会主义现代化建设事业服务。㈡、学历、资历条件1、具备《工程技术人员职务试行条例》所规定的高级工程师学历、资历条件，即获得博士学位后，取得工程师任职资格并受聘工程师专业技术职务二年以上；大学本科毕业及以上学历，取得工程师任职资格并受聘工程师专业技术职务五年以上(专业工作年限截止到2014年12月31日)。对取得全国计算机技术与软件专业技术资格（水平）考试中级资格的专业技术人员，学历、专业工作年限符合高级工程师申报条件，可申报工程系列计算机技术及应用专业高级技术职务任职资格。2、对仅具有理工类相关专业大专学历的申报人，须在评聘工程师职务后获得以下奖项或成果之一：⑴、取得国家级及省部级科技进步奖、自然科学奖、技术发明奖主要贡献者，具有个人证书；⑵、经本市人才工作部门确认的领军人才培养对象。⑶、享受国务院政府特殊津贴者。⑷、具有两项（含）以上已获授权并有效应用的本专业较高技术水平发明专利的主要发明人（前三位）。可以破格申报评审。3、已取得其他相关系列高级专业技术职务后，因工作需要转到计算机技术及应用专业技术岗位工作一年及以上，并经考核能履行现岗位职责，可转评工程系列计算机技术及应用专业高级专业技术职务任职资格。4、先评、聘工程师职务，后通过成人教育取得本科及以上学历的工程技术人员申报高级工程师，在取得学历后任工程师职务，不得少于两年。其中，取得的成人教育本科学历为非理工科的须参加专业学科组答辩。㈢、年度业绩考核近三年业绩考核合格及以上。㈣、职称外语、计算机考试1、根据原上海市人事局(沪人【2007】54号)《关于贯彻落实人事部〈关于完善职称外语考试有关问题的通知〉的通知》，申报人按要求通过“全国职称外语等级考试”，考试类别和等级为理工类A级（2012年之后应选择理工类A级考试）。2、根据原上海市人事局(沪人【2008】26号)《关于完善专业技术人员计算机应用能力考试有关问题的通知》文件要求，申报人按要求通过“全国专业技术人员计算机应用能力考试”，考试类别按有关规定选择模块。3、回国留学人员，取得博士学位的人员以及原有中级职称的访问学者的职称外语和职称计算机应用能力考试等有关问题，按市人力资源和社会保障局有关规定执行。4、“全国职称外语等级考试”和“全国专业技术人员计算机应用能力考试”报名注册和考前培训的具体事项请到“上海市职业能力考试院”网站（www.spta.gov.cn“职称考试”栏目）或“上海继续工程教育协会”网站（www.sacee.org.cn“培训信息”栏目）查询。㈤、继续教育培训1、公需科目培训根据原人事部、国家知识产权局(国人厅发【2007】59号)《关于开展知识产权公需科目继续教育的通知》以及市人社局（沪人【2007】105号、沪人【2008】38号）《关于开展知识产权公需科目继续教育的通知》有关文件精神，申报人须通过“知识产权公需科目继续教育”的培训和考核，培训1天（8学时）获得2学分。根据市人社局、市科委(沪人社专【2011】399号)《关于开展创新知识公需科目继续教育的通知》文件精神，申报人须通过“创新知识公需科目继续教育”的培训和考核，培训2天（16学时）获得4学分。“知识产权”和“创新知识”培训的具体事项请到“上海继续工程教育协会”网站（www.sacee.org.cn“培训信息”栏目）查询。2、专项培训根据《关于在本市组织开展计算机与信息技术应用专业技术人员继续教育专项培训的通知》（沪经信人【2012】675号）精神，申报人员参加有关计算机与信息技术继续教育培训考核情况将作为职称评审依据之一。具体事项请上“上海市工业和信息化人才继续教育”网站（www.sheitc.gov.cn热点栏目中的“继续教育”）或“上海继续工程教育协会”网站（www.sacee.org.cn“培训信息”栏目）查询。3、其他培训申报人在担任工程师期间参加的由所在单位组织的、与本专业相关的、并有培训证书的工程技术人员继续教育培训（申报人应提供所在单位出具的培训内容和培训学时证明材料）。㈥、申报材料验证为保证评审质量，切实把好申报第一关，高评委办公室将认真核查申报材料，特别是学历证书、学位证书、资格证书、获奖证书、业绩材料的真实性。对于学历、学位材料，必要时可要求申报人提供学历、学位验证材料。四、申报评审程序㈠、网上申报2014年工程系列计算机技术及应用专业高级工程师资格申报采取网上申报和书面材料报送相结合的办法，具体如下：1、进入21世纪人才网首页（www.21cnhr.gov.cn）／公共人事服务／点击“职称专家”／点击“上海市职称服务系统”（www.12333sh.gov.cn）。申报人首次登录选择菜单栏“网上职称申报注册”／点击“高级职称申报”／在［高级职称］评委会列表栏内／点击“上海市工程系列计算机技术及应用专业高级专业技术职务任职资格评审委员会”／点击“计算机技术及应用”即可进入计算机技术及应用专业申报平台，申报人需设定用户名和密码，如实注册用户信息、填写基本资料，按照要求上传申报材料和附件。申报材料填写和附件上传完毕后点击提交，同时打印申报表。（请确认上传申报材料和附件不含病毒，否则可能导致申报材料上传不完整而影响评审）。2、申报人再次登录上海市职称服务系统，进入计算机技术及应用专业申报平台，可以直接输入用户名和密码进行登录。申报人可以继续进行申报内容的编辑和修改。3、如果申报人首次登录注册申报平台，在填写部分申报内容后，发现评委会选择发生错误而需要改变，可以在申报信息填写栏内找到并点击“申办帐号删除”，选择删除即可重新注册。申报人参加职称评审，按规定只能选择一个评委会（包括学科组）。4、申报人网上申报材料前，应根据要求整理好书面材料，由单位人事部门对申报材料进行审验并盖章后，按要求上传申报材料。5、高评委办公室及所属学科组将对申报材料进行初审，对通过初审人员分配受理号，并通知申报人递交书面材料，由申报人或申报人所在单位人事部门工作人员把申报材料报送高评委办公室。初审未通过的，通过职称服务系统告知申报人。6、申报人上传网上申报平台的申报材料内容应与申报人递交的书面申报材料内容完全一致，如果有不一致的情况发生，以申报人上传网上申报平台的申报材料为准。㈡、评审流程1、申报材料及论文鉴定。高评委办公室安排相关专家对申报者的申报材料及论文进行学术性鉴定，提出鉴定意见。2、学术能力考察为真实了解申报人员的学术水平、能力、业绩材料的真实性，继续加强申报人员的面试答辩工作，逐步扩大面试答辩人员的比例。以下申报人应参加面试答辩：⑴、凡破格申报者；⑵、低一级任职年限在6年以内(不含6年)者；⑶、转系列申报高一级资格者；⑷、近3年内(含3年)曾参加过评审但未通过者；⑸、非本专业学历者；⑹、现有专业技术职务任职资格非本市评审的申报对象；⑺、其它需要参加面试答辩者，由高评委确定。3、学科组评议。学科组专家对申报者是否达到任职条件进行评议。4、高评委评审。由高评委专家组成的执行高评委，依据《工程技术人员职务试行条例》对申报人提供的学历、资历和专业工作业绩、论文等情况，重点对参评对象专业理论水平、专业技术能力及专业工作业绩进行综合评审。5、网上公示。对高评委表决通过的人员，由高评委办公室在21世纪人才网公示20天。五、申报时间安排㈠、2014年7月1日至7月31日接受经单位推荐和通过审核的申报人网上申报，逾期申报系统将自动关闭。对未按时申报或未完成提交的申报人，不纳入今年评审受理范围。㈡、2014年8月1日至8月31日高评委办公室向申报人反馈申报材料受理凭证。对于因申报人申报材料提交不全的，由高评委办公室网上反馈通知补正，在8月31日前未按要求完成修改补充并提交的，高评委办公室不再受理审核。㈢、2014年9月1日至9月16日申报人或所在单位人事部门凭受理凭证按照书面材料上报要求，将材料送达高评委办公室。六、申报材料及要求㈠、申报人需提供的材料及要求1、表一《高级专业技术职务任职资格评定申报表》由申报人网上申报完成后，直接A4纸单面打印一式三份。2、附件一《高级工程师申报人自荐综合材料》可以A4纸双面打印3份。该材料是提供评审的主要材料，应能反映申报人的专业水平、能力和业绩以及综合方面的情况。申报人应按格式要求逐项认真填写。3、附件二《专业技术人员考核推荐表》可以A4纸双面打印3份，叠放在附件一后面一起装订。该材料由申报人所在单位的人事部门填写。4、论文是提供评审的主要材料之一，申报人至少需提供与本人工作、专业内容相关的，担任工程师期间独立撰写或者以第一作者撰写的论文二篇，一篇必须发表，另一篇自主选择是否发表。申报人提交主送论文（自主选择是否发表)一篇，可以A4纸双面打印2份。申报人至少提交其他论文(自主选择是否发表)一篇，可以A4纸双面打印1份。如提交已发表论文，除了提交电脑打印件（作为主件）外，还需附上刊载该论文的期刊封面、目录和该期刊上的论文的复印件（作为附件）。外文论文的主件是译文，附件1是论文原文，附件2是刊物复印件（网上申报上传的是扫描件）。没有译文的外文论文不予受理。送审论文均须在封面左上角注明“主送论文""或“其他论文”，已经发表的论文注明“已发表”，未发表的论文注明“未发表”，列出论文标题，作者单位和作者，并盖上单位人事部门章。“其他论文”有多篇的，应编顺序号。5、申报人提交的各类证书复印件须加盖本单位公章或人事部门章，作为单位通过材料审核的依据。申报人应提供下列材料：⑴、高中教育和完整的高等教育《学历证书》和《学位证书》复印件各1份，上传资料为扫描件。⑵、《中级专业技术职务任职资格证书》（包含通过考试取得中级及以上《计算机技术与软件专业技术资格(水平)证书》）复印件1份，上传资料为扫描件。硕士研究生及以上学历，没有取得资格证书的申报人无需提交。⑶、表二《专业技术职务聘任表》。从个人档案中复印的，提供复印件各1份，上传提交扫描件；新填写的提供原件各1份，上传提交扫描件。聘任表是体现申报人聘任中级或以上专业技术职务的全部聘任经历，按聘任单位和受聘的中、高级职务分页提交。《专业技术职务聘任表》可在21世纪人才网首页/公共人事服务/表格下载栏内下载。申报人获得用人单位发放的专业技术职务聘任证书的，其复印件和扫描件与聘任表等效。⑷、《职称外语等级考试合格证书》或《成绩合格通知单》复印件1份，上传提交扫描件。⑸、《职称计算机考试合格证书》复印件1份，上传提交扫描件。⑹、《继续教育培训合格证书》复印件各1份，上传提交扫描件。⑺、专业技术成果、获奖证书或其它重要业绩方面的证明材料复印件各1份，上传提交扫描件。上述⑴至⑺项书面材料，须按次序装订成1册。⑻、《居民身份证》正反面复印件1份，上传提交扫描件。⑼、非沪籍申报人需要提交《上海市居住证》复印件及副联或有效期证明复印件，以及由所在单位出具的，由养老保险单位提供的，申报人最近六个月以上交纳上海市养老保险金的证明材料复印件等各1份，上传提交扫描件。⑽、当年已达到退休年龄者按国家规定已办理延长退休手续的，须提供延长退休审批表复印件，上传提交扫描件。⑾、附件三《高级工程师申报人情况表》打印1份，原件直接上传。⑿、附件四《申报人诚信承诺书》打印1份，上传提交扫描件。⒀、事业单位申报人必须提交附件五《事业单位推荐证明》打印1份，上传提交扫描件。以上⑻至⒀项书面材料，须按次序装订成1册。⒁、附件六《申报工程师递交材料目录》不用上传，申报人仅填写姓名、单位和联系方式，并按要求打印一份随申报材料一起提交，用于提交申报材料时的核对和材料袋的封面。申报人还需提供以下材料：⒂、本人近期二寸证件照一张。照片反面写上单位名称及本人姓名装入小信封内。㈡、对申报人所在单位的要求1、对申报人的表一《高级专业技术职务任职资格评定申报表》所填写内容和各类证书、证明材料进行核实，在“业绩、论文、论著等情况核实意见”栏和“学历、经历等情况核实意见”栏内，按要求填写经认真审核后的核实意见。在规定的地方盖上公章和负责人章，以及骑缝章。2、实事求是，认真填写好附件二《专业技术人员考核推荐表》,盖单位章并叠放在附件一《高级工程师申报人自荐综合材料》后面一起装订3份。3、对申报人提供的各类证书材料，经核对无误后在复印件上盖人事部门章，完成审核，证书原件退还本人。4、对申报人提供的各类申报材料（附件一《高级工程师申报人自荐综合材料》、论文等）逐一核实后，在首页上加盖人事部门章，完成审核。七、评审费用评审费用：900元人民币／每人(含评审费、论文评定费等，不含制证费)，费用在递交材料时一并交付。八、其他事项㈠、受理单位上海市工程系列计算机技术及应用专业高评委办公室㈡、申报材料受理时间2014年9月1日至16日（工作日受理）上午9:30至下午4:00，逾期不予受理。㈢、受理方式由申报人或申报人所在单位人事部门工作人员前来递交材料。㈣、受理要求高评委办公室工作人员根据评审工作对材料的要求，应仔细核对申报材料，填好附件六《申报工程师递交材料目录》，并黏贴在材料袋上。㈤、受理地点静安区西康路638号-3(昌平路口，上海市计算机行业协会内)㈥、受理人员联系人：刘容手机：18602141262E--mail：rongliu1@139.com电话：52133193传真：52137153特此通知。上海市工程系列计算机技术及应用专业高级专业技术职务任职资格评审委员会二〇一四年五月二十六日附件：附件一：《高级工程师申报人自荐综合材料》附件二：《单位对申报人的评价意见》附件三：《高级工程师申报人情况表》附件四：《申报人诚信承诺书》附件五：《事业单位推荐证明》附件六：《申报高级工程师递交材料目录》附件七：《部分申报材料打印格式要求》附件下载地址： /s/1mg5bUgo",2014/6/13
688,2014年计算机专业中级专业技术职务任职资格申报评审工作的通知,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8594,"长江计算机（集团）公司长江计职改办(2014)001号--------------------------------------------------------------------------------关于开展2014年度上海市工程系列计算机专业中级专业技术职务任职资格申报评审工作的通知本市各企、事业单位：经上海市人力资源和社会保障局同意，现将2014年度上海市工程系列计算机专业中级专业技术职务任职资格申报评审工作有关事宜通知如下：一、评审机构经上海市人力资源和社会保障局备案的上海市工程系列计算机专业中级专业技术职务任职资格评审委员会（以下简称中评委），负责本市工程系列计算机专业中级专业技术职务任职资格的申报和评审工作。长江计算机(集团)公司负责中评委的组建工作。二、申报范围㈠、在本市企、事业单位中，已经取得大学专科及以上（属于工学或理学类）计算机或与计算机相关专业学历，担任计算机研发、制造、维护、应用、技术服务和技术管理等工作，在计算机专业技术岗位上工作的工程技术人员。计算机专业技术岗位可分为技术研发、生产制造、系统维护、系统集成、信息安全、应用技术、网络工程、物联网技术、互联网技术、数字媒体技术等。㈡、申报对象必须是本市户籍人员。外省市户籍在沪工作的在职专业技术人员申报，须符合国家和本市的相关申报规定，取得《上海市居住证》满一年以上，且在有效期内的。㈢、当年已达到退休年龄者，不受理申报（按国家规定已办理延长退休手续的除外）。㈣、上一年度评审未通过人员的申报，须在本年度取得以下突出业绩和重大贡献之一，否则当年不予受理。1、取得国家级及省部级科技进步奖、自然科学奖、技术发明奖主要贡献者，具有个人证书；2、作为项目负责人完成了省部级以上重点攻关项目、产学研项目，或者作为项目负责人通过上海市高新技术成果转化A级认定的项目，须提交立项、项目完成及相关证明材料。3、独立撰写并公开出版专著。㈤、按市人力资源和社会保障局有关规定，事业单位应根据本单位专业技术岗位设置情况，按岗位缺额进行推荐申报，申报人员须提供事业单位推荐证明。三、申报条件㈠、政治条件热爱祖国，遵纪守法，具有良好的职业道德，热爱本职工作，积极为我国社会主义现代化建设事业服务。㈡、学历、资历条件1、具备《工程技术人员职务试行条例》所规定的工程师学历、资历条件，即获得硕士研究生学历或取得第二学士学位，受聘助理工程师工作二年以上；大学专科、本科毕业，取得助理工程师任职资格并受聘助理工程师职务四年以上(专业工作年限截止到2014年12月31日)。2、对已评聘其他相关系列中级专业技术职务后，因工作需要转到计算机专业技术岗位工作一年以上，并经考核能履行现岗位职责，可申报转评计算机专业中级专业技术职务任职资格。3、对于先评聘助理工程师职务，后通过成人教育取得大专以上学历的工程技术人员，在取得学历后任助理工程师职务不得少于两年。其中，取得的成人教育学历为非理工科的须参加专业学科组答辩。㈢、年度业绩考核近三年业绩考核合格及以上。㈣、职称考试1、严格按原上海市人事局(沪人[2007]54号)《关于贯彻落实人事部〈关于完善职称外语考试有关问题的通知〉的通知》，申报人已按要求通过“全国职称外语等级考试”，考试类别和等级为理工类B级（2012年之后应选择理工类B级考试）。2、根据原上海市人事局(沪人[2008]26号)《关于完善专业技术人员计算机应用能力考试有关问题的通知》文件要求，申报人已按要求通过“全国专业技术人员计算机应用能力考试”，考试类别按有关规定选择模块。3、回国留学人员的职称外语和职称计算机应用能力考试等有关其问题，严格按市人力资源和社会保障局有关规定执行。4、“全国职称外语等级考试”和“全国专业技术人员计算机应用能力考试”报名注册和考前培训的具体事项请到“上海市职业能力考试院”网站或“上海继续工程教育协会”网站查询。㈤、继续教育培训继续教育培训有三项内容：公需科目培训、专项培训和其他培训。申报人需要完成继续教育培训总分达到20学分或以上，才能符合申报要求。公需科目是必须培训项目，专项培训和其他培训是选择培训项目。1、公需科目培训根据原人事部、国家知识产权局(国人厅发[2007]59号)《关于开展知识产权公需科目继续教育的通知》以及市人社局（沪人[2007]105号、沪人[2008]38号）《关于开展知识产权公需科目继续教育的通知》有关文件精神，申报人需通过“知识产权公需科目继续教育”的培训和考核，培训1天（8学时）获得2学分。根据市人社局、市科委(沪人社专[2011]399号)《关于开展创新知识公需科目继续教育的通知》文件精神，申报人需通过“创新知识公需科目继续教育”的培训和考核，培训1天（8学时）获得2学分。“知识产权”和“创新知识”培训的具体事项请到“上海继续工程教育协会”网站查询。2、专项培训根据市经信委、市人社局（沪经信人[2012]675号）《关于在本市组织开展计算机与信息技术应用专业技术人员继续教育专项培训的通知》文件精神，申报人需参加有关“计算机与信息技术继续教育专项培训”考核情况作为职称申报依据之一。共五个科目，申报人选择培训科目，一个科目培训2天（16学时）获得4学分。具体事项请到“上海市工业和信息化人才继续教育”网站查询。3、其他培训申报人在担任助理工程师期间参加的由所在单位组织的、与本专业相关的、并有培训证书的工程技术人员继续教育培训（申报人应提供所在单位出具的培训内容和培训学时证明材料）。㈥、申报材料验证为保证评审质量，切实把好申报第一关，中评委办公室将认真核查申报材料，特别是学历证书、学位证书、资格证书、获奖证书、业绩材料的真实性。对于学历、学位材料，必要时可要求申报人提供学历、学位验证材料。四、申报评审程序㈠、申报1、2014年工程系列计算机专业工程师申报采用书面材料直接报送的办法。2、申报人申报材料前应根据要求整理好书面材料，由单位人事部门对材料进行审验并盖章。然后制作成电子申报材料，由申报人或申报人所在单位人事部门工作人员把书面申报材料和电子申报材料报送材料受理点或中评委办公室。3、中评委办公室及所属学科组将对申报材料进行初审，通过材料初审的申报人员进入评审流程。初审未通过的，中评委办公室通过材料受理点或直接告知申报人。4、申报人应报送与书面材料内容完全一致的电子申报材料，可以通过光盘或其他储存器件、电子邮件等报送。如果有不一致的情况发生，以申报人报送的电子申报材料内容为准。㈡、评审流程1、申报材料及论文鉴定。中评委办公室安排相关专家对申报者的申报材料及论文进行学术性鉴定，提出鉴定意见。2、学术能力考察为真实了解申报人员的学术水平、能力、业绩材料的真实性，继续加强申报人员的面试答辩工作，逐步扩大面试答辩人员的比例。以下申报人应参加面试答辩：⑴、凡破格申报者；⑵、低一级任职年限在5年以内(不含5年)者；⑶、近3年内(含3年)曾参加过评审但未通过者；⑷、非本专业学历者；⑸、其它需要参加面试答辩者，由中评委确定。3、学科组评议。学科组专家对申报者是否达到任职条件进行评议。4、中评委评审。由中评委专家组成的执行中评委，依据《工程技术人员职务试行条例》对申报人提供的学历、资历和专业工作业绩、论文等情况，重点对参评对象专业理论水平、专业技术能力及专业工作业绩进行综合评审。5、网上公示。对中评委表决通过的人员，由中评委办公室在21世纪人才网公示20天。五、申报时间安排㈠、2014年8月1日至8月31日接受经单位推荐和通过审核的申报人及所在单位向材料受理点或中评委办公室提交书面申报材料（包括电子申报材料）。对未按时申报或未完成材料提交的申报人，不纳入今年评审受理范围。㈡、2014年9月1日至9月30日中评委办公室向申报人反馈材料受理情况。对于因申报人材料提交不完整、材料有误的，由中评委办公室反馈通知补正，在9月30日前申报人未按要求完成修改补充并提交申报材料的，中评委办公室不再受理审核。六、申报材料及要求㈠、申报人需提供的材料及要求1、表一《中级专业技术职务任职资格评定申报表》必须A4纸单面打印3份。在21世纪人才网首页/公共人事服务/表格下载栏内下载。2、附件一《工程师申报人自荐综合材料》可以A4纸双面打印12份。该材料是申报人提供评审的主要材料，应能反映申报人的专业水平、能力和业绩以及综合方面的情况。申报人应按格式要求逐项认真填写。3、附件二《专业技术人员考核推荐表》可以A4纸双面打印12份，叠放在附件一后面一起装订。该材料由申报人所在单位的人事部门填写。4、论文是提供评审的主要材料之一，申报人需提供与本人工作、专业内容相关的，担任助理工程师期间撰写的论文至少一篇，作为主送论文(不论是否发表)，双面打印2份。如已发表，除了提供电脑打印件（作为主件）外，还需附上刊载该论文的期刊封面、目录和该期刊上的论文的复印件（作为附件）。如有多篇论文，除了选择一篇作为主送论文外，剩余的可以作为“其他论文”送审，其他论文(不论是否发表)可选择提交，如提交，则各打印1份，装订要求与主送论文相同。外文论文的主件是译文，附件1是论文原文，附件2是刊物复印件，没有译文的外文论文不予受理。送审论文均须在封面左上角注明“主送论文""或“其他论文”，已经发表的论文注明“已发表”，未发表的论文注明“未发表”，列出论文标题，作者单位和作者，并盖上单位人事部门公章。“其他论文”有多篇的，应编顺序号。5、申报人提交的各类证书复印件须加盖本单位公章或人事部门章，作为单位通过材料审核的依据。申报人应提供下列材料：⑴、高中教育和完整的高等教育《学历证书》和《学位证书》复印件各1份，电子文档为扫描件。⑵、《专业技术职务任职资格证书》（包含通过考试取得初级及以上《计算机技术与软件专业技术资格(水平)证书》）复印件1份，电子文档为扫描件。没有取得资格证书的申报人无需提交。⑶、表二《专业技术职务聘任表》。从个人档案中复印的，提供复印件各1份，电子文档为扫描件；新填写的提供原件各1份，电子文档为原件。聘任表是体现申报人聘任初级级或以上专业技术职务的全部聘任经历，按聘任单位和受聘的初、中级职务分页提交。《专业技术职务聘任表》可在21世纪人才网首页/公共人事服务/表格下载栏内下载。申报人获得用人单位发放的专业技术职务聘任证书的，其复印件和扫描件与聘任表等效。⑷、《职称外语等级考试合格证书》或《职称外语成绩合格通知单》复印件1份，电子文档为扫描件。⑸、《职称计算机考试合格证书》复印件1份，电子文档为扫描件。⑹、继续教育培训合格证书复印件各1份，电子文档为扫描件。⑺、专业技术成果、获奖证书或其它重要业绩方面的证明材料复印件各1份,电子文档为扫描件。上述(1)至(7)项材料，须按次序装订成1册。⑻、《居民身份证》正反面复印件1份。⑼、非沪籍申报人须提交《上海市居住证》复印件及副联或有效期证明复印件，以及由所在单位出具的、由养老保险单位提供的、申报人最近六个月以上交纳上海市养老保险金的证明材料复印件等各1份。⑽、当年已达到退休年龄者按国家规定已办理延长退休手续的，须提供延长退休审批表复印件。⑾、附件三《工程师申报人情况表》(电子文档为原件)。⑿、附件四《申报人诚信承诺书》。⒀、事业单位申报人须提交附件五《事业单位推荐证明》。以上⑻至⒀项材料，须按次序装订成1册。⒁、附件六《申报工程师递交材料目录》（电子文档为原件），申报人仅填写姓名、单位和联系方式，并按要求打印一份随申报材料一起提交，用于提交申报材料时的核对和材料袋的封面。申报人还需提供以下材料：⒂、本人近期二寸证件照一张。照片反面写上单位名称及本人姓名装入小信封内。⒃、申报材料电子文档刻录光盘一张，内含：表一《中级专业技术职务任职资格评定申报表》（填写后直接提交）、表二《专业技术职务聘任表》（新填写的直接提交）、附件一《工程师申报人自荐综合材料》（填写后直接提交）、附件二《专业技术人员考核推荐表》（填写后直接提交）、附件三《工程师申报人情况表》（填写后直接提交）；附件六《申报工程师递交材料目录》（填写申报人姓名、单位、手机后提交），各类证书的扫描资料，以及主送论文和其他论文的扫描资料。电子文档是直接提交的无需印章，是扫描件的必须盖有印章。光盘内刻录的文件，其内容必须与提交的纸质文件内容一致，无误，保证能够读取和没有电脑病毒。(二)对申报人所在单位的要求1、对申报人的《中级专业技术职务任职资格评定申报表》(表一)所填写内容和各类证书、证明材料进行核实，在“业绩、论文、论著等情况核实意见”栏和“学历、经历等情况核实意见”栏内，按要求填写经认真审核后的核实意见。在规定的地方盖上公章和负责人章，以及骑缝章。2、实事求是，认真填写好《专业技术人员考核推荐表》(附件二),盖单位章并叠放在《工程师申报人自荐综合材料》(附件一)后面一起装订（12份）。3、对申报人提供的各类证书材料，经核对无误后在复印件上盖人事部门章，完成审核，证书原件退还本人。4、对申报人提供的各类申报材料（附件一《工程师申报人自荐综合材料》、论文等）逐一核实后，在首页上加盖人事部门章，完成审核。七、评审费用评审费用：700元人民币／每人(含评审费、论文评定费等，不含制证费)，费用在递交材料时一并交付。八、其他事项㈠、委托受理单位从2014年起为方便非公企业和社会组织的申报人和申报人所在单位提交申报材料，已委托上海市人才服务中心（梅园路77号）及区县人才服务中心代为受理上海市工程系列计算机专业中级专业技术职务任职资格申报资料（联系方式详见上海人才网）。㈡、直接受理单位上海市工程系列计算机专业中评委办公室㈢、申报材料受理时间2014年8月1日至31日（工作日受理）上午9:30至下午4:00。㈣、受理方式由申报人或申报人所在单位人事部门工作人员前来递交材料。㈤、受理要求中评委办公室工作人员根据评审工作对材料的要求，应仔细核对申报材料，填好附件六《申报工程师递交材料目录》，并黏贴在材料袋上。㈥、受理地点静安区西康路638号-3(昌平路口，上海市计算机行业协会内)㈦、受理人员联系人：刘容手机：18602141262E--mail：rongliu1@139.com电话：52133193传真：52137153特此通知。长江计算机(集团)公司职改办二〇一四年五月：附件一：《工程师申报人自荐综合材料》附件二：《专业技术人员考核推荐表》附件三：《工程师申报人情况表》附件四：《申报人诚信承诺书》附件五：《事业单位推荐证明》附件六：《申报工程师递交材料目录》附件七：《部分申报材料打印格式要求》附件下载地址： /s/1nt2Yas5",2014/6/13
689,你知道客户想要什么么？,张元利,http://180.168.156.212:2262/wecenter/?/article/8593,所有客户想要同样的12件东西，不管他们是谁，不管谁在向他们推销或者他们在买些什么：1：他们希望感觉自己很重要。2：他们希望被赞赏。3：他们希望你停止谈论你自己。4：他们希望你停止谈论你的公司。5：他们希望你真诚的聆听。6：他们希望被理解。7：他们想教给你一些东西。8：他们希望和需要你的帮助。9：他们想要买些东西。10：他们希望你使他们高兴和有意外之喜。11：他们想假装他们作出合乎逻辑的决定。12：他们渴望成功和幸福。几乎都是如此。当你面对客户时，请记住这12件事情，将不断会有人要求你和他们做生意。现在，这里是好的一方面。将以上内容手写在百事贴上，然后粘在你的办公桌上，让这份清单出现在你眼前会不断提醒你，你的客户希望你如何做。,2014/6/13
690,2014年第2届计算机职称考试报名时间,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8592,2014年第2次职称计算机考试报名开始了。计划申报职称的同事，请及时报名。 ,2014/6/13
691,图片相似度比对（不是检索）升级版（64位）,王健敏,http://180.168.156.212:2262/wecenter/?/article/8591,之前使用Lire做的图片相似度比对效果比较差，所以网上找了点资料，用opencv做了个C++的例子，使用下来效果比Lire好一些。注：需要安装vc2012运行环境&目前只编译了64位的release版本。附件包含：1、Compare.exe：主程序使用方法：cmd里输入Comparex.jpgy.jpg注：一定要2个参数，如果直接双击运行或缺少参数，程序会报错2、compare.cpp：程序源码3、vcredist_x64.exe：vc2012运行环境鸣谢@罗小辉给予的灵感图片相似度比对.zip,2014/6/12
692,更新数据库中序号字段值的几种方法比较！,陈军志,http://180.168.156.212:2262/wecenter/?/article/8587,"在一些特定的业务流程中，经常会涉及到更新表中序号字段的值，以下就是按条件更新v_file_full表中序号字段：file_item_number的值的几种方法：1、SQL语句第一种写法：updatev_file_fullsetfile_item_number=(selectnumfrom(select(selectcount(1)fromv_file_fullwherefonds_id=t.fonds_idandcatalogue_id=t.catalogue_idandyear_code=2014andid<=t.id)asnum,idfromv_file_fulltwhere1=1andyear_code=2014)awherev_file_full.id=a.id)where1=1andyear_code=2014orderbyida)受影响的行:1时间:0.035sb)受影响的行:503时间:10.339s，c)受影响的行:640时间:16.679s，16.796s，16.756s2、SQL语句第二种写法：set@r=0;updatev_file_fullsetfile_item_number=(selectnumfrom(select(@r:=@r+1)asnum,idfromv_file_fulltwhere1=1andyear_code=2014)awherev_file_full.id=a.id)where1=1andyear_code=2014orderbyida)受影响的行:1时间:0.027sb)受影响的行:503时间:0.159sc)受影响的行:640时间:0.194s，0.195s，0.183s3、程序配合SQL语句使用，将需要更新的条目拼成一批SQL语句，一次执行，这里采用复制同一条数据的方式进行测试对比updatev_file_fullsetfile_item_number=1whereid='20140507110208578';1条该语句执行时间为:0.003s503条该语句执行时间为：0.758s640条该语句执行时间为：0.897s，0.948,0.909以上测试结果为MySql中执行，当条目数量很少时，差异不大，当数量不断增大时，第一种方法时间已经无法忍受，第二种方法和第三种方法在可接受范围，但是第二种方法明显比第三种方式快。以后在类似更新行号或者序号时，推荐采用第二种方式。",2014/6/5
693,利用WM_COPYDATA消息实现程序间的数据传递,许海宝,http://180.168.156.212:2262/wecenter/?/article/8586,"文件操作在实际应用中,我们经常需要多个程序相互配合来完成某些特定功能,这就需要利用数据传递来实现,利用WM_COPYDATA消息可以方便的解决这类问题。使用该消息涉及一个TcopyDataStruct结构类型的指针。该结构中有三个成员:dwData是一个32位的附加参数cbData表示要传递的数据区的大小lpData表示要传递的数据区的指针下面举例说明。该例子由两个程序构成,分别为SendData和GetData。SendData程序向GetData程序发送消息,并传递edit1中的字符串;GetData在收到消息后,把SendData发送的字符串接受下来,并显示在相应的edit1中。SendData程序:……varForm1:TForm1;implementation{$R*.DFM}procedureTForm1.Button1Click(Sender:TObject);vards:TCopyDataStruct;hd:THandle;beginds.cbData:=Length(Edit1.Text)+1;GetMem(ds.lpData,ds.cbData);//为传递的数据区分配内存StrCopy(ds.lpData,PChar(Edit1.Text));Hd:=FindWindow(nil,'Form2');//获得接受窗口的句柄ifHd<>0thenSendMessage(Hd,WM_COPYDATA,Handle,Cardinal(@ds))//发送WM_COPYDATA消息elseShowMessage('目标窗口没找到！');FreeMem(ds.lpData);//释放资源end;GetData程序:TForm2=class(TForm)Edit1:TEdit;private{Privatedeclarations}publicprocedureMymessage(vart:TWmCopyData);messageWM_COPYDATA;{Publicdeclarations}end;varForm2:TForm2;implementationprocedureTForm2.Mymessage(vart:TWmCopyData);beginEdit1.text:=StrPas(t.CopyDataStruct.lpData);//接受数据并显示。end;",2014/6/5
694,Delphi7项目到XE3迁移注意事项,张守伟,http://180.168.156.212:2262/wecenter/?/article/8585,"Delphi7项目到XE3迁移注意事项增经历过把Delphi7成功升级到了Delphi2010，升级过程中很艰辛，现在又遇到要把Delphi7直接升级到XE3，经过研究和之前的经验总结了一下与大家分享。1、PChar在XE3中PChar已经不再表示PAnsiChar而是表示PWideChar。考虑如下代码：varP:PChar;Buffer:Pointer;beginGetMem(Buffer,255);P:=Buffer;p^:=#1;Inc(P);p^:=#2;FreeMem(Buffer,255);end;如果依然这样写，运行时很可能会得到一个内存访问错误。因为每次Inc(P)，实际上指针向前移动了2字节，因为SizeOf(WideChar)=2，Inc(P)相当于P:=P+SizeOf(WideChar)。解决方法是把PChar替换成PAnsiChar2、MoveFillCharCopyMemory这些函数依赖的是字节长度，往往我们直接使用Length(Str)来获取，这在XE3下是行不通的。考虑如下代码：varP1,P2:String;beginP1:='test';SetLength(P2,Length(P1));Move(P1[1],P2[1],Length(P1));在XE3中String默认映射到UnicodeString，单个字符是2字节，所以上面的P1实际占用了8字节内存，而传给Move函数的长度只有4字节，最终结果是P2=""te""。解决办法1：修改String为AnsiString，该方案虽然可行，但你的程序就享受不到Unicode待遇了。解决办法2：SetLength函数不要修改，因为他的长度参数是字符长度，而不是字节长度。Move函数的最后一个参数Length(P1)修改成Length(P1)*SizeOf(Char)。3、Keyin['a'..'z','B','C']这类代码最好替换成CharInSet(Key,['a'..'z','B','C'])不然会当作AnsiChar处理。4、WideString代码中的所有WideString都考虑替换成String，现在WideString只是为了与COM兼容而存在，且没有引用计数，性能低下。5、引用AnsiStrings单元如果有必要使用AnsiLowerCaseAnsiCompareStr之类的函数，一定要引用AnsiStrings单元。如果不引用该单元，即便编译不报错，你实际上是用的还是Unicode版本的函数，会有隐式的转化。打开IDE参数自动完成，编译时会看到相应的提示。6、编译期警告：[DCCWarning]Unit1.pas(31):W1057Implicitstringcastfrom'AnsiString'to'string'如果你的代码中包含了两种字符串（Unicode、Ansi）之间进行隐式转化的时候就会出现该提示。如下代码就会触发该警告：varUnicode:String;Ansi:AnsiString;beginAnsi:='test..';Unicode:=Ansi;end;把旧版本的Delphi项目升级到XE3，我通常都是借助编译警告来快速寻找需要改动的部分。通常你可以把赋值双方都声明为String(默认影射到UnicodeString)，就可以避免该警告。但如果你确定必须在此处保留Ansi并进行转化的时候，建议你显式的转化他们（例如：Unicode:=String(Ansi);），这样可以避免该警告，方便你在升级过程中继续寻找其他需要修改的地方。7、ReadlnWriteln写入文件时候要注意如果你传给Writeln一个AnsiString，那么它也会在文件中写入AnsiString，那么你读取得时候就必须传给Readln一个AnsiString的类型，否则就是乱码。8、SizeOf()与Length()FillChar(,,)如果采用#0填充，替换为*SizeOf(Char)；如果填充其它字符，替换为StringOfChar函数。范例：varCount:Integer;Buffer:array[0..255]ofChar;begin//现有代码-当string=UnicodeString(char=2字节)时，这段代码是错的Count:=Length(Buffer);FillChar(Buffer,Count,0);//正确的代码应该写作下面这样Count:=SizeOf(Buffer);Count:=Length(Buffer)*SizeOf(Char);FillChar(Buffer,Count,0);end;Length返回的是字符数，而FillChar的Count参数需要的是字节数，所以必须用SizeOf替换Length，或者使用Length*SizeOf(Char)。",2014/6/5
695,Delphi XE3开发环境升级,孙传金,http://180.168.156.212:2262/wecenter/?/article/8584,最近开发环境有Delphi7或Delphi2007升级到Unicode版本DelphiXE3，pascal语法有的部分发生了变化，甚至是变化很明显的，因此上网找了一份关于Unicode版本的语法参考手册，以便于开发过程中出现问题的时候，可以进行参考。具体语法参考手册参见《DelphiUnicode版语法手册.pdf》DelphiUnicode版语法手册.pdf,2014/6/5
696,D2007与XE3开发OCX时的差异,王孝本,http://180.168.156.212:2262/wecenter/?/article/8590,差异点D2007XE3OCX断点IE8以上手工加注册表参数：regedit→HKEY_LOCAL_MACHINE→SOFTWARE→Microsoft→InternetExplorer→Main。在Main里新建一个DWORD类型名为TabProcGrowth值为0。IE8以上手工加参数，同D2007。打开调试开关（菜单Tools--Options的debuggeroptions中）；OCX输出目录及调试参数目录中不能带空格。OCX启动时候的CreateEvent过程执行不执行OCX的ActiveForm窗体的OnCreate事件执行执行OCX退出时候的DestroyEvent过程执行执行OCX的ActiveForm窗体的OnDestroy事件不执行不执行OCX的Application.Handle为0为0,2014/6/5
697,Jfreechart使用,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8583,"JFreeChart的使用：Jfreechart是JAVA平台上的一个开放的图表绘制类库；完全是用JAVA语言编写使用步骤：1、导入jfreechart.jar包2、在web.xml中配置一、制作自定义仪表盘仪表盘涉及几个对象：表盘、刻度、指针、值//通过DefaultValueDataset设置表盘中显示的值DefaultValueDatasetdataset=newDefaultValueDataset(35.92);//定义表盘对象(表盘)DialPlotdiaplot=newDialPlot();diaplot.setDataset(dataset);//设置显示在表盘中央位置的信息（值）DialValueIndicatordialValueIndicator=newDialValueIndicator();diaplot.addLayer(dialValueIndicator);//根据表盘的直径大小(0.88)，设置总刻度范围（刻度）StandardDialScalestandardDialScale=newStandardDialScale(0.0D,100D,-157.0D,-225.0D,20,2);//参数1：刻度最小值；参数2：刻度最大值；参数3、4：刻度位置调整；参数5：设置每20数字显示一次；参数6：设置两个数字之间显示2格diaplot.addScale(0,standardDialScale);//设置指针（指针）Pointerpointer=newPointer();pointer.setFillPaint(newColor(35,161,246));//设置指针的大小粗细pointer.setWidthRadius(0.05D);//添加指针到仪表盘中央diaplot.addLayer(pointer);//实例化DialCapDialCapdialcap=newDialCap();//指针中心圆的大小dialcap.setRadius(0.1D);//添加指针中心圆到仪表盘中央//diaplot.setCap(dialcap);//生成chart对象JFreeChartjfreechart=newJFreeChart(diaplot);//设置仪表盘背景图片jfreechart.setBackgroundImage(image);//生成的图片名Stringfilename=ServletUtilities.saveChartAsPNG(jfreechart,163,163,request.getSession());//图片路径StringraphURL=request.getContextPath()+""/DisplayChart?filename=""+filename二、制作区域图表JFreeChartchart=ChartFactory.createAreaChart(title,"""","""",dataset,PlotOrientation.VERTICAL,false,false,false);//参数1：图表标题，参数2：设置横坐标标题，参数3：设置纵坐标标题，参数4：值，参数5：是否需要对其说明，参数6：是否安装chart工具，参数7：是否链接//获取绘图区对象CategoryPlotplot=chart.getCategoryPlot();//设置坐标轴标尺值字体plot.getDomainAxis().setTickLabelFont(newFont(""楷体"",0,12));//设置坐标轴标尺值显示位置plot.getDomainAxis().setCategoryLabelPositions(CategoryLabelPositions.DOWN_90);//默认情况下，网格左右两边都会有空白区域，以下是设置空白区域为0plot.getDomainAxis().setLowerMargin(0D);plot.getDomainAxis().setUpperMargin(0D);//设置网格线颜色plot.setDomainGridlinePaint(newColor(85,86,94));plot.setRangeGridlinePaint(newColor(85,86,94));//设置网格背景颜色plot.setBackgroundPaint(newColor(65,66,75));//设置区域颜色透明度plot.setForegroundAlpha(0.3F);//设置显示网格plot.setDomainGridlinesVisible(true);//设置区域图中区域背景色CategoryItemRendererrenderer=plot.getRenderer(0);renderer.setSeriesPaint(0,Color.magenta)研发中心经验共享_毛璀玲[201405].doc",2014/5/29
698,函数 WaitForSingleObject,许海宝,http://180.168.156.212:2262/wecenter/?/article/8582,"当需要监控另外一个进程运行是否结束的解决方法functionWaitForSingleObject(hHandle:THandle;{要等待的对象句柄}dwMilliseconds:DWORD{等待的时间,单位是毫秒}):DWORD;stdcall;{返回值如下:}WAIT_OBJECT_0{等着了,本例中是:等的那个进程终于结束了}WAIT_TIMEOUT{等过了点(你指定的时间),也没等着}WAIT_ABANDONED{好不容易等着了,但人家还是不让咱执行;这一般是互斥对象}//WaitForSingleObject的第二个参数一般给常数值INFINITE,表示一直等下去,死等.WaitForSingleObject等待什么?在多线程里就是等待另一个线程的结束,快来执行自己的代码;不过它可以等待的对象可不止线程;这里先来一个等待另一个进程结束的例子,代码文件:unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls;typeTForm1=class(TForm)Button1:TButton;procedureButton1Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}varhProcess:THandle;{进程句柄}{等待一个指定句柄的进程什么时候结束}functionMyThreadFun(p:Pointer):DWORD;stdcall;beginifWaitForSingleObject(hProcess,INFINITE)=WAIT_OBJECT_0thenForm1.Text:=Format('进程%d已关闭',[hProcess]);Result:=0;end;{启动一个进程,并建立新线程等待它的结束}procedureTForm1.Button1Click(Sender:TObject);varpInfo:TProcessInformation;sInfo:TStartupInfo;Path:array[0..MAX_PATH-1]ofChar;ThreadID:DWORD;begin{先获取记事本的路径}GetSystemDirectory(Path,MAX_PATH);StrCat(Path,'\notepad.exe');{用CreateProcess打开记事本并获取其进程句柄,然后建立线程监视}FillChar(sInfo,SizeOf(sInfo),0);ifCreateProcess(Path,nil,nil,nil,False,0,nil,nil,sInfo,pInfo)thenbeginhProcess:=pInfo.hProcess;{获取进程句柄}Text:=Format('进程%d已启动',[hProcess]);CreateThread(nil,0,@MyThreadFun,nil,0,ThreadID);{建立线程监视}end;end;end.窗体文件:objectForm1:TForm1Left=0Top=0Caption='Form1'ClientHeight=124ClientWidth=241Color=clBtnFaceFont.Charset=DEFAULT_CHARSETFont.Color=clWindowTextFont.Height=-11Font.Name='Tahoma'Font.Style=[]OldCreateOrder=FalsePixelsPerInch=96TextHeight=13objectButton1:TButtonLeft=88Top=56Width=75Height=25Caption='Button1'TabOrder=0OnClick=Button1Clickendend",2014/5/28
699,SVN服务器迁移后--客户端SVN升级与SVN服务器ip变更问题客户端重定向等问题,方俊新,http://180.168.156.212:2262/wecenter/?/article/8581,由于目前SVN服务器采用的是新版本的visualSVN4.0.7(ApacheSubversion1.8.9)，而客户端TortoiseSVN1.7以下版本需要进行升级处理，才能正常使用客户端SVN升级与SVN服务器ip变更问题客户端重定向等问题.docx,2014/5/23
700,Delphi 使用内存块拷贝与API拷贝文件优缺点,陈军志,http://180.168.156.212:2262/wecenter/?/article/8589,"目前常用的文件拷贝方法有三种：内存块拷贝与API拷贝及文件流拷贝，因文件流拷贝方式存在问题：目前测试下来文件超过800多MB时，会出现内存溢出的BUG，故该方法不推荐使用，附件DEMO中也有该方法使用的详细代码。下面将简单分析下内存块拷贝与API拷贝的优缺点供大家参考：1、内存块拷贝优点：界面不会出现卡死无响应情况，可以实时显示出拷贝进度缺点：代码量较多，使用较复杂2、API拷贝优点：使用便捷缺点：界面会卡死无响应，无法显示拷贝进度主要代码如下：内存块拷贝procedureTForm1.Mycopyfile(sourceFileName,targetFileName:string);varsource,target:fileofbyte;buffer:array[0..4069]ofchar;numread:integer;filelength:longint;begintryShowMessage('开始复制');AssignFile(source,sourceFileName);Reset(source);AssignFile(target,targetFileName);ReWrite(target);FileLength:=filesize(source);exceptShowmessage('文件复制错误！');exit;end;withprogressbar1dobeginmin:=0;position:=min;max:=filelength;whilefilelength>0dobeginBlockRead(source,buffer[0],sizeof(buffer),numread);filelength:=filelength-numread;BlockWrite(target,buffer[0],numread);position:=position+numread;application.ProcessMessages;end;CloseFile(source);CloseFile(target);end;ShowMessage('复制完成');end;API拷贝procedureTForm1.Button1Click(Sender:TObject);beginifnotFileExists(Trim(edtsource.Text))thenbeginShowMessage('源文件不存在');Exit;end;ShowMessage('开始复制');CopyFile(PChar(Trim(edtsource.Text)),PChar(Trim(edttarget.Text)),false);ShowMessage('复制完毕');end;综上所述：当我们能确定拷贝文件比较小并且无需显示进度时，可以使用API进行拷贝，而文件大小未知或要显示进度时，尽量使用内存块的拷贝方式。DEMO.zip",2014/5/23
701,DELPHI Memo1自动循环上下滚屏,王孝本,http://180.168.156.212:2262/wecenter/?/article/8580,"DELPHIMemo1自动循环上下滚屏一、自动加垂直滚动条procedureTForm1.Memo1Change(Sender:TObject);varContentHeight:Integer;beginCanvas.Font:=Memo1.Font;//canvas是memo1控件的画布，memo1显示出的东西都是画在这上面的。ContentHeight:=Canvas.TextHeight('好');//这句是得到单独一行文字的高度，""好""字没意义，只是随便用一字来取得当前字体下，一行文字的高度，你可以换成其它字。ContentHeight:=(Memo1.Lines.Count+1)*ContentHeight;//这句话得到memo1中所有行的文字高度ifContentHeight<Memo1.Heightthen//这里下面我知道.判断是否超出memo的高度beginMemo1.ScrollBars:=ssNone;endelsebeginMemo1.ScrollBars:=ssVertical;end;end;end.==============================================================================二、发消息滚动MEMO屏幕--------------Start--------------------procedureTForm1.Timer1Timer(Sender:TObject);beginifMemo1.Perform(EM_SCROLL,SB_LINEDOWN,0)=0thenbeginMemo1.Perform(WM_VSCROLL,SB_TOP,0);endelsebeginSendMessage(Memo1.Handle,WM_VSCROLL,SB_LINEDOWN,0);end;end;--------------End-----------------------希望对做屏幕滚动的朋友,有实际的使用价值.//执行到底SendMessage(Memo1.Handle,EM_SCROLL,SB_BOTTOM,0);//一步一步往下走SendMessage(Memo1.Handle,WM_VSCROLL,SB_LINEDOWN,0);//往下走SendMessage(Memo1.Handle,EM_SCROLL,SB_PAGEDOWN,0);ifMemo1.Perform(EM_SCROLL,SB_LINEDOWN,0)=0then//下滚button2.Enable:=False;ifMemo1.Perform(EM_SCROLL,SB_LINEUP,0)=0then//上滚button1.Enable:=False;如何编程使Memo的滚动条滚到行首？发送消息：WPARAMpara=MAKELONG(SB_THUMBPOSITION,0);//将滚动条移动到0SendMessage(Memo1->Handle,WM_VSCROLL,para,0);Memo1->Perform(EM_SCROLL,SB_TOP,0);//第一行Memo1->Perform(EM_SCROLLCARET,0,0);//自动滚动到最后一行改进一下：Memo1->Lines->BeginUpdate();Memo1->Perform(WM_VSCROLL,SB_TOP,0);//先回到顶部for(inti=0;i<1500;++i)//向下滚1500行Memo1->Perform(WM_VSCROLL,SB_LINEDOWN,0);Memo1->Lines->EndUpdate();移到指定位置，发送消息吧WPARAMpara=MAKELONG(SB_THUMBPOSITION,50);//将滚动条移动到50Position//具体参数请看win32帮助有关于WM_VSCROLL的帮助//Memo1->Perform(WM_VSCROLL,para,0);//这个也行SendMessage(Memo1->Handle,WM_VSCROLL,para,0);",2014/5/23
702,DLL返回位图对象,孙传金,http://180.168.156.212:2262/wecenter/?/article/8579,"DLL直接返回对象时是有可能出错的，这是因为程序和DLL用了不同的VCL，就是相当于一个接口的不同实例，所以只要是从DLL里返回VCL相关的对象都会出错。有两种方法可以解决：1、在Controls单元的implementation前面声明一个GetControlAtom方法{...}implementationfunctionGetControlAtom:Pointer;beginResult:=@ControlAtom;end;然后在DLL里实现并导出以下两个过程procedureDLLInitialize(App:TApplication;Scr:TScreen;RealControlAtom:Integer);varx:pointer;p:^Word;beginIf(OldApp=Nil)ThenBegin//storeawaythecurrentapplication,screenandcontrolatomOldApp:=Application;OldScreen:=Screen;p:=GetControlAtom;OldControlAtom:=p^;//AssigntheEXE'sapplication,screenandcontrolatomApplication:=App;Screen:=Scr;p^:=RealControlAtom;end;end;procedureDLLFinalize;varp:^Word;begin//restoretheDLL'sapplication,screenandcontrolatomp:=GetControlAtom;p^:=OldControlAtom;Screen:=OldScreen;Application:=OldApp;end;这两个过程的作用，一个是初始化DLL时将宿主程序与DLL的全局原子ControlAtom同步，另一个是DLL释放前还原相关内容。然后你就可以在DLL里用函数返回VCL对象了，此方法也适用于在DLL里创建窗体在Dock到宿主的Panel里，反正最关键的是ControlAtom同步。2、不使用VCL对象作为返回值很简单，可以用内存来做交换，例如转换图像后，申请一块内存，将转换后的图像写入这块内存，方法就不多说了，用流操作或Move都可以，关键是返回指针地址和长度。functionbmp2jpg(filename:PChar;varPtr:Pointer;varSize:Integer):Boolean;varstream:TmemoryStream;begintry{转换}exceptresult:=false;exit;end;Stream:=TMemoryStream.Create;jpg.saveToStream(Stream);Size:=Stream.Size;GetMem(Ptr,Size);Stream.Position:=0;Stream.Read(Ptr^,Size);Stream.Free;Result:=True;end;在DLL里声明全局变量varOldApp:TApplication;OldScreen:TScreen;OldControlAtom:TAtom;exprots....;beginOldApp:=nil;OldScreen:=nil;OldControlAtom:=0;end;调用代码：functionbmpfromjpg(jpgf:string):Tbitmap;stdcall;external'jpgtobmp.dll';//静态调用procedureTForm1.Button1Click(Sender:TObject);varmyb:TBitmap;i,w1,h1:integer;beginmyb:=TBitmap.Create;trymyb:=bmpfromjpg('c:/1.jpg');fori:=0to30do//测试代码begin......end;finallymyb.Free;end;end;",2014/5/23
703,不带条件的Select查询语句所存在的隐患,张守伟,http://180.168.156.212:2262/wecenter/?/article/8588,不带条件的Select查询语句所存在的隐患前几天我们的格式转换工具在一家客户现场出现启动时和配置保存时卡死的现象，接到这个问题，我们搭建了一个和现场一样的环境(数据库中的数据是不一样的)，经过测试却怎么也无法重现该问题。后来我们只能在程序里加上日志输出功能，然后到客户现场去测试，经过测试发现原来是执行了一条不带条件的Select查询语句去查询一个包含十几万条记录的表造成的。其实这并没有卡死，只是很慢，原因就是该转换工具运行在一个虚拟机上，本身就很慢，再加上通过网络去查询并返回一个十几万条的数据集，这样就很费时了。原因找到了，下面我们来分析一下关键语句及解决方法：其实很多时候我们都想找一个能同时支持SQLServer和Oracle数据库的语句，比如下面我们想判断一个表里有没有含有某个字段，主要代码如下：withtmpQuerydobeginSQL.Text:='select*from'+ATableName;Open;Result:=FieldList.IndexOf(AFieldName)>=0;end;这段代码从语法上来看没有任何问题，但是当待查询的表中数据量很大的时候就会出现很费时的现象，就像前面所提到的那个实例一样，这样让用户很难接受。其实解决这个问题有好几种方法，比如在查询语句中加入Top1，但是这样的话，就要对SQLServer和Oracle数据库分别处理了，因为Top只支持SQLServer。其实这个问题有个特点，就是没有记录也可以判断字段在表中是否存在，将上面的代码稍做一点修改就可以了，如下：withtmpQuerydobeginSQL.Text:='select*from'+ATableName+'where1=0';Open;Result:=FieldList.IndexOf(AFieldName)>=0;end;这样的话，这段句即可以支持SQLServer和Oracle数据库，也不会因为数据量大而费时了。,2014/5/23
704,中华人民共和国食品安全法（修订草案）审议通过，将食品追溯写入其中,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8578,"新华社北京5月14日电国务院总理李克强5月14日主持召开国务院常务会议,部署加快生产性服务业重点和薄弱环节发展促进产业结构调整升级,讨论通过《中华人民共和国食品安全法(修订草案)》。其中最大的亮点就是第39条：“为落实食品企业追溯义务，《送审稿》提出，食品生产经营企业应当建立食品追溯管理制度，保证食品可追溯”。这是中国首次将食品追溯写入国家立法，对我司的追溯业务开展无疑是一个重大利好。",2014/5/16
705,OCX通过CTRL+C实现复制功能的完善,张守伟,http://180.168.156.212:2262/wecenter/?/article/8577,"OCX通过CTRL+C实现复制功能的完善上次介绍了在调用别人的OCX时通过钩子实现ctrl+c进行复制功能（ ），但是存一个问题，就是当OCX窗口打开没有关闭时，钩子是一直起作用的，这样，别的程序的CTRL+C就无法正常工作。这次花了一些时间研究了一下，主要是判断当前的活动的编辑器和OCX的当前编辑器是不是同一个编辑器，但是OCX的编辑器的句柄不好获取，所以通过编辑器的句柄不太好判断，那剩下的方法就是判断两者所在的进程是不是相同，或者是两者所在的线程是不是相同。经过实现发现通过进程来判断还是有一点不完美，就是在和OCX同一个进程的其它页面的ctrl+c也会失效，现在也只能用线程进行判断了。现在以AutoVueX为例说明一下进行线程比较，通过下面的代码可以取得AutoVueX所在线程的ID：GetWindowThreadProcessID(FAutoVueX_Ctrl.Handle,nil);下面的方法可以取得当前获得焦点的控件所对应的线程ID：GetWindowThreadProcessID(GetFocus,nil);把两者的线程ID进行比较，如果两者相等说明当前是在OCX进行复制，则执行钩子功能；如果两者不等，则说明当前获得焦点的编辑器窗口不是OCX所在的窗口，这时就要把钩消息传下去，让对应的窗体自己处理。这样就可以实现在不影响其它程序或窗口使用CTRL+C，并用OCX也能使用CTRL+C来实现复制功能。注意：有一点要特别注意就是卸载钩子的代码不能放在OCX窗体的ActiveFormDestroy事件里，因为这个事件有时会不执行，这样就会导致钩子卸载失败，会影响后面的再次创建。要把钩子的卸载代码放在OCX窗体的DestroyEvent事件里，这样可以确保每次关闭该窗体时，钩子都被卸载。",2014/5/9
706,Delphi线程类详解,孙传金,http://180.168.156.212:2262/wecenter/?/article/8576,我们常有工作线程和主线程之分，工作线程负责作一些后台操作，比如接收邮件；主线程负责界面上的一些显示。工作线程的好处在某些时候是不言而喻的，你的主界面可以响应任何操作，而背后的线程却在默默地工作。VCL中，工作线程执行在Execute方法中，你必须从TThread继承一个类并覆盖Execute方法，在这个方法中，所有代码都是在另一个线程中执行的，除此之外，你的线程类的其他方法都在主线程执行，包括构造方法，析构方法，Resume等，很多人常常忽略了这一点。最简单的一个线程类如下：TMyThread=class(TThread)protectedprocedureExecute;override;end;在Execute中的代码，有一个技术要点，如果你的代码执行时间很短，像这样，Sleep(1000)，那没有关系；如果是这样Sleep(10000)，10秒，那么你就不能直接这样写了，须把这10秒拆分成10个1秒，然后判断Terminated属性，像下面这样：procedureTMyThread.Execute;vari:Integer;beginfori:=0to9doifnotTerminatedthenSleep(1000)elseBreak;end;这样写有什么好处呢，想想你要关闭程序，在关闭的时候调用MyThread.Free，这个时候线程并没有马上结束，它调用WaitFor，等待Execute执行完后才能释放。你的程序就必须等10秒以后才能关闭，受得了吗。如果像上面那样写，在程序关闭时，调用Free之后，它顶多再等一秒就会关闭。为什么？答案得去线程类的Destroy中找，它会先调用Terminate方法，在这个方法里面它把Terminated设为True（仅此而已，很多人以为是结束线程，其实不是）。请记住这一切是在主线程中操作的，所以和Execute是并行执行的。既然Terminated属性已为Ture，那么在Execute中判断之后，当然就Break了，Execute执行完毕，线程类也正常释放。或者有人说，TThread可以设FreeOnTerminate属性为True，线程类就能自动释放。除非你的线程执行的任务很简单，不然，还是不要去理会这个属性，一切由你来操作，才能使线程更灵活强大。接下来的问题是如何使工作线程和主线程很好的通信，很多时候主线程必须得到工作线程的通知，才能做出响应。比如接收邮件，工作线程向服务器收取邮件，收取完毕之后，它得通知主线程收到多少封邮件，主线程才能弹出一个窗口通知用户。在VCL中，我们可以用两种方法，一种是向主线程中的窗体发送消息，另一种是使用异步事件。第一种方法其实没有第二种来得方便。想想线程类中的OnTerminate事件，这个事件由线程函数的堆栈引起，却在主线程执行。事实上，真正的线程函数是这个：functionThreadProc(Thread:TThread):Integer;函数里面有Thread.Execute，这就是为什么Execute是在其他线程中执行，该方法执行之后，有如下句：Thread.DoTerminate;而线程类的DoTerminate方法里面是ifAssigned(FOnTerminate)thenSynchronize(CallOnTerminate);显然Synchronize方法使得CallOnTerminate在主线程中执行，而CallOnTerminate里面的代码其实就是：ifAssigned(FOnTerminate)thenFOnTerminate(Self);只要Execute方法一执行完就发生OnTerminate事件。不过有一点是必须注意，OnTerminate事件发生后，线程类不一定会释放，只有在FreeOnTerminate为True之后，才会Thread.Free。看一下ThreadProc函数就知道。依照Onterminate事件，我们可以设计自己的异步事件。Synchronize方法只能传进一个无参数的方法类型，但我们的事件经常是要带一些参数的，这个稍加思考就可以得到解决，即在线程类中保存参数，触发事件前先设置参数，再调用异步事件，参数复杂的可以用记录或者类来实现。假设这样，上面的代码每睡一秒，线程即向外面引发一次事件，我们的类可以这样设计：TSecondEvent=procedure(Second:Integer)ofobject;TMyThread=class(TThread)privateFSecond:Integer;FSecondEvent:TSecondEvent;procedureCallSecondEvent;protectedprocedureExecute;override;publicpropertySencondEvent:TSecondEventreadFSecondEventwriteFSecondEvent;end;{TMyThread}procedureTMyThread.CallSecondEvent;beginifAssigned(FSecondEvent)thenFSecondEvent(FSecond);end;procedureTMyThread.Execute;vari:Integer;beginfori:=0to9doifnotTerminatedthenbeginSleep(1000);FSecond:=i;Synchronize(CallSecondEvent);endelseBreak;end;在主窗体中假设我们这样操作线程：procedureTForm1.Button1Click(Sender:TObject);beginMyThread:=TMyThread.Create(true);MyThread.OnTerminate:=ThreadTerminate;MyThread.SencondEvent:=SecondEvent;MyThread.Resume;end;procedureTForm1.ThreadTerminate(Sender:TObject);beginShowMessage('ok');end;procedureTForm1.SecondEvent(Second:Integer);beginEdit1.Text:=IntToStr(Second);end;我们将每隔一秒就得到一次通知并在Edit中显示出来。现在我们已经知道如何正确使用Execute方法，以及如何在主线程与工作线程之间通信了。但问题还没有结束，有一种情况出乎我的意料之外，即如果线程中有一些资源，Execute正在使用这些资源，而主线程要释放这个线程，这个线程在释放的过程中会释放掉资源。想想会不会有问题呢，两个线程，一个在使用资源，一个在释放资源，会出现什么情况呢，用下面代码来说明：typeTMyClass=classprivateFSecond:Integer;publicprocedureSleepOneSecond;end;TMyThread=class(TThread)privateFMyClass:TMyClass;protectedprocedureExecute;override;publicconstructorMyCreate(CreateSuspended:Boolean);destructorDestroy;override;end;implementation{TMyThread}constructorTMyThread.MyCreate(CreateSuspended:Boolean);begininheritedCreate(CreateSuspended);FMyClass:=TMyClass.Create;end;destructorTMyThread.Destroy;beginFMyClass.Free;FMyClass:=nil;inherited;end;procedureTMyThread.Execute;vari:Integer;beginfori:=0to9doFMyClass.SleepOneSecond;end;{TMyClass}procedureTMyClass.SleepOneSecond;beginFSecond:=0;Sleep(1000);end;end.用下面的代码来调用上面的类：procedureTForm1.Button1Click(Sender:TObject);beginMyThread:=TMyThread.MyCreate(true);MyThread.OnTerminate:=ThreadTerminate;MyThread.Resume;end;procedureTForm1.Button2Click(Sender:TObject);beginMyThread.Free;end;先点击Button1创建一个线程，再点击Button2释放该类，出现什么情况呢，违法访问，是的，MyThread.Free时，MyClass被释放掉了FMyClass.Free;FMyClass:=nil;而此时Execute却还在执行，并且调用MyClass的方法，当然就出现违法访问。对于这种情况，有什么办法来防止呢，我想到一种方法，即在线程类中使用一个成员，假设为FFinished，在Execute方法中有如下的形式：FFinished:=False;try//......finallyFFinished:=True;End;接着在线程类的Destroy中有如下形式：WhilenotFFinisheddoSleep(100);MyClass.Free;这样便能保证MyClass能被正确释放。线程是一种很有用的技术。但使用不当，常使人头痛。在CSDN论坛上看到一些人问，我的窗口在线程中调用为什么出错，主线程怎么向其他线程发送消息等等，其实，我们在抱怨线程难用时，也要想想我们使用的方法对不对，只要遵循一些正确的使用规则，线程其实很简单。后记上面有一处代码有些奇怪：FMyClass.Free;FMyClass:=nil;如果你只写FMyClass.Free，线程类还不会出现异常，即调用FMyClass.SleepOneSecond不会出错。我在主线程中试了下面的代码MyClass:=TMyClass.Create;MyClass.SleepOneSecond;MyClass.Free;MyClass.SleepOneSecond;同样也不会出错，但关闭程序时就出错了，如果是这样：MyClass:=TMyClass.Create;MyClass.SleepOneSecond;MyClass.Free;MyThread:=TMyThread.MyCreate(true);MyThread.OnTerminate:=ThreadTerminate;MyThread.Resume;MyClass.SleepOneSecond;马上就出错。所以这个和线程类无线，应该是Delphi对于堆栈空间的释放规则，我想MyClass.Free之后，该对象在堆栈上空间还是保留着，只是允许其他资源使用这个空间，所以接着调用下面这一句MyClass.SleepOneSecond就不会出错，当程序退出时可能对堆栈作一些清理导致出错。而如果MyClass.Free之后即创建MyThread，大概MyClass的空间已经被MyThread使用，所以再调用MyClass.SleepOneSecond就出错了。,2014/5/9
707,delphi 制作不规则窗体+透明输入框,陈军志,http://180.168.156.212:2262/wecenter/?/article/8575,"制作不规则窗体的两种方式：方法一：加载任意格式的透明图片，将底色填充为一种纯色（此处取白色），在窗体创建事件中，加入以下关键代码：（DEMO见附件一）self.TransparentColor:=true;self.TransparentColorValue:=clwhite;self.AlphaBlend:=true;self.AlphaBlendValue:=255;方法二：格式暂定为bmp，动态加载，图片的底色为某一指定纯色，（此处为纯蓝），在窗体创建处加入以下关键代码：（DEMO见附件二）procedureTForm1.FormCreate(Sender:TObject);varthreadrgn,tmprgn:HRGN;x,y,t,h:integer;beginBitmapb:=TBitMap.Create;Bitmapb.LoadFromFile('Heart.bmp');threadrgn:=CreateRectRgn(0,0,bitmapb.Width,bitmapb.Height);t:=bitmapb.Height;h:=bitmapb.Width;self.Height:=t;self.Width:=h;fory:=0totdoforx:=0tohdoifbitmapb.Canvas.Pixels[x,y]=rgb(0,0,255)thenbegintmpRgn:=CreateRectRgn(x,y,x+1,y+1);CombineRgn(threadrgn,threadrgn,tmpRgn,RGN_XOR);DeleteObject(tmpRgn);end;SetWindowRgn(handle,Threadrgn,false);end;2、透明输入框（TRichEdit）（DEMO见附件一）edtUserID.Brush.Style:=bsClear;SetWindowLong(edtUserID.Handle,GWL_EXSTYLE,GetWindowLong(edtUserID.Handle,GWL_EXSTYLE)orWS_EX_TRANSPARENT);edtPassword.Brush.Style:=bsClear;SetWindowLong(edtPassword.Handle,GWL_EXSTYLE,GetWindowLong(edtPassword.Handle,GWL_EXSTYLE)orWS_EX_TRANSPARENT);利用第一种制作不规则窗体的方法以及透明输入框的方式，做出demo中的登录框效果。不规则窗体+透明输入框DEMO.zip非矩形窗口测试.rar",2014/5/9
708,Delphi创建及调用DLL资料,王孝本,http://180.168.156.212:2262/wecenter/?/article/8574,"首先需要一个声明typeTDll=procedure(ID:string;AHandle:THandle;ADOConnection:TADOConnection);stdcall;//该定义的作用相当于C++中的函数指针声明通过某个事件来调用procedureTForm1.Button1Click(Sender:TObject);varDll:TDll;DllName:THandle;beginDllName:=LoadLibrary('../Dll/Test_Dll.dll');//Dll的路径tryifDllName<32thenbeginmessagebox(handle,'没有找到附带DLL文件，请确认程序是否完整！','加载DLL失败',MB_OK+MB_ICONEXCLAMATION);exit;end;@Dll:=GetProcAddress(DllName,'CreateTest_DLLForm');if@dll<>nilthentryDll('000001',Application.Handle,form1.ADOConnection1);exceptraiseException.Create('不存在！');end;finallyFreeLibrary(DllName);//注意释放end;end;在被调用的Dll里面写个函数，Dll被调用的时候用当然，首先要声明了procedureCreateTest_DllForm(ID:string;AHandle:THandle;ADOConnection:TADOConnection);stdcall;函数具体内容procedureCreateTest_DllForm(ID:string;AHandle:THandle;ADOConnection:TADOConnection);varOldHandle:THandle;beginOldhandle:=Application.Handle;Application.Handle:=AHandle;MainFrm:=TMainFrm.Create(nil);conn:=ADOConnection;//conn为已定义的全局变量TryMainFrm.ShowModal;finallyApplication.Handle:=OldHandle;MainFrm.Free;MainFrm:=nil;end;end;最后不要忘了在ViewSource里写上exportsCreateTest_DllForm;以上是动态调用，很简单的。一Dll的制作一般步骤二参数传递三DLL的初始化和退出清理[如果需要初始化和退出清理]四全局变量的使用五调用静态载入六调用动态载入七在DLL建立一个TForM八在DLL中建立一个TMDIChildForM九示例：十Delphi制作的Dll与其他语言的混合编程中常遇问题：十一相关资料一Dll的制作一般分为以下几步：1.在一个DLL工程里写一个过程或函数2.写一个Exports关键字，在其下写过程的名称。不用写参数和调用后缀。二参数传递1.参数类型最好与windowC++的参数类型一致。不要用DELPHI的数据类型。2.最好有返回值[即使是一个过程]，来报出调用成功或失败，或状态。成功或失败的返回值最好为1[成功]或0[失败].一句话，与windowsc++兼容。3.用stdcall声明后缀。4.最好大小写敏感。5.无须用far调用后缀，那只是为了与windows16位程序兼容。三DLL的初始化和退出清理[如果需要初始化和退出清理]1.DLLProc[SysUtils单元的一个Pointer]是DLL的入口。在此你可用你的函数替换了它的入口。但你的函数必须符合以下要求[其实就是一个回调函数]。如下：procedureDllEnterPoint(dwReason:DWORD);far;stdcall;dwReason参数有四种类型：DLL_PROCESS_ATTACH:进程进入时DLL_PROCESS_DETACH进程退出时DLL_THREAD_ATTACH线程进入时DLL_THREAD_DETACH线程退出时在初始化部分写:DLLProc:=@DLLEnterPoint;DllEnterPoint(DLL_PROCESS_ATTACH);2.如Form上有TdcomConnection组件,就UsesActivex,在初始化时写一句CoInitialize(nil);3.在退出时一定保证DcomConnection.Connected:=False,并且数据集已关闭。否则报地址错。四全局变量的使用在widnows32位程序中，两个应用程序的地址空间是相互没有联系的。虽然DLL在内存中是一份，但变量是在各进程的地址空间中，因此你不能借助dll的全局变量来达到两个应用程序间的数据传递，除非你用内存映像文件。五调用静态载入1客户端函数声名:1)大小写敏感。2)与DLL中的声明一样。如：showform(form:Tform);Far;external'yproject_dll.dll';3)调用时传过去的参数类型最好也与windowsc++一样。4)调用时DLL必须在windows搜索路径中，顺序是：当前目录；Path路径；windows;widows/system;windows/ssystem32;六调用动态载入1.建立一种过程类型[如果你对过程类型的变量只是一个指针的本质清楚的话，你就知道是怎么回事了]。如：typemypointer=procedure(form:Tform);Far;external;varHinst:Thandle;showform:mypointer;beginHinst:=loadlibrary('yproject_dll');//Load一个Dll,按文件名找。showform:=getprocaddress(Hinst,'showform');//按函数名找，大小写敏感。如果你知道自动化对象的本质就清楚了。showform(application.mainform);//找到函数入口指针就调用。Freelibrary(Hinst);end;七.在DLL建立一个TForM1把你的FormUses到Dll中，你的Form用到的关联的单元也要Uses进来[这是最麻烦的一点，因为你的Form或许Uses了许多特殊的单元或函数]2传递一个Application参数，用它建立Form.八.在DLL中建立一个TMDIChildForM1Dll中的MDIForm.FormStyle不用为fmMDIChild.2在CreateForm后写以下两句：functionShowForm(mainForm:TForm):integer;stdcallvarForm1:TForm1;ptr:PLongInt;beginptr:=@(Application.MainForm);//先把dll的MainForm句柄保存起来，也无须释放，只不过是替换一下ptr^:=LongInt(mainForm);//用主调程序的mainForm替换DLL的MainForm。MainForm是特殊的WINDOW，它专门管理Application中的Forms资源.//为什么不直接Application.MainForm:=mainForm,因为Application.MainForm是只读属性Form1:=TForm1.Create(mainForm);//用参数建立end;备注：参数是主调程序的Application.MainForm九.示例：DLL源代码：libraryProject2;usesSysUtils,Classes,Dialogs,Forms,Unit2in'Unit2.pas'{Form2};{$R*.RES}varccc:Pchar;procedureOpenForm(mainForm:TForm);stdcall;varForm1:TForm1;ptr:PLongInt;beginptr:=@(Application.MainForm);ptr^:=LongInt(mainForm);Form1:=TForm1.Create(mainForm);end;procedureInputCCC(Text:Pchar);stdcall;beginccc:=Text;end;procedureShowCCC;stdcall;beginShowMessage(String(ccc));end;exportsOpenForm;InputCCC,ShowCCC;beginend.调用方源代码：unitUnit1;interfaceusesWindows,Messages,SysUtils,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls;typeTForm1=class(TForm)Button1:TButton;Button2:TButton;Edit1:TEdit;procedureButton1Click(Sender:TObject);procedureButton2Click(Sender:TObject);private{Privatedeclarations}public{Publicdeclarations}end;varForm1:TForm1;implementation{$R*.DFM}procedureOpenForm(mainForm:TForm);stdcall;External'project2.dll';procedureShowCCC;stdcall;External'project2.dll';procedureInputCCC(Text:Pchar);stdcall;External'project2.dll';procedureTForm1.Button1Click(Sender:TObject);varText:Pchar;beginText:=Pchar(Edit1.Text);//OpenForm(Application.MainForm);//为了调MDICHILDInputCCC(Text);//为了实验DLL中的全局变量是否在各个应用程序间共享end;procedureTForm1.Button2Click(Sender:TObject);beginShowCCC;//这里表明WINDOWS32位应用程序DLL中的全局变量也是在应用程序地址空间中，16位应用程序或许不同，没有做实验。end;十Delphi制作的Dll与其他语言的混合编程中常遇问题：1.与PowerBuilder混合编程在定义不定长动态数组方面在函数退出清理堆栈时老出现不可重现的地址错，原因未明，大概与PB的编译器原理有关，即使PB编译成二进制代码也如此。来自：zhousy_2000,时间：2005-9-148:20:59,ID：3204433tiDLL参数调用约定----------------------令传递顺序参数删除stdcall从左到右函数方面cdecl从右到左调用方面pascal从左到右函数方面register从左到右函数方面━━━━━━━━━━━━━━━━━━━━━━退出过程编译时必须关闭stack_checking，因而需设置编译指示{$S-}。━━━━━━━━━━━━━━━━━━━━━//----------dll的创建librarymydll{$S-}//--------uses单元usesclasses,stdsys,formin'form.pas'{form};//---------变量声明varlove:string;baby:integer;SaveExit:Pointer;//---------函数和过程proceduremyinnerproc();stdcall;//内部使用过程begin{添入代码}end;proceduremyproc(varlove:string);stdcall;export;//输出可以调用过程begin{添入代码}end;functionmyfunction(baby:integer):integer;stdcall;export;//可调用函数begin{添入代码}end;procedureLibExit;far;beginifExitCode=wep_System_Exitthenbegin{系统关闭时的相应处理}endelsebegin{DLL卸出时的相应处理}end;ExitProc:=SaveExit;{恢复原来的退出过程指针}end;//----------输出说明exportsmyprocname'myproc'index1,myfunctionname'myfuntion'index2risdent;//输出信息始终保持在内存中{risdent}//----------初始化工作begin{DLL的初始化工作}SaveExit:=ExitProc;{保存原来的退出过程指针}ExitProc:=@LibExit;{安装新的退出过程}End.━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━表10.1ExitCode的取值与意义：取值意义---------------------WEP_System_ExitWindows关闭WEP_Free_DLLxDLLs被卸出━━━━━━━━━━━━━━━━━━━━━//--------------调用dll1。静态调用在静态调用一个DLLs中的过程或函数时，external指示增加到过程或函数的声明语句中。被调用的过程或函数必须采用远调用模式。这可以使用far过程指示或一个{$F+}编译指示。Delphi全部支持传统Windows动态链接库编程中的三种调用方式，它们是：●通过过程/函数名●通过过程/函数的别名●通过过程/函数的顺序号//--------------------静态调用举例unitwindowsinterfacefunctionFindWindowsEx(Parent,Child:hwnd;classname,windowsname:pchar):hwnd;stdcall;constuser32='user32.dll'implementationfunctionFindWindowEx;externaluser32name'FindWindowExA'━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━2.动态调用2.1动态调用中的API函数动态调用中使用的WindowsAPI函数主要有三个,即：Loadlibrary，GetProcAddress和Freelibrary。1.Loadlibrary:把指定库模块装入内存语法为：functionLoadlibrary(LibFileName:PChar):THandle;LibFileName指定了要装载DLLs的文件名，如果LibFileName没有包含一个路径，则Windows按下述顺序进行查找：(1)当前目录；(2)Windows目录(包含win.com的目录)。函数GetWindowDirectory返回这一目录的路径；(3)Windows系统目录(包含系统文件如gdi.exe的目录)。函数GetSystemDirectory返回这一目录的路径；(4)包含当前任务可执行文件的目录。利用函数GetModuleFileName可以返回这一目录的路径；(5)列在PATH环境变量中的目录；(6)网络的映象目录列表。如果函数执行成功，则返回装载库模块的实例句柄。否则，返回一个小于HINSTANCE_ERROR的错误代码。错误代码的意义如下表：表10.2Loadlibrary返回错误代码的意义━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━错误代码意义--------------------------------------0系统内存不够，可执行文件被破坏或调用非法2文件没有被发现3路径没有被发现5企图动态链接一个任务或者有一个共享或网络保护错6库需要为每个任务建立分离的数据段8没有足够的内存启动应用程序10Windows版本不正确11可执行文件非法。或者不是Windows应用程序，或者在.EXE映像中有错误12应用程序为一个不同的操作系统设计(如OS/2程序)13应用程序为MSDOS4.0设计14可执行文件的类型不知道15试图装载一个实模式应用程序(为早期Windows版本设计)16试图装载包含可写的多个数据段的可执行文件的第二个实例19试图装载一个压缩的可执行文件。文件必须被解压后才能被装裁20动态链接库文件非法21应用程序需要32位扩展━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━假如在应用程序用Loadlibrary调用某一模块前，其它应用程序已把该模块装入内存，则Loadlibrary并不会装载该模块的另一实例，而是使该模块的""引用计数""加1。2.GetProcAddress：捡取给定模块中函数的地址语法为：functionGetProcAddress(Module:THandle;ProcName:PChar):TFarProc;Module包含被调用的函数库模块的句柄，这个值由Loadlibrary返回。如果把Module设置为nil，则表示要引用当前模块。ProcName是指向含有函数名的以nil结尾的字符串的指针，或者也可以是函数的次序值。如果ProcName参数是次序值，则如果该次序值的函数在模块中并不存在时，GetProcAddress仍返回一个非nil的值。这将引起混乱。因此大部分情况下用函数名是一种更好的选择。如果用函数名，则函数名的拼写必须与动态链接库文件EXPORTS节中的对应拼写相一致。如果GetProcAddress执行成功，则返回模块中函数入口处的地址，否则返回nil。3.Freelibrary：从内存中移出库模块语法为：procedureFreelibrary(Module:THandle);Module为库模块的句柄。这个值由Loadlibrary返回。由于库模块在内存中只装载一次，因而调用Freelibrary首先使库模块的引用计数减一。如果引用计数减为0，则卸出该模块。每调用一次Loadlibrary就应调用一次FreeLibray，以保证不会有多余的库模块在应用程序结束后仍留在内存中。//------------动态调用举例在利用GetProcAddess返回的函数指针时，必须进行强制类型转换：Order:=TInstr(PFunc)(text,Key);TInStr是一个定义好了的函数类型：typeTInStr=function(Source:PChar;Check:Char):Integer;//---------------------------------procedureTForm1.Edit2KeyPress(Sender:TObject;varKey:Char);varorder:Integer;txt:PChar;PFunc:TFarProc;Moudle:THandle;beginMoudle:=Loadlibrary('c:/dlls/example.dll');ifMoudle>32thenbeginEdit2.text:='';Pfunc:=GetProcAddress(Moudle,'Instr');txt:=StrAlloc(80);txt:=StrPCopy(txt,Edit1.text);Order:=TInstr(PFunc)(txt,Key);ifOrder=-1thenLabel1.Caption:='不包含这个字符'endelseLabel1.Caption:='位于第'+IntToStr(Order+1)+'位';Freelibrary(Moudle);end;//------------用于实现数据传输的DLLs的编写用于实现数据传输的DLLs与一般DLLs的编写基本相同，其中特别的地方是：1.定义一个全局变量句柄：varhMem:THandle;2.定义一个过程，返回该全局变量的句柄。该过程要包含在exports子句中。如：functionGetGlobalMem:THandle;export;beginResult:=hMem;end;3.在初始化代码中分配全局内存块：程序清单如下：beginhMem:=GlobalAlloc(gmem_MOVEABLEandgmem_DDEShare,num);ifhMem=0thenMessageDlg('Couldnotallocatememory',mtWarning,[mbOK],0);end.//--------------------------------num是一个预定义的常数。表10.3全局内存块的分配标志：标志意义---------------------------------gmem_DDEShare分配可由应用程序共享的内存gmem_Discardable分配可抛弃的内存(只与gmem_Moveable连用)gmem_Fixed分配固定内存gmem_Moveable分配可移动的内存gmem_Nocompact该全局堆中的内存不能被压缩或抛弃gmem_Nodiscard该全局堆中的内存不能被抛弃gmem_NOT_Banked分配不能被分段的内存gmem_Notify通知功能。当该内存被抛弃时调用GlobalNotify函数gmem_Zeroinit将所分配内存块的内容初始化为零━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━有两个预定义的常用组合是：GHND=gmem_Moveableandgmem_ZeroinitGPTK=gmem_Fixedandgmem_Zeroinit来自：zsy146,时间：2005-9-148:22:41,ID：3204435|编辑一、开使你的第一个DLL专案1.File->Closeall->File->New﹝DLL﹞代码://自动产生Code如下libraryProject2;//这有段废话usesSysUtils,Classes;{$R*.RES}beginend.2.加个Func进来：代码:libraryProject2;usesSysUtils,Classes;FunctionMyMax(X,Y:integer):integer;stdcall;beginifX>YthenResult:=XelseResult:=Y;end;//切记：Library的名字大小写没关系，可是DLL-Func的大小写就有关系了。//在DLL-Func-Name写成MyMax与myMAX是不同的。如果写错了，立即//的结果是你叫用到此DLL的AP根本开不起来。//参数的大小写就没关系了。甚至不必同名。如原型中是(X,Y:integer)但引//用时写成(A,B:integer)，那是没关系的。//切记：要再加个stdcall。书上讲，如果你是用Delphi写DLL，且希望不仅给//Delphi-AP也希望BCB/VC-AP等使用的话，那你最好加个Stdcall;的指示//参数型态：Delphi有很多种它自己的变量型态，这些当然不是DLL所喜欢的//，Windows/DLL的母语应该是C。所以如果要传进传出DLL的参数，我们//尽可能照规矩来用。这两者写起来，后者会麻烦不少。如果你对C不熟//的话，那也没关系。我们以后再讲。{$R*.RES}beginend.3.将这些可共享的Func送出DLL，让外界﹝就是你的Delphi-AP啦﹞使用：光如此，你的AP还不能用到这些，你还要加个Exports才行。代码:{$R*.RES}exportsMyMax;beginend.4.好了，可以按Ctrl-F9编译了。此时可不要按F9。DLL不是EXE┌不可单独执行的，如果你按F9，会有ErrorMsg的。这时如果DLL有Error，请修正之。再按Ctrl-F9。此时可能有Warning，不要紧，研究一下，看看就好。再按Ctrl-F9，此时就『Done,Compiled』。同目录就会有个*.dll。恭喜，大功告成了。二、进行测试：开个新application：1.加个TButton代码:ShowMessage(IntToStr(MyMax(30,50)));2.告知Exe到那里抓个Func代码://在Form,interface,var后加FunctionMyMax(X,Y:integer):integer;stdcall;external'MyTestDLL.dll';//MyTestDLL.dll为你前时写的DLL项目名字//DLL名字大小写没关系。不过记得要加extension的.DLL。在Win95或NT，//是不必加extension，但这两种OS，可能越来越少了吧。要加extension可以了，简单吧。上面的例子是不是很简单？熟悉Delphi的朋友可以看出以上代码和一般的Delphi程序的编写基本是相同的，只是在TestDll函数后多了一个stdcall参数并且用exports语句声明了TestDll函数。只要编译上面的代码，就可以玫揭桓雒狣elphi.dll的动态链接库。现在，让我们来看看有哪些需要注意的地方：1.在DLL中编写的函数或过程都必须加上stdcall调用参数。在Delphi1或Delphi2环境下该调用参数是far。从Delphi3以后将这个参数变为了stdcall，目的是为了使用标准的Win32参数传递技术来代替优化的register参数。忘记使用stdcall参数是常见的错误，这个错误不会影响DLL的编译和生成，但当调用这个DLL时会发生很严重的错误，导致操作系统的死锁。原因是register参数是Delphi的默认参数。2.所写的函数和过程应该用exports语句声明为外部函数。正如大家看到的，TestDll函数被声明为一个外部函数。这样做可以使该函数在外部就能看到，具体方法是单激鼠标右键用""快速查看（QuickView）""功能查看该DLL文件。（如果没有""快速查看""选项可以从WindowsCD上安装。）TestDll函数会出现在ExportTable栏中。另一个很充分的理由是，如果不这样声明，我们编写的函数将不能被调用，这是大家都不愿看到的。3.当使用了长字符串类型的参数、变量时要引用ShareMem。Delphi中的string类型很强大，我们知道普通的字符串长度最大为256个字符，但Delphi中string类型在默认情况下长度可以达到2G。（对，您没有看错，确实是两兆。）这时，如果您坚持要使用string类型的参数、变量甚至是记录信息时，就要引用ShareMem单元，而且必须是第一个引用的。既在uses语句后是第一个引用的单元。如下例：usesShareMem,SysUtils,Classes;还有一点，在您的工程文件（*.dpr）中而不是单元文件（*.pas）中也要做同样的工作，这一点Delphi自带的帮助文件没有说清楚，造成了很多误会。不这样做的话，您很有可能付出死机的代价。避免使用string类型的方法是将string类型的参数、变量等声明为Pchar或ShortString（如：s:string[10]）类型。同样的问题会出现在当您使用了动态数组时，解决的方法同上所述。在Delphi中静态调用DLL调用一个DLL比写一个DLL要容易一些。首先给大家介绍的是静态调用方法，稍后将介绍动态调用方法，并就两种方法做一个比较。同样的，我们先举一个静态调用的例子。unitUnit1;interfaceusesWindows,Messages,SysUtils,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls;typeTForm1=class(TForm)Edit1:TEdit;Button1:TButton;procedureButton1Click(Sender:TObject);private{Privatedeclarations}public{Publicdeclarations}end;varForm1:TForm1;implementation{$R*.DFM}//本行以下代码为我们真正动手写的代码functionTestDll(i:integer):integer;stdcall;external'Delphi.dll';procedureTForm1.Button1Click(Sender:TObject);beginEdit1.Text:=IntToStr(TestDll(1));end;end.上面的例子中我们在窗体上放置了一个编辑框（Edit）和一个按钮（Button），并且书写了很少的代码来测试我们刚刚编写的Delphi.dll。大家可以看到我们唯一做的工作是将TestDll函数的说明部分放在了implementation中，并且用external语句指定了Delphi.dll的位置。（本例中调用程序和Delphi.dll在同一个目录中。）让人兴奋的是，我们自己编写的TestDll函数很快被Delphi认出来了。您可做这样一个实验：输入""TestDll（""，很快Delphi就会用fly-by提示条提示您应该输入的参数是什么，就像我们使用Delphi中定义的其他函数一样简单。注意事项有以下一些：一、调用参数用stdcall和前面提到的一样，当引用DLL中的函数和过程时也要使用stdcall参数，原因和前面提到的一样。二、用external语句指定被调用的DLL文件的路径和名称正如大家看到的，我们在external语句中指定了所要调用的DLL文件的名称。没有写路径是因为该DLL文件和调用它的主程序在同一目录下。如果该DLL文件在C:/，则我们可将上面的引用语句写为external'C:/Delphi.dll'。注意文件的后缀.dll必须写上。三、不能从DLL中调用全局变量如果我们在DLL中声明了某种全局变量，如：vars:byte。这样在DLL中s这个全局变量是可以正常使用的，但s不能被调用程序使用，既s不能作为全局变量传递给调用程序。不过在调用程序中声明的变量可以作为参数传递给DLL。四、被调用的DLL必须存在这一点很重要，使用静态调用方法时要求所调用的DLL文件以及要调用的函数或过程等等必须存在。如果不存在或指定的路径和文件名不正确的话，运行主程序时系统会提示""启动程序时出错""或""找不到*.dll文件""等运行错误。在Delphi中动态调用DLLtop动态调用DLL相对复杂很多，但非常灵活。为了全面的说明该问题，这次我们举一个调用由C++编写的DLL的例子。首先在C++中编译下面的DLL源程序。#includeextern""C""_declspec(dllexport)intWINAPITestC(inti){returni;}编译后生成一个DLL文件，在这里我们称该文件为Cpp.dll，该DLL中只有一个返回整数类型的函数TestC。为了方便说明，我们仍然引用上面的调用程序，只是将原来的Button1Click过程中的语句用下面的代码替换掉了。procedureTForm1.Button1Click(Sender:TObject);typeTIntFunc=function(i:integer):integer;stdcall;varTh:Thandle;Tf:TIntFunc;Tp:TFarProc;beginTh:=LoadLibrary('Cpp.dll');{装载DLL}ifTh>0thentryTp:=GetProcAddress(Th,PChar('TestC'));ifTp<>nilthenbeginTf:=TIntFunc(Tp);Edit1.Text:=IntToStr(Tf(1));{调用TestC函数}endelseShowMessage('TestC函数没有找到');finallyFreeLibrary(Th);{释放DLL}endelseShowMessage('Cpp.dll没有找到');end;大家已经看到了，这种动态调用技术很复杂，但只要修改参数，如修改LoadLibrary('Cpp.dll')中的DLL名称为'Delphi.dll'就可动态更改所调用的DLL。一、定义所要调用的函数或过程的类型在上面的代码中我们定义了一个TIntFunc类型，这是对应我们将要调用的函数TestC的。在其他调用情况下也要做同样的定义工作。并且也要加上stdcall调用参数。二、释放所调用的DLL我们用LoadLibrary动态的调用了一个DLL，但要记住必须在使用完后手动地用FreeLibrary将该DLL释放掉，否则该DLL将一直占用内存直到您退出Windows或关机为止。现在我们来评价一下两种调用DLL的方法的优缺点。静态方法实现简单，易于掌握并且一般来说稍微快一点，也更加安全可靠一些；但是静态方法不能灵活地在运行时装卸所需的DLL，而是在主程序开始运行时就装载指定的DLL直到程序结束时才释放该DLL，另外只有基于编译器和链接器的系统（如Delphi）才可以使用该方法。动态方法较好地解决了静态方法中存在的不足，可以方便地访问DLL中的函数和过程，甚至一些老版本DLL中新添加的函数或过程；但动态方法难以完全掌握，使用时因为不同的函数或过程要定义很多很复杂的类型和调用方法。对于初学者，笔者建议您使用静态方法，待熟练后再使用动态调用方法。使用DLL的实用技巧一、编写技巧1、为了保证DLL的正确性，可先编写成普通的应用程序的一部分，调试无误后再从主程序中分离出来，编译成DLL。2、为了保证DLL的通用性，应该在自己编写的DLL中杜绝出现可视化控件的名称，如：Edit1.Text中的Edit1名称；或者自定义非Windows定义的类型，如某种记录。3、为便于调试，每个函数和过程应该尽可能短小精悍，并配合具体详细的注释。4、应多利用try-finally来处理可能出现的错误和异常，注意这时要引用SysUtils单元。5、尽可能少引用单元以减小DLL的大小，特别是不要引用可视化单元，如Dialogs单元。例如一般情况下，我们可以不引用Classes单元，这样可使编译后的DLL减小大约16Kb。二、调用技巧1、在用静态方法时，可以给被调用的函数或过程更名。在前面提到的C++编写的DLL例子中，如果去掉extern""C""语句，C++会编译出一些奇怪的函数名，原来的TestC函数会被命名为@TestC$s等等可笑的怪名字，这是由于C++采用了C++namemangling技术。这个函数名在Delphi中是非法的，我们可以这样解决这个问题：改写引用函数为functionTestC(i:integer):integer;stdcall;external'Cpp.dll';name'@TestC$s';其中name的作用就是重命名。2、可把我们编写的DLL放到Windows目录下或者Windows/system目录下。这样做可以在external语句中或LoadLibrary语句中不写路径而只写DLL的名称。但这样做有些不妥，这两个目录下有大量重要的系统DLL，如果您编的DLL与它们重名的话其后果简直不堪设想，况且您的编程技术还不至于达到将自己编写的DLL放到系统目录中的地步吧！三、调试技巧1、我们知道DLL在编写时是不能运行和单步调试的。有一个办法可以，那就是在Run|parameters菜单中设置一个宿主程序。在Local页的HostApplication栏中添上宿主程序的名字就可进行单步调试、断点观察和运行了。2、添加DLL的版本信息。开场白中提到了版本信息对于DLL是很重要的，如果包含了版本信息，DLL的大小会增加2Kb。增加这么一点空间是值得的。很不幸我们如果直接使用Project|options菜单中Version选项是不行的，这一点Delphi的帮助文件中没有提到，经笔者研究发现，只要加一行代码就可以了。如下例：libraryDelphi;usesSysUtils,Classes;{$R*.RES}//注意，上面这行代码必须加在这个位置functionTestDll(i:integer):integer;stdcall;beginResult:=i;end;exportsTestDll;beginend.3、为了避免与别的DLL重名，在给自己编写的DLL起名字的时候最好采用字符数字和下划线混合的方式。如：jl_try16.dll。",2014/5/9
709,中共中央办公厅  国务院办公厅印发《关于加强和改进新形势下档案工作的意见》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8573, 这是20年以来，首次以中央两办的名义发布加强档案工作的文件，显示出中央对于档案工作的重视，也表明了中国档案部门地位的提升。预计今后几年档案信息化工作将掀起一个小高潮，我司的档案业务也将迎来新的发展机遇。中共中央办公厅国务院办公厅印发《关于加强和改进新形势下档案工作的意见》.mht,2014/5/8
710,js前端技术,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8572,"jquery操作iframe中的js函数1、jquery操作iframe中的元素(2种方式)vardiv1=$(window.frames[“frameName”].document).find(“#divId”).html();vardiv2=$(“#frameId”).contents().find(“#divId”).html();2、操作父页面种的元素(hearder：为某个元素的id)$(“#header”,parent.document).text()3、js调用iframe中的js函数(2种)window.frames[“frameName“].window.textFunc();document.getElementById(“frameId”).contentWindow.textFunc();4、jquery调用iframe中的js函数(带参数的会有返回值)$(“#frameId”)[0].contentWindow.text(“11”)二、禁止输入框输入的方法1、设置输入框的onfocus=”this.blur()”2、设置input的readonly=”readonly”3、设置input的disabled=”disabled”三、Javascript中prototype、constructor的理解1、PrototypePrototype本质上还是一个javascript对象；每个函数都有一个默认的prototype属性；通过prototype我们可以扩展javascript的内建对象例一：如果函数被用在创建自定义对象的场景中，则此函数为构造函数//构造函数functionPerson(name){this.name=name;}//定义Person的原型，原型中的属性可以被自定义对象引用Person.prototype={getName:function(){returnthis.name;}};varzhang=newPerson(""ZhangSan"");console.log(zhang.getName());//""ZhangSan""例二：通过prototype扩展javascript的内建对象//向JavaScript固有类型Array扩展一个获取最小值的方法Array.prototype.min=function(){varmin=this[0];for(vari=1;i<this.length;i++){if(this[i]<min){min=this[i];}}returnmin;};//在任意Array的实例上调用min方法vararr=[1,56,34,12];vartotal=0;for(variinarr){if(arr.hasOwnProperty(i)){total+=parseInt(arr[i],10);}}console.log(total);//1032、ConstructorConstructor始终指向创建当前对象的构造函数；每个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数例子://等价于vararr=newArray(1,56,34,12);vararr=[1,56,34,12];console.log(arr.constructor===Array);//true//等价于varfoo=newFunction();varFoo=function(){};console.log(Foo.constructor===Function);//true//由构造函数实例化一个obj对象varobj=newFoo();console.log(obj.constructor===Foo);//true//将上面两段代码合起来，就得到下面的结论console.log(obj.constructor.constructor===Function);//true3、constructor与prototype的综合应用：functionPerson(name){this.name=name;}Person.prototype.getName=function(){returnthis.name;};varp=newPerson(""ZhangSan"");console.log(p.constructor===Person);//trueconsole.log(Person.prototype.constructor===Person);//true//将上两行代码合并就得到如下结果console.log(p.constructor.prototype.constructor===Person);//true研发中心经验共享_毛璀玲[201404].doc",2014/5/6
711,office等文件转换为pdf三种方法各优缺点,方俊新,http://180.168.156.212:2262/wecenter/?/article/8571,office等文件转换为pdf三种方法各优缺点一、现况概述公司一直采用的是灵器小组开发的格式转换工具将office等格式转换为pdf，采用的方式是msoffice+虚拟机打印机，但以前被封装为dll，不能进行二次维护，导致出现bug不能进行修改。再一个原因是文档需要进行在线浏览，而在线浏览采用的方案是swf格式进行播放，所以需要将word、excel、PowerPoint等格式转换为pdf，再将pdf转换为swf。故需要对office转换为pdf进行探索。二、解决方案在office等文件转换为pdf中，转换的核心还是目前使用较多的三款office软件：msoffice、wps与OpenOffice。各有个的优缺点，具体如下说明：第一种：采用msoffice进行pdf转换：需要安装微软官方的“SaveAsPDF.exe”插件，下载地址： /zh-cn...D9943缺点：msoffice是微软产品，需要收费才能进行合法使用只支持windows系统，不能跨平台但转换wps等office格式转换时，有可能丢失格式数据优点：msoffice目前市面上使用率最高的office软件，支持格式较多，转出来的pdf保留原来的界面格式；在大文件转换过程中，速度很快：经测试一百万多行、两万多页的excel在一分钟左右时间转完。第二种：采用wps进行pdf转换：缺点：转换效率没有msoffice转换快针对msoffice编辑的格式有可能丢失数据问题ppt转换为pdf，pdf文档效果在四周有白边优点：wps具有免费产品，可以免费使用国产软件，政府机构可能使用较多第三种：采用OpenOffice进行pdf转换：缺点：转换效率没有msoffice快，与wps差不多针对msoffice与wps编辑的格式，在word方面丢失数据比较严重优点：开源免费、跨平台,2014/5/5
712,LockWindowUpdate的函数的用法,许海宝,http://180.168.156.212:2262/wecenter/?/article/8570,"LockWindowUpdate(Self.Handle);//锁住当前窗口LockWindowUpdate（0）//解除锁定窗口LockWindowUpdate不但闪烁，而且有可能引起桌面闪烁。因为LockWindowUpdate并不忽略消息，只是暂时不响应，所以有可能积聚多个重画消息，并在使用LockWindowUpdate（0）之后依次响应。而使用SendMessage(ClientHandle,WM_SETREDRAW,0,0)之后，控件根本不接收重画消息，除非使用SendMessage(ClientHandle,WM_SETREDRAW,1,0)之后;LockWindowUpdate的意思是暂时禁止某控件或窗口所在的区域更新(这个区域可能有多个窗口)，LockWindowUpdate（0）的意思是有更新消息就更新屏幕上所有该更新的窗口吧。所以LockWindowUpdate（0）之后，若此前有重画消息积聚，会立刻重画。所以使用LockWindowUpdate会在不同的时候有不同的表现，比如屏幕上窗口多少、堆放情况等等，所以有时不闪有时却闪个不停。SendMessage(ClientHandle,WM_SETREDRAW,0,0)的意思是不接收任何重画消息；SendMessage(ClientHandle,WM_SETREDRAW,1,0)的意思是可以接收并响应重画消息了，但并不立即重画，所以必须附加ReDrawWindow(ClientHandle,nil,0,RDW_INVALIDATEorRDW_ALLCHILDREN);",2014/4/24
713,使用MediaInfo.dll获取音视频等文件信息,王孝本,http://180.168.156.212:2262/wecenter/?/article/8569,使用免费开源的MediaInfo.dll可以获取音视频等文件的详细信息，附件是DELPHI使用MediaInfo.dll的例子程序Mediainfo提取多媒体信息.rar,2014/4/24
714,Dll封装窗体调用方法,孙传金,http://180.168.156.212:2262/wecenter/?/article/8568,"作为框架代码中的一部分，将窗体独立放在dll中是通用的做法，下面为大家演示一个最简单的实例，在此实例基础上可以进行引申，作为抛砖引玉，具体代码如下：//显示窗口的动态链接库代码libraryProject1;usesSysUtils,Classes,Forms,windows,dialogs,Unit1in'Unit1.pas'{Form1};{$R*.res}functionShowFormByName(FormName:string):boolean;stdcall;varTheClass:TPersistentClass;aForm:TForm;beginresult:=false;{如果您的Dll中有很多FORM，请在这儿注册哦RegisterClasses([TForm1,TForm2,TForm3,...]);}RegisterClasses([TForm1]);TheClass:=GetClass('T'+FormName);if(TheClass=nil)thenExit;ifTheClass.InheritsFrom(TForm)thenbeginaForm:=Tform(TheClass.Create).Create(nil);tryaForm.ShowModal;result:=true;finallyFreeAndNil(aForm);end;end;end;exportsShowFormByName;beginend.//窗体代码显示动态库中的窗体procedureCreateDllForm(constDllFileName,DllFormName:String;constmethodName:string);typeTRunForm=function(formname:string):boolean;stdcall;varRunForm:TRunForm;GetDllHWND:HWND;beginGetDllHWND:=LoadLibrary(PChar(DllFileName));tryifGetDllHWND<32thenbeginMessageBox(0,Pchar('没有找到'+DllFileName+'DLL文件！'),'加载DLL失败',MB_OK);Exit;end;@RunForm:=GetProcAddress(GetDllHWND,pchar(methodName));if@RunForm<>nilthentryRunForm(DllFormName);exceptraiseException.Create('对不起,找不到T'+DllFormName+'窗体！');endelseraiseException.Create('无效的方法名调用');finallyFreeLibrary(GetDllHWND);end;end;procedureTForm1.Button1Click(Sender:TObject);beginCreateDllForm('project1.dll','form1','ShowFormByName');end;",2014/4/24
715,在OCX控件上实现Ctrl+C复制功能,张守伟,http://180.168.156.212:2262/wecenter/?/article/8567,"在OCX控件上实现Ctrl+C复制功能这个问题是在通用浏览器上碰到的，客户要求在查看Txt文件、Office文件、PDF文件的时候能复制里面的内容。首先我想到的就是拦截键盘事件KeyDown，实现方法：定义事件procedureDoMouseKeyDown(Sender:TObject;varKey:Word;Shift:TShiftState);关联事件procedureTCESBrowserX.Initialize;begininheritedInitialize;...OnKeyDown:=DoMouseKeyDown;...end;实现事件procedureDoMouseKeyDown(Sender:TObject;varKey:Word;Shift:TShiftState);begin判断按键。end;这个方法在查看Txt文件的时候，可以拦截到键盘按键事件，因为查看Txt文件是使用Delphi7自带的TMemo控件，但是查看Office文件的时候及PDF文件的时候就根本拦截不到键盘按键事件，因为后两者都是第三方OCX控件（AutoVueX.ocx和FoxitReader_AX_Pro.ocx）。经过反复的测试没有找到好的办法，于是想到用弹出菜单的方式，因为查看Txt文件和PDF文件的控件都有弹出菜单，只有AutoVueX控件没有弹出菜单，那么就自己定义一个菜单，于是在主窗体添加一个TPopupMent，命名为pmPopupMenu，并添加菜单项(按钮)TMenuItem;命名为miCopy，在miCopy的单击事件里添加代码：procedureTCESBrowserX.miCopyClick(Sender:TObject);beginSendMessage(ActiveControl.Handle,WM_COPY,0,0);end;为TFunction类型及其子类的Initialize函数增加一个参数(APopupMent:TPopupMenu)，然后把pmPopupMenu传为AutoVueX对象的PopupMenu属性。这样就可以通过单击右键，用弹出的菜单功能实现复制，但单击复制按钮时，会报地址错误，于是把上面代码改为：procedureTCESBrowserX.miCopyClick(Sender:TObject);vartmpMPos:TPoint;beginGetCursorPos(tmpMPos);SendMessage(WindowFromPoint(tmpMPos),WM_COPY,0,0);end;这样就不报错了，而且可以复制，但是复制的中文部分粘贴出来会是乱码，还要再做修改，如下：procedureTCESBrowserX.miCopyClick(Sender:TObject);vartmpMPos:TPoint;tmpStr:string;beginGetCursorPos(tmpMPos);SendMessage(WindowFromPoint(tmpMPos),WM_COPY,0,0);tmpStr:=UTF8Decode(Clipboard.AsText);Clipboard.AsText:=tmpStr;end;OK，可以了。但是现在还是有一个问题，就是在AutoVueX控件里，如果滚动条往下拉，然后选择文字，再单击右键，此时滚动条会自动往上跑，其实这是AutoVueX的本身的BUG，单击右键的时候滚动条不但会往上跑，而且显示内容会缩小，我以前做过处理的，就是定义一个变量记住当前状态，当单击右键的时候，再根据变量的值恢复它的状态，所以现在它不会变小了。我也想过用同样的方法来保存并重新设置滚动条的位置，但是经过反复偿试没能成功。到此为止，我已经用了一天的时间，现在虽然可以实现，但是不是很完美，我想，应该还有更好的方法。后来听说用键盘钩子可以实现，于是测试，SetWindowsHookEx(0,@LowLevelKeyboardProc,HInstance,0);挂接的钩子在XP下运行正常，但在Win7下却无法挂接成功。后来发现把第一个参数0改为13即可。钩子实现代码：unituHHOOK;interfaceusesWindows,Messages,Forms,SysUtils;type//TKeyBoardProc=function(nCode:Integer;WParam:WPARAM;LParam:LPARAM):LRESULTofobject;stdcall;TCopyData=procedureofobject;tagKBDLLHOOKSTRUCT=packedrecordvkCode:DWORD;scanCode:DWORD;flags:DWORD;time:DWORD;dwExtraInfo:DWORD;end;KBDLLHOOKSTRUCT=tagKBDLLHOOKSTRUCT;PKBDLLHOOKSTRUCT=^KBDLLHOOKSTRUCT;constWH_KEYBOARD_LL=13;LLKHF_ALTDOWN=$20;functionEnableHHOOK:Boolean;stdcall;functionDisableHHOOK:Boolean;stdcall;varhHk:HHOOK;//ExecKeyBoardProc:TKeyBoardProc;ExecCopyData:TCopyData;implementationusesCESBrowserImpl1;functionLowLevelKeyboardProc(nCode:Integer;WParam:WPARAM;LParam:LPARAM):LRESULT;stdcall;varp:PKBDLLHOOKSTRUCT;beginResult:=0;p:=PKBDLLHOOKSTRUCT(lParam);if(nCode=HC_ACTION)thenbeginif(wParam=WM_KEYDOWN)or(wParam=WM_SYSKEYDOWN)or(wParam=WM_KEYUP)or(wParam=WM_SYSKEYUP)thenbegincasep.vkCodeof67:beginifGetKeyState(VK_CONTROL)and$8000<>0thenbeginResult:=1;ExecCopyData;end;end;end;end;end;ifnCode<>0thenResult:=CallNextHookEx(0,nCode,wParam,lParam);end;functionEnableHHOOK:Boolean;stdcall;beginifhHk=0thenbeginhHk:=SetWindowsHookEx(13,@LowLevelKeyboardProc,HInstance,0);Result:=True;endelseResult:=False;end;functionDisableHHOOK:Boolean;stdcall;beginifhHk<>0thenbeginUnHookWindowsHookEx(hHk);hHk:=0;Result:=True;endelseResult:=False;end;end.在主程序里调用EnableHHOOK即可开启键盘钩子功能，这样就可以拦截到Ctrl+C按键，程序退出的时候调用DisableHHOOK删除钩子。现在通过钩子，可以接收到键盘按键事件了，剩下的事情就是实现复制功能了，其实理论上很简单，就是把miCopyClick事件里的代码拿过来就可以用了，但是，由于TCESBrowserX没有声明实例，所以外面无法调用其内部的函数，于是定义一个类型：TCopyData=procedureofobject;并声明变量：ExecCopyData:TCopyData;在TCESBrowserX里声明一个公用函数：procedureTCESBrowserX.DoCopyData;vartmpMPos:TPoint;tmpStr:string;beginGetCursorPos(tmpMPos);SendMessage(WindowFromPoint(tmpMPos),WM_COPY,0,0);tmpStr:=UTF8Decode(Clipboard.AsText);Clipboard.AsText:=tmpStr;end;主窗体创建的时候ExecCopyData:=DoCopyData;在LowLevelKeyboardProc函数里，判断到Ctrl+C组合按键时就调用ExecCopyData;这样就可以实现复制功能了，但是很遗憾，复制现来的内容为空，同样的代码，在右键按钮单击时调用可以，而在钩子调用就不行。后来把EnableHHOOK和LowLevelKeyboardProc声明到TCESBrowserX里面，编译时SetWindowsHookEx(13,@LowLevelKeyboardProc,HInstance,0)报错，错误位置在第二个参数，这里引用的不能是类内部函数，必须是全局函数，于是还是使用外面的LowLevelKeyboardProc函数，运行测试，还是复制不到内容。关键是LowLevelKeyboardProc要做为TCESBrowserX内部函数，于是再做调整，把LowLevelKeyboardProc声明在TCESBrowserX的内部，EnableHHOOK声明在外面，再定义类型：TKeyBoardProc=function(nCode:Integer;WParam:WPARAM;LParam:LPARAM):LRESULTofobject;stdcall;然后声明一个全局变量：ExecKeyBoardProc:TKeyBoardProc;在主窗体创建的时候ExecKeyBoardProc:=LowLevelKeyboardProc;然后在EnableHHOOK里引用ExecKeyBoardProc，运行跟踪查看，跟踪到LowLevelKeyboardProc函数的时候，看到，传进来的参数值都不对，所以就不能正确的判断Ctrl+C按键。把这些判断去掉，直接调用DoCopyData;进行复制，经测试，OK的，但是现在唯一的问题就是怎么能让LowLevelKeyboardProc参数传入的数据正确，又是经过一段时间的测试，没有找到解决方法。再调整代码，把LowLevelKeyboardProc定义到外面，见上面表格中的代码(TKeyBoardProc定义及其变量定义作废)，修改DoCopyData函数的内容：procedureTCESBrowserX.DoCopyData;varActiveHandle:THandle;//当前活动窗体ThreadIDFocusHandle:THandle;//焦点控件CurHandle:THandle;//本程序ThreadIDtmpStr:string;beginCurHandle:=GetCurrentThreadID;ActiveHandle:=GetWindowThreadProcessID(GetForeGroundWindow,nil);AttachThreadInput(CurHandle,ActiveHandle,True);FocusHandle:=GetFocus;SendMessage(FocusHandle,WM_COPY,0,0);tmpStr:=UTF8Decode(Clipboard.AsText);Clipboard.AsText:=tmpStr;end;然后运行测试，OK了，查看Office文档时可以复制到正确的内容，查看Txt文件时也可以复制到正确的内容，但是查看PDF文档时，却复制不到内容，可能是FoxitReader_AX_Pro.ocx控件屏蔽到了这个消息。通过查找，发现TFoxitReaderSDK有一个方法GetSelectedText可以获得当前选择的文本，那么在这里就作判断了，如果是PDF就要利用这个方法来实现复制功能了，首先为IFunction接口及其实现的类和子类中添加一个方法：functionGetSelectText:string;virtual;abstract;然后对上面的函数进行修改：procedureTCESBrowserX.DoCopyData;varActiveHandle:THandle;//当前活动窗体ThreadIDFocusHandle:THandle;//焦点控件CurHandle:THandle;//本程序ThreadIDtmpStr:string;begintmpStr:='';ifg_FunctionOption.FunctionType='PDF'thenbeginifAssigned(g_IFunctionObj)thentmpStr:=g_IFunctionObj.GetSelectText;endelsebeginCurHandle:=GetCurrentThreadID;ActiveHandle:=GetWindowThreadProcessID(GetForeGroundWindow,nil);AttachThreadInput(CurHandle,ActiveHandle,True);FocusHandle:=GetFocus;SendMessage(FocusHandle,WM_COPY,0,0);tmpStr:=UTF8Decode(Clipboard.AsText);end;Clipboard.AsText:=tmpStr;end;这样的话，就可以根据文件类型调用对应的方法了。",2014/4/23
716,一 张 图 证 明 谷 歌 的 安 卓 是 山 寨 我 天 朝 的 。。。。,王链玮,http://180.168.156.212:2262/wecenter/?/article/8566,上图青铜小人.jpg,2014/4/18
717,别哭，水晶石----中国数字帝国的覆灭,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8565,听到水晶石公司一年功夫濒临破产，相当震惊…… ?action-viewnews-itemid-70908,2014/4/10
718,查找当前程序外部指定窗体代码,许海宝,http://180.168.156.212:2262/wecenter/?/article/8564,"当我们调用外部程序的窗体资源时,因为不是自己写的程序没有源码,无法调用,遇到这类问题可以用windows系统API,用枚举窗体函数来解决EnumChildWindows举例说明如下:遍历窗体函数EnumChildWindows(FFoxitReaderSDK_Ctrl.Handle,@EnumProc,FFoxitReaderSDK_Ctrl.Handle);遍历FFoxitReaderSDK_Ctrl.Handle的所有子窗口枚举窗体回调函数functionEnumProc(hwnd,lparam:Integer):Boolean;varbuffer:array[0..255]ofchar;p:PChar;str:string;beginResult:=True;GetClassName(hwnd,buffer,256);str:=StrPas(Buffer);ifstr='AfxControlBar42s'thenbegingetmem(p,255);getwindowtext(hwnd,p,255);str:=StrPas(p);ifstr='DockContainer'thenbeginSendMessage(hwnd,$0010,0,0);Result:=False;end;freemem(p);end;end;",2014/4/9
719,delphi控件消息截获处理问题,许海宝,http://180.168.156.212:2262/wecenter/?/article/8562,"平时我们用控件,由于控件本身的功能局限性,缺少一些事件,这时我们可以控件循环处理消息的原理来截获控件的消息来处理相应的代码,来扩展控件没有的功能举例如下:截获ScrollBox1控件的声明老的消息处理方法临时变量OldWndProc:TWndMethod;窗体初始化OldWndProc:=ScrollBox1.WindowProc;//存放老的消息处理代码ScrollBox1.WindowProc:=WndProc;//使用新的消息处理代码WndProc处理代码procedureTForm1.WndProc(varMessage:TMessage);varScrl:TWMVScroll;beginwithMessagedo///////////////增加自己的消息处理代码caseMsgofWM_VSCROLL:beginScrl:=TWMVScroll(Message);caseScrl.ScrollCodeofSB_THUMBTRACK:beginScrollBox2.VertScrollBar.Position:=Scrl.Pos;end;SB_LINEUP:beginScrollBox2.VertScrollBar.Position:=ScrollBox1.VertScrollBar.Position;end;end;end;end;OldWndProc(Message);///回调老的消息处理代码end;",2014/4/9
720,打开Oracle表时报“数据类型不支持”的原因及处理,张守伟,http://180.168.156.212:2262/wecenter/?/article/8563,"在Oracle数据库中有一个表，里面有这样的字段：…(dlIDnumber(10,0)PRIMARYKEY,dlTimeTIMESTAMP,dlOperatorvarchar(50),dlFileNamevarchar(100),dlUservarchar(50))当使用select*from打开表时，就报错(如题)，后来经过多次测试才知道原来是TIMESTAMP这个数据类型的问题，这可能是由于Oracle版本的问题造成的吧。第一次遇到这个问题，还真难判断它是由TIMESTAMP这个数据类型造成的，还以为是由于代码书错误造成的呢。对于这个问题的解决，要么就是更换Oracle的版本，要么就是把这个类型改为varchar类型。相对来说，后者应该更易操作一些。",2014/4/9
721,转换目标类型为字符串技巧总结,孙传金,http://180.168.156.212:2262/wecenter/?/article/8561,"在实际开发中，我们会遇到以特定格式显示字符串的场景，那么如何能高效简洁的实现这样的功能，在以下的文章中大家将会体会到如何简单的实现想要的功能：一、Format的用法首先看它的声明：functionFormat(constFormat:string;constArgs:arrayofconst):string;overload;事实上Format方法有两个种形式，另外一种是三个参数的，主要区别在于它是线程安全的，但并不多用，所以这里只对第一个介绍：functionFormat(constFormat:string;constArgs:arrayofconst):string;overload;Format参数是一个格式字符串，用于格式化Args里面的值的。Args又是什么呢，它是一个变体数组，即它里面可以有多个参数，而且每个参数可以不同。如以下例子：Format('mynameis%6s',['wind']);返回后就是mynameiswind现在来看Format参数的详细情况：Format里面可以写普通的字符串，比如'mynameis'但有些格式指令字符具有特殊意义，比如""%6s""格式指令具有以下的形式：""%""[index"":""][""-""][width]["".""prec]type它是以""%""开始,而以type结束，type表示一个具体的类型。中间是用来格式化type类型的指令字符，是可选的。先来看看type,type可以是以下字符：d十制数，表示一个整型值u和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时是一个2的32次方减去这个绝对值的数如：Format('thisis%u',[－2]);返回的是：thisis4294967294f对应浮点数e科学表示法，对应整型数和浮点数，比如Format('thisis%e',[-2.22]);返回的是：thisis-2.22000000000000E+000等一下再说明如果将数的精度缩小g这个只能对应浮点型，且它会将值中多余的数去掉比如Format('thisis%g',[02.200]);返回的是：thisis2.2n只能对应浮点型，将值转化为号码的形式。看一个例子就明白了Format('thisis%n',[4552.2176]);返回的是thisis4,552.22注意有两点，一是只表示到小数后两位，等一下说怎么消除这种情况二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的m钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化另外它只对应于浮点值Format('thisis%m',[9552.21]);返回：thisis￥9,552.21p对应于指针类型，返回的值是指针的地址，以十六进制的形式来表示例如：varX:integer;p:^integer;beginX:=99;p:=@X;Edit1.Text:=Format('thisis%p',[p]);end;Edit1的内容是：thisis0012F548s对应字符串类型，不用多说了吧x必须是一个整形值，以十六进制的形式返回Edit1.Text:=Format('thisis%X',[15]);返回是：thisisF类型讲述完毕，下面介绍格式化Type的指令：[index"":""]这个要怎么表达呢，看一个例子Format('thisis%d%d',[12,13]);其中第一个%d的索引是0，第二个%d是1，所以字符显示的时候是这样thisis1213而如果你这样定义：Format('thisis%1:d%0:d',[12,13]);那么返回的字符串就变成了thisis1312现在明白了吗，[index"":""]中的index指示Args中参数显示的顺序还有一种情况，如果这样Format('%d%d%d%0:d%d',[1,2,3,4])将返回12312。如果你想返回的是12314，必须这样定：Format('%d%d%d%0:d%3:d',[1,2,3,4])但用的时候要注意，索引不能超出Args中的个数，不然会引起异常如Format('thisis%2:d%0:d',[12,13]);由于Args中只有1213两个数，所以Index只能是0或1，这里为2就错了[width]指定将被格式化的值占的宽度，看一个例子就明白了Format('thisis%4d',[12]);输出是：thisis12这个是比较容易，不过如果Width的值小于参数的长度，则没有效果。如：Format('thisis%1d',[12]);输出是：thisis12[""-""]这个指定参数向左齐，和[width]合在一起最可以看到效果：Format('thisis%-4d,yes',[12]);输出是：thisis12,yes["".""prec]指定精度，对于浮点数效果最佳：Format('thisis%.2f',['1.1234]);输出thisis1.12Format('thisis%.7f',['1.1234]);输了thisis1.1234000而对于整型数，如果prec比如整型的位数小，则没有效果反之比整形值的位数大，则会在整型值的前面以0补之Format('thisis%.7d',[1234]);输出是：thisis0001234]对于字符型，刚好和整型值相反，如果prec比字符串型的长度大则没有效果，反之比字符串型的长度小，则会截断尾部的字符Format('thisis%.2s',['1234']);输出是thisis12而上面说的这个例子：Format('thisis%e',[-2.22]);返回的是：thisis-2.22000000000000E+000怎么去掉多余的0呢，这个就行啦Format('thisis%.2e',[-2.22]);二、FormatDateTime的用法声明为：functionFormatDateTime(constFormat:string;DateTime:TDateTime):string;overload;当然和Format一样还有一种，但这里只介绍常用的第一种Format参数是一个格式化字符串。DateTime是时间类型。返回值是一种格式化后的字符串重点来看Format参数中的指令字符c以短时间格式显示时间，即全部是数字的表示FormatdateTime('c',now);输出为：2004-8-79:55:40d对应于时间中的日期，日期是一位则显示一位，两位则显示两位FormatdateTime('d',now);输出可能为1～31dd和d的意义一样，但它始终是以两位来显示的FormatdateTime('dd',now);输出可能为01～31ddd显示的是星期几FormatdateTime('ddd',now);输出为:星期六dddd和ddd显示的是一样的。但上面两个如果在其他国家可能不一样。ddddd以短时间格式显示年月日FormatdateTime('ddddd',now);输出为：2004-8-7dddddd以长时间格式显示年月日FormatdateTime('dddddd',now);输出为：2004年8月7日e/ee/eee/eeee以相应的位数显示年FormatdateTime('ee',now);输出为：04（表示04年）m/mm/mmm/mmmm表示月FormatdateTime('m',now);输出为：8FormatdateTime('mm',now);输出为08FormatdateTime('mmm',now);输出为八月FormatdateTime('mmmm',now);输出为八月和ddd/dddd一样，在其他国家可能不同yy/yyyy表示年FormatdateTime('yy',now);输出为04FormatdateTime('yyyy',now);输出为2004h/hh,n/nn,s/ss,z/zzz分别表示小时，分，秒,毫秒t以短时间格式显示时间FormatdateTime('t',now);输出为10:17tt以长时间格式显示时间FormatdateTime('tt',now);输出为10:18:46ampm以长时间格式显示上午还是下午FormatdateTime('ttampm',now);输出为：10:22:57上午大概如此，如果要在Format中加普通的字符串，可以用双引号隔开那些特定义的字符，这样普通字符串中如果含特殊的字符就不会被显示为时间格式啦：FormatdateTime('""todayis""c',now);输出为：todayis2004-8-710:26:58时间中也可以加""-""或""\""来分开日期：FormatdateTime('""todayis""yy-mm-dd',now);FormatdateTime('""todayis""yy\mm\dd',now);输出为：todayis04-08-07也可以用"":""来分开时间FormatdateTime('""todayis""hh:nn:ss',now);输出为：todayis10:32:23三、FormatFloat的用法声明为：functionFormatFloat(constFormat:string;Value:Extended):string;overload;和上面一样Format参数为格式化指令字符，Value为Extended类型为什么是这个类型，因为它是所有浮点值中表示范围最大的，如果传入该方法的参数比如Double或者其他，则可以保存不会超出范围。关键是看Format参数的用法0这个指定相应的位数的指令。比如：FormatFloat('000.000',22.22);输出的就是022.220注意一点，如果整数部分的0的个数小于Value参数中整数的位数，则没有效果如：FormatFloat('0.00',22.22);输出的是：22.22但如果小数部分的0小于Value中小数的倍数，则会截去相应的小数和位数如：FormatFloat('0.0',22.22);输出的是：22.2也可以在整数0中指定逗号，这个整数位数必须大于3个，才会有逗号出句FormatFloat('0,000.0',2222.22);输出是：2,222.2如果这样FormatFloat('000,0.0',2222.22);它的输出还是：2,222.2注意它的规律#和0的用法一样，目前我还没有测出有什么不同。FormatFloat('##.##',22.22);输出是：22.00E科学表示法，看几个例子大概就明白了FormatFloat('0.00E+00',2222.22);输出是2.22E+03FormatFloat('0000.00E+00',2222.22);输出是2222.22E+00FormatFloat('00.0E+0',2222.22);22.2E+2",2014/4/9
722,Delphi处理科学计数的浮点数时存在的问题及解决思路,张守伟,http://180.168.156.212:2262/wecenter/?/article/8560,"在处理带有科学计数的浮点数时发现所得到的结果总是不对，后来经过测试发现Delphi在处理这类浮点数时存一些问题，比如把科学计数法的浮点数用FormatFloat转换成字符串时，得到的结果是0，如果用科学计数法的浮点数与别的数字进行计算，那么科学计数法的浮点数是以0的值参与计算的。下面以实例说明：这里是部分主要的代码Unit………….privateFTestValue,FTestX:Double;functionMove_E_In_Num(AValue:Double):Double;public{Publicdeclarations}end;varForm1:TForm1;implementation{$R*.dfm}procedureTForm1.FormCreate(Sender:TObject);beginFTestValue:=4.8984254153e-16;//赋值一个科学计数法的浮点数end;procedureTForm1.btn1Click(Sender:TObject);beginEdit1.Text:=FormatFloat('0.00####',FTestValue);//值为0Edit2.Text:=FloatToStr(FTestValue);//值为4.8984254153e-16FTestX:=1;FTestX:=FTestX-FTestValue;//FTestX的值还是1，因为FTestValue的值被取来后为0Edit3.Text:=FloatToStr(FTestX);end;functionTForm1.Move_E_In_Num(AValue:Double):Double;//对符点数据中的E作简单的处理vartmpPos:Integer;tmpStr:string;begintmpStr:=FloatToStr(AValue);tmpPos:=Pos('E',tmpStr);iftmpPos=0thentmpPos:=Pos('e',tmpStr);iftmpPos>0thentmpStr:=Copy(tmpStr,1,tmpPos-1);Result:=StrToFloat(tmpStr);end;procedureTForm1.Button1Click(Sender:TObject);beginEdit1.Text:=FormatFloat('0.00####',Move_E_In_Num(FTestValue));Edit2.Text:=FloatToStr(Move_E_In_Num(FTestValue));FTestX:=1;FTestX:=FTestX-Move_E_In_Num(FTestValue);Edit3.Text:=FloatToStr(FTestX);end;所以我们在处理以科学计数法表示的浮点数时，必须作些特殊处理，本例只是作为一简单的事例，实际编辑中可能还需要考虑浮点数的有效位数等。",2014/4/9
723,imageEnMView加载图像缩略图与实际图片不符的问题分析,陈军志,http://180.168.156.212:2262/wecenter/?/article/8559,一体机在提交测试过程中，测试人员发现在图片收集模块将图片旋转后，图片并没有旋转，但双击打开后图片已经旋转。针对该问题进行研究后，总结出几点问题：1、JPEG/TIFF文件的头部可以插入EXIF(ExchangeableImageFile(可交换图像文件))信息，而Exif文件实际是JPEG文件的一种，遵从JPEG标准，只是在文件头信息中增加了有关拍摄信息的内容和索引图（主要包括摄影时的光圈、快门、ISO、时间等各种与当时摄影条件相关的讯息，相机品牌型号，色彩编码，拍摄时录制的声音，全球定位系统（GPS）和缩略图等信息）；2、imageEnMView使用默认方式加载缩略的情况下，在缩略图的大小不超过一定值的情况下加载EXIF中的缩略图，当缩略图放大到一定值后，会根据图像重新生成缩略图。3、imageEnMView中加载缩略的情况下，存在一个属性（EnableLoadEXIFThumbnails）可以设置不加载exif中的缩略图，该属性默认为True，当设置为false时，每次会重新生成缩略图，性能上会有一定的影响。4、使用imageEnView的Rotate方法旋转图片后，Exif中的缩略图不会旋转。5、通过软件可以修改exif中的缩略图，所以在使用控件加载缩略图过程中要注意缩略图的准确性和加载速度间的取舍。以上几点在使用缩略图过程中需要注意，以免产生各种异常而浪费大量时间去查找原因。,2014/4/9
724,通过文件头判断文件类型,王孝本,http://180.168.156.212:2262/wecenter/?/article/8558,在后缀未知，或者后缀被修改的文件，依然通过文件头来判断该文件究竟是什么文件类型。方法是：用一个文本编辑工具如UltraEdit打开文件（16进制模式下），然后看文件头是什么字符，以下是常见文件类型的文件头字符，希望对你有帮助：JPEG(jpg)，文件头：FFD8FFPNG(png)，文件头：89504E47GIF(gif)，文件头：47494638TIFF(tif)，文件头：49492A00WindowsBitmap(bmp)，文件头：424DCAD(dwg)，文件头：41433130AdobePhotoshop(psd)，文件头：38425053RichTextFormat(rtf)，文件头：7B5C727466XML(xml)，文件头：3C3F786D6CHTML(html)，文件头：68746D6C3EEmail[thoroughonly](eml)，文件头：44656C69766572792D646174653AOutlookExpress(dbx)，文件头：CFAD12FEC5FD746FOutlook(pst)，文件头：2142444EMSWord/Excel(xls.or.doc)，文件头：D0CF11E0MSAccess(mdb)，文件头：5374616E64617264204AWordPerfect(wpd)，文件头：FF575043Postscript(eps.or.ps)，文件头：252150532D41646F6265AdobeAcrobat(pdf)，文件头：255044462D312EQuicken(qdf)，文件头：AC9EBD8FWindowsPassword(pwl)，文件头：E3828596ZIPArchive(zip)，文件头：504B0304RARArchive(rar)，文件头：52617221Wave(wav)，文件头：57415645AVI(avi)，文件头：41564920RealAudio(ram)，文件头：2E7261FDRealMedia(rm)，文件头：2E524D46MPEG(mpg)，文件头：000001BAMPEG(mpg)，文件头：000001B3Quicktime(mov)，文件头：6D6F6F76WindowsMedia(asf)，文件头：3026B2758E66CF11MIDI(mid)，文件头：4D546864,2014/4/9
725,会议室预定的建议,史服宇,http://180.168.156.212:2262/wecenter/?/article/8557,自从OA系统中会议室预定功能上线以来，大家都遵守先订先得的规则，紧张有序。现在碰到的问题是，有的部门滥用了预定的功能，一下子占了好多的会议室，即使会议取消系统里也不更新，别人都没办法下单了会议室资源非常紧张，经常碰到要开会找不到会议室的情况。我倡议大家相互体谅，提高会议效率，合理使用会议室，营造和谐社会。1.最多提前2周预定会议室2.每次会议时间不超过2小时，杜绝一订一整天的情况发生。如果仍有人大量占用会议室，建议财务部按照预定时间结算使用成本，每月公布，年底划账。,2014/4/4
726,2013大数据全球技术峰会讲师PPT,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8556,毋庸置疑，大数据时代已经到来，谁能成为这一波浪潮的弄潮儿？ 大数据.ppt大数据2.pdf,2014/4/2
727,骑行爱好者,胡学伟,http://180.168.156.212:2262/wecenter/?/article/8555,公司有没有正在爱好骑行或即将爱好骑行的汽油，请留下联系方式，方便相约,2014/4/2
728,热闹庆祝中信论坛上线一周年,杨木江,http://180.168.156.212:2262/wecenter/?/article/8554,掌声、鲜花声。。。。。。。。。。。。。。。。。。。,2014/4/1
729,中信学院能否对外招生,杨木江,http://180.168.156.212:2262/wecenter/?/article/8553,为了能够挑选好的应届毕业生，并进行岗前针对公司技术及业务的培训，同时识别好的毕业生为我所用。我想我们能否将中信学院对外（主要面向应届毕业生）招生，类似现有的职前培训机构一样。我们的优势会更明显，因为我们能够直接提供就业机会。同时培训费用可以少取甚至全免（确定通过考核并被中信录取）。从而让中信学院成为中信的人才后备（储备）中心，同时也为在职人员提供深造能力。希望中信学院能够实现真正的开班授课。,2014/4/1
730,存储---DAS,叶剑挺,http://180.168.156.212:2262/wecenter/?/article/8552,存储系统是整个IT系统的基石，是IT技术赖以存在和发挥效能的基础平台。早先的存储形式是存储设备（通常是磁盘）与应用服务器其他硬件直接安装于同一个机箱之内，并且该存储设备是给本台应用服务器独占使用的。随着服务器数量的增多，磁盘数量也在增加，且分散在不同的服务器上，查看每一个磁盘的运行状况都需要到不同的应用服务器上去查看。更换磁盘也需要拆开服务器，中断应用。于是，一种希望将磁盘从服务器中脱离出来，集中到一起管理的需求出现了。不过，一个问题：如何将服务器和盘阵连接起来？面临这样的问题，有厂商提出了SCSI协议，通过专用的线缆将服务器的总线和存储设备连接起来，通过专门的SCSI指令来实现数据的存储。后来发展到FC协议。这样，多个服务器可以通过SCSI线缆或光纤建立与存储系统的连接。这样的方式，我们称之为直接附加存储（DAS）。DAS（DirectAttachedStorage—直接附加存储）是指将存储设备通过SCSI线缆或光纤通道直接连接到服务器上。一个SCSI环路或称为SCSI通道可以挂载最多16台设备；FC可以在仲裁环的方式下支持126个设备；DAS方式实现了机内存储到存储子系统的跨越，但是缺点依然有很多：u扩展性差，服务器与存储设备直接连接的方式导致出现新的应用需求时，只能为新增的服务器单独配置存储设备，造成重复投资。u资源利用率低，DAS方式的存储长期来看存储空间无法充分利用，存在浪费。不同的应用服务器面对的存储数据量是不一致的，同时业务发展的状况也决定这存储数据量的变化。因此，出现了部分应用对应的存储空间不够用，另一些却有大量的存储空间闲置。u可管理性差，DAS方式数据依然是分散的，不同的应用各有一套存储设备。管理分散，无法集中。异构化严重，DAS方式使得企业在不同阶段采购了不同型号不同厂商的存储设备，设备之间异构化现象严重，导致维护成本据高不下。,2014/3/24
731,其实很多时候是这样的。。。,叶剑挺,http://180.168.156.212:2262/wecenter/?/article/8551,很多时候是这样的。。。。问题已经发生的情况！但是没有现成的处理机制或者没有应急机制！在项目管理的流程中其实我们需要这些机制，防止犯错及能够纠正错误！,2014/3/24
732,可爱的流程，可爱的你，可爱的项目经理！,叶剑挺,http://180.168.156.212:2262/wecenter/?/article/8550,1.流程流畅是关键2.人员专业是关键售前大哥：你好，第一时间发份方案发给我吧，也大可告知那些东西是完全行不通的或者是非设计因素添加的！都是技术工种嘛，互相帮助！另外，请考虑下辅材吧，至少设计些辅材费用！因为后期没有费用处理项目比较麻烦，辛苦您了！销售大姐：百忙时间内把项目合同发给我吧！领导要求项目经理的周报里也需要写项目金额，另外各位，如果下单的时候能提前告诉我一声，那就太好了！采购妹子：采购单流转到你哪儿的时候，麻烦你通知我一声买了些什么以及什么时候到货！这样我心里有点底，知道有没有辅材采购，有多少设备可能需要另行采购及多出的东西的，其实，有些内容超出你们工作范畴了。当然还是请告知设备大致的到货时间。谢谢！仓库帅哥：发货单请一定记得发出来，让客户签字或者直接到达现场的货物一定让项目经理帮忙确认，如果客户（单项货物太多的情况）真心不愿意签多个。记得问项目经理要一份供货单做确认。另外，让项目经理做确认的时候，你问采购妹子要一份采购清单发给项目经理，多重确认总不会错的！特别是工程类项目的时候，一般都是项目经理才知道到底用了那些东西，你问采购妹子拿到供货商提供的供货清单后，一定准备一份发货单给项目经理。项目经理能与供货商确认的是现场货物。但是不一定与你的发货单对上的。项目经理也是人呀，也会出错的！,2014/3/24
733,Windows 8 x64 使用公司的VPN（原创）,孙进,http://180.168.156.212:2262/wecenter/?/article/8549,我的电脑安装的是64位的Windows8，相信很多同学也跟我一样，当公司外网直接访问内网OA的地址关闭之后，尝试通过“员工入口”链接访问内网，一直没有成功，这个问题困扰了我很长时间，经过一翻折腾之后，终于搞定了，现在将解决方案与大家分享。Windows8x64使用公司的VPN（原创）.docxVPN安装-win864位.rar,2014/3/15
734,最新福利：IOS企业级APP发布概述,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8548,公司IOS企业级开发账号已经申请成功。企业级APP的发布将不再需要苹果的审核、而是可以直接将APP部署到公司网站上，用户也可以直接扫描公司提供的二维码进行下载安装。现在奉上企业级APP部署文档，请笑纳iOS企业证书发布App流程.docx,2014/3/14
735,Delphi中使用Office中VBA的优缺点,孙传金,http://180.168.156.212:2262/wecenter/?/article/8547,"在Delphi中使用OLE来与Office应用程序通讯，不外乎两种方式：直接使用VBA和使用Delphi的封装组件(TExcelApplication,TExcelWorkbook,TExcelSheet等等)，两种方式各有优劣。这里简要谈谈直接VBA调用方式。直接使用VBA的优点：1：参数传递方面比较灵活。比如打开文档函数Workbooks.Open，它有很多可选参数（可以认为等同于默认参数），在VBA中定义如下：FunctionOpen(FilenameAsString,[UpdateLinks],[ReadOnly],[Format],[Password],[WriteResPassword],[IgnoreReadOnlyRecommended],[Origin],[Delimiter],[Editable],[Notify],[Converter],[AddToMru],[Local],[CorruptLoad])AsWorkbook在一般的编程语言中，是不可以跳过参数表中某个参数而传递后面的参数的，所以几乎所有的语言都要求例程的默认参数必须定义在参数表的最后。而使用VBA可以做到参数的跳跃传递。比如要以只读方式打开文档“D:\Test.xls”，就可以这样调用Open函数：xlApp:=CreateOleObject('Excel.Application');xlApp.Caption:='Delphi中使用VBA与Excel通讯';xlApp.Visible:=True;xlApp.Workbooks.Open(FileName:='D:\Test.xls',ReadOnly:=True);请注意，上面的调用在传递参数时跳过了参数UpdateLinks。我是在Excel中录制宏并参考其代码后才想到在Delphi中也这样写试试的，结果运行通过。这种写法我从来没在Delphi中见过，感到不可思议。所以说，有想法就要实践！2：可以在Office应用程序中录制宏，然后将生成的宏代码稍加修改就可以复制到Delphi中，简化了代码的编写。参考宏代码时要注意去除无用的冗余代码。比如你打开字体对话框，仅改变字体大小，但是在录制的宏代码中会设置所有的字体选项，你需要删除冗余代码。3：可以传递多种VBA能识别的格式的参数。比如：xlSheet.Columns[1]表示第一列xlSheet.Columns['A:G']表示1-7列有优点自然也有缺点，直接使用VBA的缺点是1：使用Variant来代表OLE对象属于后期绑定方式，效率较低2：手动编写代码时比较烦琐，因为没有了代码提示功能，并且不能使用with……do来简化代码",2014/3/12
736,外出日志新增外出时间没效果？权限不够？？,李志雄,http://180.168.156.212:2262/wecenter/?/article/8546,第一次填外出日志，想想还有点小激动。。。。万万没想到会有这样的悲剧，，，，外出明细填写一切如常，当新增外出时间可是报null了啊，，，没看错，是报null了。导致时间填不了，单子不能提交再去看同事的，一切如常啊！难道是我没权限填时间？求解决啊！！！！！有图有真相，下面有图报错图片.JPG皮肤样式设置.jpg皮肤样式设置.jpg,2014/3/12
737,delphi实现幻灯片播放功能 (照片切换时有淡入淡出效果),陈军志,http://180.168.156.212:2262/wecenter/?/article/8545,"最近一体机项目需要实现全屏幻灯片播放功能，在完成基本功能的基础上通过以下方法实现了两张照片切换时淡入淡出的效果。以下单元文件具有播放幻灯片和文件的功能，主要代码如下，1：初始化函数：（通过该函数可以传入一组或一张照片，通过Type来控制播放样式（全屏幻灯片播放或者照片浏览））procedureTfrmShowSlide.initShowSlide(lsFileList:TStringList;sType:integer);vari,j,k:Integer;beginFileList:=lsFileList;FType:=sType;ifsType=0thenbeginifFileList.count>0thenSelf.Caption:=ExtractFileName(FileList.Strings[0])elseSelf.Caption:='照片浏览';Self.BorderStyle:=bsSingle;self.WindowState:=wsMaximized;endelsebeginSelf.BorderStyle:=bsNone;Self.Caption:='幻灯片播放';self.WindowState:=wsMaximized;tmrSlide.Enabled:=True;end;ifFileList.count>0thenbeginFindex:=0;ifsType=0thenspnlShowImageIndex.Visible:=FalseelsespnlShowImageIndex.Caption:=IntToStr(Findex+1)+'/'+inttostr(FileList.Count);imgShowimage.IO.LoadFromFile(FileList.Strings[Findex]);ifsType=0thenbeginimgShowimage.Fit;endelsebeginj:=imgShowimage.LayersCurrent;imgShowimage.Layers[j].Transparency:=15;end;end;end;2.加入第一个时钟控件，具体事件如下：（通过该控件可以控制播放的速度，及淡入效果）procedureTfrmShowSlide.tmrSlideTimer(Sender:TObject);vari,j,k:Integer;begintmrSlide.Enabled:=False;ifnotAssigned(FileList)or(FileList.Count=0)thenExit;if(Findex=-1)or(Findex=FileList.count-1)thenbeginFindex:=0;end;imgShowimage.Clear;spnlShowImageIndex.Caption:=IntToStr(Findex+1)+'/'+inttostr(FileList.Count);imgShowimage.IO.LoadFromFile(FileList.Strings[Findex]);inc(Findex);j:=imgShowimage.LayersCurrent;imgShowimage.Layers[j].Transparency:=15;i:=0;while(i<20)dobeginimgShowimage.Layers[j].Transparency:=imgShowimage.Layers[j].Transparency+12;Sleep(100);imgShowimage.Refresh;Application.ProcessMessages;inc(i);end;tmrSlide.Enabled:=True;tmr1.Enabled:=True;end;3.加入第二个时钟控件，通过该控件控制淡出效果：procedureTfrmShowSlide.tmr1Timer(Sender:TObject);vari,j,k:Integer;begintmr1.Enabled:=False;j:=imgShowimage.LayersCurrent;k:=0;while(k<10)dobeginifimgShowimage.Layers[j].Transparency>20thenimgShowimage.Layers[j].Transparency:=imgShowimage.Layers[j].Transparency-20;Sleep(100);imgShowimage.Refresh;Application.ProcessMessages;inc(k);end;end;4.通过FormKeyDown事件控制按下Esc键时，退出播放procedureTfrmShowSlide.FormKeyDown(Sender:TObject;varKey:Word;Shift:TShiftState);beginif(Key=VK_ESCAPE)and(FType=1)thenbegintmrSlide.Enabled:=False;Self.Close;end;end;以上为该功能实现的大致代码。DEMO如附件所示。幻灯片播放.rar",2014/3/5
738,光典4.x ocx点击次数优化与flexpaper在线浏览office文档,方俊新,http://180.168.156.212:2262/wecenter/?/article/8544,详情请见附件02月份经验共享--方俊新.ppt,2014/3/5
739,Jqgrid中的联动和初始化,张伟,http://180.168.156.212:2262/wecenter/?/article/8543,"联动：在dataEventstype:'change'中去实现联动的效果，这里主要是要取得所对应的表单元素varselvalue=$(this).val();//获得选中行varrow=$(""#search1"").jqGrid('getGridParam','selrow');//alert(""selvalue""+selvalue);if(selvalue!='4'){$(""#""+row).find(""td:eq(6)"").find(""select"").css(""visibility"",""hidden"");}else{$(""#""+row).find(""td:eq(6)"").find(""select"").css(""visibility"",""visible"");}初始化：对jqgrid表格中的复选框和下拉列表的初始化有两种方式，一种是内置的formatter:'select’，一种是用formatter:函数名(该函数返回一个html字符串)，第二种通过自定义函数返回一个字符串进行页面的初始化{name:'IS_UPDATE',index:'IS_UPDATE',formatter:'checkbox',edittype:""checkbox"",editable:true,formatoptions:{disabled:false},editoptions:{value:""1:0""}}第一种中只能进行一些简单的初始化，比如下拉选中第几个或者复选框是否选中等第二种就可以通过自定义函数返回所需要的html字符串来显示在表格中这样的话可以对每个元素进行随心所欲的控制（比如可用不可用可见不可见等），但是这样去返回一个checkbox的时候，当你勾上的时候它的返回值永远不会变，需绑定一个事件去改变{name:'IS_UPDATE',index:'IS_UPDATE',align:'center',width:'70%',sortable:true,formatter:currencyFmatter1},下面是currencyFmatter1中的内容if(cellvalue=='1'){html=""<inputtype='checkbox'value='1'checked='checked'onclick='changeValue(this)'>"";}else{html=""<inputtype='checkbox'value='0'onclick='changeValue(this)'>"";}returnhtml；functionchangeValue(v){if(v.checked){v.value=""1"";}else{v.value=""0"";}}研发中心经验共享_张伟[201402].docx",2014/3/5
740,js中文乱码处理以及java文件上传之进度条显示,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8542,"1、javascript弹出中文乱码问题：HTML页面的字符集为GBK，如果在javascript中的alert弹出的对话框出现中文乱码，使用如下方法：<scripttype=""text/javascript""charset=""UTF-8"">functioncheck(){alert(""中文乱码"");}</script>2、java文件上传之进度条显示：插件：commons-fileupload、commons-io进度参数的封装对象：publicclassProcessBanner{privatedoubleupRate=0.0;//上传速度privatedoublepercent=0.01;//上传进度privatelonguseTime=0;//当前耗时量privatelongupSize=0;//已上传大小privatelongallSize=0;//文件大小privateintitem;//当前文件索引值}实现监听器接口：publicclassUploadProgressimplementsProgressListener{privateHttpSessionsession;privateHttpServletRequestrequest;privatedoubleupRate=0.0;//上传速度privatedoublepercent=0.0;//上传进度privatelonguseTime=0;//当前耗时量privatelongupSize=0;//已上传大小privatelongallSize=0;//文件大小privateintitem;//当前文件索引值privatelongbeginT=System.currentTimeMillis();privatelongcurT=System.currentTimeMillis();//构造方法publicUploadProgress(HttpServletRequestrequest){session=request.getSession();ProcessBanneruLister=newProcessBanner();session.setAttribute(""uplistener"",uLister);}/***@parampBytesRead已读入字节数*@parampContentLength文件大小(单位byte)*@parampItems当前文件索引值*/publicvoidupdate(longpBytesRead,longpContentLength,intpItems){curT=System.currentTimeMillis();item=pItems;//文件索引值allSize=pContentLength;//文件大小upSize=pBytesRead;//已读入字节数(byte)useTime=curT-beginT;//用时(ms)if(useTime!=0)upRate=pBytesRead/useTime;elseupRate=0.0;if(pContentLength==0)return;percent=(double)pBytesRead/(double)pContentLength;ProcessBanneruLister=newProcessBanner();uLister=(ProcessBanner)session.getAttribute(""uplistener"");uLister.setAllSize(allSize);uLister.setPercent(percent);uLister.setUpRate(upRate);uLister.setUseTime(useTime);uLister.setUpSize(upSize);//把进度对象封装到session里session.setAttribute(""uplistener"",uLister);}}Java文件上传代码：//准备上传DiskFileItemFactoryfactory=newDiskFileItemFactory();ServletFileUploadupload=newServletFileUpload(factory);upload.setHeaderEncoding(""UTF-8"");//设置进度监听器upload.setProgressListener(newUploadProgress(request));ListfileItems=upload.parseRequest(request);Jsp文件上传提交varint;functionupload(){form.submit();int=window.setInterval(""fileupload()"",50);}functionfileupload(){$.ajax({url:'docAffixUpload.do?flag=false&docID=<%=docID%>',type:""POST"",dataType:""json"",success:function(data){if(data.bannerValue==100){$(""#span"").css(""width"",data.parcent);clearInterval(int);}else{$(""#span"").css(""width"",data.parcent);}}});}研发中心经验共享_毛璀玲[201402].doc",2014/3/5
741,sqlserver里面关于查询到ADOquery字符串 数字排序问题,许海宝,http://180.168.156.212:2262/wecenter/?/article/8541,"一般sqlserver里面的字符串类型字段里面的数字值查询到delphi程序ADOquery数据集里面都是按照字符串排序的，如果里面的是位数不同的数值的话就不会按数值大小排序了解决这个办法可以用特殊sql语句来查询数据集，在grid数据显示控件里面字段标题点击事件加ADOquery数据集排序处理如下selectcasewhenlen(FOLDER_NO)=1then''00000000''+FOLDER_NO'whenlen(FOLDER_NO)=2then''0000000''+FOLDER_NO''whenlen(FOLDER_NO)=3then''000000''+FOLDER_NO'whenlen(FOLDER_NO)=4then''00000''+FOLDER_NO'whenlen(FOLDER_NO)=5then''0000''+FOLDER_NO'whenlen(FOLDER_NO)=6then''000''+FOLDER_NO'whenlen(FOLDER_NO)=7then''00''+FOLDER_NO'whenlen(FOLDER_NO)=8then''0''+FOLDER_NO'elseFOLDER_NOendasFOLDER_NOForSort,feild1,feild2......fromtablenameprocedureTfrmArchZL.dbgrdh2TitleClick(Column:TColumnEh);varLineID:string;beginifqry2.Activeand(notqry2.IsEmpty)thenbeginLineID:=qry2.FieldByName('ID').AsString;if(Column.Title.SortMarker=smNoneEh)or(Column.Title.SortMarker=smDownEh)thenbeginifUpperCase(COLUMN.FIELDNAME)='FOLDER_NO'thenqry2.SORT:='FOLDER_NOForSort'elseqry2.SORT:=COLUMN.FIELDNAME;Column.Title.SortMarker:=smUpEhendelsebeginifUpperCase(COLUMN.FIELDNAME)='FOLDER_NO'thenqry2.SORT:='FOLDER_NOForSort'+'DESC'elseqry2.SORT:=COLUMN.FIELDNAME+'DESC';Column.Title.SortMarker:=smDownEhend;qry2.Locate('ID',LineID,[]);end;end;",2014/3/5
742,EhLib_DBGridEh组件在Delphi中应用全攻略总结,王孝本,http://180.168.156.212:2262/wecenter/?/article/8540,"EhLibDBGridEh组件在Delphi中应用全攻略总结【DBGridEh（增强型表格组件）功能详解】DBGridEh组件无论在外观上还是功能上都非常类似Borland开发工具中现有的dbgrid组件，它除了提供dbgrid组件的全部功能外，还增加了下列新功能:●任意选择多行、列或矩形区域的数据.●为多列标题设定共同的父标题行.●表格底部（Footer）区显示求和、计数和其它统计信息.●自动调整组件宽度与客户区域等宽.●设置标题行、数据行的高度.●超长的标题行、数据行文本自动折行处理.●标题行可作为按钮使用，并可选择是否显示排序标志符（▽降序△升序）.●点击列标题可对当前列自动排序而无需编写代码.●能够自动设置删除超长文本显示不下的多余部分，并以省略号（…）代替.●自动搜索字段（Lookup）数据单元格以单、多列字段下拉列表形式显示.●自动搜索字段（Lookup）数据单元格可进行增量搜索.●可锁定任意列数在屏幕水平方向不滚动.●日期时间控件DateTimepicker可支持TDateFieldandTDateTimeField两种日期格式.●根据字段不同值显示关联的ImageList对象图片组中的图片.●隐藏任意列.●显示3D风格的数据区、表尾区和锁定滚动列，制作3D外观表格.●显示Memo类型字段值.●除BOOLEAN型数据外，其它数据类型也可以检查框(checkbox)形式显示数据.●使用专门的函数和过程来存取以reg或ini文件格式保存的表格布局（包含各数据列表、数据列访问顺序、列宽、索引标识、行高等信息）文件。●通过设置数据单元格的hint和ToolTips属性，当移动鼠标到该单元格时，可以显示单元格容纳不下的文本内容.●将组件中数据导入/导出到Text,Csv,HTML,RTF,XLS和内部数据等多种格式的文件中.【Ehlib在Delphi7中的安装】（我可是花了半天的力气才搞定的哦）Delphi7中的安装方法1.把EhLib中的common和DataService文件夹下的文件拷贝到Delphi7目录中.2.在TOOLS->EnvironmentOptions->Library->LibraryPath中添入EHLIB路径。3.打开新建文件夹中的EHLIB70.dpk,编译一下，但不要安装。4.打开新建文件夹中的EhLibDataDrivers70.dpk,编译一下，但不要安装。5.打开Ehlib中的DclEhLib70.dpk,编译,安装6.打开Ehlib中的DclEhLibDataDrivers70.dpk,编译,安装（实际中不用也可以）7.组件面板中出现一个EhLib的组件页。8.打开附带的DEMOS1，编译并运行，测试安装成功。【DBGridEh控件的页脚属性怎么设】1、将dBGridEh.FooterRowCount:=12、将DBGridEh.SumList.Active:=True;3、将Columns[要求和的字段].Footer.ValueType:=vtSum;就行了，最后要注意，在FormCloseQuery事件中，一定要将SumList.Active:=False，因为在数据集中的数据多了以后，FormClose会让DBGridEh释放所有EhLib资源，会使得退出很慢，所以将SumList.Active:=False不会引起退出很慢（还没有试）。【实现DBGridEh隔行分色显示】procedureTForm1.DBGridEh1GetCellParams(Sender:TObject;Column:TColumnEh;AFont:TFont;varBackground:TColor;State:TGridDrawState);beginifDBGridEh1.SumList.RecNomod2=1thenBackground:=clinfobkelseBackground:=RGB(238,238,238);end;【DBGridEh在某些条件下某行显示特定颜色】procedureTForm1.DBGridEh1GetCellParams(Sender:TObject;Column:TColumnEh;AFont:TFont;varBackground:TColor;State:TGridDrawState);begin//在name字段值为aaa的行设置行背景色（ado设置情况下）ifADOQuery1.FieldByName('name').AsString='aaa'thenBackground:=$00FFC4C4//在xm字段值为Liming的行设置行背景色（bde设置情况下）elseifDBGridEh1.DataSource.DataSet.FieldByName('xm').AsString='Liming'thenBackground:=$00FFC4C4elseBackground:=$00FFDDDD;end;【实现DBGridEh全选】procedureTForm1.N_CopyPolListClick(Sender:TObject);beginif(ActiveControlisTDBGridEh)thenwithTDBGridEh(ActiveControl)doifCheckSelectAllActionand(geaSelectAllEhinEditActions)thenSelection.SelectAll;end;【Ehlib的DBGridEh控件输出文件到EXCEL】（其实EHLIB的DEMO1中已有）procedureTForm1.N_SaveSelectionClick(Sender:TObject);varExpClass:TDBGridEhExportClass;Ext:String;beginSaveDialog1.FileName:='file1';if(ActiveControlisTDBGridEh)thenifSaveDialog1.ExecutethenbegincaseSaveDialog1.FilterIndexof1:beginExpClass:=TDBGridEhExportAsText;Ext:='txt';end;2:beginExpClass:=TDBGridEhExportAsCSV;Ext:='csv';end;3:beginExpClass:=TDBGridEhExportAsHTML;Ext:='htm';end;4:beginExpClass:=TDBGridEhExportAsRTF;Ext:='rtf';end;5:beginExpClass:=TDBGridEhExportAsXLS;Ext:='xls';end;elseExpClass:=nil;Ext:='';end;ifExpClass<>nilthenbeginifUpperCase(Copy(SaveDialog1.FileName,Length(SaveDialog1.FileName)-2,3))<>UpperCase(Ext)thenSaveDialog1.FileName:=SaveDialog1.FileName+'.'+Ext;SaveDBGridEhToExportFile(ExpClass,TDBGridEh(ActiveControl),SaveDialog1.FileName,False);end;end;end;【在DBGridEh中直接点击title就可按点击的那个字段排序的方法】procedureTForm1.DBGridEh1TitleClick(Column:TColumnEh);varsortstring:string;//排序列begin//进行排序withColumndobeginifFieldName=''thenExit;if(Title.SortMarker=smNoneEh)or(Title.SortMarker=smDownEh)thenbeginsortstring:=Column.FieldName+'ASC';;Title.SortMarker:=smUpEh;endelsebeginsortstring:=Column.FieldName+'DESC';Title.SortMarker:=smDownEh;end;tryADOQryPolicyList.Sort:=sortstring;//dataset为实际数据集变量名exceptMessageBox(Handle,'排序出错，请核实后重试！','提示',MB_ICONError);end;end;end;注意：1.在窗体上放置一个DBGridEh组件，并将其连接到相应的BDE数据集；2.将该组件的[OptionsEn]中的dgAutoSortMarking属性设置为True;3.双击该组件，在其弹出的属性编辑器中添加相关字段；4.将要排序的字段的属性列表的[Title]的TitleButton属性设置为True;5.最后，千万不要忘了在uses子句中加上EhlibBDE单元。【DBGridEh从注册表或ini文件中保存或恢复网格和列的层次】TDBGridEh有一个常规设置来从注册表或ini文件中保存和恢复网络以及列的层次：RestoreColumnsLayout-从注册表中恢复列的次序，宽度，排序标志。RestoreColumnsLayoutIni-从ini文件中恢复列的次序，宽度，排序标志。RestoreGridLayout-从注册表中恢复列的次序，宽度，可视，排序标志，排序索引或行高。RestoreGridLayoutIni-从ini文件中恢复列的次序，宽度，可视，排序标志，排序索引或行高。SaveColumnsLayout-保存列的次序，宽度，排序标志到注册表中。SaveColumnsLayoutIni-保存列的次序，宽度，排序标志到ini文件中。SaveGridLayout-保存列的次序，宽度，可视，排序标志，排序索引或行高到注册表中。SaveGridLayoutIni-保存列的次序，宽度，可视，排序标志，排序索引或行高到ini文件中。举例如下：//存储Grid格式inifunctionSaveGridIni(ADBGridEhNameStr:string;ADBGridEh:TDBGridEh):Boolean;varIniFileNameStr:string;beginIniFileNameStr:=ExtractFileDir(ParamStr(0))+'\'+'DBGirdConfig.ini';ADBGridEh.SaveGridLayoutIni(IniFileNameStr,ADBGridEhNameStr,False);end;//加载读取Grid格式inifunctionRestoreGridIni(ADBGridEhNameStr:string;ADBGridEh:TDBGridEh):Boolean;varIniFileNameStr:string;RestoreParams:TDBGridEhRestoreParams;beginIniFileNameStr:=ExtractFileDir(ParamStr(0))+'\'+'DBGirdConfig.ini';ADBGridEh.RestoreGridLayoutIni(IniFileNameStr,ADBGridEhNameStr,RestoreParams);end;",2014/3/5
743,解决Delphi ADO无法为更新定位行。一些值可能已在最后一次读取后已更改的问题,许海宝,http://180.168.156.212:2262/wecenter/?/article/8539,"在Delphi中，如果使用ADOQuery插入数据没有问题,之后对数据进行修改保存时，就会遇到“无法为更新定位行，一些值可能已在最后一次读取后已更改”的问题。原因有这样几种：1.在数据库设计时，为某些字段设置了默认值，在修改进行提交以后，数据库会自动修改对应字段的所有行的默认值，从而导致了数据库与数据集中数据的不一致，使ADOQuery无法对数据集进行定位。2.数据库对应的表没有主键，输入了重复的数据以后，数据库里有两条一样的数据，从而使ADOQuery无法对数据进行定位。解决方法：1.修改数据库设计，不再设置默认值，为数据库表定义主键，保证其唯一性。2.在执行完ADOQuery.Post之后，执行ADOQuery.Refresh，对于设置默认值的情况可以解决。(refresh后dataset中的默认值字段获得了值,跟数据库中一致了)3.改用Insertintosql语句插入,而不是add--post方式.但这种方式不更新其他打开该表的query,所以要requery才行,refresh不起作用.",2014/3/5
744,TClientDataSet使用Aggregates分组函数查询统计,孙传金,http://180.168.156.212:2262/wecenter/?/article/8538,TClientDataSet是一个非常不错的内存数据集，不仅拥有TDataSet通用的数据集功能，还拥有其独特的查询分组统计功能。为了表述方便，TClientDataSet简称为CDS。设置分组功能如下操作：1、首先，必须建立CDS.IndexDefs索引。直接使用CDS.IndexFieldnames是不行，原因是这种简单的建立索引方式无法使用GroupingLevel属性。2、设置Aggregates。3、激活Aggregates。下面是一个例子，比如，我们希望对某个数据集的字段进行分组显示，方法很多，但我们不希望再去从后台数据库查询，希望充分利用现有的CDS数据集进行分组，并将其结果集添加到TStrings（如TCombobox的Items）。functionGetGroupName(cdsData:TClientDataSet;constGroupName:string;GroupList:TStrings):Integer;varCDS:TClientDataSet;sIndexName:string;beginResult:=-1;CDS:=TClientDataSet.Create(nil);tryCDS.DisableControls;sIndexName:='cds_Index_'+GroupName;ifnotcdsData.ActivethenExit;CDS.Data:=cdsData.Data;//复制数据，避免建立索引与原有数据集冲突withCDS.IndexDefs.AddIndexDefdobeginName:=sIndexName;Fields:=GroupName;GroupingLevel:=1;//非常重要的属性end;CDS.IndexName:=sIndexName;//当前使用索引withCDS.Aggregates.AdddobeginGroupingLevel:=1;IndexName:=sIndexName;Visible:=False;Active:=True;end;CDS.AggregatesActive:=True;GroupList.Clear;GroupList.Add('');CDS.First;Result:=0;whilenotCDS.EofdobeginifgbFirstinCDS.GetGroupState(1)thenbeginGroupList.Add(CDS.FieldByName(GroupName).AsString);Inc(Result);end;CDS.Next;end;finallyCDS.EnableControls;CDS.Free;end;end;,2014/3/5
745,delphi下TImgTrackBar进度条,胡贤卿,http://180.168.156.212:2262/wecenter/?/article/8536,"之前方俊新找到的delphi开源的进度条相对现有进度条来说效果可以说效果要好不少缺点的话里面开放的事件看似较多事实上支持的很少优点是控件本身是delphi做并且开源的在有预研时间的情况下完全可以自己扩展开发,且图片已经支持较全自己diy度较高介绍几个相关主要时间和属性onplayposchanged进度位置改变触发事件onthumbdraged进度位置点击触发事件posplay进度条播放进度属性posload进度条缓冲进度属性max进度条满进度属性一般设为100结合posplay使用111.JPG",2014/3/5
746,Delphi读取64位Windows注册表的值,张守伟,http://180.168.156.212:2262/wecenter/?/article/8537,Delphi的Tregistry类读注册表倒是很方便的，比如判断当前系统下某个软件有没有安装，代码如下：vartmpReg:TRegistry;begintmpReg:=TRegistry.Create;trytmpReg.RootKey:=HKEY_LOCAL_MACHINE;Result:=tmpReg.KeyExists('\SOFTWARE\XXXX');finallyFreeAndNil(tmpReg);end;end;如果是XP系统，则没有任何问题，但是如果是高版本（Win7、Win8）的64位系统，那么上面的代码就无法正确的读取注册表里的内容，因为权限不够。那么用Delphi怎么才能正确的读到64位系统下的的注册表的内容呢，其实很简单，只要把上面的代码稍做一些修改即可，如下：vartmpReg:TRegistry;begintmpReg:=TRegistry.Create(KEY_READorKEY_WOW64_64KEY);trytmpReg.RootKey:=HKEY_LOCAL_MACHINE;Result:=tmpReg.KeyExists('\SOFTWARE\XXXX');finallyFreeAndNil(tmpReg);end;end;这一段代码是能正确的读取64位系统下注册表的值，但是很遗憾，这段代码在Delphi7下无法编译通过，要使用Delphi2009以上的版本才能编译，因为这里含有一些高版本的常量。由此看来，我们的Delphi开发环境是时候升级了。,2014/3/5
747,Windows XP 4月退休 继续使用10分钟中毒？,张元利,http://180.168.156.212:2262/wecenter/?/article/8535,4月8日，已经“服役”12年的微软WindowsXP系统即将光荣退休。有消息称，若在微软停止服务后继续使用XP系统，用户的电脑将在十分钟内被感染。消息一出，不少市民揪心不已。面对已经使用得非常习惯的系统，到底要升级还是继续坚守？专家表示，10分钟感染的说法并不准确，但安全风险的确存在。目前市区部分银行等公共电脑系统已经升级，据电脑商家反映，想要重装电脑系统的市民也有所增加。但是，选择升级操作的市民却又遇到另一个问题，老电脑使用Windows7或者Windows8系统时“跑不动”了。关注WindowsXP剩下不足50天的生命最近一条微博让不少市民揪心：“WindowsXP系统将于4月8日停止向用户提供各种服务。继续使用该系统的用户极有可能在10分钟内遭受攻击。对此微软也表示，如果你在XP停止支持后还坚持使用该系统，并联网使用你的计算机的话，你的电脑就会陷入重大危险中。你还在用XP吗？”其实早在去年11月，微软就已经发布了XP系统即将光荣退休的消息，但是并未受到国内用户的关注。如果不是“10分钟内就感染”这一极具危险性的说法出现，相信很多人还是不会把XP系统退役的消息放在心上。有专家认为，其实XP系统已经不能适应大数据时代的要求，却掌控着大量普通用户的心，2001年推出至今，已经“服役”12年多，是微软历史上最长寿的操作系统。目前XP系统在中国的市场份额高达70%以上，有超过2亿的中国人正在使用这一系统。在XP系统退休的消息传出后，有机构专门做出调查，结果显示，即便微软不再提供服务，仍有60%的用户将继续坚守XP系统。银行部分已完成ATM系统更换昨日记者从中国银行、中国建设银行、中国工商银行、交通银行等多家银行了解到，部分银行从去年年底开始，就让ATM取款机系统维护的外包公司对系统进行更换，从XP系统更换到Windows7或8的系统。“从去年年底到现在基本已经更新完毕。”中国银行ATM取款机的一位技术维护人员告诉记者。但是，也有银行仍没有什么动作。“目前没有收到任何要求更新系统的通知，这个项目是外包公司做的。”有两家银行的工作人员告诉记者。业内人士表示，因为银行ATM取款机并未连接互联网，而是连接银行的内部办公网络，另外还有其他安全监控程序，市民的账户安全有保障。除了银行外，不少机关单位和企业还运用XP系统，但是到目前为止，绝大部分单位并没有更改所有办公电脑系统的安排。“大部分单位的电脑是不能上外网的，或者对上网有严格监控。因为常年不联网并安装内部系统，一些单位的办公电脑系统甚至还停留在Windows2003的年代。”也有业内人士认为，微软让XP退休，影响到中国2亿以上的电脑用户，这可能导致用户对微软忠诚度降低，从而为国产系统打开市场。商家电脑重装系统业务量增加WindowXP即将退役，继续使用可能导致电脑10分钟内被病毒感染的消息传开后，一些市民开始琢磨给自用的电脑换系统。“这几天不少客人打电话来询问继续使用XP系统到底是否有风险，还询问重装电脑系统的价格。目前已经有一些人要求我们上门为电脑重装系统。XP退休后，应该有更多的人为电脑更换系统。”泉州某电脑城一位商家告诉记者。记者从多个电脑销售商家处了解到，这两天询问电脑重装事宜的客人数量有所增加。“大家最担心的是电脑里面保存的资料会丢失。有些客人的电脑已经使用七八年，担心继续使用XP系统会导致电脑崩溃。”另一位商家告诉记者。但是，一部分用惯XP系统的“固执”市民并不愿意重装系统，而是使用其他办法保留重要资料。“我家有三台电脑，其中两台装的是XP系统，其中一台是大学时用的笔记本电脑，已经用了八年了，资料非常多。昨天我赶紧买了2个移动硬盘，把两台XP系统电脑里的资料都备份好了，其中一些资料还传到网络微盘上。只要资料不丢，用什么系统都可以。”市民蔡先生告诉记者。专家“10分钟感染”说法不准确一位从事IT行业多年的专业人士表示，“微软停止服务后，XP系统的电脑10分钟内就会被感染”的说法其实是一个误会。“微软停止服务后，继续使用XP系统电脑的确可能感染病毒，用户将面临安全风险。但是，谁也不能说清电脑到底几分钟内会被感染，可能是10分钟，也可能是10天。当微软不再继续提供安全补丁后，电脑被感染的时间是没有确定概率的。”业内人士说。目前，奇虎360已经表示将继续为XP用户提供全方位安全防护，并将针对XP新出现的高危漏洞提供防护措施。一些用户认为，只要有杀毒软件保驾护航，XP系统仍旧有强悍的生命力，他们将坚守XP系统。虽然第三方的安全软件可以帮助XP系统解决安全问题，但是专业人士认为，将电脑升级到新版本的操作系统才是最安全的。因为第三方安全软件能否完全有效地保护XP系统，不得而知。“事实上，如果有杀毒软件公司为XP系统提供服务，用户面临的安全风险将降低不少。在正常情况下，安装杀毒软件的XP系统应该不会在10分钟内就被感染。事实上，XP系统已经不能完全满足大数据时代的要求了，但是对一些只将电脑当成普通娱乐设施，连网游都不打的市民来说，他们并不愿意更换已经习惯的系统。”业内人士表示。尴尬老电脑装上新系统“跑不动”专家建议用户及时将电脑升级到Windows7或者Windows8系统，但是一些市民却在升级前面临尴尬。“目前将电脑升级到Windows7系统的市民比升级到Windows8系统的要多，毕竟国内一些软件还无法适应Windows8系统。但是，即便不装最新的系统，很多市民家中使用年限超过5年的电脑根本很难适应新系统。”一位从事IT行业的业内人士表示。业内人士告诉记者，更换系统的前提是电脑的配置跟得上，双核系统，内存3G以上的电脑运用Windows7或者Windows8系统时更加流畅。配置跟不上的电脑装上新系统后，将出现“跑不动”或者“跑得很辛苦”的情况。在适应XP系统多年之后，为了更换新系统，部分市民可能得花费几千元的资金更换电脑，或者对电脑硬件进行升级。如果不愿花费这笔资金，就必须忍受“跑不动”的电脑，或者继续使用XP系统，面对可能存在的安全风险。“为电脑升级操作系统的花费不超过100元，可是如果你想拥有一台运行顺畅的电脑，也许不止要花这个钱。”业内人士表示,2014/2/28
748,Web应用开发者的福音，Google宣布将停止支持IE 9,杨木江,http://180.168.156.212:2262/wecenter/?/article/8534,2013年11月，Google宣布将停止支持IE9，这很可能将成为其他UX社区不久也将效仿该做法的信号。,2014/2/27
749,GoldenGate安装配置实施步骤,杨木江,http://180.168.156.212:2262/wecenter/?/article/8533,"GoldenGate安装配置实施步骤GoldenGate安装Windows下安装安装MicrosoftVisualC++2005SP1绿色安装GoldenGate下载对应平台版本的GoldenGate（V22232-01.zip）安装包，解压。使用CMD，进入GoldenGate解压路径下，执行：GG_HOME>ggsci--进入GoldenGate命令窗口模式GGSCI>CREATESUBDIRS--创建子目录GGSCI>editparammgr--配置GoldenGate主进程参数输入参数：PORT7801--GoldenGate主进程端口号DYNAMICPORTLIST7802-7820--GoldenGate为进程间通讯动态分配的端口段，注意这里如果分配的端口少于extract-replicat进程对的话，会导致部分进程因通讯失败而出错保持，生成的参数文件保存在GG_HOME\dirprm下然后可以启动GoldenGate主控制进程：GGSCI>startmgrGGSCI>infoall--查看进程状态如果进程MANAGER状态显示为RUNNING则表示主进程已在运行。至此软件安装完成。管理GoldenGate服务在windows下还可以将GoldenGate主进程作为系统服务进行管理，如下配置：GGSCI>editparam./globals--配置全局参数，注意前面的./表明与其他参数文件位置不同，该参数文件是直接位于GoldenGate安装路径下的输入参数：MGRSERVNAME<name>--为GoldenGate定义系统服务名保存，然后退出GGSCI命令行：GGSCI>exitGG_HOME>installaddserviceaddevents--创建服务Windows删除GoldenGate服务：GG_HOME>installdeleteeventsdeleteservice--删除对应服务或者在注册表删除：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services下对应的GoldenGate服务名Linux和Unix下安装检查必需的lib包下载对应平台版本的GoldenGate（V22227-01.zip），解压。在解压路径下执行：[root@GG_HOME]>lddggsci将列出所有需要的lib和当前缺少的。GoldenGate在Linux和Unix下安装，需要安装Oracle的lib环境以及$ORACLE_HOME/lib下的几个包，所以必须安装在Oracle之后，而且确保在环境变量中加入：exportLD_LIBRARY_PATH=$ORACLE_HOME/lib绿色安装GoldenGate[root@GG_HOME]>./ggsci--进入GoldenGate命令窗口模式GGSCI>CREATESUBDIRS--创建子目录GGSCI>editparammgr--配置GoldenGate主进程参数输入参数：PORT7801--GoldenGate主进程端口号DYNAMICPORTLIST7802-7820--GoldenGate为进程间通讯动态分配的端口段，注意这里如果分配的端口少于extract-replicat进程对的话，会导致部分进程因通讯失败而出错保持，生成的参数文件保存在GG_HOME\dirprm下然后可以启动GoldenGate主控制进程：GGSCI>startmgrGGSCI>infoall--查看进程状态如果进程MANAGER状态显示为RUNNING则表示主进程已在运行。至此软件安装完成。数据库准备打开归档模式SQL>archiveloglist--查看是否当前归档模式状态若处于非归档模式，则改为归档模式：SQL>shutdownimmediateSQL>startupmount;SQL>alterdatabasearchivelog;SQL>alterdatabaseopen打开forcelogging实际生产应用中，最好同时打开Oracle的强制日志模式，以防止源数据库因直接路径加载忽略redo生成而导致这部分数据无法同步SQL>selectforce_loggingfromv$database;SQL>alterdatabaseforcelogging;开启最小附加日志模式SQL>selectsupplemental_log_data_minfromv$database;SQL>alterdatabaseaddsupplementallogdata;SQL>altersystemswitchlogfile;开启数据库补全日志（如果要同步的数据库表中存在没有主键的表时一定要开启）SQL>selectsupplemental_log_data_min,supplemental_log_data_pk,supplemental_log_data_uifromv$database;SQL>alterdatabaseaddsupplementallogdata(primarykey,unique,foreignkey)columns;创建GoldenGate同步管理用户SQL>createtablespacetbs_ggdatafile‘/oradata/orcl/ts_gg.dbf’size200mautoextendon;SQL>createuseroggidentifiedby“ogg”defaulttablespacetbs_ggtemporarytablespacetempquotaunlimitedontbs_gg;SQL>grantconnect,resourcetoogg;SQL>grantcreatesession,altersessiontoogg;SQL>grantselectanydictionary,selectanytabletoogg;SQL>grantalteranytabletoogg;SQL>grantflashbackanytabletoogg;SQL>grantexecuteondbms_flashbacktoogg;SQL>grantcreatetabletoogg;SQL>grantdbatoogg;GoldenGate配置源数据库配置datapump进程GGSCI>addextractpump1,exttrailsource<local_trail>,beginnow--local_trail即对应extl配置文件中定义的文件夹：c:\tools\GG\gg10g\dirdat\l1GGSCI>editparampump1extractpump1useridogg,passwordoggrmthost192.168.0.102,mgrport7801rmttrail/oracle/oracle/gg10g/dirdat/rlpassthrugettruncatestablegg.*;GGSCI>addrmttrail/oracle/oracle/gg10g/dirdat/rlextractpump1源数据库添加提取进程GGSCI>addextractextl,tranlog,beginnow如果是在RAC环境下，需要再增加threads<n>指定提取的日志threadGGSCI>addextractextl,tranlog,beginnow,THREADS<n>GGSCI>editparamextlextractextluseridogg,passwordoggexttrail/oracle/oracle/gg10g/dirdat/l1dynamicresolutiongettruncatestablegg.*;GGSCI>addrmttrail/oracle/oracle/gg10g/dirdat/l1extractextlGGSCI>startpump1GGSCI>startextlGGSCI>infoallGGSCI>viewreportextl目标数据库添加复制应用进程GGSCI>addreplicatreplexttrailc:\tools\GG\gg10g\dirdat\rl,beginnow,nodbcheckpointGGSCI>editparamreplreplicatrepluseridogg,passwordoggassumetargetdefsreperrordefault,discarddiscardfilec:\tools\repsz.dsc,append,megabytes100gettruncatesmapgg.*,targetgg.*;--注意:target前必须留一个空格GGSCI>startrepl",2014/2/26
750,项目中常见技术问题及解决措施,杨木江,http://180.168.156.212:2262/wecenter/?/article/8532,"WebSphere6上部署Struts2无法找到Action问题描述:在websphere6.1.0.2的版本上发布struts2的程序，跑画面的时候总是会出现FileNotFoundException的404错误（找不到静态资源，比如struts2里面集成的js文件），导致无法进行客户端验证以及实现ajax技术。控制台也总是会出现下面两个警告：WARNING:Cannotsetstatus.Responsealreadycommitted.WARNING:Cannotsetheader.Responsealreadycommitted.解决思路:应用程序服务器>[选择所使用的服务器]>Web容器设置>Web容器>定制属性，增加名称为“com.ibm.ws.webcontainer.invokefilterscompatibility”，并将他的值设置为“true”，重新启动WAS服务即可。问题根源:Websphere默认禁用filter上海消防网后台跨站漏洞问题问题描述:跨站点脚本攻击（简称XSS，这样我们就不会混淆它们与层叠样式表）是目前的主要攻击媒介。它们攻击从用户那里得到信息的脆弱网站，而这些网站把这些数据返回到浏览器。XSS攻击发生时，恶意人士在其他用户的浏览器中运行一个恶意的浏览器脚本。然后，攻击者可以窃取的cookies-或者甚至使用脆弱的电子商务网站-使浏览器忙于处理问题，使它像是受害者的浏览器。我们在Intelguardians的渗透测试工作中，所测试的Web应用大约有80%含有XSS漏洞。解决思路:通过使用过滤器将请求地址中与脚步相关的字符进行过滤或判断publicvoiddoFilter(ServletRequestrequest,ServletResponseresponse,FilterChainchain)throwsIOException,ServletException{HttpServletRequestreq=(HttpServletRequest)request;HttpServletResponseres=(HttpServletResponse)response;StringqueryString=req.getQueryString();if(queryString!=null&&!"""".equals(queryString)){Stringtemp=htmlEncode(queryString);if(temp.equals(queryString)){System.out.println(""没有代码!"");}else{System.out.println(""有攻击代码!"");res.sendRedirect(""error.jsp"");return;}}chain.doFilter(request,response);}privateStringhtmlEncode(Stringstr){//str=replace(str,""&"",""&amp;"");str=replace(str,""\"""",""&quot;"");str=replace(str,""<"",""&lt;"");str=replace(str,"">"",""&gt;"");str=replace(str,""'"",""&#146;"");str=replace(str,""-"",""&#45;"");str=replace(str,""("",""&#40;"");str=replace(str,"")"",""&#41;"");//str=replace(str,""*"",""&#42;"");//str=replace(str,""="",""&#61;"");str=replace(str,"";"",""&#59;"");str=replaceAll(str,""javascript:"",""javascript："");str=replaceAll(str,""vbscript:"",""vbscript："");str=replaceAll(str,""jscript:"",""jscript："");returnstr;}问题根源:其实这和现在比较热门的SQL注入的原理有异曲同工之处，都是由于程序员在写程序的时候对一些变量没有做充分的过滤，或者没做任何的过滤就直接把用户提交的数据送到SQL语句里执行，这样导致了用户所提交的一些特意构造的语句一般都是带有象JAVAScript等这类脚本代码，这样在服务里一旦被执行就形成了所谓的跨站攻击了。当向数据库（Oracle9i）表中存储一个长度大于1000的字符串（Varchar2（4000））时，系统报错问题描述:上实协同办公系统当向数据库（Oracle9i）表中存储一个长度大于1000的字符串（Varchar2（4000））时，系统报错：net.sf.hibernate.util.JDBCExceptionReporter-CouldnotexecuteJDBCbatchupdatejava.sql.BatchUpdateException:ORA-01461:仅可以为插入LONG列的LONG值赋值解决思路:确保应用、应用服务器中使用的数据库驱动包和使用的数据库版本一致将数据库表中的字段类型修改为Clob<beanid=""oracleLobHandler""class=""org.springframework.jdbc.support.lob.OracleLobHandler""lazy-init=""true""><propertyname=""nativeJdbcExtractor""ref=""nativeJdbcExtractor""/></bean><beanid=""nativeJdbcExtractor""class=""org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor""lazy-init=""true""/><propertyname=""lobHandler""ref=""oracleLobHandler""/>问题根源:、数据库驱动包和对应数据库版本不一致、如果数据库是Oracle10g以上测试正常，如果数据库是Oracle9i，并且在你的表单中有2个或者以上的Varchar2、clob，则有下列限制：当Clob的长度>varchar2的长度，所有varchar2的长度最多2000，当数据库为UTF-8时所有varchar2的长度最多1000，超出这个长度则保存不了，提示：java.sql.BatchUpdateException:ORA-01461:仅可以为插入LONG列的LONG值赋值，如果Clob<Varchar2,则Varchar2的长度等于该字段定义的长度。如果您的表单有2个varchar2,也是遵循这个规则。估计是10g的驱动与9i的数据库兼容问题，所有您的varchar2如果要存入超出1000的长度就用Clob吧，如果你要用varchar2就要在程序逻辑里限制校验他的长度对于UTF-8或欧洲的某些字符集，oracle在存储时，对于一个字符需要2个或3个字节的存储空间，虽然表定义中为varchar2(4000)，但是其实该字段的data_length为其2倍或3倍长。这种情况下oracle会把data_length长度超过4000的当做LONG型处理，你的表中有两个这样的字段，插入数据时相当于同时操作2个LONG字段，所以报错Tomcat迁移到WebLogic问题问题描述：1、Hibernate无法加载POJO，出现该异常：org.springframework.orm.hibernate3.HibernateQueryException:ClassNotFoundException:org.hibernate.hql.ast.HqlToken[frombus.beans.Product];nestedexceptionisorg.hibernate.QueryException:ClassNotFoundException:org.hibernate.hql.ast.HqlToken[frombus.beans.Product]Causedby:org.hibernate.QueryException:ClassNotFoundException:org.hibernate.hql.ast.HqlToken[frombus.beans.Product]atorg.hibernate.hql.ast.HqlLexer.panic(HqlLexer.java:57)atantlr.CharScanner.setTokenObjectClass(CharScanner.java:340)atorg.hibernate.hql.ast.HqlLexer.setTokenObjectClass(HqlLexer.java:31)atantlr.CharScanner.<init>(CharScanner.java:51)atantlr.CharScanner.<init>(CharScanner.java:60)atorg.hibernate.hql.antlr.HqlBaseLexer.<init>(HqlBaseLexer.java:56)atorg.hibernate.hql.antlr.HqlBaseLexer.<init>(HqlBaseLexer.java:53)atorg.hibernate.hql.antlr.HqlBaseLexer.<init>(HqlBaseLexer.java:50)atorg.hibernate.hql.ast.HqlLexer.<init>(HqlLexer.java:26)atorg.hibernate.hql.ast.HqlParser.getInstance(HqlParser.java:44)atorg.hibernate.hql.ast.QueryTranslatorImpl.parse(QueryTranslatorImpl.java:242)atorg.hibernate.hql.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:157)atorg.hibernate.hql.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:111)atorg.hibernate.engine.query.HQLQueryPlan.<init>(HQLQueryPlan.java:77)atorg.hibernate.engine.query.HQLQueryPlan.<init>(HQLQueryPlan.java:56)atorg.hibernate.engine.query.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:72)atorg.hibernate.impl.AbstractSessionImpl.getHQLQueryPlan(AbstractSessionImpl.java:133)atorg.hibernate.impl.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:112)atorg.hibernate.impl.SessionImpl.createQuery(SessionImpl.java:1623)atorg.springframework.orm.hibernate3.HibernateTemplate$29.doInHibernate(HibernateTemplate.java:837)atorg.springframework.orm.hibernate3.HibernateTemplate.execute(HibernateTemplate.java:367)atorg.springframework.orm.hibernate3.HibernateTemplate.find(HibernateTemplate.java:835)atorg.springframework.orm.hibernate3.HibernateTemplate.find(HibernateTemplate.java:827)atdb.ProductManagerDaoHB.getProductList(ProductManagerDaoHB.java:14)atbus.ProductManager.getProducts(ProductManager.java:25)atweb.controllers.SpringappController.handleRequest(SpringappController.java:33)atorg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter.handle(SimpleControllerHandlerAdapter.java:48)atorg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:819)atorg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:754)atorg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:399)atorg.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:354)atjavax.servlet.http.HttpServlet.service(HttpServlet.java:740)atjavax.servlet.http.HttpServlet.service(HttpServlet.java:853)atweblogic.servlet.internal.ServletStubImpl$ServletInvocationAction.run(ServletStubImpl.java:971)atweblogic.servlet.internal.ServletStubImpl.invokeServlet(ServletStubImpl.java:402)atweblogic.servlet.internal.ServletStubImpl.invokeServlet(ServletStubImpl.java:305)atweblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:6350)atweblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:317)atweblogic.security.service.SecurityManager.runAs(SecurityManager.java:118)atweblogic.servlet.internal.WebAppServletContext.invokeServlet(WebAppServletContext.java:3635)atweblogic.servlet.internal.ServletRequestImpl.execute(ServletRequestImpl.java:2585)atweblogic.kernel.ExecuteThread.execute(ExecuteThread.java:197)atweblogic.kernel.ExecuteThread.run(ExecuteThread.java:170)2、使用getServletContext()时出现异常：error.jsp:28:87:ThemethodgetServletContext()isundefinedforthetype__error解决思路：、Hibernate无法加载POJO，出现该异常：在hibernate配置属性hibernateProperties中增加配置<propkey=""hibernate.query.factory_class"">、使用getServletContext()时出现异常：更改为application、web.xml中使用web-app_2_4.xsd标准时如果配置文件中使用taglig必须将其放置在jsp-config标记中，如：公司使用的查询框架无法进行多表查询问题描述：公司使用的查询框架无法进行多表查询解决思路:宝勤提供的查询框架应用多表联合查询问题：中的设置：query=""<queryid=\""0\"">""+""<>""+""<>""+""<>""+""</query>"";修正的类及代码：*@paramcom*@return*@throwsParseException*@throwsNoSuchMethodException*@throwsInvocationTargetException*@throwsIllegalAccessException*@authorReamyyangmujiang@sohu.com20101011更新*修正查询时无法进行多表联合查询的BugprivateStringcompare(Comparecom)throwsParseException,IllegalAccessException,InvocationTargetException,NoSuchMethodException{StringBuffertempStrBuf=newStringBuffer();Stringname=com.getName();//TODOReamy20101011修正后代码if(name.indexOf('.')!=-1){Stringop=ces.jyj.supervision.arch.query.Query.getOperator(com.getOperator());tempStrBuf.append(com.getTarget()).append("""").append(op).append("""").append(name);}else{Objectvalue=PropertyUtils.getSimpleProperty(listForm,com.getName());if(value!=null&&!value.equals("""")){Stringop=ces.jyj.supervision.arch.query.Query.getOperator(com.getOperator());tempStrBuf.append(com.getTarget()).append("""").append(op).append("""").append("":"").append(name);if(op.equals(""like"")){value=""%""+value.toString().trim()+""%"";listFilter.putParameter(name,value);return"""";//thrownewIllegalArgumentException(""[""+name+""]"");returntempStrBuf.toString();张家港档案信息网访问响应慢问题描述：访问网站页面时，要很久才会出现内容问题分析：、网页使用Table布局、网页中存在较多的大图片和Flash资源解决思路:修改布局方式为Css+Div上海市残联应用启动无法加载数据库配置信息问题问题描述：当应用服务器重新启动时应用服务器报urlcannotbenull异常，只有在服务器重启时才会出现，当服务器启动完成后通过使用启动WebSphere脚步来启动应用服务时便不会出现该问题问题分析：、CesGlobal类会一直不停的加载数据库配置文件；、数据库链接池管理文件ConnectionPool中对链接参数是否为空的现象没有进行控制；问题推测：、应用项目中的配置文件ces_config.xml文件损坏、数据库驱动文件不正确、系统频繁的重复加载配置文件ces_config.xml，系统无法正确加载文件导致解决思路:、更换数据库驱动文件classes12.jar、重写ces_config.xml配置文件、重写编译并重写XMLProperties.class文件，增加配置文件缓存策略，解决系统频繁的重复读取配置文件到内存；增加数据库配置信息缓存策略，解决系统频繁重复的解决配置文件问题、修改ConnectionPool.class使用？运算符时，系统出现转型错误问题描述：在JSP页面中使用？号表达式时<%=t==0?""/"":t%>，出现转型错误问题分析：返回值数据类型不一致解决思路:java中如何发送邮件sendMail.jar/***创建邮件Session.**@paramemail邮件地址*@parampwd密码*@paramsmtpsmtp服务器地址*@paramportsmtp服务器端口*@paramcheck需要验证身份*@paramssl是否需要使用SSL*@return邮件Session*/privatestaticSessioncreateSession(Stringemail,Stringpwd,Stringsmtp,Stringport,Booleancheck,Booleanssl){Security.addProvider(newcom.sun.net.ssl.internal.ssl.Provider());//GetaPropertiesobjectPropertiesprops=System.getProperties();props.setProperty(""mail.smtp.host"",smtp);props.put(""mail.from"",email);props.setProperty(""mail.smtp.socketFactory.fallback"",""false"");if(ssl){props.setProperty(""mail.smtp.socketFactory.class"",SSL_FACTORY);}if(port!=null&&!"""".equals(port.trim())){props.setProperty(""mail.smtp.port"",port);props.setProperty(""mail.smtp.socketFactory.port"",port);}finalStringusername=email;finalStringpassword=pwd;if(check){props.put(""mail.smtp.auth"",""true"");Sessionsession=Session.getDefaultInstance(props,newAuthenticator(){protectedPasswordAuthenticationgetPasswordAuthentication(){returnnewPasswordAuthentication(username,password);}});session.setPasswordAuthentication(newURLName(smtp),newPasswordAuthentication(email,pwd));returnsession;}returnSession.getDefaultInstance(props);}/***发送邮件.**@paramsession邮件Session*@paramto收信人*@parammimeType邮件编码*@throwsMessagingException*/privatevoidsendMessage(Sessionsession,Stringto,StringmimeType)throwsMessagingException{Messagemessage=newMimeMessage(session);message.setSentDate(newDate());message.setSubject(man.getMail().getTitle());message.setContent(man.getMail().getContent(),mimeType);message.setRecipients(Message.RecipientType.TO,InternetAddress.parse(to,false));Transport.send(message);}浦发系统宕机问题问题描述：1、系统启动后，用户第一次登录系统需要十几分钟才能够登录系统；2、当系统并发登录用户数较多时，系统出现OutOfMemoryError及CPU占用率一直处在25%-95%之间的现象，导致系统不能访问；问题分析：、系统中使用了系统管理平台3.1.1版本，该版本中在用户、组织、角色和角色资源上采用了Hibernate级联配置方案；同时在Acegi中使用了EHCache对用户信息进行缓存。、该方案的优势在于当系统中的注册用户、组织、角色和角色资源相对比较少的情况下，可以有效的提高系统的性能。所有用户的数据均从内存中获取而不去查询数据库。、而在浦发银行公文管理系统中，系统中存在2万多的注册用户，当用户现场出现20多个用户并发登录的时候，系统将2万多个用户的数据加载了20多份进入内存，而导致系统出现OutOfMemoryError错误。同时系统要出这40多万（2万多X20多个用户）个缓存用户中去遍历查找，验证用户的缓存数据时则会导致CPU占用率一直处在25%-95%之间。解决思路:、改变Hibernate级联配置方式为延迟加载方式。主要是解决当用户登录系统时系统会将数据库中的所有用户、组织、角色和角色资源加载到内存中的问题。因此当用户登录后Session中将会只放置该登录用户的个人信息。而内存缓存中也只会缓存登录过系统的用户的对应信息，而不是数据中的所有用户信息。、改变系统中使用级联方式自动从内存中获取用户、组织、角色和角色资源的方式为直接从数据库获取中。主要是解决系统从内存中遍历查询用户时会导致占用大量CPU资源的问题。公安局条形码生成控件无法生成条形码问题描述：1、运行系统，进入指定打印预览页面后，在客户端C盘目录下没有生产对应的条形码图片文件；2、在word文档中无法插入条形码图片问题分析：、OCX控件没有被正确安装并注册；、系统中使用金格的文档编辑控件来加载条形码图片，并将其插入到word中，调用的接口为从服务器上获取条形码图片文件。而东方通条形码生成控件则是将条形码图片文件生成在本地系统中解决思路:、发现使用IE自动安装东方通控件后，在客户端机器上的system32目录下缺少PDFENC32.DLL文件。手动将该PDFENC32.DLL文件，拷贝到客户机system32目录下，并手动注册了barOcx.ocx、PDF417.ocx和pdf417Read.ocx三个OCX文件。、取消原本使用VBScript方式动态创建东方通条形码生成控件方式，取而代之的是，使用Object标记来创建控件，然后使用JavaScript调用控件中的接口来生成条形码图片文件。、使用金格的从本地插入图片文件到word中的接口webform.WebOffice.WebObject.Application.Selection.InlineShapes.AddPicture('c:\\a.jpg',false,true);，将生成在客户端上的图片文件插入到word文件中侨办系统静态化页面时传输系统管理平台令牌报错问题描述：在后台使用HttpClient对象请求应用指定页面将其另存为Html静态页面时，因为涉及到单点登录问题，使用系统管理平台中的令牌无法登录，后台报错解决办法:调用系统管理平台令牌加密方法将获得的令牌明文加密后提交问题根源:系统管理平台在解析单点登录令牌时，要求接收到的令牌为加密后的密文，而不是明文附带问题：在URL后面直接提交带有中文字符的参数时注意事项：如： index.jspDocumentRoot""D:\wjwx\wotalk-admin""ErrorLoglogs/wotalk.error_logJkMount/*.dowotalkJkMount/*.jspwotalk在workers.properties配置文件中添加服务器：worker.list=test113,test96,wotalkSetpropertiesforwotalk(ajp13)#Setpropertiesfortest113(ajp13)#Setpropertiesfortest96(ajp13)关于脚本注入和SQL注入问题不使用sql语句连接的方式生产sql，用setParam方法进行值设置",2014/2/26
751,html5 canvas 实现的心形绘制动画,杨木江,http://180.168.156.212:2262/wecenter/?/article/8531,演示地址,2014/2/26
752,如果告诉你这是使用webGL生成的水池互动效果，你敢相信自己的眼睛么？,杨木江,http://180.168.156.212:2262/wecenter/?/article/8530,在线演示,2014/2/26
753,VCL 中的 Windows API  图形图像函数   BeginPath、EndPath,许海宝,http://180.168.156.212:2262/wecenter/?/article/8529,"vcl里面封装了很多图形图像的绘制函数，功能强大可以实现各种视觉效果这里抛砖引玉，提几个常用的图形函数WinAPI:BeginPath、EndPath、StrokePath、FillPath、StrokeAndFillPathBeginPath{路径开始}EndPath{路径结束}StrokePath{绘制路径}FillPath{填充路径}StrokeAndFillPath{绘制并填充路径}//在路径中可以使用的图形命令有:AngleArcArcArcToChordCloseFigureEllipseExtTextOutLineToMoveToExPiePolyBezierPolyBezierToPolyDrawPolygonPolylinePolylineToPolyPolygonPolyPolylineRectangleRoundRectTextOut本例效果图:代码文件:unitUnit1;interfaceusesWindows,Messages,SysUtils,Variants,Classes,Graphics,Controls,Forms,Dialogs,StdCtrls,ExtCtrls;typeTForm1=class(TForm)RadioGroup1:TRadioGroup;procedureFormCreate(Sender:TObject);procedureFormPaint(Sender:TObject);procedureRadioGroup1Click(Sender:TObject);end;varForm1:TForm1;implementation{$R*.dfm}procedureTForm1.FormCreate(Sender:TObject);beginRadioGroup1.Items.CommaText:='绘制路径,填充路径,绘制并填充';RadioGroup1.ItemIndex:=0;RadioGroup1.Columns:=RadioGroup1.Items.Count;end;procedureTForm1.FormPaint(Sender:TObject);beginCanvas.Font.Size:=36;Canvas.Font.Style:=[fsBold];SetBkMode(Canvas.Handle,TRANSPARENT);BeginPath(Canvas.Handle);Canvas.Rectangle(10,10,110,110);Canvas.TextOut(20,30,'helloworld!');EndPath(Canvas.Handle);Canvas.Brush.Color:=clYellow;Canvas.Pen.Color:=clRed;caseRadioGroup1.ItemIndexof0:StrokePath(Canvas.Handle);1:FillPath(Canvas.Handle);2:StrokeAndFillPath(Canvas.Handle);end;end;procedureTForm1.RadioGroup1Click(Sender:TObject);beginRepaint;end;end.窗体设计:objectForm1:TForm1Left=373Top=260Caption='Form1'ClientHeight=193ClientWidth=321Color=clBtnFaceFont.Charset=DEFAULT_CHARSETFont.Color=clWindowTextFont.Height=-11Font.Name='Tahoma'Font.Style=[]OldCreateOrder=FalsePosition=poDesignedOnCreate=FormCreateOnPaint=FormPaintPixelsPerInch=96TextHeight=13objectRadioGroup1:TRadioGroupLeft=28Top=131Width=265Height=49Caption='RadioGroup1'TabOrder=0OnClick=RadioGroup1Clickendenddemo.jpgdemo.bmp",2014/2/21
754,Delphi 实现照片库分组浏览功能,陈军志,http://180.168.156.212:2262/wecenter/?/article/8528,"Delphi实现照片库分组浏览功能：功能介绍：通过添加监控文件夹，可以对监控文件夹的图片进行图片分组管理，对未分组的照片可以按文件夹或者按时间排序查看，已分组的照片可以按指定顺序查看，对所有照片可以进行简单的操作（旋转，删除），可调整查看界面图片显示的大小。具体实现：1.通过Access数据库记录分组以及用户操作情况。2.通过两个线程来加载和显示信息（一个线程用于遍历文件夹，并将信息跟Access数据库中比对，写入新的信息。另外一个线程通过查找Access数据的数据，将图片信息显示到界面上）。3.界面上通过listView展示分组情况，通过imageEnMview加载每个分组的图片的缩略图。4.拖动效果的实现：通过listview的OnDragOver事件控制拖动时，该listView图标是否允许拖入状态：具体代码如下：procedureTfrmLocalImageCollectInfo.lvImageGroupInfoDragOver(Sender,Source:TObject;X,Y:Integer;State:TDragState;varAccept:Boolean);varindex:Integer;beginiflvImageGroupInfo.GetItemAt(x,y)<>nilthenbeginindex:=lvImageGroupInfo.GetItemAt(x,y).Index;end;ifFlistIndex=-1thenbeginif(Source=TfrmImageBrowse(FFrameList[FframeIndex]).ImageEnMView1)and(lvImageGroupInfo.GetItemAt(x,y)<>nil)and(FlistIndex<>index)thenbeginAccept:=True;endelseAccept:=False;endelsebeginif(Source=TTreeNodeData(FTreeList[FlistIndex]).frmImageBrowse.ImageEnMView1)and(lvImageGroupInfo.GetItemAt(x,y)<>nil)and(FlistIndex<>index)thenbeginAccept:=True;endelseAccept:=False;end;end;在允许拖动时，放开后，控制界面上的不同组的情况，代码如下：procedureTfrmLocalImageCollectInfo.lvImageGroupInfoDragDrop(Sender,Source:TObject;X,Y:Integer);varindex:Integer;sGroupName:string;beginiflvImageGroupInfo.GetItemAt(x,y)<>nilthenbeginindex:=lvImageGroupInfo.GetItemAt(x,y).Index;end;ifFlistIndex=-1thenbeginif(Source=TfrmImageBrowse(FFrameList[FframeIndex]).ImageEnMView1)and(lvImageGroupInfo.GetItemAt(x,y)<>nil)and(FlistIndex<>index)thenbeginsGroupName:=TTreeNodeData(FTreeList.Items[index]).FGroupName;RefreshAfterDragOver(sGroupName,index);end;endelsebeginif(Source=TTreeNodeData(FTreeList[FlistIndex]).frmImageBrowse.ImageEnMView1)and(lvImageGroupInfo.GetItemAt(x,y)<>nil)and(FlistIndex<>index)thenbeginsGroupName:=TTreeNodeData(FTreeList.Items[index]).FGroupName;RefreshAfterDragOver(sGroupName,index);//拖动后刷新组信息end;end;end;5.实现对指定图片的旋转，利用ImageEnView控件对的图片翻转，并重新加载，代码如下：fori:=0toTfrmImageBrowse(FFrameList.Items[FframeIndex]).ImageEnMView1.MultiSelectedImagesCount-1dobeginiSelect:=TfrmImageBrowse(FFrameList.Items[FframeIndex]).ImageEnMView1.MultiSelectedImages[i];sFileName:=TfrmImageBrowse(FFrameList.Items[FframeIndex]).ImageEnMView1.ImageFileName[iSelect];imageEnView.io.LoadFromFile(sFileName);ImageEnView.Proc.Rotate(90,False,ierFast,-1);DeleteFile(sFileName);ImageEnView.IO.SaveToFile(sFileName);TfrmImageBrowse(FFrameList.Items[FframeIndex]).ImageEnMView1.ReloadImage(iSelect);Sleep(3);end;6.通过滚动条的移动来动态设置ImageEnMview缩略图尺寸：ThumbWidth，ThumbHeight的大小，当滚动条停止移动时，重新加载图片。该功能主要通过以上几个步骤来实现，其中有个问题是：两个线程同时操作ACCESS时，会出现异常，原因是ACCESS不支持多线程的访问，目前解决办法是，一个线程在插入完数据后，另外一个线程在读取数据时，如果读取为空则循环再次读取，当读取到数据或者读取时间超过指定时间则不再读取。该方法目前测试下来没有问题，但是不知道还有啥其他更好的办法可以解决这个问题呢？（补充：曾经尝试过使用全局变量控制，存在不稳定性，有时可以有时不可以，故全局变量控制的方法不可取）未命名222.bmp",2014/2/21
755,delphi调用脚本动态刷图,胡贤卿,http://180.168.156.212:2262/wecenter/?/article/8527,"之前调研lua的时候的发现,通过调用lua的动态库简单的脚本文件,实现刷图效果functionGetTortoise(L:Plua_State;Index:Integer):TTortoise;beginResult:=TTortoise(LuaGetTableLightUserData(L,Index,HandleStr));end;functionTortoiseForward(L:Plua_State):Integer;cdecl;beginCheckArg(L,2);GetTortoise(L,1).Go(lua_tonumber(L,2));LuaIdle(L);Result:=0;end;functionTortoiseBack(L:Plua_State):Integer;cdecl;beginCheckArg(L,2);GetTortoise(L,1).Go(-lua_tonumber(L,2));LuaIdle(L);Result:=0;end;functionTortoiseRight(L:Plua_State):Integer;cdecl;beginCheckArg(L,2);GetTortoise(L,1).Rotate(-DegToRad(lua_tonumber(L,2)));LuaIdle(L);Result:=0;end;functionTortoiseLeft(L:Plua_State):Integer;cdecl;beginCheckArg(L,2);GetTortoise(L,1).Rotate(DegToRad(lua_tonumber(L,2)));LuaIdle(L);Result:=0;end;脚本示例图.JPG",2014/2/21
756,Delphi调用PLOP插件修改PDF文件的安全性,张守伟,http://180.168.156.212:2262/wecenter/?/article/8526,"在Delphi中测试过很多种方法都没能实现对PDF文件的安全性进行修改，包括使用福昕相关插件也没有达到想要的效果，最多只能是给PDF文件进行加密，但是却无法修改PDF文件的打印、复制等相关限制。后来试了一下PLOP组件，效果果然不同凡响，^_^。首先测试的是其命令行方式，如下：plop-v2-c1.6-uPW-mDEMO--permissions""noprintnocopynoannots""-ooup.pdf1.pdf一下子就看到了我想要的效果了，OK，太棒了。再来试试Delphi调用其插件，也是同样的棒，下面就来说一说Delphi调用PLOP插件来设置PDF文件的密码、打印限制、复制限制等安全性。PLOP的安装、OCX的注册、包括在Delphi导入PLOP插件在这里就不细说了，主要来看看Delphi调用的关键代码部分：1、引用PLOP_com_TLB单元。2、定义TPLOP变量，假如为tmpPLOP。3、创建tmpPLOP实例。4、设置tmpPLOP授权码。5、用tmpPLOP设置PDF的安全属性。6、保存，关闭、释放tmpPLOP。具体代码如下：uses…,PLOP_com_TLB;….procedureDoSetPDFSafety(AFileName:string);vartmpPW,tmpPerm:string;tmpDoc:Integer;tmpPLOP:TPLOP;tmpSearchPath:string;tmpSign_Opts,tmpOutList:string;begintmpPLOP:=TPLOP.Create(Application);trytmpSearchPath:='searchpath={data../data}';tmpSign_Opts:='sign={""+""engine=mscapidigitalid={certstore={store=Mysubject={CN_CES}}}'+'reason={Iagreetothisdocument}'+'contactinfo={tel(123)456789}'+'location=Munich'+'}';tmpOutList:='license=w410702-019200-132887-GPC6C2-PP5CD2'+'searchpath{'+tmpSearchPath+'}';tmpPLOP.set_option(tmpOutList);tmpDoc:=tmpPLOP.open_file(AFileName,'');iftmpDoc=-1thenbeginWarningDialog('Error:'+tmpPLOP.get_errmsg);Exit;end;tmpPW:='';tmpPerm:='';ifPDFSafety.Password<>''thenbegintmpPW:='userpassword{'+PDFSafety.Password+'}masterpassword{<####>}';ifPDFSafety.NoPrintthentmpPerm:='noprint';ifPDFSafety.NoCopythentmpPerm:=tmpPerm+'nocopy';iftmpPerm<>''thentmpPW:=tmpPW+'permissions{'+tmpPerm+'}'end;iftmpPLOP.create_file(AFileName,tmpPW)=-1thenWarningDialog('Error:'+tmpPLOP.get_errmsg);tmpPLOP.close_document(tmpDoc);finallytmpPLOP.Free;end;end;注意：上面的参数部分，userpassword参数必须放在masterpassword参数的前面，不然将无法实现设置打印限制和复制限制。",2014/2/21
757,原生ADO对查询出的数据进行分页显示,王孝本,http://180.168.156.212:2262/wecenter/?/article/8525,1、这个小程序演示了如何使用原生ADO对查询出的数据进行分页显示；2、我们平时看到的网页新闻列表就是分页显示的结果，是VBScript编写网页的一项基本技巧，不过到了Delphi中都成了稀罕东西了；3、一些朋友也研究过这个问题，不少是用MoveBy加计算实现的，不过研究得再深入也不能改变ADO本身的运行机制；分页功能是ADO自带的，既然它本身有这个功能，何乐而不为？注：为了大家使用方便，此程序用到的原生ADO仍然采用了Delphi包装过的_Recordset；对原生ADO感兴趣的朋友可以到我这篇烂文章里看看： /delphibbs/dispq.asp?lid=3047846ADOPageSample.rar,2014/2/21
758,公司内部报修有跟踪流程吗（我的座机已经从2013年9月停机至今，报修无门啊）,杨木江,http://180.168.156.212:2262/wecenter/?/article/8524,如题，已经无语了,2014/2/20
759,Delphi使用COM对象的时候是否需要CoInitialize,孙传金,http://180.168.156.212:2262/wecenter/?/article/8523,"MSDN上CoInitialize的解释：InitializestheCOMlibraryonthecurrentapartmentandidentifiestheconcurrencymodelassingle-threadapartment(STA).ApplicationsmustinitializetheCOMlibrarybeforetheycancallCOMlibraryfunctionsotherthanCoGetMallocandmemoryallocationfunctions.CoInitialize并不装载com库，这个函数只是用来初始化当前线程使用什么样的套间。当使用这个函数以后，线程就和一个套间建立了对应关系。线程的套间模式决定了该线程如何调用com对象，是否需要列集等你可以看一下有关列集的资料，使用不同套间之间对象接口是通过列集来完成的。关于列集的实现，很多书上都有较详细的说明。CoInitialize()并不会干扰客户和服务之间的通信，套所作的事情只是让线程注册一个套间，而线程运行过程中就必然在此套间中，就象我们每个活着的人，都一定属于某个国家一样。需要强调的是，套间是com中用来解决并发调用冲突的很有效的办法BeforecallinganyCOMfunctions,athreadneedstocallCoInitializetoloadtheCOMinfrastructure(andtoenteranapartment).OnceathreadcallsCoInitialize,thethreadisfreetocallCOMAPIs.CoInitialize(0)让当前线程进入一个STA的ApartmentCoInitialize、CoInitializeEx都是windows的API，主要是告诉windows以什么方式为程序创建COM对象。有哪些方式呢？单线程和多线程。CoInitialize指明以单线程方式创建。CoInitializeEx可以指定COINIT_MULTITHREADED以多线程方式创建。创建单线程方式的COM服务器时不用考虑串行化问题，多线程COM服务器就要考虑。在使用中，使用CoInitialize创建可使对象直接与线程连接，得到最高的性能。创建多线程对象可以直接接收所有线程的调用，不必像单线程那样需要消息排队，但却需要COM创建线程间汇集代理，这样访问效率不高。来看一下delphi的代码，在ComObj.pas和ComServ.pas代码中有这样的一个函数：procedureInitComObj;beginifSaveInitProc<>nilthenTProcedure(SaveInitProc);if(CoInitFlags<>-1)andAssigned(ComObj.CoInitializeEx)thenbeginNeedToUninitialize:=Succeeded(ComObj.CoInitializeEx(nil,CoInitFlags));IsMultiThread:=IsMultiThreador((CoInitFlagsandCOINIT_APARTMENTTHREADED)<>0)or(CoInitFlags=COINIT_MULTITHREADED);//thisflaghasvaluezeroendelseNeedToUninitialize:=Succeeded(CoInitialize(nil));end;很明显他就是用来调用CoInitialize初始化com环境的。在ComObj.pas的initialization部分：initializationbeginLoadComExProcs;VarDispProc:=@VarDispInvoke;DispCallByIDProc:=@DispCallByID;{$IFDEFMSWINDOWS}SafeCallErrorProc:=@SafeCallError;{$ENDIF}ifnotIsLibrarythenbeginSaveInitProc:=InitProc;//将InitProc指针指向InitComObj函数。InitProc:=@InitComObj;end;end;来到Forms.pas文件中，看一下TApplication.Initialize部分：procedureTApplication.Initialize;beginifInitProc<>nilthenTProcedure(InitProc);end;所以说，只要我们在dpr文件中包含了ComObj.pas或者是ComServ.pas，delphi就会自动为我们初始化com环境，这样就不用我们手动调用了。在delphi中调用COM控件有下面几种方法：CreateComObject、CreateOleObject，这两个函数都包含在ComObj.pas中。通过ImportTypeLibrary将COM控件导入，生成的pas文件都包含ComObj这个单元。还有通过ImportActivex生成的pas文件也会包含ComObj单元。所以说，delphi使用COM控件不需要手动调用CoInitialize",2014/2/19
760,Delphi自我删除方法,孙传金,http://180.168.156.212:2262/wecenter/?/article/8522,"在程序自我更新时，我们需要将自身的程序关闭，使用新的程序替换自身程序，我们可以使用批处理文件的方式，将更新文件替换自身程序，代码如下：procedureTForm1.CloseMyself;varf:textfile;beginassignfile(f,'.\delmyself.bat');rewrite(f);writeln(f,'@echooff');writeln(f,':loop');writeln(f,'del""'+application.ExeName+'""');writeln(f,'ifexist.\file.exegotoloop');writeln(f,'del.\delmyself.bat');closefile(f);winexec('.\delmyself.bat',SW_HIDE);close;end;winexec(pchar('command.com/cdel'+ParamStr(0)),SW_MINIMIZE);//最小化执行删除操作，否则将看到DOS窗口的瞬间闪烁",2014/2/19
761,产品、组件构件的定位,杨木江,http://180.168.156.212:2262/wecenter/?/article/8521,我觉的一个产品还是要体现在核心功能上，做好的接口应对各种项目的需求，一个良好的产品不是去适应规则，而是规则的制定和引领！,2014/2/19
762,从iPhone系统的文本选择功能，看苹果公司的团队合作与设计之上的理念,王链玮,http://180.168.156.212:2262/wecenter/?/article/8520,"原文截图前界面设计师首谈iOS文本选择功能的开发iOS,文本选择,设计师,BasOrding苹果新_副本.png",2014/2/19
763,借此宝地抛砖引玉，关于在现有条件下改善单机程序的界面展示效果的可行方案,王链玮,http://180.168.156.212:2262/wecenter/?/article/8519,现在单机工具软件的界面太素，已经很落伍了，之前往往是设计出一个界面，由于实现不了，最终做出的效果是打了很多折扣的，甚至是设计人员去改设计；苹果公司的理念是技术迁就设计，而我们目前是相反的设计去迁就技术。。。当然现在可行的方案还是不少，比如升级IDE的方式，比如采用新的开发语言等等，但这些方式对于现有资源，现有进行中甚至是已经收尾的项目来说改造成本太大，所以不再本帖讨论范围之内。讨论1：根据公司现有的资源，想到的一种似乎靠谱的解决方案是单机界面中嵌套HTML网页，在网页中嵌套flash的方式进行展现，这样将界面展示方式交给善于此的flash和美工资源，这样运用的实例是迅雷的存钱罐界面，如附件所示。不知众大神对此有没有实例或经验可以传授？讨论2：在一体机项目中新设计的视频播放界面，如在单机程序中100%实现设计，众大神有没有靠谱的解决方案？迅雷存钱罐2.jpg迅雷存钱罐.jpg一体机视频截图.jpg,2014/2/18
764,IOS引导式访问教程,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8518,引导式访问是IOS6引入的一个新功能，它能帮助您在使用iPhone、iPad或iPodtouch时专注于一个任务。引导式访问限制设备运行单个app并让您控制可用的app功能。附件中是关于如何开启引导式访问的图文教程，有兴趣的同时可以看看。iOS：关于引导式访问.docx,2014/2/11
765,华为心声社区中的超搞笑视频，但又不得不承认人家有才。值得我们产品、市场相关部门好好学习！,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8517, /video/video/videoColligation.do?method=moreVideo&title=企业传奇其中有不少IPD相关的内容，大家在笑过之后可以回味一下。,2014/2/8
766,《上海市食品安全信息追溯管理办法》完成起草,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8516,本市已连续多年投入人力物力完善食品安全信息追溯体系建设，食药监管局、商务委已联合相关部门起草了食品安全信息追溯管理办法草案，目前该项目已列入2014年市政府规章审议项目，要求在肉类、蔬菜、粮食、食用油、乳制品、禽类、淡水鱼等7类食品领域必须建立食品安全信息追溯体系。《上海市食品安全信息追溯管理办法》完成起草.mht,2014/1/28
767,建议wotalk增加功能,孙进,http://180.168.156.212:2262/wecenter/?/article/8515,每次到过节的时候，公司都有不少外地员工离开上海，有时候想联系谁，打电话一问回老家了，如果能提前知道，想必是极好的。公司有OA方便办公，有wotalk方便联系，那能不能集成得再紧密点，让wotalk自动读取OA的请假和外出，然后在wotalk的状态上显示出来，岂不美哉。,2014/1/28
768,从程序员到CTO的Java技术路线图,杨木江,http://180.168.156.212:2262/wecenter/?/article/8514,"在技术方面无论我们怎么学习，总感觉需要提升自已不知道自己处于什么水平了。但如果有清晰的指示图供参考还是非常不错的，这样我们清楚的知道我们大概处于那个阶段和水平。Java程序员高级特性反射、泛型、注释符、自动装箱和拆箱、枚举类、可变参数、可变返回类型、增强循环、静态导入核心编程IO、多线程、实体类、集合类、正则表达式、XML和属性文件图形编程AWT（Java2D/JavaSound/JMF）、Swing、SWT、JFace网路编程Applet、Socket/TCP/UDP、NIO、RMI、CORBAJava语法基础类、抽象类、接口、最终类、静态类、匿名类、内部类、异常类、编码规范Java开发环境JDK、JVM、Eclipse、LinuxJava核心编程技术Java，设计而又非常精巧的语言。学习Java，须从Java开发环境开始，到Java语法，再到Java的核心API。1.Java开发入门：Java开发环境的安装与使用，包括JDK命令、EclipseIDE、Linux下Java程序的开发和部署等。2.Java语法基础：基于JDK和Eclipse环境，进行Java核心功能开发，掌握Java面向对象的语法构成，包括类、抽象类、接口、最终类、静态类、匿名类、内部类、异常的编写。3.Java核心API：基于JDK提供的类库，掌握三大核心功能：A。Java核心编程:包括Java编程的两大核心功能——Java输入/输出流和多线程，以及常用的辅助类库——实体类、集合类、正则表达式、XML和属性文件。B。Java图形编程：包括Sun的GUI库AWT（Java2D、JavaSound、JMF）和Swing，IBM和GUI库SWT和Jface;C.Java网路编程：Applet组件编程，Socket编程，NIO非阻塞Socket编程、RMI和CORBA分布式开发。4.Java高级特性：掌握JDK1.4、JDK5.0、JDK6.0中的Java高级特性，包括反射、泛型、注释，以及java高级特性——自动装箱和拆箱、枚举类、可变参数、可变返回类型、增强循环、静态导入等。JavaEE初级软件工程师JSF框架开发技术配置文件（页面导航、后台Bean）、JSF组件库（JSFEL语言、HTML标签、事件处理、）、JSF核心库（格式转换、输入验证、国际化）Javaweb核心开发技术开发环境（Eclipse、Linux）三大组件（JSP、JavaBean、Servlet）扩展技术（EL、JSTL、Taglib）网页开发技术HTML、XML、CSS、JavaScript、AJAX数据库设计技术SQL、MySql、Oracle、SQLServer、JDBCWeb服务器（Tomcat/Jetty/Resin/JBossWeb）JavaWeb核心技术：JavaWeb项目开发的全过程可以分解为：网页开发+数据库设计——>JavaWeb项目开发，其中，javaWeb由6项基本技术组成：JSP+JavaBean+Servlet+EL+JSTL+Taglib，而JSF正是将这6种技术进行有机结合的技术框架：JavaEE中级软件工程师四种经典架构SSH1、SSI1、SSH2、SSI2Struts1表现层框架入门配置、核心组件、标签库、国际化、数据检验、数据库开发、Sitemesh集成、集成Hibernate/iBATISStruts2表现层框架入门配置、核心组件、标签库、国际化、数据校验、Sitemesh集成转换器、拦截器、集成Hibernate/iBATISSpring业务层框架入门配置、IoC容器、MVC、标签库、国际化、数据校验、数据库开发Hibernate持久层框架MySQL、Oracle、SQLServeriBATIS持久层框架MySQL、Oracle、SQLServerWeb服务器（Tomcat/Jetty/Resin/JBossWeb）Java高级软件工程师javaWeb开源技术与框架工作流、规则引擎搜索引擎、缓存引擎、任务调度、身份认证报表服务、系统测试、集群、负载平衡、故障转移JavaWeb分布式开发技术JTA（Java事物管理）JAAS（Java验证和授权服务）JNDI（Java命名和目录服务）JavaMail（Java邮件服务）JMS（java信息服务）WebService(web服务)JCA（java连接体系）JMS（java管理体系）应用服务器（JBossAS/WebLogic/WebSphere）JavaEE系统架构师面向云架构（COA）COA、SaaS、网格计算、集群计算、分布式计算、云计算面向资源架构（ROA）ROA、RESI面向web服务架构（SOA）WebService、SOA、SCA、ESB、OSGI、EAIJava设计模式创建式模式：抽象工厂/建造者/工厂方法/原型/单例构造型模式：适配器/桥接/组合/装饰/外观/享元/代理行为型模式：责任链/命令/解释器/迭代子/中介者/备忘录/观察者/状态/策略/模板方法/访问者Java与UML建模对象图、用例图、组件图、部署图、序列图、交互图、活动图、正向工程与逆向工程CTO首席技术官发展战略技术总监团队提升团队建设项目管理产品管理下面的更深入的有兴趣可以了解一下，我的目的不是要大家掌握下面的知识，只是希望扩展自己的思维，摘自牛人的技术博客。/**************************************************牛人必看*****************************************************************/系统后台框架： /images/magplus.gif),pointer;border-top:0px;border-right:0px;border-bottom:0px;border-left:0px""title=""点击查看原始大小图片""width=""700""/>",2014/1/27
769,软件新产品开发失败原因分析,潘云峰,http://180.168.156.212:2262/wecenter/?/article/8513,新产品开发是企业远离残酷竞争、获取持续经营优势和实现绩效目标的不二法宝。通用电气、微软、思科、英特尔、3M、宝洁和杜邦等获得持续成功的国际性企业无一例外都在产品创新方面成为行业领导者。我国的许多企业也正在逐步摆脱低水平模仿的红海，开始走上自主创新之路。但一项国际权威研究表明：在大多数企业进行的新产品开发活动中，平均每7个新产品创意，有4个进入开发阶段，有1.5个进入市场，只有1个能取得商业化成功。新产品开发的失败率之高可见一斑。很多企业在新产品开发过程和市场推广活动中投入了大量的人力、资源和金钱，但回报却差强人意，甚至有的企业由此失去了再次卷土重来的本钱。纵观众多失败或成功的案例，新产品开发成败的关键无非在于三个方面：战略、流程和团队。一、战略方面对于企业新产品开发而言，战略是指路明灯，其决定了企业新产品开发的方向和范围。一些企业在新产品开发方面朝三暮四、浅尝辄止或者遍地开花、广种薄收，其最根本的原因就是战略的缺失。有效的战略定位能使企业专注于自己的事业而不受其它短期诱惑的干扰;能使企业为其目标顾客创造出独特的价值;能使企业将有限的资源聚焦在能产生最大绩效的少数几件事情上。缺乏清晰明确的战略定位的企业在新产品开发方面可能“赢得一场战斗，但很可能输掉整场战争”。战略的缺失导致新产品开发失败主要表现在如下三个方面：1、目标顾客定位不清晰。一些企业将目标顾客定位为渠道商或者是购买产品的人，而未能充分考虑最终的消费者的行为特征及需求。我们可以期望连为谁开发产品都未能达成共识的团队将会开发出什么样的新产品?“准备、射击、瞄准”的程序是不太可能打出10环的成绩的。目标顾客定位的目的就是要在对目标顾客群的地理范围、行为特征及心理需要进行充分了解和分析的基础上，提出独具特色的新产品创意。2、顾客价值定位没特色。一些企业清楚自己的目标顾客是谁，但是未能对目标顾客的价值需要进行深入分析和了解，未能有效的“倾听顾客的声音”，也未能将企业拟开发新产品的价值要素与竞争对手的同类产品进行对比，很多企业只是简单的模仿竞争对手的产品或者在竞争产品的基础上稍加改进即急不可耐地将“新产品”推向市场。由于产品与竞争对手雷同，企业只能通过广告战、渠道战和价格战与同类产品在红海中进行搏杀，其结果要不是两败俱伤，要不就是一败涂地。这样的案例在我国当前的彩电、空调、手机、饮料和啤酒等行业层出不穷。3、商业模式定位无实效。有些企业的目标顾客定位清晰、产品也受顾客喜爱，但是成本却高居不下。如果维持高价，则销量很难达到规模效应;如果低于成本价格销售，则可能卖得越多赔得越多，形成赔钱赚吆喝的局面。有效的商业模式定位应该在提升顾客价值的同时降低企业成本，而不是在二者之间进行权衡和取舍。企业可在内部运营流程、外部合作伙伴及产品定价模式等方面进行创新，以有效控制企业成本，实现目标利润水平。二、流程方面战略定位决定企业是否“做正确的事”，而流程设计则决定企业能否“正确地做事”。有好的战略的企业不少，但如果流程设计不对或者流程实施质量不高，最终也难以开发出成功的新产品。流程是最佳实践的总结，是企业做事的规范。设计和实施经实践验证系统有效的流程，能使企业缩短自行摸索前行的时间，避免走一些不必要的弯路。“多、快、好、省”地开发出新产品是新产品开发流程设计和实施的目的。企业在新产品开发流程方面容易出现的主要问题有：1、缺乏系统科学的新产品开发流程。很多企业在新产品开发方面的管理还仅局限于项目管理的水平，甚至项目管理做得都不太理想。中国很多企业对为世界500强企业普遍采用的新产品开发过程管理方法——门径管理(Stage-Gate)方法知之不多。在项目筛选、开发、测试和上市的各个阶段相互衔接之处缺乏有效的检测和评价标准。由于缺乏系统规范的流程而导致项目半途而废、多次返工和上市时机延误的情况比比皆是。2、前期产品定义准备工作不充分。很多企业以赶进度为由，对新产品开发前的论证阶段投入的人力和资源非常有限。更有一些企业的新产品开发完全基于某位公司领导的“拍脑袋”，或者以“边做边想”为指导思想。其结果很可能是“一步错，步步错”，这就好比建房子，事先没有蓝图或者基础没打牢，最后要么房子建不起来，要么就是建起来也很快倒塌。成功的新产品开发经验表明，在正式进入开发阶段前，应进行非常严肃的市场、技术和商业可行性研究，产品本身定义也至少应有50%的确定内容，其余50%应有基本的想法，并在开发过程中进行验证和调整。3、产品组合管理决策失效。一些企业创意很多，而且觉得这些创意都有开发成新产品的必要。但是企业的资源特别是人力资源总是非常有限的，过多同时展开的项目导致重要项目一再延期上市或者最终开发不出有市场竞争力的新产品。“百鸟在林不如一鸟在手”。在进行项目筛选时，企业管理团队应设定“必须满足的条件”和“应该满足的条件”。对于“必须满足的条件”如战略一致性、市场吸引力和技术可行性等应遵循“一票否决制”的原则，对不符合其中的任何一条的新产品项目应坚决中止。而对于那些通过“必须满足的条件”的检验的项目，也应该继续按“应该满足的条件”通过打分进行资源优先排序，对排序靠后但是公司没有资源的项目也应该暂行搁置，而不应该试图勉强为之。三、团队方面团队是决定“做什么”及践行“如何做”的主体。在明确方向和掌握方法的基础上，团队能力及其行动最终决定了企业的绩效水平。团队能力是潜在的，是需要激发与培养的，不同企业在不同的发展阶段需要提升和发挥不同侧重的能力。团队能力、内外资源及企业声誉共同构成了企业实力的三大要素。就新产品开发而言，企业团队需要具备的能力主要体现在三个方面：1、领导决策能力。领导者最重要的三项职能为：指引方向、整合资源以及激励团队。其中指引方向就是指领导者要具备卓有成效的决策能力。企业首先要决定其“狩猎”范围，即决定通过什么方式为谁提供什么产品和服务，这也是企业战略定位的核心。国内一些家电企业盲目攀比，贪大求全，其结果是什么都想做，也什么都做了，但什么都没做好。这是典型的战略缺失表现。在明确企业整体发展战略的基础上，还应制定具体的产品组合战略，即决定基础研发、新产品开发及现有产品改进各占多大的比例。有些企业只注重短期目标的实现，不愿在基础研究方面适当“下注”，其结果是企业发展后劲不足，无法确立可持续的核心经营优势。此外，企业的领导决策能力还应体现在具体的产品筛选层面，即在进入正式的开发流程前要决定哪些新产品创意可以进入开发阶段，哪些应该扼杀，哪些应该搁置，哪些应该做进一步的调查研究。企业发展战略、产品组合战略及项目筛选决策共同构成了企业依次进行的系统完整的新产品开发决策过程。2、流程管理能力。明确了新产品开发的决策流程及内容，企业需要做的就是通过系统的流程将新产品开发出来并成功上市。具备一定规模的高新技术企业都有专职或兼职的流程经理。流程经理的主要职责就是在企业中导入系统科学的新产品开发过程管理流程并进行有效的管理，确保新产品开发从创意搜寻、范围确定、可行性研究，到开发实施、测试，再到上市及上市后的评价等每个环节都能“执行到位”。其中还包括组织对产品人员及研发人员的相关培训，每个重要决策点决策的组织和落实等工作。出色的流程经理能使企业的新产品开发过程有条不紊地进行，不会忽略或遗忘任何重要的环节。3、相关专业能力。如果说领导决策能力和流程管理能力是实现成功的新产品开发的保证的话，那么相关专业能力则是其基础。再好的决策和流程，如果没有相应专业人员的智慧和汗水的付出，也不可能成就任何事业。软件、电子、IT、通信、医药、化工等等行业的新产品开发都需要相应专业人员的专业能力。高新技术企业的专业人员就好比饭店的厨师，没有优秀的厨师饭店是不可能做出各种各具特色的美食的。所以，相关专业人员专业能力的培养和提升是企业进行新产品开发的基础，专业能力是企业最重要的核心能力之一。由上可见，要提高新产品开发的成功率，要做到“多、快、好、省”地开发新产品，企业就必须从战略、流程和团队三方面着手对企业现状进行全方位的审计，认真思考和回答如下三个问题：(1)我们的战略定位清晰吗?全体员工都理解和认同我们的战略并愿意为之全力以赴吗?(2)我们的流程管理完善吗?我们能确保从创意到上市的所有环节都有章可循吗?(3)我们的团队能力具备吗?我们有充分的信心和能力开发出目标顾客所预期的新产品吗?,2014/1/25
770,Delphi事件日志参考,胡贤卿,http://180.168.156.212:2262/wecenter/?/article/8512,"目前灵器产品在日志方面还比较欠缺,这里提供一种比较新的日志方式,起码目前的灵器产品中还没发现有使用.样例如图最上时间(通用浏览器作为测试),可以考虑用产品英文简称作为来源进行管理，维护调试的时候也比较容易查看。使用函数：withTEventLogger.Create('CESBROWER')dotryLogMessage(['NOERROR',''],etWarning,Category_Business,EventID_Operate);finallyFree;end;部分单元函数：procedureTEventLogger.LogMessage(Message:arrayofString;EventType:TEventType;Category:Word;ID:DWord);varP:Pointer;NumStrings:Word;begintryifFEventLog=0thenFEventLog:=RegisterEventSource(nil,PChar(FName));P:=PChar(@Message);NumStrings:=Length(Message);ReportEvent(FEventLog,TEventTypeArray[EventType],Category,ID,nil,NumStrings,0,P,nil);exceptShowMessage('写事件日志错误');end;end;eventlog.bmp",2014/1/24
771,中信十年，感恩中信,杨木江,http://180.168.156.212:2262/wecenter/?/article/8511,感谢大张总教会我坦诚、真诚、诚实、正直，敢做敢为的做事风格；感谢女张总让我知道何谓管理、绩效、培训；让我明白关注员工成长，管理出效益，实践出真理；只有有勇气去实践才有希望收获成功；管理不只是门科学，更是一门艺术；感谢小张总让我明白目标、理想、策略、胸怀的重要性；只有拥有宽阔的胸怀，远大的理想，才能站在全局的高度去考虑问题，发现机会从而实现理想；眼光不只只是胸怀和谋略，更是需要高瞻远瞩，需要牺牲小我，完成大我；感谢杨总让我认识到对于软件企业技术只是手段，业务才是企业的核心、财富及竞争力；你可以不熟悉技术、不熟悉软件工程，但是你不能不熟悉业务；业务是现实需求，是人们的期望，是市场，技术只是工具，我们只需要了解如何去使用它就可以了；,2014/1/24
772,Jar包数字签名的好处，保护组件、构件及产品的原始性,杨木江,http://180.168.156.212:2262/wecenter/?/article/8510,作为公司统一的推广的java组件、构件及产品应尽可能的把java类按功能或业务打成jar包，然后进行数字签名。以防止在推广及使用过程中出现被项目部（或第三方）进行篡改（同时也可防病毒）。从而保证代码的原始性、真实性，对于进行统一的维护、更新及升级有较大的帮助。一旦一个已签名jar包文件中的内容被修改后，应用服务器加载该jar包时将会抛出异常，明确指出jar包中的那些文件被篡改，如：Causedby:Unabletoloadjar:file:/E:/workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp1/wtpwebapps/fundevelop/WEB-INF/lib/xarch-1.1.0.jar!/struts.xml-Class:sun.security.util.ManifestEntryVerifier该异常指出在xarch-1.1.0.jar中的struts.xml文件被篡改了，因此无法加载该jar包,2014/1/20
773,公司CMMI5级认证的成果文件分享 -评审过程优化改进方案,王链玮,http://180.168.156.212:2262/wecenter/?/article/8509,详见附件10-评审过程优化改进方案(第十稿).xls,2014/1/17
774,公司CMMI5级认证的成果文件分享 -敏捷开发改进活动方案,王链玮,http://180.168.156.212:2262/wecenter/?/article/8508,下载附件敏捷开发改进活动方案121024.xls,2014/1/17
775,方正国际对于EEP封装的解决方案,王链玮,http://180.168.156.212:2262/wecenter/?/article/8507,见附件EEP封装工具软件-新闻动态-方正国际软件有限公司.png,2014/1/17
776,使用Office OCR转换时存在的问题,张守伟,http://180.168.156.212:2262/wecenter/?/article/8506,首先确定转换工具主程序和OfficeOCR组件程序都已加入到数据执行保护，加入方法如下：在WindowsServer2003系统右键单击“我的电脑”，选择“属性”-->“高级”-->“性能”-->“设置”-->“数据执行保护”，在“除所选之外，为所有程序和服务启用数据执行保护”下面的列表中增加使用OCR的程序，这里是：文件格式转换服务器的安装目录\PDFTransfer.exe也可以直接选择“只为关键Windows程序和服务启用数据执行保护”选项，不过这样可能降低系统的安全性。最近接到个一个实施人员反馈的一个很奇怪的问题，就是“文件格式转换服务器”进行中信OCR转换时，提示成功，但是却没有生成转换后的PDF文件。的来到申银万国现场才发现原来是OfficeOCR组件本身的问题。所以，在处理中信息OCR转换相关的问题时，最好先确定OfficeOCR组件是否工作正常，以免浪费不必要的时间。确定OfficeOCR组件是否正常的方法：1、先准备一个含有OCR信息的Tif图片文件。2、打开Office的DocumentImaging程序，（能过开始菜单或直接进入C:\ProgramFiles\CommonFiles\MicrosoftShared\MODI\12.0\(根据系统安装的环境确认该路径)打开MSPVIEW.EXE，程序界面如下：图片显示不了，就看附件吧。然后打开准备好的Tiff文件，接下来点击“工具”菜单下的“使用OCR识别文件”，如果OfficeOCR组件有问题，会弹出一个报错对话框，此时就需要对OfficeOCR组件进行修复(此问题基本上都是出现在Office2007的版本，只要安装一下对应的补丁包就行了)。111.JPG,2014/1/17
777,Delphi脱离控件简易图片处理,胡贤卿,http://180.168.156.212:2262/wecenter/?/article/8505,"当前灵器产品基本都运用了控件作为图片处理的主力这里简单举例利用系统函数进行图片转换在一般情况下以bmp图像作为图像转换的发起点，对于其他格式的图像首先把它转换为位图。procedureTFormMain.PicToBMP(Picture:TPicture);varBmp:TBitmap;beginifnot(Picture.GraphicisTBitmap)then//判断是否是BMP图像beginBmp:=TBitmap.Create;//不是BMP图形，就生成一个tryBmp.Width:=Picture.Width;bmp.Height:=Picture.Height;bmp.Canvas.Draw(0,0,Picture.Graphic);//把其他格式的图像复制到BMPPicture.Graphic:=Bmp;//原始非BMP图像转换为BMP图像FinallyBmp.Free;end;end;end;利用得到的bmp图像根据实际需求，对长和宽进行尺寸改变procedureTFormMain.PicToMiniature(SourceBMP,DescBMP:TBitmap;picH,picW:Integer);varbmp:TBitmap;begintrybmp:=TBitmap.Create;//生成位图bmp.Assign(SourceBMP);//位图图像为SourceBMP,ifpicW>255thenPicW:=255;//长宽不可超出255ifpicH>255thenpicH:=255;bmp.Width:=PicW;bmp.Height:=PicH;bmp.PixelFormat:=pf24bit;//24位位图bmp.Canvas.StretchDraw(Rect(0,0,picW,picH),SourceBMP);//使位图尺寸符合要求DescBMP.Assign(bmp);finallybmp.Free;end;end;之后的工作,可以以得到的bmp文件所以源进行转换，根据具体的需求可以进行具体的转换操作这里也只是一个举例希望能逐步摆脱对控件的全面依赖",2014/1/17
778,delphi实现图片文字水印效果,许海宝,http://180.168.156.212:2262/wecenter/?/article/8504,"通用浏览器目前只有pdf加文字水印方法，现研究了用imageenview控件添加字体水印方法先生成文字图片functionTFunImage.DrawWaterMarkFile(sTextInfo,sFont,sColor:WideString;nSize,nRowWidth,nColHeight,ImgWidth,ImgHeight,nAngle:Integer;varsResultFile,sMsg:string):Boolean;varimageenView:TImageEnView;Color:TColor;beginResult:=False;tryimageenView:=TImageEnView.Create(nil);tryimageenView.Width:=ImgWidth;imageenView.Height:=ImgHeight;imageenView.IO.Bitmap.Width:=ImgWidth;imageenView.IO.Bitmap.Height:=ImgHeight;imageenView.LayersAdd;imageenView.Proc.Fill(CreateRGB(255,255,255));imageenView.Bitmap.Canvas.Font.Name:=sFont;imageenView.Bitmap.Canvas.Font.Size:=nSize;Color:=GetColorValue(sColor);imageenView.Bitmap.Canvas.Font.Color:=Color;IETextOut(imageenView.Bitmap.Canvas,imageenView.Height,imageenView.Width,nRowWidth,nColHeight,nAngle,sTextInfo);//drawtextonsecondlayerimageenView.Proc.SetTransparentColors(CreateRGB(255,255,255),CreateRGB(255,255,255),0);sResultFile:='c:\1.bmp';imageenView.IO.SaveToFile(sResultFile);finallyFreeAndNil(imageenView);end;exceptonE:ExceptiondosMsg:='水印文件生成失败，原因：'+E.Message;end;end;其中图片画布对象写入文字功能函数procedureTFunImage.IETextOut(Canvas:TCanvas;nheight,nWidth,x,y:integer;angle:integer;constText:string);varLogFont:TLogFont;iTextWidth,iTextHeight:Integer;nCurrentX,nCurrentY:Integer;beginiTextWidth:=0;iTextHeight:=0;nCurrentY:=0;whilenCurrentY<nheightdobeginnCurrentX:=0;whilenCurrentX<nWidthdobeginwithCanvasdobeginGetObject(Font.Handle,SizeOf(TLogFont),@LogFont);LogFont.lfEscapement:=angle*10;LogFont.lfQuality:=3;Font.Handle:=CreateFontIndirect(LogFont);ifiTextWidth=0theniTextWidth:=TextWidth(Text);ifiTextHeight=0theniTextHeight:=TextHeight(Text);ifnCurrentY=0thenbeginTextOut(nCurrentX,iTextHeight,Text);nCurrentY:=iTextHeight;endelseTextOut(nCurrentX,nCurrentY,Text);end;nCurrentX:=nCurrentX+iTextWidth+x;end;nCurrentY:=nCurrentY+iTextHeight+y;end;end;然后用imageenview添加新的图层设置透明度functionTFunImage.SaveWaterMarkFile(sSaveFileName:string):Boolean;varisel:Integer;beginresult:=true;tryimageenView.LayersAdd;///添加图层imageenView.IO.LoadFromFile(sImageFileName);//图层载入图片文件isel:=imageenView.LayersCurrent;imageenView.Layers[isel].Transparency:=150;//当前图层透明度imageenView.Layers[isel].Operation:=ielmul;//当前图层渲染类型imageenView.LayersMergeAll;//合并图层imageenView.IO.SaveToFileJpeg(sSaveFileName);//生成添加水印后的图片文件exceptresult:=false;end;end;1.JPGsss1.JPGsss.jpg",2014/1/17
779,调用命令行程序后立即就判断所存在的隐患,张守伟,http://180.168.156.212:2262/wecenter/?/article/8503,有时我们会在自己的代码中调用一个EXE程序来实现某些功能，然后紧接就来判断这个EXE程序所操作的结果。比如“文件格式转换服务器”中就有类似代码：执行winhtml.exe把html文件转换到pdf1.pdf，然后紧接着就判断，如下：ifFileExists(pdf1.pdf)thenbeginResult:=True;…….end;看似这段代码没有什么问题，但是在有些电脑下运行却产生一个错误的结果，特别是那些比较慢的电脑。因为有可以pdf1.pdf这个文件还没有生成，而判断语句if就先执行了。而得到的错误的结果就是这个文件没有生成出来，而实际上这个文件已经成功的生成了。建议：这样的代码应该在中间加个延时，如：执行winhtml.exe把html文件转换到pdf1.pdf，然后紧接着就判断，如下：Sleep(500);ifFileExists(pdf1.pdf)thenbeginResult:=True;…….End;,2014/1/17
780,Delphi 对不同编码格式的文本文件的处理方式,陈军志,http://180.168.156.212:2262/wecenter/?/article/8502,"转换工具使用北京文通OCR过程中，需要用到北京文通OCR生成的临时txt文本文件，此临时文件的格式在北京文通不同版本的程序中不同，我们在读取其内容时，需要判断文本文件的编码格式，再根据不同的格式进行读取。1、判断文本文件的编码格式方法如下：TTextFormat=(tfAnsi,tfUnicode,tfUnicodeBigEndian,tfUtf8);constTextFormatFlag:array[tfAnsi..tfUtf8]ofword=($0000,$FFFE,$FEFF,$EFBB);functionWordLoHiExchange(w:Word):Word;register;asmXCHGAL,AHend;{TextFormat返回文本编码类型}procedureReadTextFile(constFileName:string;varTextFormat:TTextFormat);varw:Word;b:Byte;beginwithTFileStream.Create(FileName,fmOpenReadorfmShareDenyNone)dotryRead(w,2);w:=WordLoHiExchange(w);//因为是以Word数据类型读取，故高低字节互换ifw=TextFormatFlag[tfUnicode]thenTextFormat:=tfUnicodeelseifw=TextFormatFlag[tfUnicodeBigEndian]thenTextFormat:=tfUnicodeBigEndianelseifw=TextFormatFlag[tfUtf8]thenbeginRead(b,1);//这里要注意一下，UFT-8必须要跳过三个字节。TextFormat:=tfUtf8;endelsebeginTextFormat:=tfANSI;Position:=0;end;finallyFree;end;end;2、读取特殊文本格式的方法（Unicode、UtF-8）：1)Unicode文件读取函数functionLoadUnicodeFile(constFileName:string;ReadHeader:Boolean=True):string;varMemStream:TMemoryStream;FlagStr:String;WStr:WideString;beginResult:='';ifnotFileExists(FileName)thenExit;MemStream:=TMemoryStream.Create;tryMemStream.LoadFromFile(FileName);ifReadHeaderthenbeginSetLength(FlagStr,2);MemStream.Read(FlagStr[1],2);ifFlagStr=#$FF#$FEthenbeginSetLength(WStr,(MemStream.Size-2)div2);MemStream.Read(WStr[1],MemStream.Size-2);end;endelsebeginSetLength(WStr,MemStream.Sizediv2);MemStream.Read(WStr[1],MemStream.Size);end;Result:=AnsiString(WStr);finallyMemStream.Free;end;end;2)UtF-8文件读取函数functionLoadUTFFile(constFileName:string;ReadHeader:Boolean=True):string;varMemStream:TMemoryStream;S,HeaderStr:string;beginResult:='';ifnotFileExists(FileName)thenExit;MemStream:=TMemoryStream.Create;tryMemStream.LoadFromFile(FileName);ifReadHeaderthenbeginSetLength(HeaderStr,3);MemStream.Read(HeaderStr[1],3);ifHeaderStr=#$EF#$BB#$BFthenbeginSetLength(S,MemStream.Size-3);MemStream.Read(S[1],MemStream.Size-3);end;endelsebeginSetLength(S,MemStream.Size);MemStream.Read(S[1],MemStream.Size);end;Result:=Utf8ToAnsi(S);finallyMemStream.Free;end;end;",2014/1/17
781,关于ADO方式访问mdb、excel、dbf文件方式,孙传金,http://180.168.156.212:2262/wecenter/?/article/8501,导入导出工具中使用的比较频繁的就是对于一般导入的数据的读取，文件格式会有mdb、excel和dbf这几种常见格式，一般从效率的角度出发，采用ado方式访问会大幅提高数据的读取效率，一般访问的字符串为：mdb：C_CONNECTIONSTRING='Provider=Microsoft.Jet.OLEDB.4.0;'+'DataSource=%s;'//数据库文件(*.mdb)位置+'UserID=%s;'//用户工作组(*.mdw)用户名Admin+'Password=%s;'//用户工作组(*.mdw)密码+'PersistSecurityInfo=False;Mode=Read;'+'ExtendedProperties=%s'//默认值为空excel2013格式(xls)：C_CONNECTIONSTRING='Provider=Microsoft.Jet.OLEDB.4.0;'+'DataSource=%s;'//数据库文件(*.mdb)位置+'UserID=%s;'//用户工作组(*.mdw)用户名Admin+'Password=%s;'//用户工作组(*.mdw)密码+'PersistSecurityInfo=False;Mode=Read;'+'ExtendedProperties=excel8.0'//默认值为空excel2007格式(xlsx)：C_CONNECTIONSTRING='Provider=Microsoft.ACE.OLEDB.12.0;'+'DataSource=%s;'//数据库文件(*.mdb)位置+'UserID=%s;'//用户工作组(*.mdw)用户名Admin+'Password=%s;'//用户工作组(*.mdw)密码+'PersistSecurityInfo=False;Mode=Read;'+'ExtendedProperties=excel12.0'//默认值为空dbf：C_CONNECTIONSTRING='Provider=Microsoft.Jet.OLEDB.4.0;'+'DataSource=%s;'//数据库文件(*.mdb)位置+'UserID=%s;'//用户工作组(*.mdw)用户名Admin+'Password=%s;'//用户工作组(*.mdw)密码+'PersistSecurityInfo=False;Mode=Read;'+'ExtendedProperties=dBase5.0'//默认值为空我们可以看出，对于excel文件可能会用到两种方式访问，同时要输入excel的版本信息；Mode参数设置为只读方式，这样在访问源文件的时候可以在外部打开正在读取的文件,2014/1/17
782,test,沙大峣,http://180.168.156.212:2262/wecenter/?/article/8500,dfdfdpic.jpgpic.jpg,2014/1/16
783,创新无极限：CES 2014上10大创新产品,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8499,这个英文缩写和我们公司一样的全球最牛叉消费电子展，每年年初总能给世人带来眼前一亮的创新产品，我们是不是也能从其中获得一些灵感。CES2014上10大创新产品.mht,2014/1/15
784,杨冬权局长《在全国档案局长馆长会议上的讲话》2013,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8498,2014年1月新鲜出炉杨冬权在全国档案局长馆长会议上的讲话2013.mht,2014/1/15
785,公司往年设计的PPT模板发布在什么地方？哪里可以下载？,孙建兵,http://180.168.156.212:2262/wecenter/?/article/8497,发帖也不知道哪里合适，就先放放这里，打扰了。,2014/1/13
786,delpin组件：自制进度条,王孝本,http://180.168.156.212:2262/wecenter/?/article/8496,设计目的简化DELPHI程序开发，集成进度条显示，使开发人员只需要关注业务的具体步骤，无需考虑进度条前进步数的计算。组件特色支持无限多层显示，可控的、多颜色子进度显示；加入了事件的触发，在进度条显示过程中加入了事件触发，便于开发人员对程序流程的控制。可控的显示位置及显示方式，调用者可以提供进度条的显示位置，也可不提供，不提供时自动创建显示窗体。可以设置是否显示进度条，一便在服务程序中用于程序流程的控制。应用场合数据导入导出工具、格式转换等各种DELPHI开发的需要进度条显示的场合，可进一步封装成DLL，用于所有WINDOWS程序。参数及事件说明函数：Create：创建函数；参数为进度条显示的容器，如为空（nil）则由组件自己创建。SetTopRealNum：设置总的真实数量，即设置第一层的总步数。AddSubLevel：增加一子层，参数为子层的真实数量即子层的总步数。GoPriorLevel：从子层中返回上一次，当为第一层时将抛出异常。StepOne：在当前层上前进一步。GoEnd：直接执行到最后，如果有多层则会顺序返回到第一层，内部调研GoPriorLevel方法，执行过程中根据参数设置确定是否触发LevelPriorBefo及LevelPriorAfter事件。属性：TopPointer：第一层的结构信息；Currently：当前层的结构信息；CreateBar：是否显示进度条，只有在显示容器由组件自己创建时生效；ShowSubLin：增加子层次时是否显示子层次的进度条，子层的进度条为各种颜色的线，显示在进度条的最下面。ShowPercent：进度条上显示百分比；Caption：显示标题，只有在组件自己创建显示容器时生效；MainID：第三方的信息ID，此信息会在触发的事件中返回，调用者可根据此值做相应处理。EventWhenGoEnd：在执行GoEnd过程中是否触发LevelPriorBefo及LevelPriorAfter事件，默认为假，不触发。事件：BeginEvent：开始事件，组件开始执行时触发，即调用SetTopRealNum函数时触发；EndEvent：结束事件，组件释放或在第二次调用SetTopRealNum前触发，参数中有进度条的相关信息；DoStepEvent：前进一步事件，在进度条前进一步时触发，参数中有进度条的相关信息；DoCompleteEvent：完成事件，进度条进度达到百分百时触发；LevelNextBefo：增加子层前事件，在增加子层前触发，参数中有进度条的相关信息；LevelNextAfter：增加子层后事件，在增加子层后触发，参数中有进度条的相关信息；LevelPriorBefo：返回到上一层前事件，在返回到上一层前触发，参数中有进度条的相关信息；LevelPriorAfter：返回到上一层后事件，在返回到上一层后触发，参数中有进度条的相关信息。使用方法1、总步骤：A、创建（Create）；B、设置属性及事件；C、设置总数量（SetTopRealNum）；D、调用前进一步方法（StepOne）；E、根据需要调用增加子层方法（AddSubLevel）；F、调用前进一步方法，在子层中前进一步（StepOne）；G、根据需要调用返回上层方法（GoPriorLevel）；H、调用前进一步方法（StepOne）；I、根据需要执行GoEnd方法；J、释放（FreeAndNil或Free）。注意事项有子层时，子层相当于此层的一步，即相当于在本次内执行了一次StepOne，在子层返回上一层时执行即在GoPriorLevel中执行，因此本层的总数量为执行StepOne的数量加上本层中所有子层的数量。在触发结束事件（EndEvent）时有可能是进度并未执行到最后，可使用返回的参数来判断；完成事件DoCompleteEvent有可能不触发。4、执行GoEnd时一定触发DoCompleteEvent事件。TestProcessBar.rar,2014/1/13
787,OCX、CAB文件可以进行权威机构数字签名,方俊新,http://180.168.156.212:2262/wecenter/?/article/8495,我们以前在IE上运行ocx都是裸装的方式，并没有打包成cab文件。安装时需要降低IE的安全级别或安装自己制作的根证书。最近有些人会问，为什么华表cab安装不用降低IE级别也不用安装证书，直接就可以安装运行了？感觉我们的ocx安装那么繁琐，在每个用户的客户端都要安装一遍是多么的麻烦呀。针对这些问题，最近对ocx的安装进行了一番研究，总结了有四种安装方式。（更详细信息可参考附件文档）购买权威机构的证书自制证书，但需要在每台客户机上安装修改IE的安全级别，允许未签名的OCX安装本地注册OCX在上面四种方式中，购买权威机构的证书是最方便的。最近公司采购了一套数字证书，可以给ocx、cab、dll等程序文件进行数字签名。这样我们的ocx、cab等文件在IE上安装就像安装华表的cab文件一样简单了。CAB、OCX在IE浏览器上安装.docx,2014/1/8
788,DWR（Direct Web Remoting）一个用于改善web页面与Java类交互的远程服务器端Ajax开源框架,史服宇,http://180.168.156.212:2262/wecenter/?/article/8494," 对应dwr.xml<createcreator=""new""javascript=""Hello""scope=""page"">5、自行设计调用处理方法<scripttype=""text/javascript"">functioncallback(str){alert(str);}functiontest(){Hello.sayHelloTo(""zhangsan"",callback);}</script>参考资料1．DWR搭建以及使用教程．OPEN经验库[引用日期2013-08-20]．",2014/1/7
789,从“金字塔”到“铁三角”：华为试点少将连长,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8493,“少将连长”我不知道大家听说过没有，反正我是第一次听说，一般连长的军衔应该是上尉，是部队中的基层管理岗位，大致相当于我们公司的“项目经理”。那么“少将连长”毫无疑问就是要让公司的高管（比如副总裁）深入第一线去担任重要项目的项目经理！任正非，这位军人总裁，再一次震惊了业界！“我们将试点少将连长，按员工面对项目的价值与难度，以及已产生的价值与贡献，合理配置管理团队及专家团队。” /telecom/detail_2014_01/01/32640712_0.shtml,2014/1/2
790,大数据：取之架构 用之架构,杨木江,http://180.168.156.212:2262/wecenter/?/article/8492,读后挺有感触的。因为从我家我秀网，就开始有此，但是.......大数据：取之架构用之架构.pdf,2013/12/30
791,虚拟现实技术的增强版——增强现实，值得我们去关注和研究的牛叉技术,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8491,虚拟现实完全是由计算机3D建模技术构建的虚拟场景，而增强现实则是将虚拟的信息应用到真实世界，并将计算机生成的虚拟物体、场景或系统提示信息叠加到真实场景中，从而实现对现实的增强。增强现实具有三个突出的特点：①真实世界和虚拟世界的信息集成；②具有实时交互性；③是在三维尺度空间中增添定位虚拟物体。AR技术可广泛应用到军事、医疗、建筑、教育、工程、影视、娱乐等领域。喜欢足球的朋友有没有注意到电视转播时足球场周围显示的虚拟广告屏，这个就是增强现实的典型应用；在文博领域，通过增强现实技术能够虚拟重构文物的残缺部分；等等。更多信息： /link?url=__kbj1rIXI45mbbQQPiAKMzRNpwIvv3l1F51v6NAGScHdVmLbeouacoYKUblD14Z,2013/12/28
792,Apache用户认证方式,史服宇,http://180.168.156.212:2262/wecenter/?/article/8490,"Apache用户认证方式一.基本的Apache用户认证方法：若对某一目录下的文件如/home/ftp/pub需要做到用户认证，则在httpd.conf中加入下面的行optionsindexesfollowsymlinksallowoverrideauthconfigorderallow,denyallowfromall用在目录/home/ftp/pub下放文件.htaccess，内容如下：authname""sharedfiles""authtypebasicauthuserfile/etc/.passwdrequirevalid-user用随Apache来的程序htpasswd生成文件/etc/.passwd,每行一个用户名：密码只要能提供正确的用户名和密码对，就允许登录访问，这是针对任何地址来的请求都要求提供用户名和密码认证。二.针对部分网段或地址要求认证。若公司LAN所在网段为192.168.0.0/24，且有一防火墙专线接入Internet,内部网卡的地址为192.168.0.1/32,则现在希望所有通过拨本地163通过防火墙上的apache反向代理向LAN上的另一WWW服务器访问时需要认证，而本地LAN上的用户不需认证。可以在httpd.conf中放入：〈Directory/home/ftp/pub>OptionsIndexesFollowSymLinksAllowOverrideAuthConfigorderdeny,allowdenyfrom192.168.0.1〈/Directory>且在/home/ftp/pub/.htaccess中放入：AuthName""sharedfiles""AuthTypeBasicAuthUserFile/etc/.passwdrequirevalid-usersatisfyany三.对同一目录及其下的子目录有不同的权限，仅某些人可以存取一目录下的子目录。如有一目录/home/ftp/pub/sales,有三个用户user1,user2,user3都需要用户名和密码进入/home/ftp/pub，但仅user1,user2能进入/home/ftp/pub/sales.则放下面的行到httpd.conf〈Directory/home/ftp/pub>OptionsIndexesAllowOverrideAuthConfigorderallow,denyallowfromall〈/Directory>〈Directory/home/ftp/pub/sales>OptionsIndexesAllowOverrideAuthConfigorderallow,denyallowfromall〈/Directory>且看/home/ftp/pub/.htaccess为：AuthName""sharedfiles""AuthTypeBasicAuthUserFile/etc/.passwdrequirevalid-user且看/home/ftp/pub/sales/.htaccessAuthName""sharedfiles""AuthTypeBasicAuthUserFile/etc/.passwdAuthGroupFile/etc/.salesgrouprequiregroupmanager且文件/etc/.passwd内容为：user1:passwd1user2:passwd2user3:passwd3且文件/etc/.salesgroup内容为：manager:user1user2二、当你不希望所以的人都能看到你的Page的时候，你就会想到身份验证了。单用户的验证：Apache服务器已经内置用户验证机制，大家只要适当的加以设置，便可以控制网站的某些部分要用户验证。大家只要跟着我一步步做下来就应该能轻松实现用户验证。前期准备，必须已经安装Apache，如果还没安装，或者对安装很模糊的话，请先预习第1步我们在/var/www(apache的主页根目录)下建立一个test目录mkdir/var/www/test第2步然后我们编辑httpd.conf添加Alias/test""/var/www/test""#目录映射<Directory""/var/www/test"">OptionsIndexesMultiViewsAllowOverrideAuthConfig#表示进行身份验证Orderallow,denyAllowfromall</Directory>#AllowOverrideAuthConfig表示进行身份验证这是关键的设置第3步在/var/www/test创建.htaccess文件vi/var/www/test/.htaccessAuthName""frankshareweb""AuthTypeBasicAuthUserFile/var/www/test/.htpasswdrequirevalid-user#AuthName描述，随便写#AuthUserFile/var/www/test/.htpasswd#requirevalid-user允许所有合法用户访问或者requireuserfrank限制还是指定用户,如果要限制多个用户，可以用空格隔开多个用户名，例requireuserusr1usr2urs3......#密码文件推荐使用.htpasswd,因为apache默认系统对“.ht”开头的文件默认不允许外部读取，安全系数会高一点哦。第4步就是创建apache的验证用户#htpasswd-c/var/www/test/.htpasswdfrankNewpassword:mypasswordRe-typenewpassword:mypasswordAddingpasswordforuserfrank#第一次创建用户要用到-c参数第2次添加用户，就不用-c参数如果你们想修改密码，可以如下htpasswd-m.htpasswdfrank第5步ok，重启Apache服务，然后访问 httpd.conf中的Servername后面的值",2013/12/24
793,Ant+build.xml使用方法,史服宇,http://180.168.156.212:2262/wecenter/?/article/8489,"Ant+build.xml使用方法ant是apache的java子项目""jakarta""的子项目.你可以选择当前的版本，,window版解压后ant_home用来方便访问。并确保你也设置了java_home。setant_home=D:\java\kit\ant\jakarta-ant-1.5.1这是我的目录helloant我们要开发一个java类：其内容只有一句，输出""helloant""字符串。并使用ant完成编译和运行工作，这个例子只是为了跑通ant，不附加多余的东西。下面是：“hello.ant.HelloAnt.java”文件。packagehello.ant;publicclassHelloAnt{publicstaticvoidmain(String[]args){System.out.println(""helloant,ant的第一次接触，好棒！"");}}在项目根目录(hello-ant\)写1个文件：ant执行配置文件build.xml“build.xml”文件<?xmlversion=""1.0""encoding=""GB2312""?><!--一个项目,可包含很多任务组(target)--><projectdefault=""main""basedir="".""><!--项目中的一个任务组,可包含很多任务(task:javac,java...)--><targetname=""main""><!--编译--><javacsrcdir=""src\main\hello\ant""destdir=""build\classes""/><!--运行--><javaclassname=""hello.ant.HelloAnt""><classpath><pathelementpath=""build\classes""/></classpath></java></target></project>ok,一切大功告成，哦，不，还没有运行它。dos下进入hello-ant的目录，即build.xml所在的目录，我们要用ant工具执行它，执行:%ant_home%/bin/ant-filebuild.xml用ant工具执行当前目录下的配置文件build.xml或：ant-filebuild.xml你如果设置%ant_home%/bin到path中这次ok了，这是答案：命令提示符窗口D:\temp\hello-ant>ant-filebuild.xmlBuildbuild.xmlmain:[javac]Compiling1sourcefiletoD:\temp\hello-ant\build\classes[java]helloant,ant的第一次接触，好棒！BUILDSUCCESSFULTotaltime:2secondsD:\temp\hello-ant>检查一下build/classes目录，哦，看到编译过的文件就在这里:build/classes/hello/ant/HelloAnt.class.helloant进级我们要改进build.xml，让它做更多的事情：定义全局变量初始化,主要是建立目录编译(已有)打包为jar建立APIdocumentation生成distribution产品凡事都讲究平衡，你要ant给你做更多事，当然要累一点点，不过只用累一次，以后的代码修改后的构建都是""一键式""完成,我们制作一个hello的简单例子，你可以自己做j2ee的练习。我们要扩充目录结构，使它更像回事：：\src,\docs,\lib是自己组织的文件结构，\build,\dist是ant动态生成的成品。\src源文件：java源，源，jsp源，xml配置.....\src\mainjava源\src\window,unix,liunx的执行，我们的简单只有一个：run.bat:javahello.ant.HelloAnt\docs手写说明文档\lib程序所需类库的jar,比如j2ee.jar,mail,jar...\build用ant动态生成的构建目录\build\classes编译的类文件\build\docscopy""\docs""的手写说明文档，和ant生成的api文档\build\lib放置我们自己的HelloAnt.class打包成品hello-ant.jar\dist\bincopy""\src\""得执行文件\dist\docscopy""\build\docs""的文档\dist\lib除了copy""\build\lib""下的hello-ant.jar外，还应copy""\lib""的程序所需jar，这里我们没有。以上是我学老外的文件组织，大家可以按照自己的爱好组织我们编写必要的文件：hello.ant.HelloAnt.javasrc\.bat@echooffecho========================================================echo请先设置Environmentecho.echoJAVA_HOME:%JAVA_HOME%echo======================================================%java_home%\bin\java-classpath..\lib\hello-ant.jarhello.ant.HelloAntpause\docs\index.html随便写一个手写的文档helloant软件项目手册docs--------------------------------------------------------------------------------访问api文档\build.xml配置文件<?xmlversion=""1.0""encoding=""GB2312""?><!--=======================================================================hello-ant项目,学习ant工具的第2个buildfile.参照ant的jakarta-ant-1.6alpha的build.xmlCopyright(c)2002TheNeusoftSoftwareFoundation.Allrightsreserved.=======================================================================--><!--文档结构为:<project><property/>全局变量的定义<property/>...<targetname=""1"">任务组(tasks)<javac></javac>一项javac任务...<oneTask></ontTask>一项其它任务</target><targetname=""2""><javac></javac>...<oneTask></ontTask></target></project>project代表一个项目，default:运行到名称为""dist""的target(任务组)basedir:基准路径。--><projectdefault=""dist""basedir="".""><!--===================================================================定义属性（propertytasks）最好把用到的路径呀，名称呀都在这里定义成全局变量例：定义<propertyname=""a""=""hello""/>以后就可以这样用它：<propertyname=""b""=""${a}/b""/>现在:b==""hello/b""===================================================================--><!--主要的系统环境属性--><propertyenvironment=""env""/><!--取window,unix...的环境变量--><propertyname=""java.home""=""${env.JAVA_HOME}""/><propertyname=""ant.home""=""${env.ANT_HOME}""/><!--主要的app环境属性--><propertyname=""app.name""=""hello-ant""/><propertyname=""app.jar""=""${app.name}.jar""/><propertyname=""app.copyright""=""Copyright(c)2002TheNeusoftSoftwareFoundation.Allrightsreserved.""/><!--app中src的属性--><propertyname=""src.dir""=""src""/><propertyname=""src.main""=""${src.dir}/main""/><propertyname=""src.""=""${src.dir}/""/><!--app用到的lib--><propertyname=""lib.dir""=""lib""/><!--app的build目录中--><propertyname=""build.dir""=""build""/><propertyname=""build.classes""=""${build.dir}/classes""/><propertyname=""build.docs""=""${build.dir}/docs""/><propertyname=""build.docs.api""=""${build.docs}/api""/><propertyname=""build.lib""=""${build.dir}/lib""/><!--app的dist(distribution)目录中--><propertyname=""dist.dir""=""dist""/><propertyname=""dist.bin""=""${dist.dir}/bin""/><propertyname=""dist.docs""=""${dist.dir}/docs""/><propertyname=""dist.lib""=""${dist.dir}/lib""/><!--app的docs目录中--><propertyname=""docs.dir""=""docs""/><!--定义一组路径以后可以通过id重用这组路径，例：<javacsrcdir=""src/main""destdir=""build/classes""><classpathrefid=""classpath""/></javac>--><pathid=""classpath""><!--本项目只有一个java，用不上classpath，这里只是做个例子--><pathelementlocation=""${build.classes}""/><pathelementpath=""${java.home}/lib/tools.jar""/></path><!--===================================================================init准备目录(FileTasks)主要的目录结构通常是不会变的，一起生成他们===================================================================--><targetname=""init""><!--清除以前目录--><deletedir=""${build.dir}""fail=""false""/><deletedir=""${dist.dir}""fail=""false""/><!--准备目录--><mkdirdir=""${build.dir}""/><mkdirdir=""${build.classes}""/><mkdirdir=""${build.docs}""/><mkdirdir=""${build.docs.api}""/><mkdirdir=""${build.lib}""/><mkdirdir=""${dist.dir}""/><mkdirdir=""${dist.bin}""/><mkdirdir=""${dist.lib}""/></target><!--===================================================================Buildthecode(CompileTasks,FileTasks)===================================================================--><targetname=""build""depends=""init""><!--编译--><javacsrcdir=""${src.main}""destdir=""${build.classes}""><classpathrefid=""classpath""/></javac></target><!--===================================================================打包文档(ArchiveTasks)Createtheprojectjars:xxx1.jarandxxx2.jar===================================================================--><targetname=""jars""depends=""build""><jarbasedir=""${build.classes}""jarfile=""${build.lib}/${app.jar}""/></target><!--===================================================================CreatestheAPIdocumentation===================================================================--><targetname=""javadocs""depends=""jars""deion=""-->createstheAPIdocumentation""><!--copydocs手册...--><copytodir=""${build.docs}""><filesetdir=""${docs.dir}""/></copy><javadocpackagenames=""hello.ant.*""sourcepath=""${src.main}""defaultexcludes=""yes""destdir=""${build.docs.api}""author=""true""version=""true""use=""true""windowtitle=""DocsAPI""><doctitle><![CDATA[<h1>helloantDocsAPI</h1>]]></doctitle><bottom><![CDATA[<i>${app.copyright}</i>]]></bottom><tagname=""todo""scope=""all""deion=""Todo:""/></javadoc></target><!--===================================================================Createthedistributionthatcanrun(ArchiveTasks)主要是从各目录中把该copy的copy上===================================================================--><targetname=""dist""depends=""javadocs""><!--copybin执行文件--><copytodir=""${dist.bin}""><filesetdir=""${src.}/""/></copy><copytodir=""${dist.docs}""><filesetdir=""${build.docs}/""/></copy><!--copylib文件--><copytodir=""${dist.lib}""><filesetdir=""${build.lib}/""/></copy></target><!--===================================================================Cleanseverything(FileTasks)例如可以删除build中的文件，留给你发挥吧===================================================================--></project>build.xml多了些，但其实很简单：(注释比较详细可以参照，这里再简单说一下)一个build.xml包含一个工程的自动化处理的完整xml说明，并且基本由3种东东组成：<project>1.全局变量的定义<property/>2.任务组<target>3.许多单项任务...像copy,delete,javac,jar...<task1/><task2/><task3/></target></project>",2013/12/24
794,java应用相对路径读取xml文件,史服宇,http://180.168.156.212:2262/wecenter/?/article/8488,"-java使用相对路径读取xml文件一、xml文件一般的存放位置有三个：1.放在WEB-INF下；2.xml文件放在/WEB-INF/classes目录下或classpath的jar包中；3.放在与解析它的java类同一个包中，不一定是classpath；二、相对应的两种使用相对路径的读取方法：方法一：（未验证）将xml文件放在WEB-INF目录下，然后程序代码：InputStreamis=getServletContext().getResourceAsStream(""/WEB-INF/xmlfile.xml"");方法二：将xml文件放在/WEB-INF/classes目录下或classpath的jar包中，则可以使用ClassLoader的静态方法getSystemResourceAsStream(Strings)读取；程序代码：Strings_xmlpath=""com\xml\hotspot.xml"";InputStreamin=ClassLoader.getSystemResourceAsStream(s_xmlpath);方法三：xml在随意某个包路径下：Strings_xmlpath=""com\xml\hotspot.xml"";ClassLoaderclassLoader=HotspotXmlParser.class.getClassLoader();InputStreamin=classLoader.getResourceAsStream(s_xmlpath);",2013/12/24
795,关于命令行调用问题,孙传金,http://180.168.156.212:2262/wecenter/?/article/8487,"在实际开发过程当中，调用第三方命令行工具是我们常用的方法之一，对于常用的命令行需要注意点也是很多的，最常遇到的就是被调用的程序所在的路径中带有空格或者有中文的问题，同时被调用的参数中含有同样的路径问题。我们如何解决呢？1、被调用的程序路径带有中文或者空格，我们可以将路径转换为短路经2、被调用的程序带有参数，参数中需要传入路径，我们可以将参数用双引号("")括起来传入，也可以将路径转换为短路经3、在批处理文件中调用，比如mysql的启动批处理，数据库文件存储路径、启动路径等等，必须将路径转换为短路经才能启动以上是对路径中含有空格或者中的一些浅见，望大家有更好的方法可以补充",2013/12/24
796,Delphi的TryFinally使用,王孝本,http://180.168.156.212:2262/wecenter/?/article/8486,"描述1、Delphi中的tryfinallyend语句并非是异常防范语句，其作用是无论tryfinally之间的代码出现什么情况都会执行finallyend间的代码，如果期间有异常，则在执行完finallyend间的语句后再次抛出同样的异常。2、当tryfinally间代码有异常触发时，程序会直接执行finallyend间代码，执行完finallyend间代码后，再次触发相同的异常。3、当tryfinally间有Exit命令时，程序会在exit位置直接跳到finally处，执行finallyend间代码，之后在执行到end后直接退出函数。4、当tryfinally间有continue命令时，程序会在continue处直接跳到finally处，之后执行finallyend间代码，执行到end后回到for或repeat、while等代码处继续执行。5、当tryfinally间有break命令时，程序会在break处直接跳到finally处，之后执行finallyend间代码，执行到end后直接跳到for或repeat、while等语句的end处继续执行。建议结构一trytry//资源创建//业务处理finally//资源释放//注意判断资源是否存在end;exceptonEE:Exceptiondobegin//对异常的处理,再次出现异常将抛到外层end;end;建议结构二trytry//资源创建//业务处理exceptonEE:Exceptiondobegin//对异常的处理,再次出现异常将抛到外层,可以有exit语句end;end;//在tryexcept外的代码产生的异常会被抛到外层finally//资源释放//注意判断资源是否存在end;测试TryFinally.rar",2013/12/20
797,vcl框架经验分享,许海宝,http://180.168.156.212:2262/wecenter/?/article/8485,"vcl框架control类，很多可视化控件就是从这里继承下来的介绍下parent相关SetParent方法对应对象：Tcontrol声明：procedureSetParent(Aparent:TwinControl);virtual;功能：SetParent方法使控件可以设置它的父类。Parent属性对应对象：TControl声明：propertyParent:TwinControl;功能：属性用来指出控件的父类（容器）。控件的父类是可视的，包含了控件的窗口控件。控件在它的父类被撤消时将被自动地撤消。平时大家容易把delphi中Owner和Parent混淆，他们是有区别的Owner为创建者,Parent为容器他们的类型不同，Owner为TComponent(元件),Parent为TWinControl(窗体控件)Parent属性是指构件的包容器，构件只能在此范围内显示和移动。举例子如下：(1)在Form1的窗体上，放一个Panel1,并将Panel1拉大，(2)在Panel1上放一Button1；(3)在Form1上放一Button2。现在如果移动Panel1,则Button1随着Panel1移动，这是因为Button1的Parent是Panel1。现在将Button2移到Panel1上，再次移动Panel1,Button2并不跟着移动，这是因为Button2的Parent是Form1。除在窗体设计中，应注意构件的Parent是谁外，在动态创建构件时，也应指出构件的Parent，如在上例中继续操作：1)ProcedureTform1.Button2click(Sender:Tobjet);2)Var3)Button:Tbutton;4)Begin5)Button:Tbutton.cerate(self);6)Button.parent=panel1;7)Button.lleft=0;8)Button.top=0;9)Button.caption:=’OK’;10)End；当按Button2时，将在Panel1上创建一个Button，而如果把第6句改为Button.parent:=self；按Button2时，将在Form1上创建一个Button了。如果将第6句删除，按Button2时，什么都不会发生，这是因为创建方法无法知道应在哪里显示构件。Owner属性是指构件的所有者，它负责构件的创建和释放。如在上例中，系统默认窗体上所有构件的所有者是窗体，而窗体的所有者是Application。顺便指出，create方法应带有表示构件所有者的参数，如在上例中，构件所有者是窗体，即self。Parent属性和Owner属性是运行阶段的属性，只能在运行阶段，通过代码设置。Owner为创建者,Parent为容器他们的类型不同，Owner为TComponent(元件),Parent为TWinControl(窗体控件)一般可视化控件的容器被设置后，句柄都会由DestroyHandle方法销毁，然后重建，所以编程的时候要注意，可以用windows.setparentapi函数可以不发生变化procedureTControl.SetParent(AParent:TWinControl);beginifFParent<>AParentthenbeginifAParent=SelfthenraiseEInvalidOperation.CreateRes(@SControlParentSetToSelf);ifFParent<>nilthenFParent.RemoveControl(Self);ifAParent<>nilthenbeginAParent.InsertControl(Self);UpdateAnchorRules;end;end;end;procedureTWinControl.RemoveControl(AControl:TControl);beginPerform(CM_CONTROLCHANGE,Integer(AControl),Integer(False));ifAControlisTWinControlthenwithTWinControl(AControl)dobeginRemoveFocus(True);DestroyHandle;endelseifHandleAllocatedthenAControl.InvalidateControl(AControl.Visible,False);Remove(AControl);Perform(CM_CONTROLLISTCHANGE,Integer(AControl),Integer(False));Realign;end;",2013/12/20
798,强大的图片处理功能控件：ImagEenView  之水印处理功能使用技巧,陈军志,http://180.168.156.212:2262/wecenter/?/article/8484,"delphiImagEenView控件使用经验分享：ImagEenView控件是一款对图片具有强大处理功能的控件，在我们的日常开发过程中使用频率较高。我在授权审批工具中使用该控件实现了以下功能：添加水印，并实现手动调整水印透明度及水印位置和大小的功能；对图片进行颜色填充功能；保存此次修改并实现再次打开时可以修改之前的水印。1)、对图片添加水印功能，首先需要使用ImagEenView添加一个图层，再加载一个水印文件，实现代码如下procedureTForm1.Button1Click(Sender:TObject);varsImageFileName:string;beginImageEnView1.LayersAdd;dlgOpen1.Title:='图片选择';ifdlgOpen1.ExecutethensImageFileName:=dlgOpen1.FileName;ImageEnView1.IO.LoadFromFile(sImageFileName);ImageEnView1.Fit;ImageEnView1.Layers[0].Locked:=True;end;2)、对某一个图层（水印）手动调整透明度，通过一个ScrollBar来控制水印透明度，在ScrollBar的change事件中，获取当前选中的图层，对选中的图层的透明度赋值即可，实现方式如下procedureTForm1.ScrollBar1Change(Sender:TObject);varisel,iTransparency:Integer;beginisel:=ImageEnView1.LayersCurrent;iTransparency:=ScrollBar1.Position;ImageEnView1.Layers[isel].Transparency:=iTransparency;ImageEnView1.Refresh;end;3)、通过双击某个图层（水印），实现移动选中图层（水印）位置及改变选中图层（水印）大小的功能，代码如下：procedureTForm1.ImageEnView1DblClick(Sender:TObject);vari,isel:Integer;beginImageEnView1.Layers[0].Locked:=True;isel:=0;fori:=ImageEnView1.LayersCount-1downto1dobeginif(Fix>ImageEnView1.Layers[i].ClientAreaBox.Left)and(Fix<ImageEnView1.Layers[i].ClientAreaBox.Left+ImageEnView1.Layers[i].Width)and(Fiy>ImageEnView1.Layers[i].ClientAreaBox.top)and(Fiy<ImageEnView1.Layers[i].ClientAreaBox.top+ImageEnView1.Layers[i].Height)thenbeginisel:=i;Break;end;end;ifisel<>0thenbeginifImageEnView1.MouseInteract=[miMoveLayers]thenbeginImageEnView1.MouseInteract:=[miResizeLayers];ImageEnView1.Cursor:=crSizeNWSE;endelsebeginImageEnView1.MouseInteract:=[miMoveLayers];ImageEnView1.Cursor:=crSizeAll;end;end;end;4)、首先在调试板中选择某个颜色，赋值给ImageEnView1的背景色，选中某个图层中需要填充的区域，在SelectionChange事件中，用背景色填充选择区域即可。部分功能代码如下：选择填充色：ifColorDialog1.ExecutethenFColor:=ColorDialog1.Color;选择填充区域的形状：ImageEnView1.MouseInteract:=[miSelect];//矩形ImageEnView1.MouseInteract:=[miSelectCircle];//椭圆在SelectionChange事件中，用背景色填充选择区域：procedureTForm1.ImageEnView1SelectionChange(Sender:TObject);beginImageEnView1.Proc.Background:=FColor;ImageEnView1.Proc.ClearSel;end;5)、将图层保存为lyr,以便这些图层下次打开时可以编辑。6)、合并所有图层生成最终效果图。ImageEnView1.LayersMergeAll;ImageEnView1.IO.SaveToFileJpeg(sSaveFileName);",2013/12/20
799,回帖时显示Anonymous,聂超,http://180.168.156.212:2262/wecenter/?/article/8483,登录OA-查看帖子-回复，回帖人身份被当成Anonymous，惊呆了，文章数还31,2013/12/20
800,Windows Server 2003下Windows Media Services无法启动问题处理,胡正,http://180.168.156.212:2262/wecenter/?/article/8482,现象：常熟市档案局部署的流媒体服务器始终无法启动，而且相关的Windows服务也启动正常，重装WindowsMediaServices或重新系统也没有用。原因分析：Windows的服务启动报错，会在”事件查看器“中记录日志，查看日志发现错误原因为：“WindowsMediaServices服务因2147500037(0x80004005)服务性错误而停止”百度后得知，WindowsMediaServices只能支持16个处理器，一但超过这个数，服务就会启不动。而服务器的为32核，因此无法启动。解决方式：修改注册表HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/WindowsMedia添加Platform/Threads项再添加两个DWORD的键，名字分别为“NormalWorkerThreadsPerProc”、“IdleWorkerThreadsPerProc”，它们的数值数据都为“1”。重启后，启动正常。,2013/12/19
801,ie9环境下页面错位,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8481,"经验共享一、授权档案全文查看ie9环境下页面错位使用coral3.0组建点击查看全文新增tab标签后页面错位如图：其中ie7.8.10均正常显示用ie10向下兼容调试成ie9也显示正常，只有安装版的ie此功能页面错位。问题查找：用安装版的ie9断点调试：报js错误：SCRIPT5039:重新声明常量属性。并且指导错误代码位置是varcurrId=0仔细查看页面代码后发现其中定义了一个变量使用了关键字history总结：定义变量切记规范，误使用关键字！！！！二、【龙湾区档案局数字档案馆一期应用系统建设项目】公共数据字典更新业务数据字典后失踪问题修改前代码：sql.append(""""+dictbase.getCOLUMN_USE()==null?"""":dictbase.getCOLUMN_USE().toSting()+""',';修改后代码：sql.append(dictbase.getCOLUMN_USE()==null?"""":dictbase.getCOLUMN_USE().toString());sql.append(""','"");",2013/12/18
802,2014年职称英语考试安排,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8479,各位想申报职称的同事，千万不要错过时间哦，每年只有一次。请选择时，中级理工B，高级是理工A类报名2014年度职称外语考试安排.pdf,2013/12/17
803,祝我们敬爱的总裁张曙华生日快乐,张元利,http://180.168.156.212:2262/wecenter/?/article/8480,12月29日是我们敬爱的总裁张曙华的生辰，请作为中信人的您为他送一份最诚挚的祝福，你的美好祝愿会通过这个平台第一时间传达到他的心里，温暖点燃整个公司，感谢您！,2013/12/16
804,从人脸识别到语音检索和视频检索,齐超,http://180.168.156.212:2262/wecenter/?/article/8478,这次辽宁要求人脸识别里边描述里含糊的提及要实现语音搜索和视频搜索，由于表达含糊，暂时拒绝了这个需求，但是后续项目估计肯定还会提及，特别是视频检索已经较多成熟方案，我们是否可以作为亮点探索放入，如成功可以有较好市场空间,2013/12/16
805,Java 编程中异常处理的十大最佳实践,张建涛,http://180.168.156.212:2262/wecenter/?/article/8475,"Java编程中异常处理的最佳实践1）为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。2）在finally程序块中关闭或者释放资源这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源，在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由finally块保证。从Java7开始，该语言有了一项更有趣的功能：资源管理自动化或者ARM块能实现这一功能。尽管如此，我们仍然要记住在finally块中关闭资源，这是对于释放像FileDescriptors这类，应用在socket和文件编程的情况下的有限资源很重要的。3）在堆栈跟踪中包含引起异常的原因很多时候，当一个由另一个异常导致的异常被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。日志记录和打印根异常就变得非常重要。Java异常类提供了getCause()方法来检索导致异常的原因，这些（原因）可以对异常的根层次的原因提供更多的信息。该Java实践对在进行调试或排除故障大有帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。4）始终提供关于异常的有意义的完整的信息异常信息是最重要的地方，因为这是程序员首先看到的第一个地方，这里你能找到问题产生的根本原因。这里始终提供精确的真实的信息。例如，对比IllegalArgumentException异常的两条异常信息：消息1:""Incorrectargumentformethod""消息2:""Illegalvaluefor${argument}:${value}第一条消息仅说明了参数是非法的或者不正确，但第二条消息包括了参数名和非法值，而这对于找到错误的原因是很重要的。在用Java编程中编写异常处理代码的时候，始终遵循该Java最佳实践。5）避免过度使用检查型异常检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码，通过掩盖业务逻辑使代码可读性降低。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更清洁的代码。你同样可以使用Java7的新功能，像onecatchblockformultipleexceptions和automaticresourcemanagement以移除重复项。6）将检查型异常转为运行时异常这是在像Spring之类的多数框架中用来限制使用检查型异常的技术之一，大部分出自于JDBC的检查型异常，都被包装进DataAccessException中，而（DataAccessException）异常是一种非检查型异常。这是Java最佳实践带来的好处，特定的异常限制到特定的模块，像SQLException放到DAO层，将意思明确的运行时异常抛到客户层。7）记住对性能而言，异常代价高昂需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。假如你有方法从ResultSet（结果集）中进行读取，这时常会抛出SQLException异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。因此最大限度的减少不必要的异常捕捉和移动，那里没有什么固定的原因。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免不必须要的异常捕捉。8）避免catch块为空没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，但在程序执行期间，用日志记录错误依然是最好的（方法）。对于在Java编程中编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。9）使用标准异常我们的第九条最佳实践建议使用标准和内置的Java异常。使用标准异常而不是每次创建我们自己的异常，对于维护性和一致性，不管是现在还是以后，都是最好的选择。重用标准异常使代码更具可读性，因为大部分Java开发人员对标准的像源自于JDK的RuntimeException异常，IllegalStateException异常，IllegalArgumentException异常或者NullPointerException异常，（开发者）他们能一眼就知道每种异常的目的，而不是在代码里查找或者在文档里查找用户定义的异常的目的。10）记录任何方法抛出的异常Java提供了throw和throws关键字来抛出异常，在javadoc中用@throw记录任何方法可能会抛出的异常。如果你编写API或者公共接口，这就变得非常重要。任何方法抛出的异常都有相应的文档记录，这样你就能下意识的提醒任何使用（该方法）的人。这些就是所有在Java编程中在处理异常的时候需要遵循的最佳实践。让我们知道了什么是在Java编程中编写异常处理代码时需要遵循的实践。技术经验共享-齐超.docx",2013/12/13
806,201311经验共享,余礼华,http://180.168.156.212:2262/wecenter/?/article/8474,"经验共享IE8Applet加载不出来系统中上传时出不来，然后对进行各种设置，还是出不来。上网查IE7moveTo()编研平台没效果报错参考微软的文档 /en-us/library/ms536723(VS.85).aspxWindowsInternetExplorer7.Thismethodisonlyeffectivewhenasingletabisopenorwhentabbedbrowsingisdisabled.Ifmultipletabsareopen,thismethodisblocked.Forinformationregardingtabinteractionfromascript,seeTabbedBrowsingforDevelopers.也就是单个Tab的时候self.moveTo()和self.resizeTo()这两个函数才有效，多个Tab的时候已经被block了。表单提交用到图片利用服务平台搜索功能点击搜索总是执行两次<inputtype=""image""src=""xxx.gif""onclick=""returndosubmit();"">会发生表单提交两次的现象，经常会造成表单元素被重复提交，数据库被写入异常！！<imgsrc=""xxx.gif""onclick=""returndosubmit();"">第二种则正常！！原因：：HTML中image的描述是“创建一个图像控件，该控件单击后将导致表单立即被提交。”。请尽量少用<inputtype=""image"">以免造成不必要的异常！！！4研发中心经验共享_张建涛[201311].doc",2013/12/13
807,Spring+Quartz实现定时任务的配置方法,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8473,"第一步：.导入相关的jar包spring.jarquartz-1.6.0.jar相关包commons-collections-3.2.jar;commons-logging-1.1.1.jar;log4j-1.2.16.jar第二步：创建一个类来定义工作定义Quartz工作的第一步是创建一个类来定义工作。要做到这一点，你需要从Spring的QuartzJobBean中派生子类。见附件第三步：配置JobDetail<beanname=""topTenTask""class=""org.springframework.scheduling.quartz.JobDetailBean""><propertyname=""jobClass""value=""ces.usingservice.task.TopTenTask""/><propertyname=""jobDataAsMap""><map><entrykey=""timeout""value=""5""/></map></property></bean>值得注意的是，在这里你并没有直接声明一个TopTenTaskBean，而是声明了一个JobDetailBean。这是使用Quartz时的一个特点。JobDetailBean是Quartz的org.quartz.JobDetail的子类，它要求通过jobClass属性来设置一个Job对象。使用Quartz的JobDetail中的另一个特别之处是TopTenTask的timeout属性是间接设置的。JobDetail的jobDataAsMap属性接受一个java.util.Map，其中包含了需要设置给jobClass的各种属性。在这里，这个map包含了一个键值为timeout。当JobDetailBean实例化时，它会将5注入到EmailReportJob的timeout属性中。第四步：配置Trigger<beanid=""topTenTrigger""class=""org.springframework.scheduling.quartz.CronTriggerBean""><propertyname=""jobDetail""ref=""topTenTask""/><!--每天早上10:15时统计一次--><propertyname=""cronExpression""value=""01510**?""/></bean>工作已经被定义好了，接下来你需要调度这个工作。Quartz的org.quartz.Trigger类描述了何时及以怎样的频度运行一个Quartz工作。Spring提供了两个触发器，SimpleTriggerBean和CronTriggerBean。SimpleTriggerBean与ScheduledTimerTask类似。你可以用它来指定一个工作应该以怎样的频度运行，以及（可选地）在第一次运行工作之前应该等待多久。例如，要调度报表工作每24小时运行一次，第一次在1小时之后开始运行，可以按照以下方式进行声明：<beanid=""topTenTrigger""class=""org.springframework.scheduling.quartz.SimpleTriggerBean""><propertyname=""jobDetail""><refbean=""topTenTask""/></property><propertyname=""startDelay""><value>3600000</value></property><propertyname=""repeatInterval""><value>86400000</value></property></bean>属性jobDetail装配了将要被调度的工作，在这个例子中是topTenTaskBean。属性repeatInterval告诉触发器以怎样的频度运行这个工作（以毫秒作为单位）。这里，我们设置它为86400000，因此每隔24小时它会被触发一次。你也可以选择设置startDelay属性来延迟工作的第一次执行。我们设置它为3600000，因此在第一次触发之前它会等待1小时。CronTriggerBean允许你更精确地控制任务的运行时间。和SimpleTriggerBean一样，jobDetail属性告诉触发器调度哪个工作。这里我们又一次装配了一个topTenTaskBean。属性cronExpression告诉触发器何时触发。属性cronExpression告诉触发器何时触发。如果你不熟悉cron，这个属性可能看上去有点神秘，因此让我们进一步考察一下这个属性。Spring--quartz中cronExpression配置说明字段允许值允许的特殊字符秒0-59,-*/分0-59,-*/小时0-23,-*/日0-31,-*?/LWC月1-12或者JAN-DEC,-*/周几1-7或者SUN-SAT,-*?/LC#年(可选字段)留空,1970-2099,-*/“,”字符：指定数个值“-”字符：指定一个值的范围“*”字符可以用于所有字段，在“分”字段中设为""*""表示""每一分钟""的含义。“/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m“?”字符：表示不确定的值“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X“W”字符：指定离给定日期最近的工作日(周一到周五)“C”字符可用于“日”和“周几”字段，它是""calendar""的缩写。它表示为基于相关的日历所计算出的值（如果有的话）。如果没有关联的日历,那它等同于包含全部日历。“日”字段值为""5C""表示""日历中的第一天或者5号以后""，“周几”字段值为""1C""则表示""日历中的第一天或者周日以后""。“#”字符：表示该月第几个周X。6#3表示该月第3个周五cronExpression表达式的示例：""0012**?""每天中午12点触发""01510?**""每天上午10:15触发""01510**?""每天上午10:15触发""01510**?*""每天上午10:15触发""01510**?2005""2005年的每天上午10:15触发""0*14**?""在每天下午2点到下午2:59期间的每1分钟触发""00/514**?""在每天下午2点到下午2:55期间的每5分钟触发""00/514,18**?""在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发""00-514**?""在每天下午2点到下午2:05期间的每1分钟触发""010,4414?3WED""每年三月的星期三的下午2:10和2:44触发""01510?*MON-FRI""周一至周五的上午10:15触发""0151015*?""每月15日上午10:15触发""01510L*?""每月最后一日的上午10:15触发""01510?*6L""每月的最后一个星期五上午10:15触发""01510?*6L2002-2005""2002年至2005年的每月的最后一个星期五上午10:15触发""01510?*6#3""每月的第三个星期五上午10:15触发第五步：启动工作<!--定时任务启动--><beanautowire=""no""class=""org.springframework.scheduling.quartz.SchedulerFactoryBean""><propertyname=""triggers""><list><reflocal=""cronTrigger""/><refbean=""topTenTrigger""/></list></property></bean>属性triggers接受一组触发器。此处配置了两个触发器，其中一个就是之前配置的topTenTrigger。研发中心经验共享_余礼华[201311].doc",2013/12/12
808,ckeditor,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8472,"Ckeditor:网页文本编辑器将ckeditor集成到jsp页面的步骤：载入ckeditor;在页面<head>中引入ckeditor.js<scripttype=""text/javascript""src=""/ckeditor/ckeditor.js""></script>创建ckeditor实例：<script>CKEDITOR.replace(“editor”);//括号里面放textarea的id</script><textareaid=""editor""name=""editor""></textarea>配置ckeditor可以再config.js中修改其配置内容，也可以直接在jsp中配置：CKEDITOR.replace(“editor”,{//Ckeditor的配置内容language:""zh-cn"",//界面语言，默认为enskin:""office2003"",//编辑器风格，有office2003、”kama”,”v2”fullPage:true,//是否使用完整的html编辑模式…….//设置工具栏信息Toolbar:Basic(基础)、Full(全能)、自定义(可根据自己的需求，只需配置自己需要的工具栏信息，也可自定义工具栏按钮)});自定义工具栏按钮：在/ckeditor/plugins目录下创建自定义按钮文件夹，在该文件夹下创建plugin.js文件，该js中定义按钮点击时执行的命令，如：(function(){vara={exec:function(editor){show(editor);}},b='sendimg';CKEDITOR.plugins.add(b,{init:function(editor){editor.addCommand(b,a);editor.ui.addButton('sendimg',{label:'上传图片',icon:this.path+'/icons/sendimg.png',command:b});}});functionshow(editor){alert(“上传图片操作”)}})();最后，在编辑器配置中添加extraPlugins：“文件夹名称“(注册该按钮插件)。然后在工具栏中，添加改按钮名称就可以了。Ckeditor无法自适应高度问题：Width:”100%”,//宽度可以正常自适应Height:”100%”//高度设置的百分比无效造成无法自适应的原因是：在这个编辑器产生的html代码中，已经设置了高度为200px，所以，无法通过百分比来改变，只能是在js中动态改变使编辑器自适应高度的解决办法：在定义该编辑器的jsp中，添加：functionautoheight(){varbodyheight=document.body.clientHeight;vartdHeight=document.getElementsByTagName(""tr"")[1].cells[0].style.height;vartrHeightFirst=document.getElementsByTagName(""tr"")[0].clientHeight;vartrHeightLast=document.getElementsByTagName(""tr"")[2].clientHeight;varheight=bodyheight-trHeightFirst-trHeightLast-20;document.getElementsByTagName(""tr"")[1].cells[0].style.height=height;}window.onresize=autoheight;研发中心经验共享_毛璀玲[201311].doc",2013/12/12
809,Lucene查询优化经验谈,娄会兵,http://180.168.156.212:2262/wecenter/?/article/8471,"问题描述：陆家嘴项目用户提出一体化检索查询缓慢，查询文件级通常需要耗时1分钟左右，检索数据搭100万记录，索引库大小为2GB左右。问题原因：由于客户对一体化查询准确度要求较高，查询时需要采用**这种匹配的方式进行，这种方式会使查询时间增加一到二个数量级，再加上系统本省具有同义词查询，就是根据一个输入条件，查找是否有匹配的同义词，有的话则将该记录一并叠加上去，作为两个并列的条件，简单说来就是把原本一个条件变成两个条件中间通过or连接，使查询时间翻倍。基于客户特殊要求及lucene本身性能制约，想通过调整查询参数等常规手段，大幅度提高查询速度，看来是比较困难的。问题解决：解决思路：1注意到索引库内有100万记录，如果减少记录肯定会减少查询时间，但是如何分割数据呢？这点只有根据具体业务来确定，在档案系统中，按照年度分割是一个很不错的方案，每年产生的数据都差不多的，回到问题中执行查询语句：Selectyear_code,count(id)fromt_gdda_filegroupbyyear_code得知确实如此，从1990-2012年数据分布较为平均，那么就简单了，在建立索引时只需要每个年度都建立一个索引库即可。分割出来的数据如何拼接？有个概念叫冷数据与热数据，就是将一个大型数据库中的数据按照数据使用（查询）频率来分割，热点数据可以单独作为一个数据库，使用高性能服务器，使用大量缓存技术，甚至使用内存数据库，来提高查询效率。冷数据单独存放，因为查询利用率不高，也没必要采用上述技术。在档案中也肯定存在这点，关键这个界限如何设定，当然这个界限设定是和上述的数据分割有紧密联系的。在这里我设定近10年的记录作为热点数据，也就是说默认对近10年的数据进行查询，这样检索量一下子减少了一半，检索效率可以提升50%。如果查询所有年度的数据，该如何提高效率？如果客户硬要对所有年度的数据进行查询，那么上述手段真的都失效了么？现在服务器都有多个cpu，结合上述索引库已分割成多个，那么可以使用多个索引库并行查询来提高查询效率，但需要注意一个问题，需要所有索引库都完成查询，才能返回查询结果。可以通过java中的CountDownLatch来实现。代码片段：publicvoidparallelSearch(Stringwhere,Stringpaths[])throwsException{longt1=System.currentTimeMillis();Listdatas=Collections.synchronizedList(newArrayList());finalCountDownLatchcountDown=newCountDownLatch(paths.length);//执行计数ExecutorServiceservice=Executors.newCachedThreadPool();for(Stringpath:paths){TestThreadtt=newTestThread(path,where,countDown,datas);service.submit(tt);//提交任务}service.shutdown();//等待所有线程完成countDown.await();System.out.println(""所有查询都完成了，总耗时：""+(System.currentTimeMillis()-t1)+""毫秒，总记录数：""+datas.size());}publicstaticvoidmain(Stringargs[])throwsException{Stringpaths[]=newString[]{""E:\\ljz\\null\\"",""E:\\ljz\\2000\\"",""E:\\ljz\\2001\\"",""E:\\ljz\\2002\\"",""E:\\ljz\\2003\\"",""E:\\ljz\\2004\\"",""E:\\ljz\\2005\\"",""E:\\ljz\\2006\\"",""E:\\ljz\\2007\\"",""E:\\ljz\\2008\\"",""E:\\ljz\\2009\\"",""E:\\ljz\\2010\\""};//Stringpaths[]=newString[]{""E:\\ljz\\null_sf\\""};Stringwhere=""+(INTEGRATIVE_VALUE:*2-3地块*INTEGRATIVE_VALUE:*世纪大都会*)"";newTest().parallelSearch(where,paths);//newTest().search(where,paths);}测试对比：测试环境：CpuIntelXeonE5440@2.83G2cpuMemory16GB硬盘2TB测试结果：串行查询并行查询耗时28s4.5sCpu占用率14%86%研发中心经验共享_郭晶晶[2013011].doc",2013/12/12
810,关于“人脸识别”之openBR,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8477,OpenBR是一个用来从照片中识别人脸的工具。还支持推算性别与年龄。使用方法：$br-algorithmFaceRecognition-compareme.jpgyou.jpgOpenSourceBiometricRecognition—More...http://www.openbiometrics.org使用方法：在win764位操作系统下安装OpenBR-0.4.1-win64.exe执行[安装目录]\bin\br.exe-algorithmFaceRecognition-compare[对比文件1路径][对比文件2路径]测试结果如下：br-algorithmFaceRecognition-compareb2.jpga1.jpg相似度0.999998br-algorithmFaceRecognition-compareb1.jpgb5.jpg相似度0.999089br-algorithmFaceRecognition-comparea1.jpgb5.jpg相似度0.991334br-algorithmFaceRecognition-comparec2.jpgc1.jpg相似度1TestImages1.rar,2013/12/12
811,关于双表数据查重问题,孙传金,http://180.168.156.212:2262/wecenter/?/article/8476,"最近在修改导入导出工具，在导入数据之前进行数据检测时遇到数据查重的问题，目标数据库为Oracle10，实现思路如下：1、将需要导入的数据导入至临时表中2、通过sql语句进行查重筛选在以上思路中，步骤1主要是利用oracle自带的文本导入方式快速将文件中的内容保存至临时表，效率比使用sql语句插入效率要高；步骤2中需要注意的是在进行筛选时，字段内容为null时，拼接的sql语句需要注意，举个例子：临时表名为A，字段有A1，A2，A3，A4，目标表名为B1，B2，B3，B4，两张表的字段对应关系为A1=B1，A2=B2，A3=B3，A4=B4拼接语句：selecta.*,b.*froma,bwhereA1=B1ANDA2=B2ANDA3=B3ANDA4=B4，这样就能筛选出与待导入的记录相同的记录，但是我们会发现在有一个字段的值为null时，查询不到任何记录！这是什么原因呢，因为数据库在进行字段比较时null是不能进行比较的，这是我们需要进行null值得转换已取得可以比较的值，nvl函数可以进行相应的转换，但是我们要考虑到转换后的类型和取值必须与目标表中的字段取值不能那个重复，否则就会带来不同记录也会被查询出来的错误结果。null值转换的时候会有类型的区别：字符串，整形，浮点型，日期型；例如上例中A1为字符串；A2为整型；A3为浮点型；A4为日期型，此时我们sql可以这么写：selecta.*,b.*froma,bwherenvl(A1,'null')=nvl(B1,'null')--由于字段取值一般不会取值为'null'，所以我们可以转换为null进行比较不会与现有记录重复ANDnvl(A2,2147483647)=nvl(B2,2147483647)--整形取值一般不会取到有符号整型的最大值，所以也可以避免重复记录ANDnvl(A3,0.99999999)=nvl(B3,0.99999999)--浮点型需要根据浮点型的精度取不会存在的取值即可ANDnvl(A4,to_date('1899-01-0100:00:00','yyyy-mm-ddhh24:mi:ss')=nvl(B4,to_date('1899-01-0100:00:00','yyyy-mm-ddhh24:mi:ss')--日期型比较多，有time,date,datetime，根据需要取不重复的取值即可以上拼成的sql语句就可以把字段为null的相同记录也能查询出来",2013/12/12
812,关于“生物特征识别”--“人脸识别”技术,路斌,http://180.168.156.212:2262/wecenter/?/article/8470,一、概述生物特征识别技术是计算机科学中，利用生物特征对人进行识别，并进行访问控制的学科。包括虹膜识别、人脸识别、人耳识别、指纹识别、掌纹识别、手形识别、静脉识别等；在辽宁省档案局项目建设中，要求能够根据照片的人脸进行识别，与照片库已有照片进行比对，剔除重复照片。在前期TMT研究过lire，这个工具是整张图片比对，不能满足要求。根据项目组的要求，TMT多名成员继续进行了不同解决思路探索：二、face.com和LambaLabsface.com提供在线的面部识别api，但是被facebook收购后，被关闭。LambaLabs推出了开源版FaceAPI作为Face.comAPI替代品。由于项目场景不能连接互联网，本方案未继续探索；三、OpenBROpenBR是一个用来从照片中识别人脸的工具。还支持推算性别与年龄。官方地址 使用总结：1、javacv可以将一张图片上多个人脸识别出来；2、javacv对抽出的每个人脸建立存储库（可以理解为索引库），可以加快比对；该方案最终给项目组先集成。五、其他备选方案java的其他人脸识别项目，基本也是基于opencv。a、jViolajones是人脸检测算法Viola-Jones的一个Java实现，基于openCVb、face4jFacebook4J是一个开源的Java类库，对FacebookAPI进行了封装face.jpgface2.jpg剪贴板022.jpg,2013/12/11
813,"java与as3,amf交互相互解析vo数据例子",方俊新,http://180.168.156.212:2262/wecenter/?/article/8469,"下面这篇文章是我从"" ""上找到的一篇关于flash直接调用java后台代码的文章,通过实践,可以成功调用,demo请参考附件,正文如下:AMF这东西跟服务端交互还是挺爽的，搜了一下，发现网上没有很完整的例子，大多只有一段。今天整理下之前的项目代码，抽出amf来上个教程，怕以后忘记了。本教程写的是http,Servlet交互的方式。socket方式要写粘包，代码麻烦，不写了。调试环境1.javajdk1.62.flashbuilder4.53.blazeDS(下载地址 p</welcome-file></welcome-file-list><servlet><servlet-name>test</servlet-name><servlet-class>TestAMF</servlet-class></servlet><servlet-mapping><servlet-name>test</servlet-name><url-pattern>/TestAMF</url-pattern></servlet-mapping></web-app>5.启动web服务端.(一般默认的地址是 接收到的服务端数据varstart:Number=getTimer();varbyte:ByteArray=_loader.dataasByteArray;byte.uncompress();varobj:TestResult=byte.readObject();varend:Number=getTimer();trace(""耗时：""+(end-start)+""毫秒"");trace(obj);break;}}}}9.F11编译as项目即可看到结果了。运行后可以看到，amf解析效率还是相当不错的。我用999个对象数组放进去解析，就10个ms内搞定。不过跟.net有个相同的地方，就是第一次解析慢。启动第一次解析用了几百个毫秒，估计是生成缓存在内存吧。还有一个不足的地方是amf无法解析Vector类型，可能有方法吧，我暂时没找到。相比java,as的泛型对象显得很憋腿…最后疑惑一下，很多人跟我AMF协议，我就奇怪，网络协议一般就是http,socket,udp。socket是4层传输，http是7层传输。AMF从应用上看只是一种数据格式而已，像xml,json这样，只是通过代码将这些格式进行转换。在百度百科搜到的资料我更加疑惑了，有一句是这样“AMF协议是基于Http协议的.”http是7层协议，那AMF算什么？而且我写游戏的时候都是用socket+amf的呀，基于http是什么意思呢？这些概念不知道谁定义的，会用是一回事，不过要通透看来还要有许多学术知识才行。amfDemo.rar",2013/12/10
814,关于“人脸识别”，可以再急一些吗？,王健敏,http://180.168.156.212:2262/wecenter/?/article/8468,上周四（2013-12-05），接到公司领导通知，由于某某项目的甲方大领导对公司已有图片相似度检测工具不满意，需要改进。告知我搜索人脸识别技术的相关资料。刚得知这个消息的我，出于技术人员的本能反映，哇！高科技啊！兴奋~。随领导告知我要2天内搞定并集成。顿时的我心情就像这几天上海的空气质量，陷入了雾霾。。。（萨拉马&*……%）咋整？还是先搞吧，搞完了再发泄情绪。。。进入正题，本功能借助网上开源项目opencv+javacv制作。百度+google的相关资料甚少，只能从官方给的E文demo中找线索。不扯了，上班事比较多。做了个简单的web应用，浏览collect.jsp即可，这页面上有两个file框，第一个框做人脸采集用（上传照片并输入姓名），第二个框做识别用，需要注意的是，当采集到第三张照片之后，才可以开始识别。另外，采集和识别都可以上传多个人像的照片，系统可识别出一张照片上的多个人脸。本程序需要下载opencv并安装：下载地址： project...nload安装后设置环境变量：与往常设置JDK的环境变量一样，path前增加路径，精确到bin，像我的就是：C:\Users\wangjianmin\Downloads\opencv\build\x64\vc10\bin;如果是32位的，就是C:\Users\wangjianmin\Downloads\opencv\build\x86\vc10\bin;复制dll文件：如果是32位操作系统则把opencv\build\java\x86\opencv_java244.dll复制到系统的system32目录下，如果是64位操作系统就把opencv\build\java\x64\opencv_java244.dll复制到system32目录下另外，需要安装VC2010运行环境。网站不能更新附件，最新的程序在第五楼。。。compare.zipcompare.zipcompare.zip,2013/12/9
815,持续集成与测试自动化经验,胡乔飞,http://180.168.156.212:2262/wecenter/?/article/8467,"持续集成及其自动化编译""持续集成（ContinuousIntegration）""的概念来自于XP（极限编程）的一个实践,我们的开发模式是建立在CMM的基础之上,引入了某些XP的概念，所以我们的思想是取各方面的精华来适合自己。持续集成是指能够自动的集成已经提交(Check-in)的代码，直至发布到测试服务器供测试的整个过程。1、实现自动化日构建需要做以下几部分的工作：2、将所有的源代码保存在单一的开发服务器，让所有人都能从这里获取最新的源代码（需要用配置管理工具存放源代码:如VSS/CVS/ClearCase）。3、使创建过程完全自动化，让任何人都可以只输入一条命令就完成系统的创建。4、使测试完全自动化，让任何人都可以只输入一条命令就运行一套完整的系统测试。5、确保所有人都可以得到最新、最好的可执行文件。6、自动化编译：为了能够提供自动化测试，所以所有的代码必须能够实现自动化编译。其实很多在做持续集成的公司都实现了改功能：如java程序改进，软件项目的持续集成与测试自动化的发展是必然的，其作用也将越来越明显。不同的技术和开发环境对测试如何自动化有不同的要求，还有很多值得研究的地方。我们的产品是不是也能实现类似的自动化编译呢？是不是可以只输入一条命令就运行一套完整的系统测试？",2013/12/5
816,语音识别引发的一些列研究,王健敏,http://180.168.156.212:2262/wecenter/?/article/8466,最近公司想搞语音识别，找了两家做语音识别的公司，希望通过第三方的工具来实现页面的操控与数据检索，不需要用户输入文字和点击按钮。技术难点：1、在页面上采集语音2、第三方语音识别引擎对捕捉的WAV文件采样率有要求，需要把原本采样率为48000转换成16000的。解决：1、利用html5的recorder对象和websocket实现语音采集及上传2、用js（html5）实现wav文件头的修改，并且每6个字节取1个字节（48000/16000*2声道）具体代码请参照附件，eclipse可直接部署，浏览a.html即可TestWebSocket.rar,2013/11/25
817,让用户不再讨厌Web表单的十九个最佳设计实践,王斌,http://180.168.156.212:2262/wecenter/?/article/8465,发错版块无法删除也无法转移。,2013/11/22
818,关于打开网页的问题,方元凯,http://180.168.156.212:2262/wecenter/?/article/8464,为什么打开网页老是出现“依据组织的信息安全策略，已禁止使用无线Wi-Fi路由器接入内部网络，请关闭Wi-Fi设备。”难道是不能用无线网？我连的是“CESCISCOAP”,2013/11/19
819,微信背后的产品观—张小龙,路斌,http://180.168.156.212:2262/wecenter/?/article/8463,2012年7月24日下午14：20---23：30，由微信之父张小龙主讲《微信背后的产品观》。张小龙的讲演长达8小时20分。腾讯为此开设17个分会场，同步直播讲座，参加者超过1700人。晚上19：10分听众晚餐，20：30继续进行。恢复演讲时在线直播用户依然有600余人，加上分会场听众，总计有超过800人听完全程讲演。很多人并不知道，这可能是张小龙第一次也是最后一次做公开讲演，在公众面前讨论产品。在这次演讲中，他把自己15年来关于产品的所有经验和心得一次性全部公开，今后将不再做类似公开课。这一讲座受到腾讯保密协定约束，因此其中令人惊叹的新产品特性演示不可以对外公开。同时，腾讯大讲堂举办的这一公开课的目标群体是腾讯两万余员工中的产品经理。微信背后的产品观_—_张小龙.pptx,2013/11/18
820,感谢IT部的努力，Foxmail邮件客户端终于能收发公司邮箱的邮件了,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8462, 通过以上配置，Foxmail邮件客户端可以收发公司邮箱的邮件了。同时，公司邮箱的垃圾邮件问题也随之解决，只需要在foxmail中设置严格一点的垃圾邮件过滤策略即可，并设置邮件服务器上的邮件收取7天后自动删除。不要直接登录公司邮箱收取邮件，直接登录还是有一大堆垃圾邮件。,2013/11/18
821,关于证书，建议公司设置一个统一的证书格式，供签名时使用,王链玮,http://180.168.156.212:2262/wecenter/?/article/8461,记得很久很久以前，郑国强维护过一段时间，当时有需要签名时找他拿，现在已经没了建议有一个统一的格式，统一管理,2013/11/14
822,公司网络升级后的新问题，求解...,包士杰,http://180.168.156.212:2262/wecenter/?/article/8460,1、打外地客户电话，经常是“呼叫受限，请勿越权使用”，往往一个电话要拨10几次，有的客户反馈问题，以为我们不重视，一直不响应，反馈过，据说是公司外地电话线路有限，需要排队...2、用户通过qq反馈问题，截图不能显示了，发的文件也不能接受，一定要让客户发邮件才行，一来一回，也很耽误时间，用户也很纳闷，你们公司的管控这么严格啊...能否开发权限，多次反馈，无果...虽然都是小事，都能克服，但是如果能解决，万分感激~,2013/11/12
823,关于IE10支持cell报表,路斌,http://180.168.156.212:2262/wecenter/?/article/8459,近期部分项目客户使用IE10，发现IE10下报表显示有问题。cell报表自从被用友收购后，升级就比较很缓慢。公司采购的版本是5.3.1TMT经过寻找后，找到的升级版本，用的版本是5.3.9.14需要本版本的，可以联系方俊新。,2013/11/12
824,编码一定要统一，否则乱码随处可见,方俊新,http://180.168.156.212:2262/wecenter/?/article/8458,最近有个项目在linux环境中，将项目部署在websphere6.x上，出现很多奇怪的系统异常，如：新增的数据保存到数据库中，中文出现乱码，很多树读取数据无法显示等等。后来到现场经过一系列的问题分析，最终发现树加载出来的数据中文出现乱码情况，导致json数据无法解析。而这些乱码到底怎么产生的呢？为什么有些树可以正常显示而有些树确实乱码无法显示？这点让许多人匪夷所思。到底是什么原因导致这类奇怪的事情发生？通过对功能代码的对比，不难发现：无乱码的代码在后台采用的是UTF-8编码格式，而出现乱码的则是采用GBK编码格式，可见不难发现是编码格式的不对导致乱码出现。为什么会在一套系统中出现多种编码格式？这个才是让大家所要注意的，由于很多系统是通过拷贝几套系统的功能拼接出来的，所以在不同系统中的不同编码格式，自然会产生多种编码格式，在这方面到是可以给大家几点建议：1、在开发人员开发中，不管其他系统是采用什么编码格式，一定要将格式统一改为目前开发系统的编码格式2、在开发过程中，一定要进行编码格式检查，以免简单错误发生,2013/11/6
825,人生就如做项目,张元利,http://180.168.156.212:2262/wecenter/?/article/8457,出生：----------立项；征婚：----------公开招标；相亲：---------邀请招标；自由恋爱：--------议标；提亲：----------投标；介绍人：--------招标代理；第一次见面：---------看现场；女方家长：----------投资人；女方：----------业主；岳父岳母：-----------设计单位；婚前指导：----------技术交底；婚前指导医生：----------监理单位；过岳父岳母关：----------资格预审；男方家长：----------施工单位；男方：----------项目经理；彩礼：---------投标保证金；过朋友关：----------公示；恋爱：----------公示期；确定恋爱关系：----------确定中标候选人；婚前同居：---------非法串标；婚前约定：----------合同谈判；办结婚证：---------签定合同；办结婚酒：----------图纸会审；给男方钱：----------工程预付款；给女方钱：----------履约保证金；洞房花烛：----------施工进场；蜜月期：----------赶工期；婚后生活安排：----------施工组织设计；女方不育：----------设计缺陷；男方不育：----------施工质量缺陷；找情人：----------违法分包；生孩子：----------工程完工；满月酒：----------竣工验收；一周岁：----------质保期；分居：---------停工待料；离婚：---------因施工问题，中途被勒令退场；白头偕老：-----------达到设计使用年限,2013/11/6
826,稳定情绪-真诚表达-余姚项目,张元利,http://180.168.156.212:2262/wecenter/?/article/8456,客户讲我们2010年提供的方案，拿到今天去采购，当时没有建议购买trs(考虑预算)，今天检索速度慢了，要求增加trs，抱怨我们提供方案考虑不周，造成他们重新修改方案比较麻烦。开始客户比较激动，我们先承认说有我们考虑不周的地方，后跟客户耐心讲，说一般软件生命周期才5年，IT界的一般更新换代很快，我们没预见到这个量希望客户见谅，实际上这就委婉的表达了，客观因素同时我们说客户扫描量太快，含蓄的表达客户工作工作非常扎实，我们本想5年后提出增加trs的，现在提前了2年，夸奖了客户客户当然高兴。最后我们说如果实在协调不来，我们技术优化，尽量再保证运行2年。通过以上3个答复，客户情绪缓和下来，客户这个时候接了个电话，接完后，态度缓和很多，开始说也有他们原因，当时可能考虑预算……，谈话进入了正常轨迹。,2013/11/5
827,客户抱怨我们人不稳定,张元利,http://180.168.156.212:2262/wecenter/?/article/8430,客户抱怨我们人不稳定：首先承认存在这个问题，谢谢客户理解，同时表示我们核心是稳定的，下边变化有些没办法的无奈成分，同时可以询问客户有没有什么好的主意能帮忙留住客户，一般客户都会说多给钱啊，如果关系好，可以半开玩笑说，我们也想多给啊，你看生意不够，以后麻烦多给点生意，然后哈哈一笑，事情有时候会比较好。,2013/11/5
828,有效沟通引导客户--河南博物院,张元利,http://180.168.156.212:2262/wecenter/?/article/8429,?焦点：界面不会、数据没导、程序乱?步骤:(1)抓重点，主动交代；跟客户沟通；（2）谦虚回答不怕被批；（3）认可客户意见，先接受客户已经，再顺客户思路引导，最后引导客户认可并感觉你现在的方案是最合适的?（一）：界面：主动将界面设计理念，委婉产生，并结合客户的想法；?（二）：先类型后再条目后图片；还是类型后直接图片；从显示条目可见范围内容上做说服；并提供详细后直接看图片替代功能说服客户,2013/11/5
829,部分内容遮挡,张元利,http://180.168.156.212:2262/wecenter/?/article/8428,内容遮挡思路（1）加工里，动态存储位置；（2）图片转换时，动态变为静态，同一文件状态不同存三份（为了全文检索，如果没有全文检索，可全部动态）；（3）静态权限控制调用剪贴板02.jpg剪贴板01.jpg,2013/11/5
830,OA性能问题,张元利,http://180.168.156.212:2262/wecenter/?/article/8427,、OA:oa性能优化：（1）登陆性能，原一开始加载即加载全部，改为分步加载?（2）启动、办理、提交性能：产品部陆志超优化?IE8似乎比IE6快的多,2013/11/5
831,通用浏览器,张元利,http://180.168.156.212:2262/wecenter/?/article/8426,"5接口产品：pdf下载慢，分段读取下载方法解决；调研pdf时候先下载前5页，存成文件t1,下载浏览的同时后台线程下载剩余部分，并做提示，完成后出现查看更多,内存调用文件t2解决查看性能；?终极解决方法应该是浏览器能自动流式阅读解决人王孝本，大家可以咨询他",2013/11/5
832,通用浏览器--思路,张元利,http://180.168.156.212:2262/wecenter/?/article/8424,?4、接口产品：通用浏览器读取pdf问题：原通用浏览器读取pdf竟然方法里写是先下载到当地再当地线性化，然后流模式查看；这个思路不知道是谁想出来的，颇有画蛇添足的味道（开发人员注释为HHC）；至少反映出设计这个思路的人不了解客户需求，没有考虑性能//为了权限控制正确思路：先工具线性化，再分页查看,2013/11/5
833,通用浏览器-支持上一件，下一件,张元利,http://180.168.156.212:2262/wecenter/?/article/8423,接口产品：反复调用通用浏览器，报错同时实现通用浏览器浏览tif，jpg有pdf效果，先前1个月delphi人员都拒绝改，我们梳理思路讲图像顺序号传参数给通用浏览器，通用浏览器写内存表，依次调用，解决浏览器外增加上一页下一页的时候，反复调用浏览器，ie报错（tif、jpg需单页，其实程序里可以多页了，同时有页号，考虑多页tif显示不准，不放开暂时）据说广东也有类似需求！,2013/11/5
834,思路很重要--项目管理和分析的价值,张元利,http://180.168.156.212:2262/wecenter/?/article/8422,数字化加工：数字化加工拆卷扫描问题；由于照片都是写到xml里，而且涉及面广，修改一天后无法进行，后增加逻辑页（沟通不充分，没理解我真实意思）晚上加班半小时沟通，按照任务里档号增加起始号，且颜色标示显示，图像号跟页号分离，第二天沟通后解决。（2天到1周还不能保证稳定的工作量，到半天完全可控）,2013/11/5
835,产品人员必须懂项目，懂客户习惯,张元利,http://180.168.156.212:2262/wecenter/?/article/8421,馆藏资源：性能优化：馆藏资源左侧资源树选择类型，右边显示检索区域和检索结果区域，处理：原方式，全部加载后显示，性能慢，调去右边需要10秒以上；更改为先基本和结果区，点高级后再加载高级检索，修改后点高级检索存在遮挡情况，二次修改问题解决；,2013/11/5
836,有则改之无则加勉，记得关闭自己打开的数据库链接,刘磊,http://180.168.156.212:2262/wecenter/?/article/8425,"最近和项目组一起查系统意外宕机的原因，日志中报无法获取数据库链接，抛timeoutwaitingforidleobject异常，这个问题通常都是因为没有关闭数据库链接引起的，导致数据库连接池满而无法再获取链接。检查中发现一个类中有如下这段代码@SuppressWarnings(""unchecked"")publicstaticStringlogin(Stringloginname,HttpServletRequestrequest){Criteriaquery=App.getHibernateDao().getSessionFactory().openSession().createCriteria(Reservation.class);query.add(Restrictions.eq(""IDnumber"",loginname));query.add(Restrictions.ne(""status"",""10""));List<Reservation>list=query.list();if(list!=null&&list.size()>0){ReservationreservationUser=newReservation();reservationUser.setName(list.get(0).getName());reservationUser.setDeptId(list.get(0).getDeptId());request.getSession().setAttribute(""RESERVATIONUSER"",reservationUser);returnrequest.getSession().getId()+""$$""+list.get(0).getIDnumber()+""$$""+list.get(0).getName();}else{return""1"";}}代码中只使用了hibernate的openSession()，之后就没有再对session进行关闭了。这个就是编程时的意识和习惯问题，可能是因为java有垃圾回收机制，所以java程序从最初编程开始，就只需要new，而不需要delete，只需要编写构造方法，而不需要编写析构方法，这是java提供的一中便利，但也可能是容易引起意外的原因吧。老话说“有借有还再借不难”，东西从哪里拿的，用完之后还放回那里去，不然就要出问题了。",2013/11/1
837,通过sql语句对数据进行按年度、季度、月份进行统计,宋国梁,http://180.168.156.212:2262/wecenter/?/article/8420,"前一段时间在做一个数据统计的功能，需求对每月的数据进行统计，统计结果显示在当月数据的下面，对每个季度的数据统计，统计结果也显示在相应数据的下面，对每个年度的数据进行合计(效果图参加附件)路总帮我写了一个sql语句，通过sql语句查询得到的结果集就满足了以上需求。主要思路：先.查询出所要的数据，然后根据时间字段分别获取月份统计、季度统计、年度统计的数据，再使用unionall将数据和统计结果整合一块儿，最后再根据时间进行排序。sql语句如下：(月份、季度、年度分组排序字段要做相应处理)select'条目'aso_hide,user_nameaso_user_name,to_char(fill_date,'yyyy-Q-mm-dd')aso_fill_dateas,user_name,project_no,project_name,signings,gathering,union_bill_nofromtest_pageunionallselect'月度统计'ashide,user_nameaso_user_name,to_char(fill_date,'yyyy-Q-mm-')||'99'aso_fill_dateas,null,null,to_char(fill_date,'yyyy-mm')||'小计',sum(signings)assignings,sum(gathering)asgathering,''fromtest_pagegroupbyuser_name,to_char(fill_date,'yyyy-Q-mm-')||'99',to_char(fill_date,'yyyy-mm')||'小计'unionallselect'季度统计'ashide,user_nameaso_user_name,to_char(fill_date,'yyyy-Q-')||'99999'aso_fill_dateas,user_name,null,null,sum(signings)assignings,sum(gathering)asgathering,''fromtest_pagegroupbyuser_name,to_char(fill_date,'yyyy-Q-')||'99999'unionallselect'年度统计'ashide,user_nameaso_user_name,to_char(fill_date,'yyyy-')||'9999999'aso_fill_dateas,user_name,null,null,sum(signings)assignings,sum(gathering)asgathering,''fromtest_pagegroupbyuser_name,to_char(fill_date,'yyyy-')||'9999999'orderbyo_fill_dateas,o_user_name统计.doc",2013/10/28
838,录入问题,林超,http://180.168.156.212:2262/wecenter/?/article/8419,外出日志登记模块，录入时直接切换成中文，文字无法录入，是否有这个问题？,2013/10/22
839,中办发[2012]14号《党政机关公文处理工作条例》全文(附权威解读),杨安荣,http://180.168.156.212:2262/wecenter/?/article/8455,这个文件发布之后，我们帮党委系统和政府机关（比如市委办公厅、人大、政协、检察院等）做的公文处理系统都要符合文件要求。请相关软件部门经理和项目经理仔细研读，特别是上海分公司的软件部门。中办发[2012]14号《党政机关公文处理工作条例》全文(附权威解读).docGBT9704-2012党政机关公文格式.pdf,2013/10/18
840,关于url编码的问题,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8454,"本质：url字符集通常使用的都是US-ASCII字符集，US-ASCII字符集使用7位二进制编码（来表示打字机提供的大多数按键和少数用于文本格式和硬件通知的不可打印控制字符（如空格）），很明显这些字符并不包含世界各国的字符，所以要将转义序列（表示方法：一个%和两个十六进制数（16进制数是符合US-ASCII字符集的））集成进去,这样就可以用有限的US-ASCII字符集表示任意字符值了。URL编码规则每对name/value由&分开，每对来自表单的name/value用=分开。如果用户没有输入值的那个name依旧会出现不过就是没有值。URL编码是在字符ASCII码的十六进制数的前面加上%。例如\（她的十六进制数表示为5c）的URL编码就是%5c。url转义其实只是为了符合url的规范而已。因为在标准的url规范中中文和很多的字符是不允许出现在url中的。rfc1738:“只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-_.+!*'(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。”url编码相关知识.rtfd.zip",2013/10/17
841,iOS 硬件架构介绍,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8453,"armv6和armv7,armv7sarmv6：iPhone2G/3G，iPod1G/2Garmv7：iPhone3GS/4/4s，iPod3G/4G，iPad1G/2G/3Garmv7s：iPhone5armv6、armv7、armv7s是armCPU的指令集，原则上是向下兼容的，如：iPhone4sCPU支持armv7,但它会兼容armv6，只是使用armv6指令可能无法充分发挥它的特性。iphone5CPU支持armv7s，它也会兼容armv7。如果引用到第三方的库，以前在iphone4s下编译没有问题，但是换成iphone5之后，提示：Undefinedsymbolsforarchitecturearmv7s:""_OBJC_CLASS_$_AMapView"",referencedfrom:objc-class-refinlibMAMapKit.a(MAMapView.o)ld:symbol(s)notfoundforarchitecturearmv7s大体意思是：引用自XX.a静态库的XX类不支持armv7s指令原因是：你引用的静态库确实不支持armv7s，那么你要想顺利编译通过，要么通知开发修改，等待支持了之后再测；要么在target的buildsettings中的validArchitectures将armv7s先暂时去掉，编译就可以成功。（等待支持了之后，再添加上）",2013/10/17
842,Nginx--高性能的 HTTP 和 反向代理 服务器 IMAP/POP3/SMTP 代理服务器。,路斌,http://180.168.156.212:2262/wecenter/?/article/8452,"接到某项目要求使用此应用服务器需求，查了资料如下：Nginx(""enginex"")是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。Nginx是由IgorSysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx1.0.4发布。1简介Nginx（发音同enginex）是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师IgorSysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：新浪、网易、腾讯等。2优点nginxmapNginx可以在大多数UnixlikeOS上编译运行，并有Windows移植版。Nginx的1.4.0稳定版已经于2013年4月24日发布，一般情况下，对于新建站点，建议使用最新稳定版作为生产版本，已有站点的升级急迫性不高。Nginx的源代码使用2-clauseBSD-likelicense。Nginx是一个很强大的高性能Web和反向代理服务器，它具有很多非常优越的特性：在高连接并发的情况下，Nginx是Apache服务器不错的替代品：Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一。能够支持高达50,000个并发连接数的响应，感谢Nginx为我们选择了epollandkqueue作为开发模型。服务器Nginx作为负载均衡服务器：Nginx既可以在内部直接支持Rails和PHP程序对外进行服务，也可以支持作为HTTP代理服务器对外进行服务。Nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比Perlbal要好很多。代码Nginx代码完全用C语言从头写成，已经移植到许多体系结构和操作系统，包括：Linux、FreeBSD、Solaris、MacOSX、AIX以及MicrosoftWindows。Nginx有自己的函数库，并且除了zlib、PCRE和OpenSSL之外，标准模块只使用系统C库函数。而且，如果不需要或者考虑到潜在的授权冲突，可以不使用这些第三方库。邮件代理服务器作为邮件代理服务器：Nginx同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm描述了成功并且美妙的使用经验。Nginx是一个安装非常的简单，配置文件非常简洁（还能够支持perl语法），Bugs非常少的服务器：Nginx启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。3功能支持的操作系统FreeBSD3.x,4.x,5.x,6.xi386;FreeBSD5.x,6.xamd64;Linux2.2,2.4,2.6i386;Linux2.6amd64;Solaris8i386;Solaris9i386andsun4u;Solaris10i386;MacOSX（10.4）PPC;WindowsXP，WindowsServer2003和Windows7中。结构与扩展一个主进程和多个工作进程。工作进程是单线程的，且不需要特殊授权即可运行；kqueue(FreeBSD4.1+),epoll(Linux2.6+),rtsignals(Linux2.2.19+),/dev/poll(Solaris711/99+),select，以及poll支持；kqueue支持的不同功能包括EV_CLEAR,EV_DISABLE（临时禁止事件），NOTE_LOWAT,EV_EOF，有效数据的数目，错误代码；sendfile(FreeBSD3.1+),sendfile(Linux2.2+),sendfile64(Linux2.4.21+），和sendfilev(Solaris87/01+)支持；输入过滤(FreeBSD4.1+)以及TCP_DEFER_ACCEPT(Linux2.4+)支持；10,000非活动的HTTPkeep-alive连接仅需要2.5M内存。最小化的数据拷贝操作；其他HTTP功能：基于IP和名称的虚拟主机服务；Memcached的GET接口；支持keep-alive和管道连接；灵活简单的配置；重新配置和在线升级而无须中断客户的工作进程；可定制的访问日志，日志写入缓存，以及快捷的日志回卷；4xx-5xx错误代码重定向；基于PCRE的rewrite重写模块；基于客户端IP地址和HTTP基本认证的访问控制；PUT,DELETE，和MKCOL方法；支持FLV（Flash视频）；带宽限制。实验特性内嵌的perl；通过aio_read()/aio_write()的套接字工作的实验模块，仅在FreeBSD下；对线程的实验化支持，FreeBSD4.x的实现基于rfork()；Nginx主要的英语站点是 ;}记住subs_filter命令的格式即可随意发挥想象力替换你想替换的广告、超链接，等等。[1]基于太多人询问下面的问题：我能为了得到上传进度而关闭代理的缓存吗使用nginx我怎么才能给用户显示上传进度到目前为止（2007-Apr-26）还没有办法关闭到后端服务器的缓存.7NginxRewrite[2]1.NginxRewrite基本标记(flags)复制内容到剪贴板代码:last–基本上都用这个Flag。break–中止Rewirte，不在继续匹配redirect–返回临时重定向的HTTP状态302permanent–返回永久重定向的HTTP状态3012.正则表达式匹配，其中：代码:CODE:*~为区分大小写匹配*~*为不区分大小写匹配*!~和!~*分别为区分大小写不匹配及不区分大小写不匹配3.文件及目录匹配，其中：代码:CODE:*-f和!-f用来判断是否存在文件*-d和!-d用来判断是否存在目录*-e和!-e用来判断是否存在文件或目录*-x和!-x用来判断文件是否可执行4.Nginx的一些可用的全局变量，可用做条件判断：代码:CODE:$args$content_length$content_type$document_root$document_uri$host$http_user_agent$http_cookie$limit_rate$request_body_file$request_method$remote_addr$remote_port$remote_user$request_filename$request_uri$query_string$scheme$server_protocol$server_addr$server_name$server_port$uri8版本发布2012年08月22日，Nginx1.3.5开发版发布。2012年09月12日，Nginx1.3.6开发版发布。2012年12月11日，Nginx1.2.6稳定版发布2013年02月12日，Nginx1.2.7稳定版发布2013年02月19日，Nginx1.3.13开发版发布2013年04月03日，Nginx1.2.8稳定版发布。2013年04月16日，Nginx1.3.16开发者版本发布。2013年04月24日，Nginx1.4.0稳定版发布。2013年05月07日，Nginx1.4.1稳定版发布。2013年05月07日，Nginx1.5.0开发版本发布。2013年06月04日，Nginx1.5.1主版本发布。2013年07月02日，Nginx1.5.2开发版发布。2013年07月17日，Nginx1.4.2稳定版发布。2013年07月30日，Nginx1.5.3开发版本发布。2013年08月27日，Nginx1.5.4开发版本发布。2013年09月17日，Nginx1.5.5开发版本发布。",2013/10/17
843,HTML5语音输入x-webkit-speech方法支持webkit内核,方俊新,http://180.168.156.212:2262/wecenter/?/article/8451,"用法很简单只需要在input添加属性x-webkit-speech即可，例子如下：<inputtype=""text""x-webkit-speech/>这样你的输入框右边里就多了个「小话筒」，点击的时候就会提示这时说出来识别后就可以了，我测试下来，中文英语的识别率还挺高的。语音输入其他属性：lang这玩意可以强制输入框里面的语音的语言种类，例如<inputtype=""text""x-webkit-speechlang=""zh-CN""/>语音事件目前已知的只有onwebkitspeechchange，顾名思义，就是语音发生变化时触发的事件，一般可以作为提交<inputtype=""text""x-webkit-speechonwebkitspeechchange=""$(this).cloest('form').submit()""/>这样说完以后就自动搜索了x-webkit-grammar这个不是语音搜索用的属性，但是可以控制这个输入的语法，例如在做搜索框的话就可以用<inputtype=""text""x-webkit-speechx-webkit-grammar=""bUIltin:search""/>使得语音输入的内容尽量靠近搜索内容，去除多余的字符，例如「的」这个功能相当有趣，实用就不敢恭维了，主要是因为适用范围太小啊，所以只能希望HTML5尽快统一并应用了。TextArea对于TextArea是不能用上述功能的，不过可以从上述方法中变通使用。<textareaid=""txt""></textarea><inputx-webkit-speechid=""mike""/>设置css：#mike{font-size:25px;width:25px;height:25px;cursor:pointer;border:none;position:absolute;margin-left:5px;outline:none;background:transparent;}#txt{height:150px;width:150px;}再添加javascript处理：varmike=document.getElementById('mike');mike.onfocus=mike.blur;mike.onwebkitspeechchange=function(e){//console.log(e);//SpeechInputEventdocument.getElementById('txt').value=mike.value;};效果如下：演示地址：  /x-webkit-speech-input-and-textareas/",2013/10/14
844,MySql服务器的启动和关闭,方俊新,http://180.168.156.212:2262/wecenter/?/article/8450,"在windows下：启动：1.cdc:\mysql\bin2.mysqld--console关闭：1.cdc:\mysql\bin2.mysqladmin-urootshutdown还可以：启动：1.cdc:\mysql\bin2.netstartmysql关闭：1.cdc:\mysql\bin2.netstopmysql在linux下：采用netstat-nlp查看mysql服务的状态命令行方式：开启./mysqld_safe&关闭mysqladmin-urootshutdownrpm方式安装的开启servicemysqlstart关闭servicemysqlstop在命令行启动mysql时，如不加""--console""，启动、关闭信息不在界面中显示，而是记录在安装目录下的data目录里，文件名一般是hostname.err,通过此文件查看mysql的控制台信息。执行命令：1.mysql/bin>mysql-uroot-ptest<c:/test.sql2.mysql/bin>mysql-uroot-p然后输入密码mysql>usetestmysql>sourcec:/test.sqlwindows和linux这两种都可以使用的文件路径建议使用/而不是\------------------------------------------------------------------------------------------------------------------------------------MySQL服务器既可以做为前台服务程运行，也可以做为后台服务运行。在MySQL安装目录的bin目录下提供了以下MySQL服务程序：mysqld.exe：最基本的MySQL服务器程序。mysqld-nt.exe：WindowsNT/2000/XP平台的优化版本，支持命名管道。执行以上任意一个程序，都会以前台的方式启动MySQL服务。也可按下面的方式将它做为后台来运行。１。在DOS下转到MySQL安装目录的bin子目录下。２。在NT/2000/xp中注册MySQL服务。命令如下：mysqld-nt--install３。启动MySQL服务：命令如下：netstartmysql４。停止MySQL服务：命令如下：netstopmysql５。从NT/2000服务中移除MySQL服务：命令如下：mysqld-nt--remove原文来源： /blog/1562095",2013/10/11
845,mysql32位在win 64&32位操作系统中运行,方俊新,http://180.168.156.212:2262/wecenter/?/article/8449,"mysql32位在win64&32位操作系统中运行最近有个项目，需要将一套mysql在win32和win64操作系统上运行，固需要mysql32能在win32&64位上运行。本人在网上找到一个免安装版本mysql-5.1.51-win32，它能在win32&64上运行，具体操作方法如下：第一，在mysql的home目录下创建“my.ini”文件，内容如下：（注意标红字体，需要根据实际情况进行修改）#MySQLServerInstanceConfigurationFile#----------------------------------------------------------------------#GeneratedbytheMySQLServerInstanceConfigurationWizard###InstallationInstructions#----------------------------------------------------------------------###CLIENTSECTION#----------------------------------------------------------------------##ThefollowingoptionswillbereadbyMySQLclientapplications.#NotethatonlyclientapplicationsshippedbyMySQLareguaranteed#toreadthissection.IfyouwantyourownMySQLclientprogramto#honorthesevalues,youneedtospecifyitasanoptionduringthe#MySQLclientlibraryinitialization.#[client]port=3306[mysql]default-character-set=gbk#SERVERSECTION#----------------------------------------------------------------------##ThefollowingoptionswillbereadbytheMySQLServer.Makesurethat#youhaveinstalledtheservercorrectly(seeabove)soitreadsthis#file.#[mysqld]#TheTCP/IPPorttheMySQLServerwilllistenonport=3306#Pathtoinstallationdirectory.Allpathsareusuallyresolvedrelativetothis.basedir=""C:\mysql-5.1.51-win32\""#Pathtothedatabaserootdatadir=""C:\mysql-5.1.51-win32\data""[WinMySQLadmin]Server=""C:\mysql-5.1.51-win32\mysqld.exe""#Thedefaultcharactersetthatwillbeusedwhenanewschemaortableis#createdandnocharactersetisdefineddefault-character-set=gbk#Thedefaultstorageenginethatwillbeusedwhencreatenewtableswhendefault-storage-engine=INNODB#SettheSQLmodetostrictsql-mode=""STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION""#ThemaximumamountofconcurrentsessionstheMySQLserverwill#allow.Oneoftheseconnectionswillbereservedforauserwith#SUPERprivilegestoallowtheadministratortologinevenifthe#connectionlimithasbeenreached.max_connections=100#QuerycacheisusedtocacheSELECTresultsandlaterreturnthem#withoutactualexecutingthesamequeryonceagain.Havingthequery#cacheenabledmayresultinsignificantspeedimprovements,ifyour#havealotofidenticalqueriesandrarelychangingtables.Seethe#""Qcache_lowmem_prunes""statusvariabletocheckifthecurrentvalue#ishighenoughforyourload.#Note:Incaseyourtableschangeveryoftenorifyourqueriesare#textuallydifferenteverytime,thequerycachemayresultina#slowdowninsteadofaperformanceimprovement.query_cache_size=0#Thenumberofopentablesforallthreads.Increasingthisvalue#increasesthenumberoffiledescriptorsthatmysqldrequires.#Thereforeyouhavetomakesuretosettheamountofopenfiles#allowedtoatleast4096inthevariable""open-files-limit""in#section[mysqld_safe]table_cache=256#Maximumsizeforinternal(in-memory)temporarytables.Ifatable#growslargerthanthisvalue,itisautomaticallyconvertedtodisk#basedtableThislimitationisforasingletable.Therecanbemany#ofthem.tmp_table_size=26M#Howmanythreadsweshouldkeepinacacheforreuse.Whenaclient#disconnects,theclient'sthreadsareputinthecacheiftherearen't#morethanthread_cache_sizethreadsfrombefore.Thisgreatlyreduces#theamountofthreadcreationsneededifyouhavealotofnew#connections.(Normallythisdoesn'tgiveanotableperformance#improvementifyouhaveagoodthreadimplementation.)thread_cache_size=8#***MyISAMSpecificoptions#ThemaximumsizeofthetemporaryfileMySQLisallowedtousewhile#recreatingtheindex(duringREPAIR,ALTERTABLEorLOADDATAINFILE.#Ifthefile-sizewouldbebiggerthanthis,theindexwillbecreated#throughthekeycache(whichisslower).myisam_max_sort_file_size=100G#Ifthetemporaryfileusedforfastindexcreationwouldbebigger#thanusingthekeycachebytheamountspecifiedhere,thenpreferthe#keycachemethod.Thisismainlyusedtoforcelongcharacterkeysin#largetablestousetheslowerkeycachemethodtocreatetheindex.myisam_sort_buffer_size=52M#SizeoftheKeyBuffer,usedtocacheindexblocksforMyISAMtables.#Donotsetitlargerthan30%ofyouravailablememory,assomememory#isalsorequiredbytheOStocacherows.Evenifyou'renotusing#MyISAMtables,youshouldstillsetitto8-64Masitwillalsobe#usedforinternaltemporarydisktables.key_buffer_size=40M#SizeofthebufferusedfordoingfulltablescansofMyISAMtables.#Allocatedperthread,ifafullscanisneeded.read_buffer_size=64Kread_rnd_buffer_size=256K#ThisbufferisallocatedwhenMySQLneedstorebuildtheindexin#REPAIR,OPTIMZE,ALTERtablestatementsaswellasinLOADDATAINFILE#intoanemptytable.Itisallocatedperthreadsobecarefulwith#largesettings.sort_buffer_size=256K#***INNODBSpecificoptions***innodb_data_home_dir=""C:\mysql-5.1.51-win32\Data\INNODB\""#UsethisoptionifyouhaveaMySQLserverwithInnoDBsupportenabled#butyoudonotplantouseit.Thiswillsavememoryanddiskspace#andspeedupsomethings.#skip-innodb#AdditionalmemorypoolthatisusedbyInnoDBtostoremetadata#information.IfInnoDBrequiresmorememoryforthispurposeitwill#starttoallocateitfromtheOS.Asthisisfastenoughonmost#recentoperatingsystems,younormallydonotneedtochangethis#value.SHOWINNODBSTATUSwilldisplaythecurrentamountused.innodb_additional_mem_pool_size=2M#Ifsetto1,InnoDBwillflush(fsync)thetransactionlogstothe#diskateachcommit,whichoffersfullACIDbehavior.Ifyouare#willingtocompromisethissafety,andyouarerunningsmall#transactions,youmaysetthisto0or2toreducediskI/Otothe#logs.Value0meansthatthelogisonlywrittentothelogfileand#thelogfileflushedtodiskapproximatelyoncepersecond.Value2#meansthelogiswrittentothelogfileateachcommit,butthelog#fileisonlyflushedtodiskapproximatelyoncepersecond.innodb_flush_log_at_trx_commit=1#ThesizeofthebufferInnoDBusesforbufferinglogdata.Assoonas#itisfull,InnoDBwillhavetoflushittodisk.Asitisflushed#oncepersecondanyway,itdoesnotmakesensetohaveitverylarge#(evenwithlongtransactions).innodb_log_buffer_size=1M#InnoDB,unlikeMyISAM,usesabufferpooltocachebothindexesand#rowdata.ThebiggeryousetthisthelessdiskI/Oisneededto#accessdataintables.Onadedicateddatabaseserveryoumaysetthis#parameterupto80%ofthemachinephysicalmemorysize.Donotsetit#toolarge,though,becausecompetitionofthephysicalmemorymay#causepagingintheoperatingsystem.Notethaton32bitsystemsyou#mightbelimitedto2-3.5Gofuserlevelmemoryperprocess,sodonot#setittoohigh.innodb_buffer_pool_size=77M#Sizeofeachlogfileinaloggroup.Youshouldsetthecombinedsize#o第二：修改完上面配置信息后，打开cmd窗口，cd到mysql的bin目录，然后运行“mysqld”/“mysqld--console”命令，后者可以查看启动信息，一般出现异常情况便于查看。启动mysql，启动成功后，就可以正常使用mysql了mysql32位在win32&64.docx",2013/10/10
846,除了科大讯飞，国内做语音识别的公司----北京云知声信息技术有限公司,路斌,http://180.168.156.212:2262/wecenter/?/article/8448,"北京云知声信息技术有限公司1公司简介北京云知声专注于智能语音识别及语言处理技术的移动互联网公司，拥有完全自主知识产权的世界顶尖的智能语音识别技术。借助云计算平台和移动互联网技术，云知声目前已推出了一系列语音识别服务中间件和语音识别服务云平台，为互联网企业和用户提供专业的语音识别服务。[1]北京云知声的核心技术团队来自国内外知名企业、高校和研究所，80%以上拥有博士学位，并具有超过十年的语音识别研发和应用经验。2公司历程2012年9月29日，发布“云知声”语音识别公有云，成为国内继“科大讯飞”之后第二家语音云。[2]2012年11月，获得浦发硅谷银行和TechyizuDemoDay2012冠军，并为“搜狗语音助手”提供语音识别服务。[3]2013年1月，升级基于深度神经网络（DNN）的语音识别，并助力“搜狗语音助手”登录微信平台。[4]3公司产品语音云平台云知声语音云支持大词汇量连续语音在线识别，支持应用通过API直接调用公有云服务。在云计算平台下，借助区分度训练、自适应训练、大规模网络动态解码等技术和大规模语料支持，中文连续语音识别的准确率达90%以上，达到世界领先水平。目前云知声提供公有语音云平台[5]以及私有语音云平台。微信语音输入插件[6]云知声面向微信用户推出微信语音输入插件，通过语音在微信中直接快速输入文字；聊天利器，每分钟输入100字，让好友目瞪口呆。4相关新闻【大智慧阿思达克通讯社】2012年11月27日讯,周一,搜狗公司抢在百度(NASDAQ:BIDU)之前发布了类Siri产品--“搜狗语音助手”。搜狗官方人士今日上午对大智慧透露,搜狗语音助手的语音引擎并非由此前传闻的科大讯飞或是盛大提供,而是使用北京云知声信息技术有限公司的模块,产品由搜狗自己研发而成。[7]【IT168厂商动态】2013年02月06日，中国用户数第三大互联网公司搜狗对外发布消息称，搜狗语音助手联合微信开发首款微信语音应用——搜狗语音助手微信版，并伴随微信4.5版上线闪亮登场。与搜狗公司先期推出的搜狗语音助手一脉相承，搜狗语音助手微信版也同样借助“云知声”强大的语音识别技术，并集成了搜狗在搜索引擎及输入法两方面的优势，对中文语义分析更加精准，能够轻松理解用户语义并与其进行沟通。[8]【iOS100知识库】2013年5月7日下午2：00，乐视超级电视发布会在五棵松万事达中心举行。乐视超级电视是硬件，软件和内容的完美融合。超级电视拥有怪兽级的硬件配置，sharp的1080p屏幕、高通的骁龙s4primecpu，整机由富士康负责生产。除了硬件的强大外，最值得注意的是超级电视的语音界面，用户使用带麦克风的遥控器就可以使用自然的语音操控电视，并与电视交互。上网，聊天都不在话下。其中，语音识别和理解服务就是云知声提供的，这是云知声又一次为顶级互联网客户提供语音识别理解服务。乐视超级电视作为硬件、软件和内容的完美结合，再加上自然的语音交互方式，彻底颠覆传统电视，占领客厅指日可待。[9",2013/10/10
847,ios7与其他版本操作系统UI布局适配的经验分享,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8447,"如何更好的在iOS7以及之前的系统上进行UI布局的适配iOS7系统不仅引入了扁平化的UI设计风格，还对UI元素做了很大的修改，这让让用户可以更加灵活方便的去定制自己的UI。比如，在之前的操作系统中，如果要改变导航条的背景色、背景图片、返回按钮的颜色等，都不是一件非常容易的事情，特别是早期的操作系统。但是在iOS7中，系统提供了大量的接口让用户可以方便的实现这些功能。当然，如果应用需要兼容iOS5到iOS7的多跟版本的话，用户要做的事情还是很多的。iOS7还改变了一些UI元素的呈现方式，比如UIAlertView，现在在UIAlertView上添加子视图已经变成了无效操作，具体情况还有待研究。iOS7中，对UI布局影响最大的应该将状态条、导航条、tabbar的布局方式变成了悬浮的。这一改变导致self.view的大小变成了全屏幕，而不再受到状态条、导航条、tabbar的占用，而众所周知，iOS7之前slef.view的大小只是导航条之下已经标签栏之上的一部分，当然，前提是导航条不是透明的。这也就导致了iOS7之前的界面在iOS7上会出现偏移，从而出现于状态栏重叠或者被导航栏遮挡，以及界面底端出现空白等情况。不过，既然知道了造成问题的原因，要解决这些问题也就容易多了。要解决布局兼容的问题，有两种解决方案：方案一，通过硬编码布局通过代码布局是灵活性最好，兼容性最好的布局方式。他能够非常灵活并且精确的适配各个操作系统以及屏幕尺寸。在遇到操作系统的特性发生改变时，也可以通过比较小的代价来进行适配。同时也可以对屏幕旋转以及其他需要动态改变UI布局的情况进行精确，方便的控制。当然也能方便绘制复杂的UI。通过硬编码布局来适配iOS7时，1设置好子视图Y坐标的delta值，消除导航条以及状态条布局方式改变带来的影响；2通过代码计算导航条、便签栏、状态栏的高度，精确控制每个视图在任何情况下的大小，从而完美适配各种屏幕以及操作系统界面布局。3使用好automaticallyAdjustsScrollViewInsets特性。这是controller的一个属性，当controller只有一个scrollview的时候，自动调节scrollview的上下缩进，从而消除statusbar,navigationbar等对scrollview造成的遮挡。方案二，通过NIB文件来布局通过NIB布局可以非常直观的看到界面的预览情况，同时也能比较快速的编辑界面。但是，界面的自适应属性，以及iOS7引入的delta和automaticallyAdjustsScrollViewInsets都会对界面的实现表现造成影响，而这些属性带来的UI布局变化是没法再NIB上直接预览到的，程序员必须对此非常熟悉。同时，NIB对于实现较为复杂的的UI以及针对特定的事件重新布局UI的能力是有限的。这些情况还是需要结合硬编码去处理。通过NIB来适配iOS7时，1尽量不要让self.view上的子视图的高度自适应，这会导致在iOS7前后的操作系统上出现很大差异，从而不可控制。所以任何必须要自适应高度的视图（尺寸比较大，需要在不同尺寸屏幕适配的view），最好使用代码控制。2尽量将直接布局在self.view上的子视图设置为全视图布局区域（iOS7前后，这个区域大小是不同的，前面已经说过），这样能够很好的适配各种操作系统以及屏幕尺寸。3设置好子视图的delta以及autoresizing属性4用好automaticallyAdjustsScrollViewInsets属性同一个view设置多个autoresizing属性之后，它们会相互作用或者抵消。从而会造成不可预期的效果。在使用这些属性时，需要考虑这一点。因此单独使用NIB来适配iOS7难道比较大，而且局限性也很大。当需要对直接放在self.view上的那些视图进行高度的自适应时，是无法实现的。",2013/9/27
848,ios使用autoresizing自适应UI布局,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8446,使用autoresizing自适应UI布局，见附件zutoresizing属性相关知识.docx,2013/9/27
849,安全加固建议,刘磊,http://180.168.156.212:2262/wecenter/?/article/8445,附件中是我根据之前的项目经验，整理的一份安全加固建议，请各位同事斧正、补充！安全加固建议.docx,2013/9/26
850,使用Foxit PDF SDK ActiveX实现PDF文件异步加载,杨寅,http://180.168.156.212:2262/wecenter/?/article/8443,FoxitPDFSDKActiveX是福昕软件提供的一款可视化编程组件，可用于PDF文件的显示和打印，从5.0开始增加了异步操作的功能——主要用于打开线性化的PDF文档，在B/S架构中，快速下载第一页数据并进行显示。FoxitPDFSDKActiveX分为标准版和专业版，都提供了异步操作的功能。本文以使用Javascript为例，简单介绍调用该控件的过程。主要分为四个小节：一、下载控件二、注册控件三、编写测试代码四、PDF线性化使用FoxitPDFSDKActiveX实现PDF文件异步加载.doc,2013/9/25
851,一例 ORA-01019错误“无法在用户方分配内存问题”问题,路斌,http://180.168.156.212:2262/wecenter/?/article/8442,"上周某项目反馈,使用公司“文件格式转换工具”碰到ORA-01019错误“无法在用户方分配内存问题”但是使用pl/sqldeveloper可以正常连接从错误描述上看，似乎是内存分配的问题，但是客户端服务器上的内存有2G，而且并没有启动什么程序，显然不是简单的内存不足的问题。可能原因一：客户端用户是本机USER用户，运行访问ORACLE的程序就提示，如果客户端给它本机ADMINISTRATOR用户，所有其他地方都不变，就能正常运行。但与现场确认，是在administrator用户下使用本工具。可能原因二：没有正确设置ORACLE_HOME环境变量造成的在系统环境设置里面对ORACLE_HOME、TNS_ADMIN等进行重新设置，并重新启动。问题解决。",2013/9/25
852,外网数据库恢复一例,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8441,问题描述：公司外网服务器操作系统突然崩溃，不能通过正常方式登录系统，只能接光驱通过PE登录操作系统，好在可以将这个oracle数据库安装目录都拷出来，提供了数据库恢复的可能性。详细请查看附件。维护日志.docx,2013/9/24
853,XArch（2013公司架构）--快速创建项目（一）,杨木江,http://180.168.156.212:2262/wecenter/?/article/8440,"前言XArch架构原本是为了快速开发平台而进行设计，当时为快速开发平台确定了三大原则：1、它面向的是所有公司项目进行设计，而不是针对一个特定的项目；2、它的目标是提供快速开发的能力，并且可灵活方便的进行覆盖和扩展，让开发人员尽可能少的写代码；开发平台自动生成的代码越少越好；3、稳定，能够兼容常用应用服务器；根据确定的原则及公司技术情况，确定了架构的技术框架为：JDK1.6+Struts2.3.15.1（REST）+Spring3.2.2+Hibernate4.2+JPA2.0+SpringSecurity3.1.3+SpringData1.4.0+Jackson2.1.4+Sitemesh2.4.2架构特点1、?没有界面（界面灵活多变），采用数据模型及多名称自动映射功能来实现对所有表现层框架的支持?2、DAO类均为接口类，没有实现类?3、一般模块只需用编写Controller类，甚至可以使用一个公共的Controller类为多个模块服务，便能实现模块的增删改查功能4、?业务复杂模块可以方便的扩展Service层及DAO层5、?集成自定义查询平台（功能不完善）6、?集成系统管理平台3.57、?集成工作流平台3.0?8、集成操作日志记录功能9、?权限授权支持用户、组织及角色三种方式快速开发1、配置数据库链接，所有数据库配置文件均放在WEB-INF/conf/db目录下，其中带.development为开发模式使用的配置文件global.properties为全局配置文件db.properties为系统数据库（业务系统）coflow.properties为工作流数据库authsystem.properties为系统管理平台数据库2、创建实体类要求必须继承至BaseEntity或其子类必须添加注解@Entity必须放在entity包下约定表名：以骆驼命名法的类名转成下画线写法，所有的字母都小写，单词之间用下画线分割；也可通过注解@Table(name=“表名"")指定字段名：以骆驼命名法的类名转成下画线写法，所有的字母都小写，单词之间用下画线分割；也可通过注解@Column(name=“字段名"")指定对不需要进行持久化的属性使用注解@Transient进行标识生成json或xml日期格式化可采用注解@JsonFormat(pattern=“yyyy-MM-dd”)（默认）生成json或xml要忽略的属性可使用注解@JsonIgnore进行标识;动态过滤可以使用注解@JsonFilter(“过滤器标识"")示例packagecom.ces.xarch.core.security.entity;importjavax.persistence.Transient;importcom.ces.xarch.core.entity.StringIDEntity;importcom.fasterxml.jackson.annotation.JsonIgnore;/***SpringSecurity3认证用户实体.*<p>Company:上海中信信息发展股份有限公司</p>*@authorReamy(杨木江yangmujiang@sohu.com"">yangmujiang@sohu.com)*@date2013-04-0811:57:58*@version1.0.2013.0408*/publicclassSysUserextendsStringIDEntity{/**loginName(String):登录名.*/privateStringloginName;/**name(String):用户名.*/privateStringname;/**password(String):密码.*/privateStringpassword;/**enabled(boolean):是否有效.*/privatebooleanenabled;/**roles(String):用户角色.*/privateStringroles;/**orgs(String):用户组织.*/privateStringorgs;/**显示顺序.*/privateStringuserOrder;//getset方法略@JsonIgnore//当请求json或xml数据时，不显示该属性publicStringgetPassword(){returnpassword;}@Transient//不进行持久化publicStringgetUsername(){returnloginName;}}3、创建控制类要求必须以“Controller”做为类名结尾必须放在包（“action,actions,struts,struts2,web”中任意一个）下，可以创建子包必须继承至AbstractController或其子类约定命名空间：以包（“action,actions,struts,struts2,web”）为根Action名：去除Controller后，以骆驼命名法的类名转成中画线写法，所有的字母都小写，单词之间用中画线分割请求后缀没有后缀：返回JSPX、VM、JSPF、JSP、FTL、HTML、HTM文件json：返回json字符串xml：返回xml字符串方法定位及资源定位（资源文件根目录为：WEB-INF/views）注：*指代JSPX、VM、JSPF、JSP、FTL、HTML、HTM之一HTTP方法URI调用Action方法请求参数返回资源说明GET/testindextest/index.*GET/test/2showid=2test/index-show.*属性过滤GET/test/2/editeditid=2test/index-edit.*属性过滤GET/test/neweditNewtest/index-new.*POST/testcreatesuccess.jspPUT/test/2updateid=2success.jspDELETE/test/2destroyid=2success.jspPOST/test!searchsearchtest/index-list.*属性过滤数据模型查询参数POST/test!coflowcoflowtest/index-coflow.*属性过滤工作流参数POST/test!coflowListcoflowListtest/index-coflow-list.*属性过滤工作流参数数据模型查询参数POST/test!coflowCountcoflowCount工作流参数示例packagecom.ces.xarch.examples.actions;importcom.ces.xarch.core.security.entity.SysUser;importcom.ces.xarch.core.web.frame.dhtmlx.action.StringIDDhtmlxController;publicclassUserControllerextendsStringIDDhtmlxController<SysUser>{privatestaticfinallongserialVersionUID=3507660655363375360L;/*(non-Javadoc)*@seecom.ces.xarch.core.web.struts2.AbstractController#initModel()*@authorReamy(杨木江yangmujiang@sohu.com"">yangmujiang@sohu.com)*@date2013-03-0611:06:41*/@OverrideprotectedvoidinitModel(){setModel(newSysUser());}}4、创建页面查询页：<formmethod=""post""action=""${ctx}/user!search"">(可选）每页记录数：<inputtype=""text""name=""P_pagesize""value=""20""/>(可选）当前页号（从1开始计数）：<inputtype=""text""name=""P_pageNumber""value=""1""/>(可选）排序（排序字段,[排序字段,排序方式],[排序字段]）：<inputtype=""text""name=""P_orders""value=""id,asc,name,desc,loginName""/>（根据id升序，name降序，loginName升序）登录名：<inputtype=""text""name=""Q_LIKE_loginName""value=""""/>（根据登录名进行模糊查询，可用的查询方式：EQ,LIKE,GT,LT,GTE,LTE,NULL,BLANK）用户名：<inputtype=""text""name=""Q_LIKE_name""value=""""/>（根据用户名进行模糊查询）<buttontype=""submit"">查询</button></form>表单页：<formid=""inputForm""action=""${ctx}/user""method=""post""><inputtype=""hidden""name=""roles""value=""admin""/><inputtype=""hidden""name=""salt""value=""admin""/><fieldset><legend><small>添加用户</small></legend><divclass=""control-group""><labelclass=""control-label"">登录名:</label><divclass=""controls""><inputtype=""text""name=""loginName""value=""${loginName}""class=""input-large""/></div></div><divclass=""control-group""><labelclass=""control-label"">用户名:</label><divclass=""controls""><inputtype=""text""id=""name""name=""name""value=""${name}""class=""input-largerequired""/></div></div><divclass=""control-group""><labelfor=""plainPassword""class=""control-label"">密码:</label><divclass=""controls""><inputtype=""password""id=""password""name=""password""class=""input-large""placeholder=""...Leaveitblankifnochange""/></div></div><divclass=""control-group""><labelfor=""confirmPassword""class=""control-label"">确认密码:</label><divclass=""controls""><inputtype=""password""id=""confirmPassword""name=""confirmPassword""class=""input-large""equalTo=""#plainPassword""/></div></div><divclass=""control-group""><labelclass=""control-label"">注册日期:</label><divclass=""controls""><inputtype=""text""id=""registerDate""name=""registerDate""class=""input-large""/></div></div><divclass=""form-actions""><inputid=""submit_btn""class=""btnbtn-primary""type=""submit""value=""提交""/>&nbsp;<inputid=""cancel_btn""class=""btn""type=""button""value=""返回""onclick=""history.back()""/></div></fieldset></form>",2013/9/24
854,OFFICE的首页提取缩略图,方俊新,http://180.168.156.212:2262/wecenter/?/article/8439,最近在解决office提取首页缩略图问题，直接将office提取缩略图是比较困难的，在这里本人采用的是将office转成pdf，再在pdf中提取缩略图的做法。将office转成pdf可以参考《OFFCIE文档（word、ppt、excel）转换成SWF》中的openoffice转成pdf的做法，在这里不再复述；剩下的是将pdf提取缩略图，其实提取pdf缩略图的开源项目比较多，下面将他们对比如下：对比这几款开源项目PDFRenderer、pdfbox、jpedal的做法：1.PDFRenderer：确实效率最高，但是缺少字体支持对大多数中文pdf处理不了（很奇怪为什么项目组还没做默认字体支持）2.pdfbox：字体基本都可以转换，但容易内存溢出（我搞了几十M文件就不行了）3.jpedal：效率不错。不过我这里好几个中文pdf文件就是生成缩略图不对，我还向项目组提bug了没有办法，在目前我遇到字体解决不了情况，我寻找到了ICEPDF，这个项目也有商业和开源的。我用了开源的ICEPDF-4.2.2（最新有4.3了），它其实用了jpedal的字体支持库，确能支持我手上的中文pdf，而且效率不错（测试没遇到内存溢出）。具体demo代码可以参见附件。word2pdf.zip,2013/9/23
855,OFFCIE文档（word、ppt、excel）转换成SWF,方俊新,http://180.168.156.212:2262/wecenter/?/article/8444,"先用openOffice把ppt、word、excel、txt转换成pdf，然后用swftools转换成swf，然后在线播放。具体说明如下：1、安装openOffice软件2、下载jodconverter,这边用的是2.2，.然后将把里面的jar包放到项目的lib中3、以cmd方式启动openofficeserverJava代码cdopeonofiice的安装路径/programJava代码cdopeonofiice的安装路径/programJava代码soffice-headless-accept=""socket,host=127.0.0.1,port=8100;urp;""-nofirststartwizardJava代码soffice-headless-accept=""socket,host=127.0.0.1,port=8100;urp;""-nofirststartwizard4、看看8100被监听没Java代码netstat-an5、相关用例代码如附件。word2pdf.zip",2013/9/23
856,建议增加个UI方面的区域，集中收集提交些相关素材，方便需要的时候直接搬运,王链玮,http://180.168.156.212:2262/wecenter/?/article/8438,:shock:,2013/9/18
857,建议针对delphi程序员开一个专门的板块，便于集中交流,王链玮,http://180.168.156.212:2262/wecenter/?/article/8437,在茫茫J海中找到几个delphi的帖子实在考验眼神，请组织考虑下,2013/9/18
858,DELPHI OCX控件调用经常出现DAX ERROR这个鸟问题的解决方法参考,王链玮,http://180.168.156.212:2262/wecenter/?/article/8436, DAX错误办法-redsunchina-ChinaUnix博客.bmp,2013/9/18
859,hibernate update和saveOrUpdate,游明磊,http://180.168.156.212:2262/wecenter/?/article/8435,"在Hibernate中，最核心的概念就是对PO的状态管理。一个PO有三种状态：1、未被持久化的VO此时就是一个内存对象VO，由JVM管理生命周期2、已被持久化的PO，并且在Session生命周期内此时映射数据库数据，由数据库管理生命周期3、曾被持久化过，但现在和Session已经detached了，以VO的身份在运行这种和Session已经detached的PO还能够进入另一个Session，继续进行PO状态管理，此时它就成为PO的第二种状态了。这种PO实际上是跨了Session进行了状态维护的。Hibernate强的地方就在于，一个PO脱离Session之后，还能保持状态，再进入一个新的Session之后，就恢复状态管理的能力，但此时状态管理需要使用session.update或者session.saveOrUpdate，这就是HibernateReference中提到的“requiresaslightlydifferentprogrammingmodel”现在正式进入本话题：简单的来说，update和saveOrUpdate是用来对跨Session的PO进行状态管理的。假设你的PO不需要跨Session的话，那么就不需要用到，例如你打开一个Session，对PO进行操作，然后关闭，之后这个PO你也不会再用到了，那么就不需要用update。因此，我们来看看上例：Java代码1.Foofoo=sess.load(Foo.class,id);;2.foo.setXXX(xxx);;3.sess.flush();;4.sess.commit();;PO对象foo的操作都在一个Session生命周期内完成，因此不需要显式的进行sess.update(foo)这样的操作。Hibernate会自动监测到foo对象已经被修改过，因此就向数据库发送一个update的sql。当然如果你非要加上sess.update(foo)也不会错，只不过这样做没有任何必要。而跨Session的意思就是说这个PO对象在Session关闭之后，你还把它当做一个VO来用，后来你在Session外面又修改了它的属性，然后你又想打开一个Session，把VO的属性修改保存到数据库里面，那么你就需要用update了。Java代码1.//inthefirstsession2.Catcat=(Cat)firstSession.load(Cat.class,catId);;3.CatpotentialMate=newCat();;4.firstSession.save(potentialMate);;5.6.//inahighertieroftheapplication7.cat.setMate(potentialMate);;8.9.//later,inanewsession10.secondSession.update(cat);;//updatecat11.secondSession.update(mate);;//updatematecat和mate对象是在第一个session中取得的，在第一个session关闭之后，他们就成了PO的第三种状态，和Session已经detached的PO，此时他们的状态信息仍然被保留下来了。当他们进入第二个session之后，立刻就可以进行状态的更新。但是由于对cat的修改操作：cat.setMate(potentialMate);是在Session外面进行的，Hibernate不可能知道cat对象已经被改过了，第二个Session并不知道这种修改，因此一定要显式的调用secondSession.update(cat);通知Hibernate，cat对象已经修改了，你必须发送update的sql了。所以update的作用就在于此，它只会被用于当一个PO对象跨Session进行状态同步的时候才需要写。而一个PO对象当它不需要跨Session进行状态管理的时候，是不需要写update的。再谈谈saveOrUpdate的用场：saveOrUpdate和update的区别就在于在跨Session的PO状态管理中，Hibernate对PO采取何种策略。例如当你写一个DAOImpl的时候，让cat对象增加一个mate，如下定义：Java代码1.publicvoidaddMate(Catcat,Matemate);{2.Sessionsession=...;3.Transactontx=...;4.session.update(cat);;5.cat.addMate(mate);;6.tx.commit();;7.session.close();;8.};显然你是需要把Hibernate的操作封装在DAO里面的，让业务层的程序员和Web层的程序员不需要了解Hibernate，直接对DAO进行调用。此时问题就来了：上面的代码运行正确有一个必要的前提，那就是方法调用参数cat对象必须是一个已经被持久化过的PO，也就是来说，它应该首先从数据库查询出来，然后才能这样用。但是业务层的程序员显然不知道这种内部的玄妙，如果他的业务是现在增加一个cat，然后再增加它的mate，他显然会这样调用，new一个cat对象出来，然后就addMate：Java代码1.Catcat=newCat();;2.cat.setXXX();;3.daoimpl.addMate(cat,mate);;但是请注意看，这个cat对象只是一个VO，它没有被持久化过，它还不是PO，它没有资格调用addMate方法，因此调用addMate方法不会真正往数据库里面发送update的sql，这个cat对象必须先被save到数据库，在真正成为一个PO之后，才具备addMate的资格。你必须这样来操作：Java代码1.Catcat=newCat();;2.cat.setXXX();;3.daoimpl.addCat(cat);;4.daoimpl.addMate(cat,mate);;先持久化cat，然后才能对cat进行其他的持久化操作。因此要求业务层的程序员必须清楚cat对象处于何种状态，到底是第一种，还是第三种。如果是第一种，就要先save，再addMate；如果是第三种，就直接addMate。但是最致命的是，如果整个软件分层很多，业务层的程序员他拿到这个cat对象也可能是上层Web应用层传递过来的cat，他自己也不知道这个cat究竟是VO，没有被持久化过，还是已经被持久化过，那么他根本就没有办法写程序了。所以这样的DAOImpl显然是有问题的，它会对业务层的程序员造成很多编程上的陷阱，业务层的程序员必须深刻的了解他调用的每个DAO对PO对象进行了何种状态管理，必须深刻的了解他的PO对象在任何时候处于什么确切的状态，才能保证编程的正确性，显然这是做不到的，但是有了saveOrUpdate，这些问题就迎刃而解了。现在你需要修改addMate方法：Java代码1.publicvoidaddMate(Catcat,Matemate);{2.Sessionsession=...;3.Transactontx=...;4.session.saveOrUpdate(cat);;5.cat.addMate(mate);;6.tx.commit();;7.session.close();;8.};如上，如果业务层的程序员传进来的是一个已经持久化过的PO对象，那么Hibernate会更新cat对象(假设业务层的程序员在Session外面修改过cat的属性)，如果传进来的是一个新new出来的对象，那么向数据库save这个PO对象。BTW:Hibernate此时究竟采取更新cat对象，还是savecat对象，取决于unsave-value的设定。这样，业务层的程序员就不必再操心PO的状态问题了，对于他们来说，不管cat是new出来的对象，只是一个VO也好；还是从数据库查询出来的的PO对象也好，全部都是直接addMate就OK了：Java代码1.daoimple.addMate(cat,mate);;这便是saveOrUpdate的作用。",2013/9/16
860,国家档案局最新发布的文件：档办发[2013]5号《档案信息系统安全等级保护定级工作指南》,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8434,相关文件已经放在公司知识库中，请相关人员认真研读。,2013/9/16
861,Java控制tomcat重新加载项目,王健敏,http://180.168.156.212:2262/wecenter/?/article/8433,"为了系统配置平台把构件发布到另一个项目中进行预览，发布后需要重新启动目标工程的需要。特做此功能来解决问题。该功能模拟浏览器登陆tomcat控制台，抓取到目标项目的当前状态，并start或reload该项目。该功能可被一些需要定时重启tomcat的项目复用。注：与往常的网页登录不同，登录tomcat时登录界面使用的是浏览器自带的登陆框，需要在请求信息的头部增加Authorization:并通过使用base64编码“账号:密码”的格式获得其Authorization的值，并连同其他请求信息一同发送到服务端。目前只在apache-tomcat-7.0.40版本上进行测试并通过，若要支持其他版本的tomcat，只要修改少许代码即可。程序代码：输入参数：目标tomcat的网址（不包括 ""+sysName+"""")!=-1){if(rett[j+6].indexOf(""Start"")!=-1){returntrue;}returnfalse;}}returnfalse;}}returnfalse;}publicstaticvoidmain(String[]args){System.out.println(restartProject(""localhost"",""config"",""wjm"",""9999""));}}",2013/9/16
862,一种网页媒体播放方式,周敏,http://180.168.156.212:2262/wecenter/?/article/8432,问题：后台搭建一个流媒体服务后，前台需要一个可以提供必要的API并能与其交互的媒体播放器。解决：使用JWPlayer的flash网页播放器该播放器满足以下需求：1.支持所有主流浏览器2.能与播放器交互，播放器必须提供必要的API3.可定制外观，方便后期扩展4.支持flv、mp3、mp4格式，支持播放列表5.详尽的帮助文档说明，方便开发者使用技术经验共享201308_周敏.doc,2013/9/10
863,使用freemarker生成word文档,宋国梁,http://180.168.156.212:2262/wecenter/?/article/8431,"1.新建word文档,设置好要生成文档的格式,然后将word文档另存为xml文件2.打开xml文件,搜索，如：，然后再搜索，后面增加#list>然后搜索infoTitle将infoTitle替换成${infoTitle}，其他变量也换掉，改完后把文件的后缀名直接改为ftl，这样模板就创建好了3.编写程序代码研发中心经验共享_宋国梁[201208].doc",2013/9/10
864,修改Lucene分词器IK Analyzer，增加同义词词典功能,杨寅,http://180.168.156.212:2262/wecenter/?/article/8418,"主要分六步对程序进行修改：1、修改配置文件IKAnalyzer.cfg.xml，增加同义词词库配置。2、编写同义词引擎类Gdda4SynonymEngine，实现自已定义的接口SynonymEngine，主要实现加载和读取同义词配置的方法，支持从词库文件和数据库中读取同义词。3、修改org.wltea.analyzer.cfg.Configuration类，增加读取配置文件中同义词词典配置的代码。4、修改org.wltea.analyzer.dic.Dictionary类，从同义词词库文件中加载同义词。5、增加同义词过滤器类SynonymFilter，实现接口org.apache.lucene.analysis.TokenFilter。6、修改org.wltea.analyzer.lucene.IKAnalyzer类中的方法publicTokenStreamtokenStream(StringfieldName,Readerreader)，增加同义词过滤器。研发中心经验共享_杨寅[201308].doc",2013/9/6
865,这年头连数字证书都不靠谱。。。,王链玮,http://180.168.156.212:2262/wecenter/?/article/8415,"超级网银病毒披上数字签名的外衣被查出央视《每周质量报告》报道了一种“超级网银病毒”入侵第三方支付平台,造成不少网购用户受损的案例，引起网民极大反响。360安全中心宣布首次发现带有真实数字签名的“超级网银病毒”，为病毒提供签名的是一家名为“北京威克特瑞广告有限公司”的企业。据悉，360安全中心最早是在4月18日截获带有“北京威克特瑞广告有限公司”数字签名的“超级网银病毒”。经分析，该病毒可以劫持受害用户上网购物时的网银支付链接，将购物资金转移到黑客的账户中，使用户遭受财产损失；360安全中心还发现，“北京威克特瑞广告有限公司”曾多次为木马病毒等恶意软件提供数字签名，很可能与病毒制作者存在勾结关系。数字签名相当于一款软件的“身份证”。如果一款软件带有数字签名，则能通过为其颁发数字签名证书的机构找到软件制作者的身份信息，包括公司联系人、联系电话，以及营业执照等。而杀毒行业为避免误杀正当软件，普遍不会查杀带有真实数字签名的文件。发现“超级网银病毒”后，360安全中心一方面检测了所有“北京威克特瑞广告有限公司”出品的软件，全力查杀其中的恶意程序；另一方面，360也将该信息举报给相关部门，以便尽快找到病毒的幕后制作者。截至发稿前，数字证书颁发机构WoSign已将“北京威克特瑞广告有限公司”的数字签名进入吊销程序。",2013/9/6
866,Jqgrid列表数据不显示 前台后台都不报错,王桂子,http://180.168.156.212:2262/wecenter/?/article/8417,后台查询的List，拼成json格式数据，传到前台，后台数据实际是有的，可是前台页面列表显示为空，而且不报错，。后来把拼成的json数据在控制台输出，仔细比对格式，发现是数据中含有特殊字符英文的双引号，用&qout；替换，还有一种最常见的js错，或者数据显示不正确的，可能是最后一条多了个逗号。,2013/9/6
867,Activex控件在IE中安装提示不信任的解决方法,王链玮,http://180.168.156.212:2262/wecenter/?/article/8416,1.分别用数字签名每个CAB文件中的.dll和.ocx等文件2.把这些文件打包成.cab文件后再数字签名.cab文件，以确保所有IE加载项都被IE验证和信任。因为由于系统权限安全等原因导致无法被信任，数字签名是最好的解决方法。,2013/9/6
868,url传参编码后依旧报js错,王桂子,http://180.168.156.212:2262/wecenter/?/article/8414,"javascript中对URL字符串进行编码的方法有三种：escape()，encodeURI()，以及encodeURIComponent()。escape：不会对@*/+这些字符编码。encodeURI：不会对!@#$&*()=:/;?+'编码。encodeURIComponent：不会对!*()'编码。遇到的问题：url中含有这样的“andbgqx=’长期’”，包含了空格、英文单引号、中文解决办法：使用上面三种方法编码后传参，页面依旧报js错，最后不得已使用了最麻烦的办法在jsp页面写如下代码：//替换特殊字符，再编码vara="""".replace(//g,""@##@"").replace(/\'/g,""@###@"").replace(/%/g,""@####@"");a=encodeURIComponent(encodeURIComponent(a));在java代码获取参数时，解码之后，再把原先的替换给换回来：where=java.net.URLDecoder.decode(where1,""utf-8"");where1=where1.replace(""@##@"","""");where1=where1.replace(""@###@"",""'"");where=where.replace(""@####@"",""%"");",2013/9/6
869,itext 实现pdf合并、加水印、打印等功能,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8410,"packageces.frame.util.pdf;importjava.io.FileOutputStream;importjava.util.ArrayList;importjava.util.List;importcom.lowagie.text.Document;importcom.lowagie.text.Image;importcom.lowagie.text.pdf.PdfContentByte;importcom.lowagie.text.pdf.PdfImportedPage;importcom.lowagie.text.pdf.PdfReader;importcom.lowagie.text.pdf.PdfStamper;importcom.lowagie.text.pdf.PdfWriter;importcom.lowagie.tools.Executable;publicclassJoinPdf{/***打印pdf(可以先生成一个pdf文件，再打印，分布操作)*@parampath*@throwsException*/publicstaticvoidprintPdf(Stringpath)throwsException{Executable.openDocument(path);//打开pdf文件Executable.printDocument(path);//打印预览}/***根据指定一个pdf文件，获取其中几页，合并成新的pdf文件*例如：获取a.pdf中的第1、2页，第5,6页，第3页的数据合并一个新的pdf*@throwsException*/publicstaticvoidjoinSimplePdf(StringnewPdfPath,StringoldPdfPath,StringprintRange,StringwaterMarkPath,StringimagePath)throwsException{Documentdocument=newDocument();PdfWriterwriter=PdfWriter.getInstance(document,newFileOutputStream(newPdfPath));//创建一个输出的pdf文件document.open();PdfReaderreader=newPdfReader(oldPdfPath);//创建reader对象，读取pdf文件//printRange以"",""分割如1-3,5,7if(""0"".equals(printRange)){//全部intn=reader.getNumberOfPages();//获取此pdf的所有页数addPage(document,reader,writer,1,n);}else{String[]temp=printRange.split("","");for(inti=0;iif(temp[i].contains(""-"")){Stringbegin=temp[i].substring(0,temp[i].indexOf(""-""));Stringend=temp[i].substring(temp[i].indexOf(""-"")+1);addPage(document,reader,writer,Integer.valueOf(begin),Integer.valueOf(end));}else{addPage(document,reader,writer,Integer.valueOf(temp[i]),Integer.valueOf(temp[i]));}}}document.close();PdfReadernewReader=newPdfReader(newPdfPath);intpageSize=newReader.getNumberOfPages();//添加水印addPdfMark(newPdfPath,waterMarkPath,imagePath,pageSize);}publicstaticintgetPdfPage(StringpdfPath)throwsException{PdfReaderreader=newPdfReader(pdfPath);intpages=reader.getNumberOfPages();returnpages;}/***对指定的pdf添加新页*@paramdocument要生成的新pdfDocument*@paramreader源pdf文件*@paramwriter要生成的新pdf输出流*@paramstartNo起始页pdf起始页索引从1开始不是0*@paramendNo结束页*@throwsException*/publicstaticvoidaddPage(Documentdocument,PdfReaderreader,PdfWriterwriter,intstartNo,intendNo)throwsException{for(inti=startNo;i<=endNo;i++){PdfImportedPagepage=writer.getImportedPage(reader,i);//读取指定页对象Imageimage=Image.getInstance(page);//获取pdf此页的图片对象image.setAbsolutePosition(0,0);document.add(image);document.newPage();}}/***把多个pdf文件，合并成一个pdf文件*@throwsException*/publicstaticvoidjoinAllPdf()throwsException{Documentdocument=newDocument();PdfWriterwriter=PdfWriter.getInstance(document,newFileOutputStream(""D:\\new.pdf""));document.open();PdfReaderreader1=newPdfReader(""D:\\a.pdf"");PdfReaderreader2=newPdfReader(""D:\\b.pdf"");PdfReaderreader3=newPdfReader(""D:\\c.pdf"");Listlist=newArrayList();list.add(reader1);list.add(reader2);list.add(reader3);inttotal=0;for(PdfReaderreader:list){intn=reader.getNumberOfPages();//获取此pdf的所有页数total+=n;addPage(document,reader,writer,1,n);}document.close();addPdfMark(""D:\\new.pdf"",""D:\\new2.pdf"",""D:\\pic.jpg"",total);}/***给pdf文件添加水印*@paramInPdfFile要加水印的原pdf文件路径*@paramoutPdfFile加了水印后要输出的路径*@parammarkImagePath水印图片路径*@parampageSize原pdf文件的总页数*@throwsException*/publicstaticvoidaddPdfMark(StringInPdfFile,StringoutPdfFile,StringmarkImagePath,intpageSize)throwsException{PdfReaderreader=newPdfReader(InPdfFile);//创建水印对象PdfStamperstamp=newPdfStamper(reader,newFileOutputStream(outPdfFile));Imageimg=Image.getInstance(markImagePath);//插入水印img.setAbsolutePosition(0,0);//绝对位置：通过将图片的宽度和高度作为X和Y坐标将设置第一个图片，坐标的2倍设置第二个图片for(inti=1;i<=pageSize;i++){//pdf布局：指定图象或者文本放置在某页的指定位置PdfContentByteunder=stamp.getUnderContent(i);under.addImage(img);}stamp.close();//关闭/*Filetempfile=newFile(InPdfFile);if(tempfile.exists()){//tempfile.delete();}*/}}",2013/9/6
870,servlet3.0 -- HttpServletRequest 对文件上传的支持,孟帅,http://180.168.156.212:2262/wecenter/?/article/8409,"HttpServletRequest对文件上传的支持此前，对于处理上传文件的操作一直是让开发者头疼的问题，因为Servlet本身没有对此提供直接的支持，需要使用第三方框架来实现，而且使用起来也不够简单。如今这都成为了历史，Servlet3.0已经提供了这个功能，而且使用也非常简单。为此，HttpServletRequest提供了两个方法用于从请求中解析出上传的文件：PartgetPart(Stringname)CollectiongetParts()前者用于获取请求中给定name的文件，后者用于获取所有的文件。每一个文件用一个javax.servlet.http.Part对象来表示。该接口提供了处理文件的简易方法，比如write()、delete()等。至此，结合HttpServletRequest和Part来保存上传的文件变得非常简单，如下所示：Partphoto=request.getPart(""photo"");photo.write(""/tmp/photo.jpg"");//可以将两行代码简化为request.getPart(""photo"").write(""/tmp/photo.jpg"")一行。另外，开发者可以配合注解@MultipartConfig注解来对上传操作进行一些自定义的配置，比如限制上传文件的大小，以及保存文件的路径等。其用法非常简单，故不在此赘述了。[color=red]需要注意的是，如果请求的MIME类型不是multipart/form-data，则不能使用上面的两个方法，否则将抛异常。[/color]",2013/9/6
871,servlet3.0 -- 异步处理支持,孟帅,http://180.168.156.212:2262/wecenter/?/article/8413,"[color=darkred]异步处理支持：[/color]:)有了该特性，Servlet线程不再需要一直阻塞，直到业务处理完毕才能再输出响应，最后才结束该Servlet线程。在接收到请求之后，Servlet线程可以将耗时的操作委派给另一个线程来完成，自己在不生成响应的情况下返回至容器。针对业务处理较耗时的情况，这将大大减少服务器资源的占用，并且提高并发处理速度。[color=blue]异步处理特性可以应用于Servlet和过滤器两种组件，由于异步处理的工作模式和普通工作模式在实现上有着本质的区别，因此默认情况下，Servlet和过滤器并没有开启异步处理特性，如果希望使用该特性，则必须按照如下的方式启用：[/color]1.对于使用传统的部署描述文件(web.xml)配置Servlet和过滤器的情况，Servlet3.0为和标签增加了子标签，该标签的默认取值为false，要启用异步处理支持，则将其设为true即可。以Servlet为例，其配置方式如下所示：DemoServletfootmark.servlet.DemoServlettrue2.对于使用Servlet3.0提供的@WebServlet和@WebFilter进行Servlet或过滤器配置的情况，这两个注解都提供了asyncSupported属性，默认该属性的取值为false，要启用异步处理支持，只需将该属性设置为true即可。以@WebFilter为例，其配置方式如下所示：@WebFilter(urlPatterns=""/demo"",asyncSupported=true)publicclassDemoFilterimplementsFilter{...}[color=darkblue]一个简单的模拟异步处理的Servlet示例如下：[/color]@WebServlet(urlPatterns=""/demo"",asyncSupported=true)publicclassAsyncDemoServletextendsHttpServlet{@OverridepublicvoiddoGet(HttpServletRequestreq,HttpServletResponseresp)throwsIOException,ServletException{resp.setContentType(""text/html;charset=UTF-8"");PrintWriterout=resp.getWriter();out.println(""进入Servlet的时间：""+newDate()+""."");out.flush();//在子线程中执行业务调用，并由其负责输出响应，主线程退出AsyncContextctx=req.startAsync();newThread(newExecutor(ctx)).start();out.println(""结束Servlet的时间：""+newDate()+""."");out.flush();}}publicclassExecutorimplementsRunnable{privateAsyncContextctx=null;publicExecutor(AsyncContextctx){this.ctx=ctx;}publicvoidrun(){try{//等待十秒钟，以模拟业务方法的执行Thread.sleep(10000);PrintWriterout=ctx.getResponse().getWriter();out.println(""业务处理完毕的时间：""+newDate()+""."");out.flush();ctx.complete();}catch(Exceptione){e.printStackTrace();}}}[color=blue]除此之外，Servlet3.0还为异步处理提供了一个监听器，使用AsyncListener接口表示。它可以监控如下四种事件：[/color]1.异步线程开始时，调用AsyncListener的onStartAsync(AsyncEventevent)方法；2.异步线程出错时，调用AsyncListener的onError(AsyncEventevent)方法；3.异步线程执行超时，则调用AsyncListener的onTimeout(AsyncEventevent)方法；4.异步执行完毕时，调用AsyncListener的onComplete(AsyncEventevent)方法；要注册一个AsyncListener，只需将准备好的AsyncListener对象传递给AsyncContext对象的addListener()方法即可，如下所示：AsyncContextctx=req.startAsync();ctx.addListener(newAsyncListener(){publicvoidonComplete(AsyncEventasyncEvent)throwsIOException{//做一些清理工作或者其他}...});[color=red]结束语:新特性的确了不得,其中以前很难实现的服务器推技术在这里得到了很好的体现,如webwotalk就采用了这种技术,想了解服务器推的可联系webtotalk的作者--丁凯哦[/color]",2013/9/6
872,Hibernate之createSQLQuery浅谈,甘名辉,http://180.168.156.212:2262/wecenter/?/article/8412,"有关于hibernate的createSQLQuery的用法。1.背景:系统管理平台的DAO层,大部分是继承于HibernateDaoSupport或是JdbcDaoSupport,但在做CRUD操作的时候，对于已经定义好的接口很难在扩展，特别是在涉及到多表操作、查询中间表的时候，pojo没有中间表映射时，就显得特别的困难，因此细看了createSQLQuery。2.详解:1.addEntity()方法a.session.createSQLQuery(""select*fromt_user"").addEntity(User.class).list();b.session.createSQLQuery(""select{user.*}fromt_useruser"").addEntity(""user"",User.class).list();c.session.createSQLQuery(""selectmax(user.id)asmax_idfromt_useruser"").addScalar(""max_id"",Hibernate.DOUBLE).uniqueResult();d.假设存在多表查询,返回的数据也来源于多张表的字段:Stringsql=""selectuser.nameU_NAME,role.nameR_NAMEfromt_user,t_user_role,t_role..."";I.session.createSQLQuery(sql).setResultTransformer(Transformers.aliasToBean(ReturnUserRole.class)).list();此中情况在oralce中会报错.错误信息如下:org.hibernate.PropertyNotFoundException:CouldnotfindsetterforIDonclasscom.ReturnUserRoleII.session.createSQLQuery(sql).addScalar(""U_NAME"").addScalar(""R_NAME"").list();//返回object[]2.setResultTransformer()方法a.session.createSQLQuery(""selectid,namefromt_user"").setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).list();返回一个map,KEY:为DB中名称一致（大小写一致）遍历list时就可以Mapmap=(Map)list.get[i];map.get(""id"");map.get(""name"");来取值。按你的SQL语句select后的字段名来作为map的Key，但这个key必须与数据库中的字段名一模一样。b.session.createSQLQuery(""selectmax(id)MAX_IDfromt_user"").addScalar(""MAX_ID"",Hibernate.Integer).setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);取值的时候:map.get(""SUMID"")就可以了.3.总结:1.复杂SQL用createSQLQuery方法查询没问题，如果查询多个字段，遍历用object[]造型，下标从0开始输出值，不需要映射文件；如果愿意可以写一个映射bean，方便取用。2.如果查询SQL中是只有一个字段，那就不能用object[]数组接收，只能用object类接收，直接输出object.toString()，即是这个字段的值。3.可以用addScalar（Stringarg,Typetype）方法定义要返回的字段类型，如session.createSQLQuery(sql).addScalar(""NAME"",Hibernate.STRING);",2013/9/6
873,Chrome29版本Ext Ajax同步请求的问题/websphere6.1下使用URL.toURI方法的问题,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8411,"问题：websphere6.1下使用URL.toURI方法取得文件URI时，出现错误。解决方法：改成使用URL.getFile方法取得文件路径。FilefileLog=newFile(urlLog.toURI());改为：FilefileLog=newFile(URLDecoder.decode(urlLog.getFile(),""UTF-8""));问题：Chrome29版本ExtAjax同步请求报错：修改ext-basex.js中相关代码。在ajax请求为同步的情况下，不能设置连接的timeout属性，如果对其进行修改会报错，导致连接失败。现在加上了过滤了同步的那种情况。",2013/9/6
874,支持各种浏览关闭拦截解决办法,丁凯,http://180.168.156.212:2262/wecenter/?/article/8405,在很多应用中都需要对浏览器关闭时做一系列处理，那如何确保目前各主流浏览器关闭时我们都能够做到拦截呢？现有如下解决办案给大家分享一下：脚本见附件。。。browse_close.html,2013/9/6
875,关于OA平台中Excel导入的两个问题,夏枫林,http://180.168.156.212:2262/wecenter/?/article/8404,"一、手动启动流程的一般方法：1、业务背景业务需求是将导入的报销明细数据，生成报销单并启动流程。一般情况下，我们是先创建主表单，再启动流程。2、功能代码如下：........................//此处省略许多业务代码varwebUser=getWebUser();//此处webUser是有值的，但是是UserVO类型的，不符合参数的类型doc.findItem(""表单编号"").setValue(num);doc.findItem(""摘要"").setValue(str);doc.findItem(""总金额"").setValue(totalMoney+"""");doc.findItem(""合计人民币"").setValue(bigType);[color=red]docProcess.doCreate(doc);//生成报销单[/color]//更新子表的prarent字段for(varj=0;jsql=""updatetlk_报销申请明细单setparent='""+doc.getId()+""'whereid='""+idArr[j]+""'"";updateByDSName(""5.62"",sql);}//启动流程varparams=getParamsTable();params.setParameter(""_flowid"",""11e1-304c-446bf8f5-a207-95a38a17f2fe"");[color=red]docProcess.doStartFlow(doc,params,webUser);//在此处的webUser为null[/color]但是在实际应用中，上面代码行不通，webUser总是获得为null，后面找了一下源码，发现还有个方法可以实现，改动之后的代码如下：..............................//此处省略许多业务代码doc.findItem(""表单编号"").setValue(num);doc.findItem(""摘要"").setValue(str);doc.findItem(""总金额"").setValue(totalMoney+"""");doc.findItem(""合计人民币"").setValue(bigType);[color=red]doc.setFlowid(""11e1-304c-446bf8f5-a207-95a38a17f2fe"");//设置流程id[/color]//启动流程varparams=getParamsTable();params.setParameter(""_flowid"",""11e1-304c-446bf8f5-a207-95a38a17f2fe"");[color=red]docProcess.doStartFlowOrUpdate(doc,params,webUser);//生成报销单并启动流程[/color]//更新子表的prarent字段for(varj=0;jsql=""updatetlk_报销申请明细单setparent='""+doc.getId()+""'whereid='""+idArr[j]+""'"";updateByDSName(""5.62"",sql);}二、java使用poi解析处理excel的时候，如何防止数字变成科学计数法的形式1、业务背景当使用POI处理excel的时候，遇到了比较长的数字，虽然excel里面设置该单元格是文本类型的，但是POI的cell的类型就会变成数字类型。而且无论数字是否小数，使用cell.getNumbericCellValue()去获取值的时候，会得到一个double，而且当长度大一点的时候会变成科学计数法形式。那么获取这个单元格的原始的数据，就其实是一个double怎么转换成整数的问题了。使用DecimalFormat对这个double进行了格式话，随后使用format方法获得的String就是你想要的值了。2、Java功能代码如下：doubled=cell.getNumericCellValue();DecimalFormatdf=newDecimalFormat(""0"");returndf.format(d);",2013/9/6
876,VBA简单应用,齐超,http://180.168.156.212:2262/wecenter/?/article/8408,"VBA简介VisualBasicforApplications（VBA）是VisualBasic的一种宏语言，主要能用来扩展Windows的应用程式功能，特别是MicrosoftOffice软件。也可说是一种应用程式视觉化的BasicScript。简单来说就是建立在已有程序（Office）平台上上的一种自动化开发语言。VBA语言特点其语言以一种面向对象的、以利用其事件驱动的编程机制，通过GUI工具，使用Windows应用程序接口（API）函数，采用动态链接库（DLL）、动态数据交换（DDE）、对象的链接与嵌入（OLE）以及开放式数据库访问（ODBC）等技术来完成应用程序系统的开发。VBA运行的两种呈现形式1.运行在Windows95或NT桌面上的应用程序。2.宏:VBA由使用VBA的Excel、Word、PowerPoint等称为宿主（Host）的Office应用程序(Application)来调用。VBA示例1.ExcelGUI程序示例2.宏调用3.代码示例：SubshowGUI()UserForm.ShowEndSubSubshowHello()MsgBox""这是一个宏:修改父窗体标题""UserForm.Caption=UserForm.Caption&""_""&""追加字符xx""EndSub4.效果详见：副本新建MicrosoftOfficeExcel工作表.xlsmVBA技术共享_齐超.docx副本新建MicrosoftOfficeExcel工作表.xlsm",2013/9/6
877,Myeclipse报An internal error has occurred错误,毛璀玲,http://180.168.156.212:2262/wecenter/?/article/8403,Myeclipse启动服务的时候(刷新工程的时候)报Aninternalerrorhasoccurred错误:解决方法：给MyEclipse的快捷方式加个参数再重新启动一次。步骤如下：右键选中快捷方式属性选项，在快捷方式页，目标一项最后加上-clean选项，如“C:\MyEclipse6.5\eclipse.exe“-clean.然后重新启动一下MyEclipse，加-clean的目的是在myeclipse每次启动都清理一下。,2013/9/6
878,oracle lag()和lead()函数、over()函数,余礼华,http://180.168.156.212:2262/wecenter/?/article/8407,"oralce中lag()和lead()函数是偏移量函数，与over()函数联合使用，可以查出同一字段上一个值或下一个值。馆藏系统中连续检测：按QZH,MLH字段分类，检测AJH的连续情况:selectt.temp_formal,t.QZH,t.MLH,t.AJHcurr,lag(t.AJH,1)over(partitionbyt.QZH,t.MLHorderbyt.QZH,t.MLH,AJH)lastfromt_ar_1100_basetwhereregexp_like(trim(AJH),'^([0-9])+$')andt.temp_formal='temp'andt.delete_flag='0'查询结果如附图lead与lag函数语法：lead(列名,n,m):当前记录后面第n行记录的的值，没有则默认值为m；如果不带参数n,m，则查找当前记录后面第一行的记录的值，没有则默认值为null。lag(列名,n,m):当前记录前面第n行记录的的值，没有则默认值为m；如果不带参数n,m，则查找当前记录前面第一行的记录的值，没有则默认值为null。over函数语法：over()说明：partition-clause数据记录集分组order-by-clause数据记录集排序windowing-clause功能非常强大、比较复杂，定义分析函数在操作行的集合。有三种开窗方式:range、row、specifying上例中over(partitionbyt.QZH,t.MLHorderbyt.QZH,t.MLH,AJH)就表示按QZH,MLH字段分组,按QZH,MLH,AJH排序",2013/9/6
879,遍历表单元素－js方法与jQuery方法,余礼华,http://180.168.156.212:2262/wecenter/?/article/8402,"//普通js方式实现遍历表单元素varform=document.forms[0];for(vari=0;ivarelement=form[i];//vartype=element.type;//varname=element.name;//varid=element.id;varisExtend=element.isExtend;if(isExtend&&isExtend=='0'){element.value="""";}}//jQuery方式实现遍历表单元素$(""#inputForm:input"").each(function(index,element){varisExtend=$(element).attr(""isExtend"");if(isExtend&&isExtend=='0'){$(element).val("""");}});",2013/9/6
880,Jquery实现图片的左右滚动,张建涛,http://180.168.156.212:2262/wecenter/?/article/8406,"电子阅览室图片，视频，音频档案中用到$(function(){var$i=6;//每版显示数varnum=index+1var$cur=Math.ceil(num/$i)-1;//初始化显示的版面var$len=$('#thumbs>ul>li').length;//计算列表总长度(个数)var$pagecount=Math.ceil($len/$i);//计算展示版面数量var$showbox=$('#smallpicarea');var$showbox1=$('#thumbs');var$w=$('#smallpicarea').width();//取得展示区外围宽度var$pre=$('#play_prev');var$next=$('#play_next');$showbox1.animate({left:-($cur*630)},600);$cur++;$next.click(function(){//判断展示区是否动画if($cur==$pagecount){//在最后一个版面时,再向后滚动无动作}else{$showbox1.animate({left:'-='+$w},600);//改变left值,切换显示版面$cur++;//版面数累加}});$pre.click(function(){if($cur==1){//在第一个版面时,再向前滚动无动作}else{$showbox1.animate({left:'+='+$w},600);//改变left值,切换显示版面$cur--;//版面累减}});})经验共享2013-08张建涛.doc",2013/9/6
881,移动端推送原理研究,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8401,附件里面是我整理的关于移动端推送的一些知识，感兴趣的童鞋可以下来看看，一起探讨IOS推送预研.docx,2013/9/4
882,IOS设备推送通知服务编程,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8400,"IOS设备推送通知服务编程－译自weimenglee的ProgrammingApplePushNotificationServicesiPhone对于应用程序在后台运行有诸多限制（除非你越狱）。因此，当用户切换到其他程序后，原先的程序无法保持运行状态。对于那些需要保持持续连接状态的应用程序（比如社区网络应用），将不能收到实时的信息。为解决这一限制，苹果推出了APNs（苹果推送通知服务）。APNs允许设备与苹果的推送通知服务器保持常连接状态。当你想发送一个推送通知给某个用户的iPhone上的应用程序时，你可以使用APNs发送一个推送消息给目标设备上已安装的某个应用程序。本文中，你将学到创建使用APNs的iOS应用的详细步骤。创建证书请求使用APNs的第一步是生成一个证书请求，使用该证书请求来申请一个用于开发的SSL证书。1.打开“钥匙串访问”应用程序。2.选择“KeychainAccess->CertificateAssistant->RequestaCertificateFromCertificateAuthority”：3.输入所需的信息，勾选“Savedtodisk”选项，点击Continue：4.使用默认文件名把证书请求进行保存：在弹出窗口中，点击Done。创建AppID每个使用APNs的iOS应用必须有一个唯一的AppID。在本步骤中，你将学到如何创建推送通知中要用到的AppID。1.登录iPhoneDeveloperProgram： /iphone/。点击页面右边的“iPhoneDeveloperProgramPortal”：2.首先看到的是欢迎页面：3.点击左边的“AppID”，然后点击右边的“NewAppID”按钮：4.在Description栏输入“PushAppID”，在“BundleSeedID”栏中选择“GenerateNew”。在“BundleIdentifier”栏，输入“net.learn2develop.MyPushApp”，然后点击“Submit”：5.现在你应该能看到所创建的AppID了：配置App一旦创建了AppID，你还要为推送通知对AppID进行一些配置。1.点击AppID右边的Configure链接，会看到如下选项：勾选“EnableforApplePushNotificationservice”，点击“DevelopmentPushSSLCertificate”右边的“Configure”按钮。2.接下来你会看到“ApplePushNotificationserviceSSLCertificateAssistant”页面。点击Continue：3.点击ChooseFile按钮，选择前面保存的证书请求文件存放地址。点击Generate：4.你的SSL证书会被生成。点击Continue：5.点击DownloadNow按钮，下载SSL证书。点击Done：6.下载的SSL证书文件名为aps.developer.identity.cer。双击，将证书安装到钥匙串中。这个证书会在你的程序中用到，它允许程序接收APNs发送来的推送通知。创建ProvisioningProfile接下来，需要创建provisioningprofile以便允许应用程序安装到真实设备上。1.回到iPhoneDevelopmentProgramPortal，点击Provisioning栏，点击NewProfile按钮：2.ProfileName栏输入MyDevicesProfile，在AppID栏选择PushAppID。在Devices栏，勾选所有你想激活的设备（在iPhoneDeveloperProgramPortal的Devices页中注册的所有设备）。点击Submit。3.provisioningprofile会等待审核。几秒钟后，它会显示在页面上。点击Download按钮下载该provisioningprofile：4.下载下来的provisioningprofile名为MydevicesProfile.mobileprovision。激活设备创建provisionprofile后，你可以将它安装到真实设备中。1.将iPhone或iPod连接到Mac。2.把下载下来的MyDevicesProfile.mobileprovision文件拖到Dock栏的Xcode图标上。3.Xcode的Organizer程序将启动，选择当前连机的设备。可以看到MyDevicesProfile已自动安装到设备上了。创建iPhone应用程序1.打开Xcode，创建View-BasedApplication项目，命名为ApplePushNotification。2.把一个WAV文件（本例是beep.wav）拖到Xcode的Resouces文件夹。3.展开Xcode中的Targets项目，选择ApplePushNotification，按下?+i，在info出口，点击Properties标签栏：在Identifier文本框，输入net.learn2develop.MyPushApp.4.点击Build标签栏，在search输入框中键入CodeSigning。在AnyiPhoneOSDevice选项，选择正确的profile：5.在ApplePushNotificationAppDelegate.m文件中，输入以下代码（加粗部分）：1#import""ApplePushNotificationAppDelegate.h""23#import""ApplePushNotificationViewController.h""4567@implementationApplePushNotificationAppDelegate891011@synthesizewindow;1213@synthesizeviewController;14151617-(void)applicationDidFinishLaunching:(UIApplication*)application{1819[windowaddSubview:viewController.view];2021[windowmakeKeyAndVisible];22232425NSLog(@""Registeringforpushnotifications..."");2627[[UIApplicationsharedApplication]2829registerForRemoteNotificationTypes:3031(UIRemoteNotificationTypeAlert|3233UIRemoteNotificationTypeBadge|3435UIRemoteNotificationTypeSound)];3637}38394041-(void)application:(UIApplication*)appdidRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken{4243NSString*str=[NSString4445stringWithFormat:@""Device];4647NSLog(str);4849}50515253-(void)application:(UIApplication*)appdidFailToRegisterForRemoteNotificationsWithError:(NSError*)err{5455NSString*str=[NSStringstringWithFormat:@""Error:%@"",err];5657NSLog(str);58596061}62636465-(void)application:(UIApplication*)applicationdidReceiveRemoteNotification:(NSDictionary*)userInfo{6667for(idkeyinuserInfo){6869NSLog(@""key:%@,value:%@"",key,[userInfoobjectForKey:key]);7071}7273}7475-(void)dealloc{7677[viewControllerrelease];7879[windowrelease];8081[superdealloc];8283}8485@end6.按下?+R运行程序（在真实设备）。按下shift+?+R显示DebuggerConsole窗口。查看设备输出到控制台的devicetoken。，devicetoken是38c866ddbb323b39ffa734875e157ee5a85e0b7ce90d56e9fe145bcc6c2c594b。记下devicetoken（复制、粘贴到一个文本文件里）7.如果查看iPhone/iPod上的“Settings”程序，你会发现一个Notifications的项：创建PushNotificationProviderPushNotificationProvider是一个应用程序，用于通过APNs发送推送通知给iPhone应用。通过APNs发送推送通知有几个步骤：1.使用前面创建的SSL证书与APNs通讯；2.构造所要发送的消息载体；3.发送载体到APNs；APNs是一个基于流的TCPsocket，你的provider以SSL协议与其通讯。推送通知（包括载体）是以二进制流的方式发送的。和APNs建立连接后，你可以维持该连接并在连接中断之前发送多个通知。技巧：应避免每发送一次推送通知就建立、关闭一次连接。频繁的建立、关闭连接可能会被APNs认为是DOS攻击，从而拒绝发送provider的推送通知发送请求。一个推送通知消息的格式如图24所示：更多细节，请参考ApplePushNotificationServiceProgrammingGuide。载体（payload）是JSON字符串（最长256字节），封装了你发送给iOS应用的信息。这是一个payload的例子：1{23""aps"":{45""alert"":""Yougotanewmessage!"",67""badge"":5,89""sound"":""beep.wav""},1011""acme1"":""bar"",1213""acme2"":421415}为了省去自己编写pushnotificationprovider的麻烦，你可以使用StefanHafeneger写的一个MacOSX应用程序：PushMeBaby，下载地址1.在Xcode中打开PushMeBaby。2.右击Resouces文件夹，选择AddExistingFiles…，选择前面所下载到的aps.developer.identity.cer文件。3.在ApplicationDelegate.m文件中，修改如下代码（加粗部分）：1-(id)init{23self=[superinit];45if(self!=nil){67self.deviceToken=@""38c866ddbb323b39ffa734875e157ee5a85e0b7ce90d56e9fe145bcc6c2c594b"";89self.payload=@""{\""aps\"":{\""alert\"":\""Yougotanewmessage!\"",\""badge\"":5,\""sound\"":\""beep.wav\""},\""acme1\"":\""bar\"",\""acme2\"":42}"";1011self.certificate=[[NSBundlemainBundle]1213pathForResource:@""aps_developer_identity""ofType:@""cer""];1415}1617returnself;1819}4.按下?+R，运行程序。将会问你是否允许使用证书，点击AlwaysAllow（总是允许）：在iPhone/iPod，确认ApplePushNotification程序未运行。点击Push按钮，会向设备发送一条推送通知。服务器实际上发送了下列消息给APN服务器：1{23""aps"":{45""alert"":""Yougotanewmessage!"",67""badge"":5,89""sound"":""beep.wav""},1011""acme1"":""bar"",1213""acme2"":421415}5.如果消息推送成功，将会在iPhone/iPod上出现下图：6.如果现在按下?+R调试ApplePushNotification程序，然后从PushMeBaby中发送一条消息，控制台会显示如下输出：2009-11-2421:11:49.182ApplePushNotification[1461:207]key:acme1,value:bar2009-11-2421:11:49.187ApplePushNotification[1461:207]key:aps,value:{alert=""Yougotanewmessage!"";badge=5;sound=""beep.wav"";}",2013/9/4
883,【拉人帖】这个版面不够活跃啊！！！,邱念,http://180.168.156.212:2262/wecenter/?/article/8399,如题:(:twisted:,2013/9/2
884,基于jqMobi框架开发的移动档案webApp源码包,方俊新,http://180.168.156.212:2262/wecenter/?/article/8397,本附件是基于jqMobijs框架开发的移动档案webApp，主要功能是模仿iOS上的移动档案而开发的，主要有：首页、网上办事、信息动态与更多等模块，大部分功能是通过ajax与后台的webServices进行数据交互，还有一个在线的语音搜索功能，调用的是科大讯飞的语音接口，当然本功能只在iOS上进行了实现，在android上可以通过类似的方式去实现。本系统的运行环境需要phoneGap在iOS或android或其它移动设备上，进行编译发布。www.zipphonegap-api-demo-jq-mobi.zip,2013/9/2
885,PhoneGap开发手机程序入门教程,方俊新,http://180.168.156.212:2262/wecenter/?/article/8398,"1.什么是PhoneGapPhoneGap是一个自由开放源码的开发工具和框架，允许利用HTML+JavaScript+CSS的强大功能在多个手机平台上开发程序,开发出来的程序经过在各自的平台上编译形成独立的安装程序。使程序看起来和native的程序一样。2.PhoneGap的优势和劣势优势：l跨平台：一次开发，多个平台共用。现主要包括了android，iOS，AppleiOS,GoogleAndroid,Palm,Symbian,BlackBerry等。WP7等平台也在逐步兼容中。l降低开发门槛。对于很多WEB开发人员来说，熟悉Objective-C语言和Java语言都是比较痛苦的事情。有了PhoneGap就不用担心这些了。用熟悉的Web前端技术就可以开发出很专业的手机应用程序。l提供强大的硬件访问控制。比起传统的Web程序，PhoneGap提供了一些列的JS的类，可以直接访问硬件。比如加速，相机，指南针，GPS，文件访问等，可以让你用JS方便地调用系统的硬件。以弥补传统Web程序的一块错误。l方便的安装和使用。PhoneGap的架构很复杂，但对于大多数开发者来说，只用很简单的配置就可以搭好环境。只用专注写好自己的Web页面，拷贝进去就可以了。劣势：l运行速度慢：程序的载入和UI界面的反应都比原生的程序慢，因为它实际上还是在展示Web页面，所以载入、页面刷新等肯定是需要一定时间的。l不适合部分程序。如果你的程序需要3D功能，或者对界面刷新有较高的要求，这样的程序现在来说还只是用原生的语言会比较好。3.PHONEGAP开发需要的基本知识lHTML：做为最基本的Web开发，HTML知识必不可少。现在很多移动终端已经支持HTML5了，所以最好学会HTML5相关的知识；lCSS：定义的页面的样式等等，不用CSS，你的页面会很难控制定位和样式等等。建议能掌握CSS3的相关知识，能写出更好的界面；lJavaScript：后台的交互都由JavaScript实现，读写数据库，载入GoogleMap等等；lPhoneGap的类库：都是JavaScript的库，使用很简单，有详细文档，可以参考官网： /start4.jQueryMobile：PHONEGAP的得力助手开发PhoneGap的程序，jQueryMobile不是必备，但是有了jQueryMobile，可以使你的程序美观很多。jQueryMobile其实是一堆的样式集和JAVA事件。比如写一个按钮，iOS和android的是不同的，用HTML做出来的往往很丑。一般的处理方式是重新定义按钮的样式，使它变得更像手机平台上的按钮。jQueryMobile为你提供了这一套框架，你可以通过很简单的属性设置就可以做出跟手机平台下差不多的按钮，相当方便。",2013/8/30
886,jQMobi API 函数(中英文对照）,方俊新,http://180.168.156.212:2262/wecenter/?/article/8396,".map(elements,callback)//Executescallbackfunctiononeachelement.map(elements,callback)//把当前匹配集合中的每个元素传递给函数，产生包含返回值的新JQMobi对象。.each(elements,callback)//Iteratethroughelementsandexecutecallback.each(elements,callback)//对jQMobi对象进行迭代，为每个匹配元素执行函数。.extend(target,{params})//Extendsanobjectwithadditionalarguments.extend(target,{params})//给一个对象扩展一个额外的元素.isArray(data)//Returnstrue/falseifdataisanarray.isArray(data)//判断是否为数组，返回值为布尔值。.isFunction(data)//Returnstrue/falseifdataisafunction.isFunction(data)//判断是否为函数返回值为布尔值.isObject(param)//Returnstrue/falseifparamisanobject.isObject(param)//判断是否为对象返回为布尔值.ready(callback)//CallbackexecutedwhenDOMContentLoadedhappens.ready(callback)//页面加载完成后开始运行.find(selector)//Findallchidlrenthatmatchthegivenselector.find(selector)//根据已给的选择器查找所有下级元素.html(['newhtml'])//Get/Settheelements.innerHTML.html(['newhtml'])//取得/设置该元素的.innerHTML.text(['newtext'])//Get/Settheelements.innerTEXT.text(['newtext'])//取得/设置该元素的innerText.css('property',['value'])//Get/Settheelementscsspropertytovalue.css('property',['value'])//获得/设置元素CSS指定属性的值.empty()//Setstheelements.innerHTMLtoanemptystring.empty()//设置该元素的.innerHHML一空字符串.hide()//Setstheelementsdisplaycssattributeto""none"".hide()//设置该元素CSS的display属性为""none"".show()//Setstheelementsdisplaycssattributeto""block"".show()//设置该元素CSS的display属性为""block"".toggle()//Togglestheelementsdisplaycssattribute.toggle()//切换该元素的CSS的display属性（显示/隐藏）.val([""value""])//Get/Settheelementsvalueproperty.val([""value""])//获得该元素的value属性.attr(""attribute"",[""value""])//Get/Settheelementsattribute.attr(""attribute"",[""value""])//获得/设置这个元素的属性.removeAttr(""attribute"")//Removestheattributefromtheelements.removeAttr(""attribute"")//移除当前元素的该属性.remove()//RemoveanelementfromtheDom.remove()//从DOM中移除指定元素.addClass(""className"")//Addsthecssclassnametotheselectedelements.addClass(""className"")//给指定的元素添加该名称的css类.removeClass(""className"")//Removesacssclassfromtheselectedlements.removeClass(""className"")//移除指定元素该名称的css类.hasClass(""className"",[_element])//Checkstoseeifanelementhasaclass.hasClass(""className"",[_element])//检查一个元素时候含有该名称的类.append(element,[insert])//Appendsanelementtotheselectedelements.append(element,[insert])//向每个匹配的元素内部后置内容。.prepend(element)//Prependsanelementtotheselectedelements.prepend(element)//向每个匹配的元素内部前置内容。.insertBefore(target)//Insertsacollectionbeforethetarget(adjacent).insertBefore(target)//把匹配的元素插入到另一个指定的元素集合的前面。.insertAfter(target)//Insertsacollectionafterthetarget(adjacent).insertAfter(target)//把匹配的元素插入到另一个指定的元素集合的后面。.get([index])//GetrawDOMelementbasedonindex.()returnsfirstelement.get([index])//获得基于.index()返回的第一个元素.offset()//Calculatesthefirstelementsoffsetonthescreen.offset()//计算元素在屏幕上的位置.parent(selector)//Returnstheparentnodesbasedoffselector.parent(selector)//返回该元素的父元素.children(selector)//Returnsthechildrenoftheelements.children(selector)//返回该元素的后代元素.siblings(selector)//Returnsthesiblingsoftheelemnts.siblings(selector)//获得匹配元素集合中所有元素的同辈元素。.closest(selector,[context])//Returnstheclosestelementbasedoffselector.closest(selector,[context])//从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素。.filter(selector)//Filterstheelementsbasedoffselector.filter(selector)//将匹配元素集合缩减为匹配指定选择器的元素。.not(selector)//ReturnallmatchesthatdoNOTmatchtheselector.not(selector)//返回从匹配元素集合中删除该元素集合。.data(key,[value])//Gets/Setsadata-*attributefortheparam.data(key,[value])//获得/设置一个data-*属性。.end()//RollsbackthejqMobielementswhenfilterswereapplied.end()//回滚jqMobi元素当过滤器被应用时.clone()//Clonesthenodesinthecollection.clone()//克隆节点到知道集合.size()//Returnsthenumberofelementsinacollection.size()//返回匹配元素数量。.serialize(grouping)//Serializesaformintoaquerystring.serialize(grouping)//将表单内容序列化为字符串。.jsonP(options)//ExecuteajsonPcall,allowingcrossdomainscripting.jsonP(options)//执行JSONP请求，允许跨域.bind(""event"",function(){})//Bindsafunctiontotheeventlistener.bind(""event"",function(){})//向匹配元素附加一个或更多事件处理器.unbind(""event"",[callback])//Unbindsafunctiontotheeventlistener.unbind(""event"",[callback])//从匹配元素移除一个被添加的事件处理器.one(""event"",callback)//Bindeventtoeachelement-onlyexecutesonce.one(""event"",callback)//向匹配元素添加事件处理器。每个元素只能触发一次该处理器。.delegate(selector,""event"",callback)//Delegateaneventbassedoffselector.delegate(selector,""event"",callback)//向匹配元素的当前或未来的子元素附加事件处理器.undelegate(selector,""event"",[callback])//Unbindaneventregisteredthroughdelegate.undelegate(selector,""event"",[callback])//从匹配元素移除一个被添加的事件处理器.on(""event"",selector,callback)//类似于.delegate().off(""event"",selector,[callback])//删除.on()添点的事件处理器.trigger(""event"",data)//Triggeraneventandpassinoptionaldata.trigger(""event"",data)//触发事件，并传入一个数据（可选）.proxy(callback,context)//Createsaproxyfunctionsothe‘this’contextcanbechangedinthefunction.proxy(callback,context)//创建一个代理函数,改变该函数中'this'作用域jqMobi助手调用.param()//SerializeaJSONobjectintoKVPforaquerystring.param()//序列化一个JSON对象为键/值对字符串.parseJSON(string)//BackwardscompatabilityJSONparsingcall.UsesthebrowsersnativeJSONparserparseJSON(string)//向后兼容JSON解析调用。使用浏览器原生JSON解析器.parseXML(string)//ParsesastringandreturnsaXMLdocumentversion.parseXML(string)//解析字符串并返回一XML文档的版本.uuid//UtilityfunctiontocreateapseudoGUID.uuid//用来来创建一个伪GUID.Event(type,props)//Createsacustomeventtobeusedinternally.Event(type,props)//创建一个内部使用的自定义事件jqMobi操作系统检测$.os.webkit//Trueifwebkitfoundintheuseragent$.os.webkit//如果浏览器为webkit核心，返回true$.os.android//Trueifanroiduseragent$.os.android//如果用户设备为android，返回true$.os.ipad//TrueifiPaduseragent$.os.ipad//如果用户设备为ipad，返回true$.os.iphone//TrueifiPhoneuseragent$.os.iphone//如果用户设备为iphone，返回true$.os.webos//TrueifWebOSdetected$.os.webos//如果用户设备为webos，返回true$.os.touchpad//TrueifWebOSandTouchpaduseragent$.os.touchpad//如果用户设备为touchpad，返回true$.os.ios//TrueifiPadoriPhone$.os.ios//如果用户设备为iPad或iPhone，返回true$.os.blackberry//TrueifBlackberryPlayBookorOS>=6$.os.blackberry//如果用户设备为黑莓PlayBook或OS>=6，返回true",2013/8/30
887,jqMobi简介,方俊新,http://180.168.156.212:2262/wecenter/?/article/8395,什么是jqMobijqMobi是由appMobi针对HTML5浏览器和移动设备开发的javascript框架，是个极其快速的查询选择库，支持W3C查询。版本jqMobi源码最初在2012年1月份推出，基于MIT/X11许可证，托管在GitHub上，开发者可以参与并通过插件不断改进该框架。2012年3月13日，jqMobi1.0版本正式发布。jqMobi特点速度快适用于智能手机和平板电脑提供了60多个API调用与jQuery相同的语法插件可扩展gzip压缩到最小5k英特尔收购英特尔2013年2月22日收购HTML5移动应用公司appMobiHTML5开发工具和相关雇员，不过没有收购这家初创公司。此举是英特尔打造自有移动应用开发者工具套件的行动之一。为了对html5和css3提供更多支持，这个处理器巨头可能考虑打造相应硬件。编辑本段jqMobi与jQuery的区别jqMobi是由appMobi开发，而jQuery是jQueryFoundation的产品。jqMobi源码是基于jQuery源码重写的，但是两者又属于不同的产品，jqMobi体积更小，速度更快，兼容性也有所不同。体积更小在压缩之后，相比jQuery的24k，jqMobi的文件大小只有5k速度更快据JSPerftest的数据，它在Android上要比jQuery快3倍，在iOS上快2.2倍。兼容性jqMobi主要针对拥有WebKit浏览器的操作系统（比如Android、iOS以及最新版本的BlackBerryOS）而设计，jqMobi1.2已可兼容IE10（windows8和windowsphone8平台）；而jQuery则兼容更多浏览器（比如ie6）。编辑本段jqMobi由三个组件组成查询（query）程序库该程序库提供了60多个API调用，包括Ajax调用、针对webkit的系统选择器调用等。jqUiAppMobi目前还致力于jqUi的开发，这是一个21KB大小的用户界面程序库，提供了按钮、部件、固定的header/footer以及可控的滚动部件。该工具包也仅针对移动版本的WebKit浏览器，同时支持Android2.2及更高版本。jqPlugin用于针对WebKit浏览器交互和接口的插件支持。,2013/8/30
888,phonegap插件的实现,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8394,"1.新建Phonegap工程MyPlugin环境xcode4.5.1phonegap2.1.02.在Plugin文件夹下创建实现Plugin子类[plain]////MyPlugin.h//MyPGPlugin////Createdbykllmctrlon12-10-29.////#import@interfaceMyPlugin:CDVPlugin-(void)add:(CDVInvokedUrlCommand*)command;@end[plain]#import""MyPlugin.h""#import@implementationMyPlugin-(void)add:(CDVInvokedUrlCommand*)command{CDVPluginResult*pluginResult=nil;NSString*javaScript=nil;@try{NSString*echo=[command.argumentsobjectAtIndex:0];NSString*echo2=[command.argumentsobjectAtIndex:1];if(echo!=nil&&[echolength]>0&&echo2!=nil&&[echo2length]>0){/***相加字符串*/NSString*addResult=[NSStringstringWithFormat:@""%@%@"",echo,echo2];pluginResult=[CDVPluginResultresultWithStatus:CDVCommandStatus_OKmessageAsString:addResult];javaScript=[pluginResulttoSuccessCallbackString:command.callbackId];}else{pluginResult=[CDVPluginResultresultWithStatus:CDVCommandStatus_ERROR];javaScript=[pluginResulttoErrorCallbackString:command.callbackId];}}@catch(NSException*exception){pluginResult=[CDVPluginResultresultWithStatus:CDVCommandStatus_JSON_EXCEPTIONmessageAsString:[exceptionreason]];javaScript=[pluginResulttoErrorCallbackString:command.callbackId];}[selfwriteJavascript:javaScript];}@end3.在www->js文件夹下创建实现MyPlugin.js[plain]varMyPlugin={add:function(args,args2,addSuc,addFaild){cordova.exec(addSuc,addFaild,""MyPlugin"",""add"",[args,args2]);}};在config.xml中配置js中的插件与iOS插件实现的映射关系",2013/8/30
889,ios推送消息：客户端以及服务端实现,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8393, ,2013/8/30
890,关于websphere的问题，求助！！！,白金鹏,http://180.168.156.212:2262/wecenter/?/article/8392,"前几天实施人员说需要打个war包给客户，客户需要搭一个websphere环境来跑光典和系统管理平台，然后我就自己拉了一套程序部署上去进行测试，刚搭上去问题就来了.....问题主要就是两个不相关的web应用lib下的jar包加载的时候会报错，假如光典程序先启动起来了，然后当启动系统管理平台的时候就会报如下错误，而且会一直报错：Exceptioninthread""Task-Thread-for-com.mchange.v2.async.ThreadPerTaskAsynchronousRunner@22ac22ac""java.lang.VerifyError:classloadingconstraintviolated(class:oracle/jdbc/driver/OracleStatementmethod:parseExecuteFetchWithTimeout(Loracle/jdbc/dbaccess/DBStatement;B[BLoracle/jdbc/dbaccess/DBDataSet;ILoracle/jdbc/dbaccess/DBDataSet;I)I)atpc:0SystemErrRatjava.lang.J9VMInternals.verifyImpl(NativeMethod)SystemErrRatjava.lang.J9VMInternals.verify(J9VMInternals.java:59)SystemErrRatjava.lang.J9VMInternals.initialize(J9VMInternals.java:120)SystemErrRatoracle.jdbc.driver.OracleConnection.privateCreateStatement(OracleConnection.java:772)SystemErrRatoracle.jdbc.driver.OracleConnection.createStatement(OracleConnection.java:712)SystemErrRatoracle.jdbc.dbaccess.DBAccess.setNlsParamsClient(DBAccess.java:1647)SystemErrRatoracle.jdbc.ttc7.TTC7Protocol.initNls(TTC7Protocol.java:1590)SystemErrRatoracle.jdbc.driver.OracleConnection.(OracleConnection.java:392)SystemErrRatoracle.jdbc.driver.OracleDriver.getConnectionInstance(OracleDriver.java:468)SystemErrRatoracle.jdbc.driver.OracleDriver.connect(OracleDriver.java:314)SystemErrRatcom.mchange.v2.c3p0.DriverManagerDataSource.getConnection(DriverManagerDataSource.java:134)SystemErrRatcom.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:182)SystemErrRatcom.mchange.v2.c3p0.WrapperConnectionPoolDataSource.getPooledConnection(WrapperConnectionPoolDataSource.java:171)SystemErrRatcom.mchange.v2.c3p0.impl.C3P0PooledConnectionPool$1PooledConnectionResourcePoolManager.acquireResource(C3P0PooledConnectionPool.java:137)SystemErrRatcom.mchange.v2.resourcepool.BasicResourcePool.doAcquire(BasicResourcePool.java:1014)SystemErrRatcom.mchange.v2.resourcepool.BasicResourcePool.access$800(BasicResourcePool.java:32)SystemErrRatcom.mchange.v2.resourcepool.BasicResourcePool$AcquireTask.run(BasicResourcePool.java:1810)SystemErrRatcom.mchange.v2.async.ThreadPerTaskAsynchronousRunner$TaskThread.run(ThreadPerTaskAsynchronousRunner.java:255)按常理来说两个web应用的lib下的jar包应该是各自加载各自的不会互相干扰的，但是奇葩的websphere就出问题了....现在有三种解决方案：方案一：杨木江的解决办法，将c3p0和oracle的连接jar包都放到websphere的lib目录下，然后把工程下的这两个jar包删掉，这样就可以解决问题。方案二：就是先修改类加载器的顺序，将搭建的两个应用程序类加载器顺序都改为应用程序类加载器优先，然后在jvm中设置一个参数“-Xverify:none”，这样也能解决问题。方案三：可以看5楼，虽然我没有尝试，但是应该是没有问题的，两个web节点，就相当于跑了两个websphere服务器，应该是不会影响的。我选择的方案是我自己想出来的第二种，三种解决方案各有优势和劣势，如果以后看帖子的各位有遇到相同问题的话，欢迎使用着三种方案尝试。~~~",2013/8/13
891,公司OA数据库故障修复一例,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8391,因为监听的一个日志文件过大，导致客户端连接不上，详情请查看附件。Oracle维护日志20130813.docx,2013/8/13
892,上海推进大数据研究与发展三年行动计划（2013-2015年）,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8390,大数据时代真的来了，我们的机会在哪里？食品安全。针对食品安全和管理的需求，建设食品安全大数据服务平台。汇聚政府各部门的食品安全监管数据、食品检验监测数据、食品生产经营企业索证索票数据、食品安全投诉举报数据，建成食品安全大数据资源库，进行食品安全预警，发现潜在的食品安全问题，促进政府部门间联合监管，为企业、第三方机构、公众提供食品安全大数据服务。关键技术突破：大数据获取技术。突破分布式高速高可靠数据爬取或采集、高速数据全映像等大数据收集技术；突破高速数据解析、转换与装载等大数据整合技术；设计质量评估模型，开发数据质量技术。大数据管理技术。突破可靠的分布式文件系统（DFS）、能效优化的存储、计算融入存储等大数据存储技术；突破分布式非关系型大数据管理与处理技术，研究大数据建模技术；突破大数据索引技术；突破大数据移动、备份、复制等技术；开发大数据可视化技术。大数据分析技术。改进已有数据挖掘和机器学习技术；开发数据网络挖掘、特异群组挖掘、图挖掘等新型数据挖掘技术；突破基于对象的数据连接、相似性连接等大数据融合技术；突破用户兴趣分析、网络行为分析、情感语义分析等面向领域的大数据挖掘技术。大数据安全技术。改进数据销毁、透明加解密、分布式访问控制、数据审计等技术；突破隐私保护和推理控制、数据真伪识别和取证、数据持有完整性验证等技术。上海推进大数据研究与发展三年行动计划（2013-2015年）.mht,2013/8/8
893,Don't make me think ------转载,王蕊,http://180.168.156.212:2262/wecenter/?/article/8388,"Don’tMakeMeThink——不要让用户思考，不要让用户做复杂决策一、思想上：为什么不要让用户思考有人说选择太少很痛苦，有人说选择越多越痛苦，究竟是选择越多越好，还是选择越少越好呢？要我说呀，当然是做选择的时间越短越好，也就是不要让用户思考，果断决策。惧怕损失的本能，让用户在做决定的时候总是喜欢权衡利弊，从而花更多的时间在决策上。事实上，用户喜欢无须思考的选择。当有多种选择时，人们总是不忍放弃任何一个机会，即使这个机会已经没有价值；手忙脚乱的保留多个选择，往往会忘记在真正重要的事情上努力；在吸引力大致相同的两种选择中作取舍是最难的。生活中每天每个人都面临着无数的决策，那么是什么形成我们决策的背后力量呢？答案就是可预期的非理性。传统经济学上有一个理性经济人假设--人都希望以尽可能少的付出，获得最大限度的收益。事实上，理性行为在现实社会很少发生，人类的大部分行为都是非理性的，人类的消费行为往往会受到周围环境（时间、信息量、目标、兴趣、参照物、他人）影响。人们做选择时考虑的不是二者各自的绝对价值，而是他们的相对价值——他们得到什么，放弃什么。非理性行为并不是飘忽不定，而是有规律可循，是系统的，是可以预测的。Don’tMakeMeThink——当我们真正理解了用户行为，并可以预测他们行为的时候，我们可以通过多种方法，改善用户体验，促进用户决策，提升网站成交额。二、一些总结性的规律1、竞争就在于一个点击的差别因此如果你得罪了用户，他们就会跑到别的地方去。网页上每样东西都有可能让我们停下来，进行不必要的思考。每个问号都会加重我们的认知负担。因此，我们在页面设计的时候应该：（1）显而易见/不言而喻/不需要思考；用词：广为人知的名称；形象：明显能点击的（符合用户常用习惯）（2）崭新的开拓性的复杂的页面，尽量做到“自我解释”（3）避免：很酷或自以为聪明的名字、带有营销倾向、和具体公司有关、生僻的名词2、关于网络使用的三个事实（1）以100公里的时速驶过高速公路上的广告牌，我们不是阅读，而是扫描。原因是：我们总是在忙碌中、知道自己不必要阅读所有的内容、我们善于扫描；与我们浏览目标有关；当前或是接下来的兴趣（2）我们不作最佳选择，而是满意即可--第一合理选项、满意策略。一旦我们发现一个链接，看起来似乎能跳转到我们想去的地方，那就是一个我们将会点击它的大好机会。为什么WEB用户不寻找最佳选择呢？因为我们总是处于忙碌之中，满意策略效率更高；如果猜错了，也不会产生什么严重后果；猜测更有意思。（3）我们不是追根究底，而是勉强应付很大程度人们一直使用这些东西，并不了解它们的运作原理，甚至对它们的工作原理有完全的错误理解。对使用者来说，是否明白它的工作机制，这个并不重要；如果发现某个事物能用，我们会一直用它（很少主动寻找更好的方法）；3、设计原则--从用户角度出发的观念改变为扫描设计，不为阅读设计。做法：越重要的部分越突出、页面区域明确定义和降低视觉噪声；可以点击的地方要做明显标识；执行搜索的按钮习惯位置4、让选择变得无须思考—减少点击点击多少次都没有关系，只要每次点击都无须思考、明确无误的选择；到达任何地方的点击次数不是最重要的，一条关键的经验准则是：1次需要思考的点击=3次无需思考、明确无误的点击。除非，页面刷新较耗时，则点击数越少越好。5、如何降低噪音省略不必要的文字。事实证明，有力的文字都很简练。由于用户更喜欢直截了当，欢迎词必须消灭（只是一个劲地说自己有多好，而不是描述什么东西能让我们感觉更好）；冗长的指示说明必须消灭，因为没有人会细读它们，除非多次“勉强应付”失败。如果说明冗长，会阻碍用户发现所需信息。6、导航怎么做先搜索还是先浏览，取决于用户的打算、匆忙程度以及网站是否有良好的导航机制。所以可以讲用户分为搜索型用户（直接询问）和浏览型用户（通过标志的引导在层次结构中穿行然后从下一层栏目中再选择）。在web世界，很难借助其他的感觉来locate，用户感觉不到大小、方向和位置，所以，Web比真实世界更需要导航。持久导航的5个元素：7、页面设计三大方面（1）页面名称：不可缺少，每个页面都需要一个名称（每个拐角都需要一个路牌）；页面名称要出现在合适的位置；页面名称要引人注目；名称要和点击的链接一致（2）大类标签：提供清晰的视觉线索、明确地告诉用户“你在这里”标签灵活，且暗示了物理的空间。使用要点：正确绘制；激活的标签页在前，对比强烈，有弹出感；当进入网站时，有一个标签已经选中（3）层级菜单：补充机制、层级菜单就像面包屑，有以下实践要点：放在最顶端，不与主导航条竞争；使用小字体；使用文字“你在这里”；最后一个元素加粗；惯用方式：使用“>”对层级进行分隔8、主页设计要点主页要满足的目标是：让我看到自己正在寻找的东西；哪些是还有我没有寻找的；告诉我从哪里开始；建立可信度和信任感。要完成的任务是：站点的标识和使命、站点层次、搜索、导读、内容更新、友情链接、快捷方式以及注册。用户心目中的布局：主页为了达到传达网站整体形象，需要：（1）口号：靠近站点ID的位置，与其相关联的短语，对整个网站的描述；好的口号要清楚、言之有物，长度适中，能表述出网站的特点和显而易见的好处。有个性、生动，有时还很俏皮；不管你多出名，也有必要抓住这个并不张扬的机会来告诉人们为什么要待在你的网站。而且网站的网络使命一定跟现实有所不同，解释这种区别很重要。（2）欢迎广告：对网站的简要描述（3）主页导航：可以不同，但不要差别太大。主页导航可采用不同的方向，也可让用于识别的空间更多。但主页导航和持久导航需要保持一定程度上的一致，才能让用户识别出这只是同一导航的两个不同版本。（4）具体页面设计：用户在底层页面上花的时间和花在顶层页面的时间相同；要保持一致性，就得从头开始设计好每一个层级的页面；在讨论主页的颜色方案之前，拥有显示网站所有潜在级别的导航的样例页。9、后备箱测试后备箱测试：想象你被蒙上双眼，锁在车子的后备箱里。车开动一会儿以后，把你发在某个网站内容的某个网页上。如果这个页面设计良好，当你除去眼罩时，应该能毫不犹豫的回答：（1）这是什么网站？（站点ID）（2）我在哪个网页上？（网页名称）（3）这个网站的主要栏目有哪些？（栏目清单）（4）在这个层次上我有哪些选择？（本页导航）（5）我在导航系统的什么位置？（“你在这里”指示器）（6）我怎么搜索9、网站可用性测试关于测试的几个事实：如果想建立一个优秀的网站，一定要测试；测试一个用户比不做测试好一倍；在项目中，早点测试一位用户好过最后测试50位用户；人们对招募用户代表的重要性估计过高；测试的关键不是要证明什么或者反驳什么，而是了解你的判断力；测试是一个迭代的过程；没有什么比现场用户的反应更重要。需要建立少量多轮的测试。每轮测试的理想用户数量是3个，最多4个。前3个用户能遇到几乎所有最明显的问题，便于在同一天完成测试和总结。三、不要照本宣科Don’tMakeMeThink并不等于说我们在做交互和页面的时候，设计者不要思考，而是说不要让用户思考。换句话也可以理解为设计者将许多以前需要用户思考的部分考虑进来，让用户的思考流程简化，最终使用户达到不需要思考而能快速准确的决策。为了能达到用户不需要思考，设计者往往要为此付出百倍、千倍的努力。那么，如何让用户不需要思考呢？这就需要我们在日常工作中不断发现和总结用户行为的规律，进而影响用户的决策。电子商务网站在做好基础用户体验（页面、流程、服务等）的同时，还有一个更重要的用户体验——消费者行为规律的研究，即如何通过搜索框位置、主页位置、页面布局、商品摆放、文案、相关商品推荐等去影响用户决策。四、学以致用：一份不全面的用户体验报告：PK我们知道在中国B2C在线零售商中，京东和亚马逊两个网站都占据着举足轻重的地位。《Don’tMakeMeThink》书中提及到的页面要符合用户心目中的布局，页面需要包含网站ID、栏目、使用工具、页面名称、页面导航以及底端导航。具体页面元素的布局如下图：实例1：我们将京东商城和亚马逊商城的主页截图，看其页面是否符合用户心目中的布局,具体页面如下：总体来看，京东商城的主页布局和元素更加符合用户心目中布局，京东商城似乎是根据用户心目中的布局形式量体裁衣的，只不过在网站ID上增加了一栏永久导航和一栏促销广告。相同之处：京东商城和亚马逊商城两者都包含（网站ID、栏目、实用工具、页面名称、页面导航、底端导航）页面元素；都具有持久导航的（站点ID、栏目、搜索的方式、回主页的方式、实用工具）5个元素。不同之处：在首页页面布局上，京东优于亚马逊。标签是大型网站的最佳导航，京东的栏目以标签的形式、激活的标签颜色和未激活的标签有很大的不同，这样使得导航更加的简洁明了，让用户不需要思考就能立马知道自己目前身处的位置。京东的右边的功能推荐（满39免邮）、快捷方式（充值、旅行、彩票、点卡等）以及内容推荐，较亚马逊的更加丰富和快捷。实例2：在京东和亚马逊都选择“手机通讯”这个类别，进入了手机通讯这个具体页面京东和亚马逊的层级菜单，放在最顶端，不与主导航条竞争，使用“>”对层级进行分隔的惯用方式。但是也有不足之处，应该使用文字“你在这里”。在页面栏目上，亚马逊要优于京东。将手机通讯的下层分类详细罗列出，可以节省用户的搜索时间，做简单选择即可。亚马逊的左侧页面导航详细、分类齐全，特别是快速选购手机，“通过高级组合搜索，您可以快速找到心仪的手机”，这个搜索别具匠心。实例1：在京东和亚马逊搜索框中输入“牛奶可乐经济学”，点击搜索，搜索框下拉的搜索建议如下：京东商城的搜索建议第一个是让用户选择分类选项，而亚马逊商城因为加入了分类选项框，故而跳过此步骤，直接进入了搜索结果，并且提供的搜索选择更加的具体和丰富。从这个搜索实例中，我们可以看出亚马逊的搜索建议要由于京东商城。实例2：由于亚马逊提供了搜索选项下拉框。那么接下来，我们验证一下选项框的可用性和实用性。在亚马逊搜索框中下拉选择“小家电”，在搜索框中输入“牛奶可乐经济学”，以便我们能看看在错误的搜索分类选项框中搜索不存在该分类中的商品，是否能正确搜索出该商品。由搜索结果中，我们可以看到虽然在亚马逊输入一个分类“小家电”下不可能存在的商品“牛奶可乐经济学”，但是能够正确搜索出商品。亚马逊的搜索处理是这样的：首先在用户指定分类中进行搜索，没有搜索到的话，页面提示该分类没有此商品；然后在所有商品类目中继续进行搜索找出该商品；接着提示用户点击在所有类别中查找到的结果；最后还有搜索结果用户及时反馈。可见，亚马逊在搜索这块做的很到位，不仅不会因为用户的误操作而影响搜索结果，而且可以给喜欢和善于用分类框搜索的用户，让他们能迅速准确的找到想要的商品。",2013/8/8
894,oa提示问题,王蕊,http://180.168.156.212:2262/wecenter/?/article/8387,在我未登录的情况下，点击知识库，提示我没有权限！我认为应该提示请登录系统之类的提示吧！登录后我就可以看了，提示需纠正,2013/8/8
895,高仿webQQ的webOS--jpush,方俊新,http://180.168.156.212:2262/wecenter/?/article/8389,本系统是高仿webQQ的webOS，采用的是jQuery框架。外面是个框架加载的模版数据全部通过XML传递后台没有架构数据还都是静态的只要在CONFIG.XML里面改改参数就可以了，里面用到的封装好的框架有弹出层的，右键菜单的，拖动的等等都是可以通过XML进行模版的。当然源码全部开源测试网址的源代码里有作者的联系方式~想要的跟作者要吧，主要是空间不太给力...额。。。。那个不兼容IE6内核你懂的。。。。谷歌浏览最好其次是IE9在就是火狐OPERASS最后是IE78兄弟了。。。 的作者博客欢迎访问jpush-plus.rar,2013/8/8
896,我的工作表单中，翻页功能提示问题,王蕊,http://180.168.156.212:2262/wecenter/?/article/8384,1.我鼠标点到下面页码输入时，提示输入参数有误，我还没输入呢亲。。。输入参数有误是什么意思，客户没学过计算机的，不知道参数是神马玩意儿的图片怎么弄到评论中呢？还得找个网站把自己的图片上传，然后弄个url地址？2.查加班的时候是否可以把加班时长显示出来，至少我能加一下我加班的总数，与系统核对核对3.为嘛在我的工作中流程下拉框不能输入啊？貌似在oa首页是可以的另：1.论坛中双击鼠标可以编辑比较人性化，但点更新立马出来脚本变更理由undefined，这是神马没有定义啊？你写理由可以，但请将undefined去掉2.论坛是否可以快捷贴图，必定有图才有真相撒，我截图了但不知道怎么上传3.我刚发的这个贴在oa首页总最新贴未出现是为虾米？,2013/8/5
897,“报销申请单”查看页面有点小问题,余礼华,http://180.168.156.212:2262/wecenter/?/article/8386,见截图，合计人民币（大写）右边的文本框在鼠标放在其偏上的位置时，其修改历史记录信息提示框跑到了上方。2013-8-813-25-18.jpg,2013/8/1
898,有没有乒乓球爱好者,陈彤,http://180.168.156.212:2262/wecenter/?/article/8385,[color=darkred]公司有没有爱好乒乓球的同事，有兴趣可以邀约一起切磋切磋联系方式：wotalk:陈彤QQ:1311202554[/color],2013/7/31
899,关于城市记忆工程浏览检索性能优化阶段性报告,方俊新,http://180.168.156.212:2262/wecenter/?/article/8383,在今年三月份对上海市档案局档案资源管理系统进行性能优化，主要优化方式是：采用拆表方式。不过性能确实提升了不少，所以把一些经验进行分享关于城市记忆工程浏览检索性能优化阶段性报告.docx,2013/7/25
900,Windows远程桌面连接Mac OS X,方俊新,http://180.168.156.212:2262/wecenter/?/article/8382,第一步：MacOSX10.5已经增加支持了由VNCViewer访问的功能，设置如下:系统偏好设置-共享-勾选“屏幕共享”，然后在电脑设置—VNC显示程序可以使用密码控制屏幕输入8位密码，并输入登录使用的密码允许设置，这样就可以通过其它PC或Mac上的VNCViewer来连接这台Msc进行远程控制了。第二步：安装VNCViewer，推荐一个自由软件TightVNC，下载地址 /download.php，TightVNC是一套免费的VNC软件，能让你轻松控制远程的计算机，就像坐在自己家的计算机前面一般。,2013/7/23
901,产品设计中，如何去安慰你的用户。产品中国摘录如下：,王蕊,http://180.168.156.212:2262/wecenter/?/article/8381,"一切都是假象：按钮的安慰效果，截取其中的一段：安慰剂按钮Placebobuttons：是指一种放置在公共场合假装有效，但实际已经停止工作的按钮。你有没有猛按电梯关门键的经验。纽约客一篇文章曾提到，在90年代初，当地的电梯都还没有关门键，这都是后来添加上的，但实际上这并没有太大的用处，只是为给人们造成‘猛击此次，关闭电梯’一个假象，同时也能缓解人们在等待电梯下楼时的烦闷。如果细致观察你的生活，想必你也有以下常见的习惯：热得不行回家马上把空调调到16°C。——但事实上气温不可能马上下降到16°C电脑卡的时候狂点击鼠标右键内的“刷新”命令。——事实上，“刷新”并不能解决卡的问题。BT下载的时候让任务暂停后马上继续，希望速度能加快。——好吧，从我个人角度来说，我发觉这好像有点效果。……从精简的角度而言,很多的设计是过度的现在邮箱的界面内为什么需要“收信”按钮?这是一个曾经在部门内部激烈讨论的问题，因为邮箱早已经实现了同步收取，邮件一发，对方无需点击收信按钮，即可收到邮件并看到提示。从精简的角度上说，“收信”按钮是软件端的产物，因为本地邮件与网络端邮件无法实时同步，才需要一个“收信”按钮。那么对于网页端来说，这个按钮就显得多余了，因为网页能够做到实时的同步了。(所以Gmail与Hotmail就去掉收信的按钮)古老的win98系统有个“我的公文包”功能，他主要用于同步更新文件，每次更新时，你都得点击一次“更新”才可让文件更新。可是，Dropbox把这个功能也省了。精简化的设计原则强调于，尽量的减少用户的操作成本，帮用户多做一步。因此，“收信”按钮其实大可不必，那么它存在理由，我只能从情感化上去理解它了。从用户的需求来说,这些设计能够让用户发泄焦灼等待的情绪记得你唤起因睡眠而黑屏的电脑时，疯狂过晃动手中的鼠标吗?记得你因为赶时间，等不及电脑提示就直接拔掉U盘闪人吗?人对时间无法有准确的主观感知，人们对较长的时间间隔，往往估计不足;而对较短的时间间隔，则估计偏高。心理学家发现，用计时器测量出的时间与估计的时间不完全一致。人的时间知觉与活动内容、情绪、动机、态度有关。内容丰富而有趣的情境，使人觉得时间过得很快，而内容贫乏枯燥的事物，使人觉得时间过得很慢;积极的情绪使人觉得时间短，消极的情绪使人觉得时间长;期待的态度会使人觉得时间过得慢。一般来说，对持续时间越注意，就越觉得时间长;对于预期性的估计要比追溯性的估计时间显得长些。来源对于信息高速传递的网络来说，用户对于一秒的等待速度都是难以接受的。但用户处于焦灼的状态时，则会不由自主的找到一种最直接方式去缓解这种情绪。对于设计师而言，就要提供像“鼠标”这样一个最直接的缓解方式。去安慰你的用户。如何去安慰用户安慰用户的关键，即在于如何提供一个内容丰富而有趣的情境给用户。我个人觉得我们应该以下三个方面着手。1、降低挫败感,尤其是多次尝试的挫败感设计时，让机器的出错反馈风趣而又具有人性化，表现出对用户的关怀，自然就容易被用户接受。采用的方法一般为：拟人化(如豆瓣开小差了)，幽默(如煎蛋超载鸡，版本二)，小游戏等。但需注意的是，对于用户的多次尝试失败，应该给予更加具有关怀性的反馈，对于用户而言，这种反馈是能够让其“内牛满面”的。如QQ邮箱的中，多次点击收信按钮的温馨提示。2、让等待变得缓慢化且可以打发我很喜欢Ghost版的系统，他不仅让安装系统变得更加快，更加重要的是，安装的时候，他还能提供空当接龙，扫雷这样的游戏给我打发时间。同时，基于等待需时的长短，提供的进度反馈也不一样。短时间的采用简单的loading图标，鼠标的忙碌状态;中长时间采用的是进度条，但同时，应尽量避免采用非确定性进度条。可参考windows交互体验规范最后，还需注意，如果所需的时间越长，进度条也应越长，这样用户能够较为轻易的感知到进度的变换而不误会进度停止。3、给予惊喜喜新厌旧是人固有的习惯，即使是再美艳的界面，再风趣的句子，也有厌倦的时候，对于网络尤甚，今天流行的句子，明天就凹凸了。这种行为表现得最突出的，就在网络产品的皮肤上。用户似乎总是没有100%满意的皮肤。所以，在设计上，应该有一些随机的，易于被用户发现的变化。通过这种变化，用户可以获得愉悦感，同时也可获得发现这种变化的成就感，这就是两种积极的情感因素。",2013/7/18
902,案例说产品意识和用户体验为中心之UI设计注意点,李志卿,http://180.168.156.212:2262/wecenter/?/article/8380,[color=red]软件的智能和记忆功能[/color]1.用户登录界面最好有用户名和ID的记忆，焦点直接定位到密码输入框2.单据录入界面最好有保存和载入默认值的功能3.单据搜索界面可以保存用户自定义的各种搜索条件组合4.用户调整过的GRID的列宽，窗口的位置可以自动记忆5.系统可以根据用户的使用频度对相关功能进行自动的优先级排序6.系统能够记忆不同用户的使用偏好，使用系统的固有模式和常用的自定义设置减少不必要的重复交互1.减少不必要的各种操作，能够点一次鼠标或敲一次键盘完成的绝不作出两次或多次。2.提示信息要适度，太多不好，太少也不好。3.数据项完整性校验问题要注意光标焦点自动定位到错误处4.完整业务功能不要让用户在多个窗口切换多次才能够完成。尽量减少这种切换。5.为了方便用户切换窗口，相关的表单最好都作为非模式的形式。6.相同的信息不要让用户在系统中多处或多次录入，保证入口的唯一性7.系统要尽可能根据用户已经录入信息自动获取其它附属信息，而不需要用户重复的选择或录入。导航和界面跳转1.表单新弹出对话框，对话框再弹出对话框的这种层次要控制在3层以内。2.所有的非模式活动窗口最好有类似桌面任务栏一样的停靠方式，方便切换窗口3.系统可以支持用户自己定义常用功能和菜单4.对于常用功能应该提供便捷的快捷键和工具栏按钮5.对于系统中提供的各种业务和表单功能能够让用户便捷挑转到帮助信息上6.对表单和界面联动和交互的时候要注意相关界面数据的自动刷新7.一个窗口中最多不要出现超过三个的GRID控件8.BS方式不要左右滚屏。CS模式既要避免左右滚屏也要避免上下滚屏9.需要根据业务查看需求和数据的展现需求来选择合适的界面控件系统性能和健壮性方面的1.系统中相关的耗时操作都必须必须转变鼠标为等待状态2.系统耗时操作超过30秒的最好能够提供给用户相关的进度条功能3.系统耗时功能超过2分钟的最好能够设计为异步多线程的方式进行处理4.系统应用有友好的完整性和约束校验的提示信息，方便用户修改录入数据5.在系统出现异常情况下应该有友好的统一的提示信息，同时后台应该记录详细的异常日志界面友好性和易用性方面的1.表单应该能够根据屏幕分辩率自动适应。在界面上让用户一次能够看到足够多的信息2.表单应该支持Tab键功能，顺序为从左到右，从上到下。3.常用的表单应该同时支持键盘操作和鼠标操作。4.界面上控件的布局应该间距适当，标签和控件对齐，有适当的录入提示信息。5.界面的配色应该尽量简单，尽量少使用各种刺眼的颜色6.用户看到表单后应该就基本清楚相关功能，表单要尽量自我解释，不要设计过多的隐含在界面里面功能数据的录入和检索1.根据业务需要选择适合的数据录入控件2.数据录入控件应该有完备的数据完整性和一致性校验功能3.系统应该提供用户暂时保存录入数据的功能4.能够自动获取数据不要让用户再去录入，能够选择录入数据不要让用户手工录入5.数据检索条件应该适中，不应太多也不应太少。检索支持组合条件检索。6.为了满足不同需求检索可以提供简单检索和高级检索多种方式。7.应该在第一时间提供给用户检索数据，因此检索功能存在性能问题时候要考虑分页。8.在检索功能较耗时的时候应该提供给用户相关的进度条显示进度9.表格最好能够提供行显示和列显示等多种显示模式，方面用户查看数据,2013/7/16
903,案例说产品意识和用户体验为中心之插件包下载安装,李志卿,http://180.168.156.212:2262/wecenter/?/article/8379,光典产品中用到了许多ocx插件，用以实现扫描、通用浏览器、chrome浏览插件、自动修改ie安全选项等功能，这些插件做成了一个安装包，约有120M大小，在实施过程中碰到如下问题：1.部分集团客户采用vpn网络，带宽比较低，安装包太大，影响用户体验；2.所有插件不是所有人都需要的，比如扫描；3.通用浏览器本身很大，很多客户不需要的cad浏览或者只需pdf查看，完全可以缩小安装包大小；4.安装包中部分控件是要经常升级更新的，部分是一般不需要升级的，比如chrome，而要更新必需全部卸载再重新下载120M文件；5.由于兼容性，部分客户不能安装chrome，部分客户对扫描控件进行了定制我们PDT如何面对这些问题？面对客户的抱怨，面对实施的抱怨，我们如何思考？最后我建议了学习360的方法，将插件包碎片化，改为多个小安装包，做一个插件包外壳，可以根据需要进行智能判断哪些需要更新升级。但思路到实际开发、部署有哪些值得思考的呢？1.智能判断升级是放在登录页面，但部分客户是单点登录的，没有登录页面，没有考虑此问题，其实大家都知道是有单点登录需求客户的，为什么没人去想这个问题？谁该去想？2.小版本发布会后我问产品经理类似三菱电梯客户不要安装chrome插件，实施如何配置呢？产品经理不知道。那实施人员应该去问谁呢？这也是易用性问题，实施易用性也是问题。建议有二：版本发布文档中进行描述说明；实施专用页面中去说明3.拆分成多个插件后360的信任拦截也改为了多次，致使部分插件无法运行，如何解决？如果是先将版本号写入注册表，即使下次登录也不会再安装部署了。此文的目的是我们不能只注重功能的开发，要站在用户角度去思考碰到这些复杂的环境如何应对，多想想可能在实施给客户升级或部署时实施会碰到什么问题,2013/7/16
904,案例说产品意识和用户体验为中心之桌面精灵,李志卿,http://180.168.156.212:2262/wecenter/?/article/8378,光典档案软件在产品总监号召下开发了桌面精灵小工具，使用户不用打开ie，开机即可知道代办事项和检索，想法不错，但从构思到实际用户使用半年时间了，没有一个用户实际使用起来，这过程中本人觉得有很多值得深思的问题。我想给售前用户秀一下，找不到要下载的地方。我们PDT团队各司其职，好像都没错。是啊，谁应该考虑，开发好这个工具后的事情呢？A.如果是免费送给所有客户，那么就可以打包在客户端插件包中，为什么没有人提出？B.对于已经部署的客户要使用，是否应在升级包中将其放入常用下载，用户需要时即可下载？是不是还有更好的方式？比如类似wotalk组的新功能提醒？此文的目的是PDT组在筹划一个功能时，不能只考虑功能实现，要考虑如何站在实施角度去思考如何部署，如何升级，站在用户角度如何快速获取这些功能。其实也包含我们的测试人员，也应该敢于直面PDT，以一个用户角度去考虑如何使用这些功能，而不是测试功能本身。产品安装包测试也是重要一项。,2013/7/16
905,优化页面加载，压缩js、css文件，减少加载线程的神器。,陈雷,http://180.168.156.212:2262/wecenter/?/article/8377," CompressServlet/combined.css5.Puttagsaroundthelistsofscriptdecorations(JSorCSS).Forexample-...<br/>goog.require('goog.dom');<br/>goog.require('goog.date');<br/>goog.require('goog.ui.DatePicker');<br/><br/>vardp=newgoog.ui.DatePicker();<br/>dp.render(document.getElementById('datepicker'));<br/>...6.Done.Runyourwebapplicationandcheckoutputhtmlsource.ItshouldconvertCSSandJSdeclarationssimilartothis.href=""/combined.css?id=cc4c21b0""/>",2013/7/14
906,关于扁平化界面风格的设计美学讨论,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8376,原文地址： /manage/2...shtml部分段落摘要：之前看到过一句话，大意是，Metro风格让人看到未来，而拟物化则让人感觉像是回到家里一样。说的挺不错的；人不可能一直呆在家里，也无法始终飘逸洒脱的在外面寻求新鲜与未来感。我喜欢听真人使用真实乐器演奏的音乐，但这不妨碍我偶尔听听电子的东西。什么是扁平化设计在实际当中，“扁平化设计”一词所指的是抛弃那些已经流行多年的渐变、阴影、高光等拟真视觉效果，从而打造出一种看上去更“平”的界面。对拟物化的逆袭正如20世纪建筑界当中的极简主义运动，扁平化设计风格的逐渐兴起也可以被看作是对多年以来过度设计、过度雕琢的界面风格的逆袭；尤其是最近一段时间，苹果一直以来的拟物风格被诟病的蛮犀利的。关于扁平化界面风格的设计美学讨论-站长之家.mht关于扁平化界面风格的设计美学讨论（3）-站长之家.mht关于扁平化界面风格的设计美学讨论（2）-站长之家.mht,2013/7/12
907,Windows 8满月了：市场反响综述,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8375,微软的市场统治力大不如前，PC市场更是江河日下，windows8的前景不容乐观Windows8满月了：市场反响综述.mht,2013/7/12
908,迅雷BOLT界面引擎,王链玮,http://180.168.156.212:2262/wecenter/?/article/8374,"这两天在梳理灵器工具时,关于界面美观性方面的完善有了一个可以研究研究的方向迅雷BOLT界面引擎迅雷7作为全球市场占有率第一的迅雷下载软件的最新一代产品，其市场占有率已经超过了85%,Bolt界面引擎在开发过程中对控制开发成本，减少开发周期等方面起了非常大的作用。据不完全统计，采用了Bolt界面引擎的迅雷7，与前一个版本相比，在保证原有功能并重新设计了全部界面的基础上，仅用了3.5个月的时间就开发出了第一个可用的Demo，代码量比迅雷5.9减少了至少40%，平均每个需求的修改成本也由原来的0.8小时降低到了0.3小时。在交互性，可维护性上都有了巨大的进步。“Bolt界面引擎让开发效率提高了一倍以上。”-----------迅雷7技术总负责人 /p/bolt-for-delphi/",2013/7/11
909,软件开发人员应具有产品意识,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8373,产品意识是一种产品理念，它是希望我们做任何事情的时候，能够从产品的角度来思考问题，用做产品的思维来指导工作。认为产品能否卖得出去是销售的事情，和技术部门无关的思想绝对是错误的。产品生产流水线任何一个环节上的人都应该站在用户的角度思考问题。软件开发人员应具有产品意识.docx,2013/7/10
910,余承东：苹果已落伍 三星靠广告卖平庸手机,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8372,余承东是华为狼性文化的代表人物，目前差不多已经取代任正非成为媒体曝光率最高的华为高管。尽管他所负责的终端事业部目前还处于亏本状态，但已经拽得不得了了。不过最新发布的HuaweiP6智能机用下来确实还不错余承东：苹果已落伍三星靠广告卖平庸手机.mht,2013/7/5
911,基于PhoneGap与Java开发的Android应用的性能对比,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8371,附件里面是我在网上找的一篇关于PhoneGap与JAVA开发应用的性能对比分析，有兴趣的可以下下来看看。基于PhoneGap与Java开发的Android应用的性能对比.docx,2013/7/5
912,tomcat虚拟目录映射网络共享目录的问题,方俊新,http://180.168.156.212:2262/wecenter/?/article/8370,查了一些资料，有些说是由于windows2003哪个服务屏蔽administrator访问网络映射驱动器的权限。解决tomcat访问网络映射盘问题有两种方式：一、就是不采用服务方式，运行startup.bat二、通过将docbase指向共享目录的UNCpath即远程访问方式[Show?]方俊新-2013-07-0406:02下午查了一些资料，有些说是由于windows2003哪个服务屏蔽administrator访问网络映射驱动器的权限。解决tomcat访问网络映射盘问题有两种方式：一、就是不采用服务方式，运行startup.bat二、通过将docbase指向共享目录的UNCpath即远程访问方式tomcat虚拟目录映射网络共享目录的问题.docx,2013/7/5
913,PhoneGap技术探索,杨世亮,http://180.168.156.212:2262/wecenter/?/article/8369,"1.什么是PhoneGapPhoneGap是一个自由开放源码的开发工具和框架，允许利用HTML+JavaScript+CSS的强大功能在多个手机平台上开发程序,开发出来的程序经过在各自的平台上编译形成独立的安装程序。使程序看起来和native的程序一样。2.PhoneGap的优势和劣势优势：?跨平台：一次开发，多个平台共用。现主要包括了android，iOS，AppleiOS,GoogleAndroid,Palm,Symbian,BlackBerry等。WP7等平台也在逐步兼容中。?降低开发门槛。对于很多WEB开发人员来说，熟悉Objective-C语言和Java语言都是比较痛苦的事情。有了PhoneGap就不用担心这些了。用熟悉的Web前端技术就可以开发出很专业的手机应用程序。?提供强大的硬件访问控制。比起传统的Web程序，PhoneGap提供了一些列的JS的类，可以直接访问硬件。比如加速，相机，指南针，GPS，文件访问等，可以让你用JS方便地调用系统的硬件。以弥补传统Web程序的一块错误。?方便的安装和使用。PhoneGap的架构很复杂，但对于大多数开发者来说，只用很简单的配置就可以搭好环境。只用专注写好自己的Web页面，拷贝进去就可以了。劣势：?运行速度慢：程序的载入和UI界面的反应都比原生的程序慢，因为它实际上还是在展示Web页面，所以载入、页面刷新等肯定是需要一定时间的。?不适合部分程序。如果你的程序需要3D功能，或者对界面刷新有较高的要求，这样的程序现在来说还只是用原生的语言会比较好。3.PHONEGAP开发需要的基本知识?HTML：做为最基本的Web开发，HTML知识必不可少。现在很多移动终端已经支持HTML5了，所以最好学会HTML5相关的知识；?CSS：定义的页面的样式等等，不用CSS，你的页面会很难控制定位和样式等等。建议能掌握CSS3的相关知识，能写出更好的界面；?JavaScript：后台的交互都由JavaScript实现，读写数据库，载入GoogleMap等等；?PhoneGap的类库：都是JavaScript的库，使用很简单，有详细文档，可以参考官网： pany.cxwjHelloWorld[/color](这里的意思是在桌面上创建一个项目名称为HellWorld的工程的文件夹）3.在终端中直接cd回到原始默认路径。然后进入我们桌面文件夹的cordova路径。在该路径下执行$./build直到你看到成功字样。4.这时候打开桌面上你创建的demo文件夹。然后用xcode打开里边的demo工程，用虚拟机运行一下如果看到下图你就成功了。5.接下来我们继续看工程。Xcode左边的树形结构应该是这个样子。看到www文件夹了吧这里边就是你的HTML5的程序所在了。以上就是PhoneGap环境搭建了。祝大家顺利。",2013/7/2
914,用tbody代替div 解决 table tr的隐藏问题,余礼华,http://180.168.156.212:2262/wecenter/?/article/8368,有这样一个需求，需要控制一个table内几个tr的显示问题。如下图，点击“案卷”，只显示1~6行，点击“卷内”，只显示7~12行，点击“文件”，显示13行。一开始的想法是，在tr标签外套上div标签，利用div的display:none属性来解决，但试了之后发现无效果。后来换用tbody标签，可以实现。,2013/7/2
915,关于document.cookie的使用,余礼华,http://180.168.156.212:2262/wecenter/?/article/8367,"设置cooki：每个cookie都是一个名/值对，可以把下面这样一个字符串赋值给document.cookie：document.cookie=""userId=828"";若要设置多个cookie，则需要多次使用document.cookie方法。示例如下：document.cookie=""key1=escape(value1)"";document.cookie=""key2=escape(value2)"";而不是将两个cookie值连在一起，document.cookie=""key1=escape(value1);key2=escape(value2)"";这样的写法是错误的。在cookie的名或值中不能使用分号（;）、逗号（,）、等号（=）以及空格。在cookie的名中做到这点很容易，但要保存的值是不确定的。如何来存储这些值呢？方法是用escape()函数进行编码，它能将一些特殊符号使用十六进制表示，例如空格将会编码为“20%”，从而可以存储于cookie值中，而且使用此种方案还可以避免中文乱码的出现。例如：document.cookie=""str=""+escape(""Iloveajax"");相当于：document.cookie=""str=I%20love%20ajax"";当使用escape()编码后，在取出值以后需要使用unescape()进行解码才能得到原来的cookie值，这在前面已经介绍过。尽管document.cookie看上去就像一个属性，可以赋不同的值。但它和一般的属性不一样，改变它的赋值并不意味着丢失原来的值，例如连续执行下面两条语句：document.cookie=""userId=828"";document.cookie=""userName=hulk"";这时浏览器将维护两个cookie，分别是userId和userName，因此给document.cookie赋值更像执行类似这样的语句：document.addCookie(""userId=828"");document.addCookie(""userName=hulk"");事实上，浏览器就是按照这样的方式来设置cookie的，如果要改变一个cookie的值，只需重新赋值，例如：document.cookie=""userId=929"";这样就将名为userId的cookie值设置为了929。获取cookie的值下面介绍如何获取cookie的值。cookie的值可以由document.cookie直接获得：varstrCookie=document.cookie;这将获得以分号隔开的多个名/值对所组成的字符串，这些名/值对包括了该域名下的所有cookie。由此可见，只能够一次获取所有的cookie值，而不能指定cookie名称来获得指定的值，这正是处理cookie值最麻烦的一部分。用户必须自己分析这个字符串，来获取指定的cookie值，例如，要获取userId的值，可以这样实现：这样就得到了单个cookie的值用类似的方法，可以获取一个或多个cookie的值，其主要的技巧仍然是字符串和数组的相关操作。给cookie设置终止日期到现在为止，所有的cookie都是单会话cookie，即浏览器关闭后这些cookie将会丢失，事实上这些cookie仅仅是存储在内存中，而没有建立相应的硬盘文件。在实际开发中，cookie常常需要长期保存，例如保存用户登录的状态。这可以用下面的选项来实现：document.cookie=""userId=828;expires=GMT_String"";其中GMT_String是以GMT格式表示的时间字符串，这条语句就是将userId这个cookie设置为GMT_String表示的过期时间，超过这个时间，cookie将消失，不可访问。删除cookie为了删除一个cookie，可以将其过期时间设定为一个过去的时间。指定可访问cookie的路径默认情况下，如果在某个页面创建了一个cookie，那么该页面所在目录中的其他页面也可以访问该cookie。如果这个目录下还有子目录，则在子目录中也可以访问。例如在www.xxxx.com/html/a.html中所创建的cookie，可以被www.xxxx.com/html/b.html或www.xxx.com/html/some/c.html所访问，但不能被www.xxxx.com/d.html访问。为了控制cookie可以访问的目录，需要使用path参数设置cookie，语法如下：document.cookie=""name=value;path=cookieDir"";其中cookieDir表示可访问cookie的目录。例如：document.cookie=""userId=320;path=/shop"";就表示当前cookie仅能在shop目录下使用。如果要使cookie在整个网站下可用，可以将cookie_dir指定为根目录，例如：document.cookie=""userId=320;path=/"";指定可访问cookie的主机名和路径类似，主机名是指同一个域下的不同主机，例如：www.google.com和gmail.google.com就是两个不同的主机名。默认情况下，一个主机中创建的cookie在另一个主机下是不能被访问的，但可以通过domain参数来实现对其的控制，其语法格式为：document.cookie=""name=value;domain=cookieDomain"";以google为例，要实现跨主机访问，可以写为：document.cookie=""name=value;domain=.google.com"";这样，所有google.com下的主机都可以访问该cookie。综合示例：构造通用的cookie处理函数cookie的处理过程比较复杂，并具有一定的相似性。因此可以定义几个函数来完成cookie的通用操作，从而实现代码的复用。下面列出了常用的cookie操作及其函数实现。1．添加一个cookie：addCookie(name,value,expiredays)该函数接收3个参数：cookie名称，cookie值，以及在多长时间后过期。该函数实现如下：functionaddCookie(name,value,expiredays){varexdate=newDate();exdate.setDate(exdate.getDate()+expiredays);document.cookie=name+""=""+escape(value)+((expiredays==null)?"""":"";expires=""+exdate.toGMTString())+""path=/"";}2．获取指定名称的cookie值：getCookie(name)该函数返回名称为name的cookie值，如果不存在则返回空，其实现如下：functiongetCookie(name){vararr=document.cookie.match(newRegExp(""(^|)""+name+""=([^;]*)(;|$)""));if(arr!=null){returnunescape(arr[2]);}returnnull;}3．删除指定名称的cookie：deleteCookie(name)该函数可以删除指定名称的cookie，其实现如下：functiondeleteCookie(name){varexp=newDate();exp.setTime(exp.getTime()-1);varcval=getCookie(name);if(cval!=null){document.cookie=name+""=""+cval+"";expires=""+exp.toGMTString();}}",2013/7/2
916,socket上传问题,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8366,"问题描述：通过socket上传，客户端发送文件数据，服务器端接收数据。性能过慢，一个30mb的文件大概要要5分钟（本机上传）。问题解决：原始代码：客户端代码：/fileSize文件大小//out网络输出流//fis文件输入流for(inti=0;iout.write(fis.read());}服务器端代码：//fileSize文件大小//in网络输入流//raf随机文件写入器for(inti=0;i<fileSize;i++){//System.out.println(""i=""+i);//intwork=newLong(i*100/fileSize).intValue();raf.write(in.read());}代码特点：单字节发送接收写入改进方案1：客户端代码byte[]buffer=newbyte[1024*8];intreadCount=0;while(true){readCount=in.read(buffer);if(readCount==-1){break;}raf.write(buffer,0,readCount);}服务器端代码：byte[]buf=newbyte[1024*8];intnum=0;intreadSize=0;while((num=fos.read(buf))!=(-1)){//是否读完文件if(num!=-1){out.write(buf,0,num);//把文件数据写出网络缓冲区buf=null;buf=newbyte[1024*8];}out.flush();//刷新缓冲区把数据写往服务器端}代码特点：没有考虑同步问题，会导致通信中断改进方案2：客户端代码byte[]buffer=newbyte[1024*8];intreadSize=0;intreadCount=0;while(readSizereadCount=in.read(buffer);if(readCount==-1){break;}readSize+=readCount;out.writeInt(readSize);out.flush();raf.write(buffer,0,readCount);}服务器端：byte[]buf=newbyte[1024*8];intnum=0;intreadSize=0;while((num=fos.read(buf))!=(-1)||readSize<fileSize){//是否读完文件if(num!=-1){out.write(buf,0,num);//把文件数据写出网络缓冲区buf=null;buf=newbyte[1024*8];}out.flush();//刷新缓冲区把数据写往服务器端readSize=in.readInt();}",2013/7/2
917,网络爬虫,党刚,http://180.168.156.212:2262/wecenter/?/article/8365,"网络爬虫是捜索引擎抓取系统的重要组成部分。爬虫的主要目的是将互联网上的网页下载到本地形成一个或联网内容的镜像备份。这篇博客主要对爬虫以及抓取系统进行一个简单的概述。一、网络爬虫的基本结构及工作流程一个通用的网络爬虫的框架如图所示：网络爬虫的基本工作流程如下：1.首先选取一部分精心挑选的种子URL；2.将这些URL放入待抓取URL队列；3.从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。4.分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。二、从爬虫的角度对互联网进行划分对应的，可以将互联网的所有页面分为五个部分：1.已下载未过期网页2.已下载已过期网页：抓取到的网页实际上是互联网内容的一个镜像与备份，互联网是动态变化的，一部分互联网上的内容已经发生了变化，这时，这部分抓取到的网页就已经过期了。3.待下载网页：也就是待抓取URL队列中的那些页面4.可知网页：还没有抓取下来，也没有在待抓取URL队列中，但是可以通过对已抓取页面或者待抓取URL对应页面进行分析获取到的URL，认为是可知网页。5.还有一部分网页，爬虫是无法直接抓取下载的。称为不可知网页。三、抓取策略在爬虫系统中，待抓取URL队列是很重要的一部分。待抓取URL队列中的URL以什么样的顺序排列也是一个很重要的问题，因为这涉及到先抓取那个页面，后抓取哪个页面。而决定这些URL排列顺序的方法，叫做抓取策略。下面重点介绍几种常见的抓取策略：1.深度优先遍历策略深度优先遍历策略是指网络爬虫会从起始页开始，一个链接一个链接跟踪下去，处理完这条线路之后再转入下一个起始页，继续跟踪链接。我们以下面的图为例：遍历的路径：A-F-GE-H-IBCD2.宽度优先遍历策略宽度优先遍历策略的基本思路是，将新下载网页中发现的链接直接插入待抓取URL队列的末尾。也就是指网络爬虫会先抓取起始网页中链接的所有网页，然后再选择其中的一个链接网页，继续抓取在此网页中链接的所有网页。还是以上面的图为例：遍历路径：A-B-C-D-E-FGHI出的链接，也就是我们之前提到的未知网页那一部分，暂时是没有PageRank值的。为了解决这个问题，会给这些页面一个临时的PageRank值：将这个网页所有入链传递进来的PageRank值进行汇总，这样就形成了该未知页面的PageRank值，从而参与排序。下面举例说明：四、需要的jar包：五、核心源代码1.定义队列publicclassLinkQueue{//已访问的url集合privatestaticSetvisitedUrl=newHashSet();//待访问的url集合privatestaticQueueunVisitedUrl=newPriorityQueue();//获得URL队列publicstaticQueuegetUnVisitedUrl(){returnunVisitedUrl;}//添加到访问过的URL队列中publicstaticvoidaddVisitedUrl(Stringurl){visitedUrl.add(url);}//移除访问过的URLpublicstaticvoidremoveVisitedUrl(Stringurl){visitedUrl.remove(url);}//未访问的URL出队列publicstaticObjectunVisitedUrlDeQueue(){returnunVisitedUrl.poll();}//保证每个url只被访问一次publicstaticvoidaddUnvisitedUrl(Stringurl){if(url!=null&&!url.trim().equals("""")&&!visitedUrl.contains(url)&&!unVisitedUrl.contains(url))unVisitedUrl.add(url);}//获得已经访问的URL数目publicstaticintgetVisitedUrlNum(){returnvisitedUrl.size();}//判断未访问的URL队列中是否为空publicstaticbooleanunVisitedUrlsEmpty(){returnunVisitedUrl.isEmpty();}}2.初始化URL队列/***使用种子初始化URL队列*@return*@paramseeds种子URL*/privatevoidinitCrawlerWithSeeds(String[]seeds){for(inti=0;iLinkQueue.addUnvisitedUrl(seeds[i]);}3.下载网页privatestaticHttpClienthttpClient=newHttpClient();//设置代理服务器static{//设置代理服务器的IP地址和端口httpClient.getHostConfiguration().setProxy(""172.17.18.84"",8080);}publicstaticbooleandownloadPage(Stringpath)throwsHttpException,Exception{InputStreaminput=null;OutputStreamoutput=null;//得到post方法PostMethodpostMethod=newPostMethod(path);//设置post方法的参数/**NameValuePair[]postData=newNameValuePair[2];postData[0]=new*NameValuePair(""name"",""lietu"");postData[1]=new*NameValuePair(""password"",""*****"");*postMethod.addParameters(postData);*///执行，返回状态码intstatusCode=httpClient.executeMethod(postMethod);//针对状态码进行处理(简单起见，只处理返回值为200的状态码)if(statusCode==HttpStatus.SC_OK){input=postMethod.getResponseBodyAsStream();//得到文件名Stringfilename=path.substring(path.lastIndexOf('/')+1);//获得文件输出流output=newFileOutputStream(filename);//输出到文件inttempByte=-1;while((tempByte=input.read())>0){output.write(tempByte);}//关闭输入输出流if(input!=null){input.close();}if(output!=null){output.close();}returntrue;}//若需要转向，则进行转向操作if((statusCode==HttpStatus.SC_MOVED_TEMPORARILY)||(statusCode==HttpStatus.SC_MOVED_PERMANENTLY)||(statusCode==HttpStatus.SC_SEE_OTHER)||(statusCode==HttpStatus.SC_TEMPORARY_REDIRECT)){//读取新的URL地址Headerheader=postMethod.getResponseHeader(""location"");if(header!=null){StringnewUrl=header.getValue();if(newUrl==null||newUrl.equals("""")){newUrl=""/"";//使用post转向PostMethodredirect=newPostMethod(newUrl);//发送请求，做进一步处理。。。。。}}}returnfalse;}4.抓取过程/***抓取过程*@return*@paramseeds*/publicvoidcrawling(String[]seeds){//定义过滤器，提取以 returntrue;elsereturnfalse;}};//初始化URL队列initCrawlerWithSeeds(seeds);//循环条件：待抓取的链接不空且抓取的网页不多于1000while(!LinkQueue.unVisitedUrlsEmpty()&&LinkQueue.getVisitedUrlNum()<=1000){//队头URL出队列StringvisitUrl=(String)LinkQueue.unVisitedUrlDeQueue();if(visitUrl==null)continue;DownLoadFiledownLoader=newDownLoadFile();//下载网页downLoader.downloadFile(visitUrl);//该url放入到已访问的URL中LinkQueue.addVisitedUrl(visitUrl);//提取出下载网页中的URLSetlinks=HtmlParserTool.extracLinks(visitUrl,filter);//新的未访问的URL入队for(Stringlink:links){LinkQueue.addUnvisitedUrl(link);}}}5.过滤器筛选出有用的信息//获取一个网站上的链接,filter用来过滤链接publicstaticSetextracLinks(Stringurl,LinkFilterfilter){Setlinks=newHashSet();try{Parserparser=newParser(url);parser.setEncoding(""utf-8//过滤标签的filter，用来提取frame标签里的src属性所表示的链接NodeFilterframeFilter=newNodeFilter(){publicbooleanaccept(Nodenode){if(node.getText().startsWith(""framesrc="")){returntrue;}else{returnfalse;}}};//OrFilter来设置过滤标签，和标签OrFilterlinkFilter=newOrFilter(newNodeClassFilter(LinkTag.class),frameFilter);//得到所有经过过滤的标签NodeListlist=parser.extractAllNodesThatMatch(linkFilter);for(inti=0;i<list.size();i++){Nodetag=list.elementAt(i);if(taginstanceofLinkTag)//标签{LinkTaglink=(LinkTag)tag;StringlinkUrl=link.getLink();//urlif(filter.accept(linkUrl))links.add(linkUrl);}else//标签{//提取frame里src属性的链接如Stringframe=tag.getText();intstart=frame.indexOf(""src="");frame=frame.substring(start);intend=frame.indexOf("""");if(end==-1)end=frame.indexOf("">"");StringframeUrl=frame.substring(5,end-1);if(filter.accept(frameUrl))links.add(frameUrl);}}}catch(ParserExceptione){e.printStackTrace();}returnlinks;}",2013/7/2
918,Hibernate 先get 一个实体数据，在修改数据，为新的数据，再add到数据库，需要注意什么？,谢霞琴,http://180.168.156.212:2262/wecenter/?/article/8364,"做一个很简单的save操作的是，定位我一个小时，通过get到数据，代码如下WorkSheetworkSheet=hibernateTemplate.get(WorkSheet.class,newInteger(id));然后对WorkSheet进行修改些字段值，并且把主键设置为null了，这样就新增一条数据了。以为几秒的事，然后兴高采烈的调用save，但是save的时候却出现，主键不能设置为空的异常，Ok我又重新new了一个WorkSheet对象，把数据重新构建了一下，这样我想估计Ok了吧。结果是OK了，新增了一条数据，但是多了一条SQL，就是执行update，把一开始获取到的数据更新了，也就是数据库中出现俩条一模一样的数据了（只是主键不一样）。后来一想估计是一开始的old对象是在session中取得的，所以这个对象已经和数据库同步了，或者说相关联了，那么修改，在spring事务提交，也会同时提交这个数据吧。然后我就为WorkSheet这个JavaBean写了个clone方法，我先clone一个，然后再修改clone过来的数据，测试了一下，终于OK了。总结：从getHibernateTemplate().ge(WorkSheet.class,newInteger(id));中get到的数据，不要直接修改它的值，这样spring事务提交的时候，会update初始的数据。如果要修改，请修改clone过来的数据getHibernateTemplate().get(WorkSheet.class,newInteger(id));中get到的对象已经被hibernate托管了，是持久化状态对象，在后续的操作中即便没有调用update操作，只要对其属性做修改，就会更新此对象属性。如果要save新的对象，需要通过new操作创建新的对象，而不是引用get方法得到的数据。hibernate中对象生命周期，自由态，持久态，游离态",2013/7/2
919,JAVA获取路径,丁凯,http://180.168.156.212:2262/wecenter/?/article/8363,"在JSP、Servlet、Java中获取详细路径的的常见方法。假设现在有一个项目，项目名为java_path,有一个jsp文件test.jsp.一、在JSP中获取文件的路径：1）得到包含工程名的当前页面的全路径：request.getRequestURI()结果：/java_path/test.jsp2)得到工程名：request.getContextPath()结果：/java_path3)得到当前页面所在目录下全名称：request.getServletPath()结果：如果页面在jsp目录下,/java_path/jsp/test.jsp4)得到页面所在服务器的全路径：application.getRealPath(""test.jsp"")结果：D:\tomcat\webapps\java_path\test.jsp5)得到页面所在服务器的绝对路径：absPath=newjava.io.File(application.getRealPath(request.getRequestURI())).getParent();结果：D:\tomcat\webapps\java_path二、在普通java类（非Servlet类，当然Servlet类也适用）中取得路径：1)类的绝对路径：SpecifiedClass.class.getClass().getResource(""/"").getPath()结果：/D:/java_path/WebRoot/WEB-INF/classes/pack/2)得到工程的路径：System.getProperty(""user.dir"")结果：D:\java_path三、在Servlet中取得路径：1)得到工程目录：request.getSession().getServletContext().getRealPath("""")，参数可具体到包名。结果：D:\Tomcat\webapps\java_path2)得到IE地址栏地址，即用户请求的URL：request.getRequestURL()结果： test",2013/7/1
920,一种简单的jsp与ocx插件交互方式,周敏,http://180.168.156.212:2262/wecenter/?/article/8362,为某个Object控件中的指定事件绑定一个js方法技术经验共享201306_周敏.doc,2013/6/28
921,Lucene分组统计,陆开奇,http://180.168.156.212:2262/wecenter/?/article/8360,Bobo-browse是一个基于lucene的搜索结果分组统计开源插件，可以完成对搜索结果的分组面统计。Bobo-browse仅关注搜索，对索引创建与它无关，索引的创建，继续使用标准的Lucene索引创建方法创建。研发中心经验共享_陆开奇[201306].doc,2013/6/28
922,SQL优化,游明磊,http://180.168.156.212:2262/wecenter/?/article/8361,"1：关于SQL语句的优化A:查询的时候不返回不需要的行，列就是尽量不用*来查询。根据数据的要求，适当的控制显示的行数，B:合理使用EXISTS,NOTEXISTS子句SELECTSUM(T1.C1)FROMT1WHERE((SELECTCOUNT(*)FROMT2WHERET2.C2=T1.C2)>0)SELECTSUM(T1.C1)FROMT1WHEREEXISTS(SELECT*FROMT2WHERET2.C2=T1.C2)两种产生相同的结果，但是后者的效率显然要高过于前者。C:充分利用连接条件在某种情况下，两个表之间可能不止一个的连接条件，这时在where字句中将连接条件完整的写上，有可能大大提高查询速度。例a)SELECTSUM(A.AMOUNT)FROMACCOUNTAleftjionCARDBonA.CARD_NO=B.CARD_NOb)、SELECTSUM(A.AMOUNT)FROMACCOUNTAleftjionCARDBonA.CARD_NO=B.CARD_NOANDA.ACCOUNT_NO=B.ACCOUNT_NOD:、WHERE字句中关系运算符的选择a)、在关系运算中，尽量使用=，尽量不要使用<>b)、WHERE字句中尽量不要使用NOT运算符，如：NOTIN,NOTEXISTS,NOT>、NOT10000K可以改为：salary<=100,如避免使用NOTIN,可以使用leftouterjion代替它。c)、where字句中条件表达式间逻辑关系为AND时，将条件为假的概率高的放在前面，概率相同、条件计算简单的放在前面。d)、尽可能不要用Orderby字句。使用Orderby时，尽量减少列数、尽量减少排序数据行数、排序字段尽量是数字型尽量不要是字符型。GROUPBY、SELECTDITINCT、UNION等字句，也经常导致Order运算。e)、不要使用Selectcount(*)方式来判断记录是否存在，建议使用Selecttop1fromtable1where……。g)、避免Select语句的Where字句条件用于假。如：where1=0;h)如果有多表连接时，应该有主从表之分，并尽量从一个表读取数据，如selecta.col1,a.col2fromajionbona.col3=b.col4whereb.col5=’a’.i)、在where字句中，如果有多个过滤条件，应将所有列或过滤记录数量最多的条件应该放在前面。Union将两个结果集合并后，会消除重复记录，而Unionall不会消除重复记录，而是直接将两个结果集直接合并。明确得知两个结果集中没有重复记录或者重复记录不影响使用，建议使用Unionall代替Union。因为Union在消除重复记录的过程中需要进行排序过滤操作，对大结果集这种排序操作会非常影响性能",2013/6/28
923,jsp代码中多余代码注释不完全，导致 js 方法不能正确执行,王桂子,http://180.168.156.212:2262/wecenter/?/article/8359,"一、Jsp文件的注释问题主要有四中方法：1.隐式注释：客户端源代码不可见2.显示注释：）3./**注释内容**/，在里的内容需要注释可使用4.//注释内容如果该jsp文件引入了DTD文件，比如你某个js方法用//这种注释方法注释,而且在该行注释的内容中包含了内容,window.location.href=”/module/manage/a.jsp”，那在该js方法被调用时，该行代码可能会引起意想不到的结果。个人建议在jsp页面中注释使用方式二、导库时视图报错是因为将ORACLE用户SZDA2_SZDAG无权访问ORACLE的另外一个用户(例如SZDA2_AUTH)的表，使用赋权sql语句来解决：grantselectonSZDA2_AUTH.table_nametoSZDA2_SZDAG;给个查询的权限就可以了。这样SZDA2_SZDAG就可以访问你赋权了的SZDA2_AUTH的某个表。",2013/6/28
924,Spring、hibernate处理CLOB字段,宋国梁,http://180.168.156.212:2262/wecenter/?/article/8358,"Spring、hibernate处理CLOB字段1.修改实体类配置：增加@Lob和@Type注解privateStringcontent;@Lob@Type(type=""org.springframework.orm.hibernate3.support.ClobStringType"")@Column(name=""CONTENT"")@PropertyMeta(name=""内容"",orderNo=4)publicStringgetContent(){returncontent;}publicvoidsetContent(Stringcontent){this.content=content;}2.修改spring配置,增加以下配置，并在sessionFactory里引用class=""org.springframework.jdbc.support.nativejdbc.C3P0NativeJdbcExtractor""lazy-init=""true""/>……定义lobHandler时注意oracle的版本，oracle9i使用SimpleNativeJdbcExtractorclass=""org.springframework.jdbc.support.nativejdbc.SimpleNativeJdbcExtractor""/>oracle10g可以使用DefaultLobHandlerclass=""org.springframework.jdbc.support.lob.DefaultLobHandler""lazy-init=""true""/>因为配置数据源时使用的c3p0方式创建的连接池，所以定义lobHandler时使用的是C3P0NativeJdbcExtractor研发中心经验共享_宋国梁[201306].doc",2013/6/28
925,WebSphere非集群环境下的部署方式,白金鹏,http://180.168.156.212:2262/wecenter/?/article/8357,"如题,因为从头到尾都是图所以奉上附件~:mrgreen:研发中心经验共享_白金鹏[201306].doc",2013/6/28
926,解决win2008下使用jdk1.5，时间差8小时的问题,方俊新,http://180.168.156.212:2262/wecenter/?/article/8356,"最近在一个项目中,碰到一个时差问题,也就是用java代码获取系统时间时,时间老与系统时间相差8小时。服务器的环境为：windows2008x64r2，tomcat5.5，jdk1.5。原因：win2008使用UTC时间，而不是GMT时间。java6可以认到，不过不知是用哪种方式认到的。java5认不到，所以无法识别时区,最后获取的时间就有问题。解决方式：打开注册表时区的节点[HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/WindowsNT/CurrentVersion/TimeZones/ChinaStandardTime]添加：MapID=-1,75",2013/6/27
927,“灵光云”杯中信第三届程序设计大赛（UI设计专场）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8355,通过组织本次程序架构设计竞赛，巩固2013年外聘项目经理培训的培训成果，培养软件人员的UI设计能力，丰富产品的UI展示体系，增强软件界面展现能力。请相关参赛人员按照比赛日程和要求安排进行参赛。UI设计大赛评分方法.docUI设计大赛.doc,2013/6/24
928,没有数据备份情况下的truncate数据恢复,路斌,http://180.168.156.212:2262/wecenter/?/article/8354,"一、概述周五接到某项目组寻求支持，用户生产数据库上被truncate一张表。该数据库没有设置闪回，没有设置归档模式。只有一个若干天前的数据库备份。从正常方式上，数据应该不能完全恢复。周末又找了找。国内ORACLE资深专家老熊开发了ODU，可以解决此问题。二、ODUODU全称为OracleDatabaseUnloader,工具虽小但功能挺强大的，通过直接扫描数据文件来获取误删的数据，在某些情况下合理使用能发挥很不错的效果。被Truncate的表，只要原来的空间没有被重用（即数据被覆盖），则数据都是可以恢复的。如果发现一个表被意外地Truncate，而需要马上恢复。首先要做的就是关闭数据库，或者OFFLINE那个表所在的表空间，或者关闭所有应用。目的只有一个，确保空间不会被重用，数据不会被覆盖。A、准备恢复数据库做一个Checkpoint，让ODU能够读到最新的数据字典数据。altersystemcheckpoint;将相关数据文件拷出SYSTEM01.DBFSYSTEM02.DBFODU.ORA将system数据文件位置配置进ODU的control.txt文件：可以预先查询数据字典设置内容：selectd.TS#ts,d.FILE#fno,d.FILE#fno,d.NAMEfilename,d.BLOCK_SIZEblock_sizefromv$datafiledorderbyts;修改filename的路径，将如下内容写入control.txt并保存011D:\odu\SYSTEM01.DBF819201313D:\odu\SYSTEM02.DBF8192161616D:\odu\ODU.ORA8192B、进行恢复点击odu.exe进入命令行界面unload数据字典ODU>unloaddict获取需要恢复的表的信息ODU>descodu.test输出如下：ObjectID:10256Storage(Obj#=10256DataObj#=10257TS#=5File#=5Block#=11Cluster=0)NO.SEGINTColumnNameNull?Type------------------------------------------------------------------------------111IDNUMBER(9)222NAMEVARCHAR2(50)可以看到，odu.test表所在的表空间号为5，数据段头部为5号文件的11号块。dataobjectid为Obj#=10256扫描表空间的extentODU>scanextent输出如下：scanextentstart:2013-06-2216:58:32scanningextent...scanningextentfinished.scanextentcompleted:2013-06-2216:58:33ODU>dumpdatafile5block11dump数据文件数据块unload数据：ODU>unloadtableodu.testobject10256输出如下：Unloadingtable:TEST,objectID:10256Unloadingsegment,storage(Obj#=10256DataObj#=10256TS#=5File#=5Block#=11Cluster=0)1000rowsunloaded执行完后，会在ODU目录的DATA文件夹中生成三个文件（默认生成SQLLDR文件时）：ODU_TEST.ctl控制文件ODU_TEST.txt文本数据文件ODU_TEST.sql表创建的DDL语句使用SQLLDR导入数据D:\odu\data>sqlldrodu/oducontrol=ODU_TEST.ctl至此，数据恢复完成。新版本中支持的更好，恢复命令不需要查询object_data_id：ODU>unloadtableusername.tablenameobjectauto",2013/6/23
929,智能弱电系统厂商品牌排名表,张绩晨,http://180.168.156.212:2262/wecenter/?/article/8353,供大家参考:D:D智能弱电系统厂商品牌排名表.doc,2013/6/21
930,职称计算机免考专业名称清单,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8352,附件为可免考职称计算机的专业名称。毕业证书上的专业必须与清单中的名称完全一致方可免考职称计算机，请留意！计算机免考专业名称清单.doc,2013/6/20
931,EXMOBI   和  CODE4APP [ios],王链玮,http://180.168.156.212:2262/wecenter/?/article/8350,"之前关注的一些ios开发平台和代码库贴出来共享,看到论坛里没有IOS相关板块,就发到这里吧Code4App: p",2013/6/19
932,jBPM5与coflow功能性对比,方俊新,http://180.168.156.212:2262/wecenter/?/article/8349,jBPM5与coflow功能性对比.docx,2013/6/17
933,关于室内WIFI定位,路斌,http://180.168.156.212:2262/wecenter/?/article/8347,1、Wi-Fi定位的原理a、是采用三角定位的方式，也就是通过移动设备和三个无线网络热点的无线信号交流，以便识别移动设备目前所在的位置。b、通过移动设备周围所有的WIFI热点（不需要连接上，只需要有信号就行），获得它们的MAC地址，然后到服务器查询这个热点是否已经登记，它的位置是多少，最后通过计算（多个热点折中）得到当前位置并返回给用户。2、当网络热点分布的越密集，定位的精确度就越高。3、基于移动设备实现定位实质是基于信号强度的定位方案。参考文档1、 ,2013/6/16
934,windows查看端口占用,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8346,windows查看端口占用未命名.bmp,2013/6/13
935,删除Oracle中重复数据,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8348,"1、查找表中多余的重复记录，重复记录是根据单个字段（id）来判断select*fromt_testwhereidin(selectidfromt_testgroupbyidhavingcount(id)>1)2、删除表中多余的重复记录，重复记录是根据单个字段（id）来判断，只留有rowid最小的记录deletefromt_testwhereidin(selectidfromt_testgroupbyidhavingcount(id)>1)androwidnotin(selectmin(rowid)fromt_testgroupbyidhavingcount(id)>1)3、查找表中多余的重复记录（多个字段Id，name）select*fromt_testawhere(a.name,a.id)in(selectname,idfromt_testgroupbyname,idhavingcount(*)>1)4、删除表中多余的重复记录（多个字段Id，name），只留有rowid最小的记录deletefromt_testawhere(a.name,a.id)in(selectname,idfromt_testgroupbyname,idhavingcount(*)>1)androwidnotin(selectmin(rowid)fromt_testgroupbyname,idhavingcount(*)>1)",2013/6/13
936,Lucene索引库的简单优化,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8345,"根据实际情况对索引库进行优化，可以提升创建索引和搜索的速度。1、合并索引库片段文件IndexWriter的optimize()方法已经过时，因为这个方法的效率很低。合并文件主要是使用IndexWriter的setMergeFactor(int)方法，但是在Lucene3.6版本中，该方法已过时，直接使用LogMergePolicy.setMergeFactor(int)方法代替。当setMergeFactor(int)的参数值较小的时候，创建索引的速度较慢。当参数值较大的时候，创建索引的速度就比较快。大于10适合批量创建索引。2、内存索引目录和文件系统索引目录结合使用内存索引目录的操作速度非常快，所以我们在操作索引的时候可以把索引库从文件系统加载到内存中，操作完成后再写回文件系统。内存中的索引文件写回到文建系统中的时候，我们需要对索引目录进行重建。比如原来文件系统中的索引目录有10个文件，加载到内存目录的时候是把10个文件拷贝一份到内存，然后我们添加了一个索引文件，内存中的索引目录文件数就变成11个，写会到文件系统的时候，内存索引目录文件数(11个)加上原来文件系统索引目录的文件数(10)就变成21个了，有10个文件是重复了，所以我们需要删除原来文件系统中的索引目录重新创建。但是如果索引库是巨大的，不建议使用，因为所需的内存很大。3、实现代码。/***索引库的优化*@authorLuxh*/publicclassIndexOptimizeTest{//分词器privateAnalyzeranalyzer;//索引存放目录privateDirectorydirectory;/***初始化Analyzer和Directory*@throwsIOException*/@Beforepublicvoidbefore()throwsIOException{//建立一个标准分词器//Version.LUCENE_36表示匹配Lucene3.6版本analyzer=newStandardAnalyzer(Version.LUCENE_36);//在当前路径下建立一个目录叫indexDirFileindexDir=newFile(""./indexDir"");//创建索引目录directory=FSDirectory.open(indexDir);}/***内存索引目录和文件系统索引目录结合*@throwsIOException*/@TestpublicvoidtestDirectoryCombination()throwsIOException{//创建内存索引目录，把文件系统中的索引库加载进来RAMDirectoryramDirectory=newRAMDirectory(directory);IndexWriterConfigramIndexWriterConfig=newIndexWriterConfig(Version.LUCENE_36,analyzer);IndexWriterramIndexWriter=newIndexWriter(ramDirectory,ramIndexWriterConfig);Bookbook=newBook();book.setId(1);book.setTitle(""建筑的永恒之道"");book.setAuthor(""亚历山大"");book.setContent(""《建筑的永恒之道》提出了一个关于建筑设计、建筑和规划的新的理论、思想，该理论的核心是社会成员按照他们自己的存在状态设定他们生活的世界秩序，这一古老方式从根本上构成了新的后工业时代建筑的基础，这些建筑由人们创造。"");//建立DocumentDocumentdoc=newDocument();//Store指定Field是否需要存储,Index指定Field是否需要分词索引doc.add(newField(""id"",book.getId().toString(),Store.YES,Index.NOT_ANALYZED));doc.add(newField(""title"",book.getTitle(),Store.YES,Index.ANALYZED));doc.add(newField(""author"",book.getAuthor(),Store.YES,Index.ANALYZED));doc.add(newField(""content"",book.getContent(),Store.YES,Index.ANALYZED));ramIndexWriter.addDocument(doc);ramIndexWriter.close();IndexWriterConfigfsIndexWriterConfig=newIndexWriterConfig(Version.LUCENE_36,analyzer);//创建新的索引目录或者覆盖原来的索引目录fsIndexWriterConfig.setOpenMode(OpenMode.CREATE);IndexWriterfsIndexWriter=newIndexWriter(directory,fsIndexWriterConfig);//把内存中的索引库写到文件系统中fsIndexWriter.addIndexes(ramDirectory);fsIndexWriter.close();}}",2013/6/13
937,"oracle11g  exp 碰到ORA-00904: ""MAXSIZE"": invalid identifier",路斌,http://180.168.156.212:2262/wecenter/?/article/8344,"一、问题概述今天一同事导入导出碰到问题，[color=red]EXP-00008:遇到ORACLE错误904ORA-00904:""MAXSIZE"":invalididentifier[/color]原因：[color=blue]他的客户端数据库版本是11.0.1.7，服务器数据库版本是10.2.0.1，MAXSIZE为11g中新引入的列[/color]二、具体原因#10gOracleDatabase10gEnterpriseEditionRelease10.2.0.1.0–64bitProductionWiththePartitioning,OLAPandDataMiningoptionsSQL>descsys.exu9tbs名称是否为空?类型—————————————–——–—————————-IDNOTNULLNUMBEROWNERCHAR(6)NAMENOTNULLVARCHAR2(30)ISONLINEVARCHAR2(7)CONTENTVARCHAR2(9)INIEXTNOTNULLNUMBERSEXTNOTNULLNUMBERPCTINCNOTNULLNUMBERMINEXTNOTNULLNUMBERMAXEXTNOTNULLNUMBERMINLENNUMBERDEFLOGNOTNULLNUMBEREXT_MGTNOTNULLNUMBERALLOC_TYPENOTNULLNUMBERBLOCKSIZENOTNULLNUMBER#11gOracleDatabase11gEnterpriseEditionRelease11.1.0.7.0–ProductionWiththePartitioning,OLAPandRealApplicationTestingoptionsSQL>descsys.exu9tbs名称是否为空?类型—————————————–——–————————-IDNOTNULLNUMBEROWNERCHAR(6)NAMENOTNULLVARCHAR2(30)ISONLINEVARCHAR2(7)CONTENTVARCHAR2(9)INIEXTNOTNULLNUMBERSEXTNOTNULLNUMBERPCTINCNOTNULLNUMBERMINEXTNOTNULLNUMBERMAXEXTNOTNULLNUMBERMINLENNUMBERDEFLOGNOTNULLNUMBEREXT_MGTNOTNULLNUMBERALLOC_TYPENOTNULLNUMBERBLOCKSIZENOTNULLNUMBER[color=red]MAXSIZENUMBER———>问题在这里[/color]三、exp和imp规则：[color=blue]规则1：低版本的exp/imp可以连接到高版本（或同版本）的数据库服务器，但高版本的exp/imp不能连接到低版本的数据库服务器;规则2：高版本exp出的dmp文件，低版本无法imp（无法识别dmp文件）；低版本exp出的dmp文件，高版本可以imp（向下兼容）;规则3：从Oracle低版本Export的数据可以Import到Oracle高版本中，但限于Oracle的相邻版本，如从Oracle10到Oracle11。对于两个不相邻版本间进行转换，如从Oracle9到Oracle11，则应先将数据输入到中间版本—Oracle10，再从中间数据库转入更高版本Oracle11。[/color]",2013/6/11
938,Oracle Flashback Data Archive应用，实现表的历史数据秒级查询及恢复,路斌,http://180.168.156.212:2262/wecenter/?/article/8351,"一、概述在公司内部信息化上线后，先后碰到几次业务部门误删数据，请求IT部门恢复数据，基于传统归档恢复数据手段，比较耗费时间。IT研发组采用了oracle11g中的OracleFlashbackDataArchive技术解决此问题，[color=red]可以实现秒级恢复数据[/color]。二、技术介绍Flashback技术是以Undosegment中的内容为基础的，因此受限于UNDO_RETENTON参数,过了一定的时间数据还是不能保留。要使用flashback的特性，必须启用自动撤销管理表空间。在Oracle11g里又出了一个新特性：OracleFlashbackDataArchive.FDA通过将变化数据另外存储到创建的闪回归档区（FlashbackArchive）中，以和undo区别开来，这样就可以为闪回归档区单独设置存储策略，使之可以闪回到指定时间之前的旧数据而不影响undo策略。闪回数据归档区是一个逻辑概念，是从一个或者多个表空间中拿出一定的空间，来保存表的修改历史，这样就摆脱了对Undo撤销数据的依赖，不利用undo就可以闪回到归档策略内的任何一个时间点上。三、表数据闪回查询SQL>select*fromtable_nameasoftimestamp(to_timestamp('2013-05-2115:00:00','yyyy-mm-ddhh24:mi:ss'));如果超出保存期限会报错：ORA-08180:nosnapshotfoundbasedonspecifiedtimeSQL>flashbacktabletable_nametotimestampto_timestamp(’2013-05-0715:00:00’,’yyyy-mm-ddhh24:mi:ss’);四、闪回归档维护命令1、创建一个系统默认的、磁盘限额为2048MB、保留策略为1个月的闪回数据归档区SQL>createtablespacefbdadatafile'D:\APP\ADMINISTRATOR\ORADATA\CES\FBDA01.DBF'size2048Msegmentspacemanagementauto;2、闪回归档维护（注意：闪回归档可以在一个或者多个表空间上）--创建闪回归档SQL>createflashbackarchivefdatablespacefbdaretention1month;--删除闪回归档，会删除里面的历史数据，但是不删除表空间SQL>DROPFLASHBACKARCHIVEfba_name;ora-55617:flashbackarchivefbda_1runsoutofspaceandtrackingonfda1issuspended--闪回归档数据恢复SQL>alterflashbackarchivefdamodifytablespacefbdaquota4g;3、表设置为闪回归档（注意：需要逐个表设置）--表使用默认闪回归档区SQL>altertabletable_nameflashbackarchive;--表使用闪回归档区fba，每个闪回归档区域保存时间可以不同SQL>altertabletable_nameflashbackarchivefba;--表取消使用闪回归档区SQL>altertabletable_namenoflashbackarchive;4、闪回归档清除SQL>alterflashbackarchivefdapurgeall;SQL>alterflashbackarchivefdapurgebeforetimestamp(systimestamp-interval'1'day);SQL>alterflashbackarchivefdapurgebeforescn728969;",2013/6/10
939,职称申报考试及培训的有效期,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8343,职称申报材料中：计算机\英语2门考试目前有效期是3年。继续教育培训、创新知识培训、计算机专业继续教育科目都没设定有效期。也提醒各位有意向申报但今年无法参加的同事，可以先完成培训的学分，避免申报当年时间重叠不好安排。,2013/6/9
940,关于居住证满1年的认定,陆晓蕾,http://180.168.156.212:2262/wecenter/?/article/8342,同事问居住证满1年的具体情况，回答如下：1、职称评审中居住证是指上海市人才引进居住证（简称A类居住证）2、评审要求中的满1年指的是截至申报当年年底，即2013年年底满1年。所以只要是2012年或之前申办完成的居住证，在有效期内就行了。,2013/6/9
941,系统办公系统ie兼容性,陈众铭,http://180.168.156.212:2262/wecenter/?/article/8341,希望对ie9个ie10能够兼容，现在的操作系统基本上都是以上版本了,2013/6/7
942,git服务器的搭建（http协议，git+apach）,方俊新,http://180.168.156.212:2262/wecenter/?/article/8340,"git所遵循的协议像SVN一样会有多种，按安全等级从弱到强顺序如下：git,http/https,ssh。在本帖中主要分享按http协议搭建git服务器。详细配置方法参见附件。git+apache.rar",2013/6/7
943,ActiveX for Chrome,方俊新,http://180.168.156.212:2262/wecenter/?/article/8339,在google的chrome浏览器上，还有另外一款插件使chrome能够支持ocx，即ActiveXforChrome。本插件可以到chrome的官方扩展库去下载安装。安装完之后能使在IE浏览器上运行的ocx，在不做任何修改的情况下，可以在chrome浏览器上正常运行。不过需要注意的是：一，activexforchrome插件出于安全性考虑，需要通过ocx所在的网址进行过滤设置，才能正常显示ocx。二，activexforchrome只能在chrome浏览器上运行，而不能在所有遵循NPAPI标准的浏览器上运行，若要使firefox等其他遵循NPAPI标准的浏览器能正常运行ocx，可参考《OCX多浏览器支持—ff-activex-host使用说明》（ ）的帖子，上有详细说明。,2013/6/7
944,OCX多浏览器支持—ff-activex-host使用说明,方俊新,http://180.168.156.212:2262/wecenter/?/article/8338,本贴主要是介绍让多浏览器支持ocx的一款插件，本插件可以使能遵循NPAPI标准的浏览器基本上都能支持ocx，不过在书写object元素时需要注意跟IE写法所很大不同。具体介绍可以参考附件的内容。附件中有《ff-activex-host使用说明》与插件安装包，其中安装包括两种安装方法：第一：exe安装插件第二：通过修改注册表，并存放dll方式安装Oocx多浏览器的支持.rar,2013/6/7
945,海量数据环境下，Lucene 的索引性能如何优化,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8337,"很多人会抱怨Lucene在数据量增加到一定规模的时候，性能会出现明显下降，对于并发用户访问的支持能力也比较弱。其实在工程师所遇到的绝大多数环境下Lucene的性能问题，往往是因为系统没有经过良好的调优。而非简单的Lucene设计缺陷所造成。当前使用Lucene的知名网站包括，StackExchange，旗下全球最大的事实性问答网站StackOverFlow.com.基于Lucene文档“Howtomakeindexingfaster”，我们可以看到如下经验可能可以应用于Lucene优化。确定的确需要进行索引性能调优很多场景之下，性能问题其实表现为整体数据架构设计的问题，而不仅仅是通过索引所可以解决的。在决定进行索引性能调优之前，可能需要首先判断，是否数据架构上出现了情况。确定在使用最新版本的LuceneLucene也是在不断发展之中。新版本的Lucene通常性能都会有些改善。使用更快的硬件，例如，改善IO系统性能通常硬件性能的改善对于系统整体性能提升是立竿见影的。例如，通过SSD硬盘（Solid-StateDisk，固态硬盘）取代通常的SATA或者SAS硬盘，将可以获得明显的系统性能提升。在建立索引过程中，使用单例的Writer基于内存执行Flush而不是基于documentcount在Lucene2.3及其以上系统中，IndexWriter可以基于内存执行Flush操作。调用writer.setRAMBufferSizeMB()可以设置Buffer大小。尽量多使用内存内存越多，Lucene应对海量数据的时候性能明显加强。关闭复合文件格式（Compoundfileformat）调用setUseCompoundFile(false)，可以关闭。建立复合文件，将可能使得索引建立时间被拉长，有可能达到7%-33%。而关闭复合文件格式，将可能大大增加文件数量，而由于减少了文件合并操作，索引性能被明显增强。重用文档与字段实例这是在Lucene2.3之后才有的一个新技术。在之前如果要修改某个记录，需要删除掉索引中的文档，然后重新添加。而新的方法通过setValue实现。这将有助于更有效的减少GC开销而改善性能。在存储字段数据以及执行termvectors的时候，使用同样的字段顺序添加文档这样将有助于保证合并操作的性能。在Analyzer中重用单例的Token在表示Token文本内容的时候，使用char[]API而不要使用StringAPI显然char的结构更简单，而操作也更加快速。基于String的性能通常都不怎么好。在打开IndexWriter的时候，设置autoCommit=false同传统的数据库操作一样，批量提交事务性能总是比每个操作一个事务的性能能好很多。同样，对于实时性要求不是很强的系统。通过标记，并定时进行索引和优化，也将比随时进行索引操作性能能改善很多。不要使用太多的小字段，如果字段过多，尝试将字段合并到一个更大的字段中，以便于查询和索引适当增加mergeFactor，但是不要增加的太多。关闭所有不需要的特性使用更快的Analyzer特别是对于中文分词而言，分词器对于性能的影响更加明显。加快文档的构造速度通常，从数据库，文件系统，或者网络爬行过程中，都可能因为上游程序处理的性能而影响Lucene文档建立的速度。除非真的需要改善索引性能，通常不要特别进行优化对于一个实例的IndexWriter可以使用多线程或者并发技术使用JavaProfiler分析Lucene和调用程序的性能，并由此改善性能Indexintoseparateindicesthenmerge.IfyouhaveaverylargeamountofcontenttoindexthenyoucanbreakyourcontentintoN""silos"",indexeachsiloonaseparatemachine,thenusethewriter.addIndexesNoOptimizetomergethemallintoonefinalindex.",2013/6/7
946,分布式系统之CAP理论杂记,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8336,"分布式系统的CAP理论：理论首先把分布式系统中的三个特性进行了如下归纳：●一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。●可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（可用性不仅包括读，还有写）●分区容忍性（P）：集群中的某些节点在无法联系后，集群整体是否还能继续进行服务。一致性与可用性的决择：而CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地1.数据库事务一致性需求很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求并不高。允许实现最终一致性。2、数据库的写实时性和读实时性需求对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。3、对复杂的SQL查询，特别是多表关联查询的需求任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复?覵QL报表查询，特别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。高可用性就是高性能。BASE提供了基本可用性。BASE是碱，ACID是酸。总结：传统的关系型数据库在功能支持上通常很宽泛，从简单的键值查询，到复杂的多表联合查询再到事务机制的支持。而与之不同的是，NoSQL系统通常注重性能和扩展性，而非事务机制（事务就是强一致性的体现。）。传统的SQL数据库的事务通常都是支持ACID的强事务机制。A代表原子性，即在事务中执行多个操作是原子性的，要么事务中的操作全部执行，要么一个都不执行;C代表一致性，即保证进行事务的过程中整个数据加的状态是一致的，不会出现数据花掉的情况;I代表隔离性，即两个事务不会相互影响，覆盖彼此数据等;D表示持久化，即事务一量完成，那么数据应该是被写到安全的，持久化存储的设备上（比如磁盘）。NoSQL系统仅提供对行级别的原子性保证，也就是说同时对同一个Key下的数据进行的两个操作，在实际执行的时候是会串行的执行，保证了每一个Key-Value对不会被破坏。Redis:BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。1.目前最快的KV数据库,10W次/S,满足了高可用性。2.Redis的k-v上的v可以是普通的值（基本操作：get/set/del）v可以是数值（除了基本操作之外还可以支持数值的计算）v可以是数据结构比如基于链表存储的双向循环list（除了基本操作之外还可以支持数值的计算，可以实现list的二头pop,push）。如果v是list，可以使用redis实现一个消息队列。如果v是set,可以基于redis实现一个tag系统。与mongodb不同的地方是后者的v可以支持文档，比如按照json的结构存储。redis也可以对存入的Key-Value设置expire时间。3.Redis的v的最大远远超过memcache。这也是实现消息队列的一个前提。在NoSQL中，通常有两个层次的一致性：第一种是强一致性，既集群中的所有机器状态同步保持一致。第二种是最终一致性，既可以允许短暂的数据不一致，但数据最终会保持一致。我们先来讲一下，在分布式集群中，为什么最终一致性通常是更合理的选择。",2013/6/7
947,java虚拟机家族,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8335,"说起Java虚拟机，许多Java程序员都会潜意识地把它与Sun[1]HotSpot虚拟机等同看待，也许还有一些程序员会注意到BEAJRockit和IBMJ9，但大多数人对JVM的认识都仅限于此了。从1996年初Sun发布的JDK1.0中所包含的SunClassicVM算起，Java虚拟机已经发展了15个年头，沧海桑田一瞬间，15年转眼而过，这期间曾经涌现、湮灭过许多或经典或优秀或有特色的虚拟机实现，在《Java虚拟机专栏》的第1篇中，我们先暂且把代码与技术放下，一起来回顾一下Java虚拟机家族的发展轨迹和历史变迁。虚拟机始祖：SunClassic/ExactVM以今天的视角来看，SunClassicVM的技术可能很原始，这款虚拟机的使命也早已终结。但仅凭它“世界上第一款商用Java虚拟机”的头衔，就足够有令历史有记住它的理由。相关厂商内容JavaOne2013再次回归，7月22-25日上海世博中心，精彩继续，5月31日前购票享半价共创Java未来：JavaOne重回上海，现报名启动，关注JavaEE7、JavaSE8与JavaCard甲骨文『Duke选择奖』首度在华启动JavaOne大会·2013·上海日程安排相关赞助商2013JavaOne全球大会将于7月22-25日在上海世博中心举办1996年1月23日，Sun发布JDK1.0，Java语言首次拥有了商用的正式运行环境，这个JDK中所带的虚拟机就是ClassicVM。这款虚拟机只能使用纯解释器方式来执行Java代码，如果要使用JIT编译器那就必须进行外挂，但是假如外挂了JIT编译器，JIT编译器就完全接管了虚拟机的执行系统，解释器便不再工作了。用户在这款虚拟机上执行java–version命令，将会看到类似下面这行的输出：javaversion""1.2.2""ClassicVM(buildJDK-1.2.2-001,greenthreads,sunwjit)其中的“sunwjit”就是Sun提供的外挂编译器，其他类似的外挂编译器还有SymantecJIT和shuJIT等。由于解释器和编译器不能配合工作，这就意味着如果要使用编译器执行，编译器就不得不为对每一个方法，每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值。基于程序响应时间的压力，这些编译器根本不敢应用编译耗时稍高的优化技术，因此这个阶段的虚拟机即使用了JIT编译器输出本地代码，执行效率也和传统的C/C++程序有很大差距，“Java语言很慢”的形象就是在这时候开始在用户心中树立起来的。Sun的虚拟机团队努力去解决ClassicVM所面临的各种问题，提升运行效率，在JDK1.2时，曾在Solaris平台上发布过一款名为ExactVM的虚拟机，它的执行系统已经具备现代高性能虚拟机雏形：如两级即时编译器、编译器与解释器混合工作模式等。ExactVM因它使用准确式内存管理（ExactMemoryManagement，也可以叫Non-Conservative/AccurateMemoryManagement）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，它到底是一个reference类型指向123456的内存地址还是一个数值为123456的整数，虚拟机将有能力分辨出来，这样才能在GC的时候准确判断堆上的数据是否还可能被使用。由于使用了准确式内存管理，ExactVM可以抛弃掉以前ClassicVM基于handler的对象查找方式（原因是GC后对象将可能会被移动位置，如果地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数据是reference的前提下，那虚拟机是不敢把内存中所有为123456的值改成654321的，所以要使用句柄来保持reference值的稳定），这样每次定位对象都少了一次间接查找的开销，提升执行性能。虽然ExactVM的技术相对ClassicVM来说先进了许多，但是它命运显得十分英雄气短，在商业应用上只存在了很短暂的时间就被更为优秀的HotSpotVM所取代，甚至还没有来得及发布Windows和Linux平台下的商用版本。而ClassicVM的生命周期则相对长了许多，它在JDK1.2之前是SunJDK中唯一的虚拟机，在JDK1.2时，它与HotSpotVM并存，但默认是使用ClassicVM（用户可用java–hotspot参数切换至HotSpotVM），而在JDK1.3时，HotSpotVM成为默认虚拟机，它仍作为虚拟机的“备用选择”发布（使用java–classic参数切换），直到JDK1.4的时候，ClassicVM才正式退出商用虚拟机的历史舞台，与ExactVM一起进入了SunLabsResearchVM之中。武林盟主：SunHotSpotVMHotSpotVM相信所有Java程序员都知道，它是SunJDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“LongviewTechnologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk语言，而虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了LongviewTechnologies公司，从而获得了HotSpotVM。HotSpotVM既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实ExactVM之中也有与HotSpot几乎一样的热点探测，为了ExactVM和HotSpotVM哪个成为Sun主要支持的产品VM，在Sun公司内部还大吵过一场，HotSpot打败Exact并不能算技术上的胜利），HotSpotVM的热点代码探测能力可以通过执行计数器找出最具优编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中回边（回边是指程序向后跳转的行为）次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无需等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。2006年的JavaOne大会上，Sun宣布最终会把Java开源，并在随后的一年，陆续地将JDK的各个部分（其中当然也包括了HotSpotVM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpotVM便成为了SunJDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。在2008年和2010年，Oracle分别收购了BEA和Sun公司，这样Oracle就同时拥有了这个星球上最优秀的两款Java虚拟机：JRockitVM和HotSpotVM。Oracle宣布在不久的将来（大约应在JDK8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。当HotSpot吸收了JRockit的全部功力之后，能否一统虚拟机的江湖，成为真正的武林盟主，我们拭目以待。小数派：SunMobile-EmbeddedVM/Meta-CircularVMSun公司所研发的虚拟机可不仅有前面介绍到的服务器、桌面领域的商用虚拟机，除此之外，Sun面对移动和嵌入式市场，也发布过虚拟机产品，另外还有一类虚拟机，在设计之初就没有抱着商用的目的，仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现。这些虚拟机对于大部分不从事相关领域开发的Java程序员来说可能比较陌生，Sun公司发布的其他Java虚拟机有：?KVMKVM中的K是“Kilobyte”的意思，它强调简单，轻量，高度可移植，但是运行速度比较慢。在Androd、iOS等智能手机操作系统出现前曾经在手机平台上得到非常广泛应用。?CDC/CLDCHotSpotCDC/CLDC全称是Connected（Limited）DeviceConfiguration，在JSR-139/JSR-218规范中进行定义，它希望在手机、电子书、PDA等设备上建立统一的Java编程接口，而CDCHotSpotVM和CLDCHotSpotVM则是它们的一组参考实现。CDC/CLDC是整个JavaME的重要支柱，但从目前Android和AppleiOS二分天下的移动数字设备市场看来，在这个领域中，Sun的虚拟机所面临的局面远不如服务器和桌面领域乐观。?SquawkVMSquawkVM是由Sun开发，运行于SunSPOT（SunSmallProgrammableObjectTechnology，一种手持的Wifi设备），也曾经运用于JavaCard。这是一个Java代码比重很高的嵌入式虚拟机实现，其中诸如类加载器、字节码验证器、垃圾收集器、解释器、编译器和线程调度都是Java语言本身所完成的，仅仅靠C语言来编写设备I/O和必要的本地代码。?JavaInJavaJavaInJava是Sun公司1997年～1998年间所研发的一个实验室性质的虚拟机，从名字就可以看出，它试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）。它必须运行在另外一个宿主虚拟机之上，内部没有JIT编译器，代码只能以解释模式执行。在上世纪末主流Java虚拟机都未能很好解决性能问题的时代，开发这种项目，其执行速度大家可想而知。?MaxineVMMaxineVM和上面的JavaInJava非常相似，它也是一个几乎全部以Java代码实现（只有用于启动JVM的加载器使用C语言编写）的元循环Java虚拟机。这个项目于2005年开始，到现在仍然在发展之中，比起JavaInJava，MaxineVM就显得“靠谱”很多，它有先进的JIT编译器和垃圾收集器（但没有解释器），可在宿主模式或独立模式下执行，其执行效率已经接近了HotSpotClientVM的水平。百家争鸣：BEAJRockit/IBMJ9VM前面介绍了Sun公司的各种虚拟机，除了Sun公司以外，其他组织、公司也研发过不少虚拟机实现，其中规模最大、最著名的就是BEA和IBM公司了。JRockitVM曾经号称“世界上速度最快的Java虚拟机”（广告词，貌似J9VM也这样说过），它是BEA公司在2002年从AppealVirtualMachines公司收购获得的虚拟机。BEA将其发展为一款专门为服务器硬件和服务端应用场景高度优化的虚拟机，由于专注于服务端应用，它可以不太关注于程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit的垃圾收集器和MissionControl服务套件等部分的实现，在众多Java虚拟机中也一直处于领先水平。IBMJ9VM并不是IBM公司唯一的Java虚拟机，不过是目前IBM主力发展的Java虚拟机，J9原本是内部开发代号，正式名称是“IBMTechnologyforJavaVirtualMachine”，简称IT4J，只是这个名字太拗口了一点，普及程度不如J9。J9VM最初是由IBMOttawa实验室一个SmallTalk的虚拟机扩展而来的，当时这个虚拟机有一个bug是因为8k值定义错误引起，工程师们花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就被称为K8了，后来扩展出支持Java的虚拟机就被称为J9了。与BEAJRockit专注于服务端应用不同，IBMJ9的市场定位与SunHotSpot比较接近，它是一款设计上从服务端到桌面应用再到嵌入式都全面考虑的多用途虚拟机，J9的开发目的是作为IBM公司各种Java产品的执行平台，它的主要市场在和IBM产品（如IBMWebSphere等）搭配以及在IBMAIX和z/OS这些平台上部署Java应用。除了BEA和IBM外，其他一些大公司如HP、SAP等也号称有自己的专属JDK和虚拟机，但是它们是通过从Sun购买版权的方式获得的，并非自己独立开发。最终兵器：AzulVM/BEALiquidVM我们平时所提及的“高性能Java虚拟机”一般是指HotSpot、JRockit、J9这类在通用平台上运行的商用虚拟机，但其实AzulVM和BEALiquidVM这类特定硬件平台专有的虚拟机才是“高性能”的最终兵器。AzulVM是AzulSystems公司在HotSpot基础上进行大量改进，运行于AzulSystems公司的专有硬件Vega系统上的Java虚拟机，每个AzulVM实例都可以管理至少数十个CPU和数百GB的内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、为专有硬件优化的线程调度等优秀特性。在2010年，Azul开始从硬件转向软件，发布了自己的ZingJVM，可以在通用x86平台上提供接近于Vega系统的特性。LiquidVM是BEA公司开发的，可以直接运行在自家Hypervisor系统上的JRockitVM的虚拟化版本，LiquidVM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如文件系统、网络支持等。由虚拟机越过通用操作系统直接控制硬件可以获得很多好处，如在线程调度时，不需要再进行内核态/用户态的切换等，这样可以最大限度地发挥硬件的能力，提升Java程序的执行性能。挑战者：ApacheHarmony/GoogleAndroidDalvikVM这节介绍的HarmonyVM和DalvikVM只能称作“虚拟机”，而不能称作“Java虚拟机”，但是这两款虚拟机（以及所代表的技术体系）对最近三年的Java世界产生了非常大的影响和挑战，甚至有悲观的评论家认为成熟的Java生态系统有崩溃的可能。ApacheHarmony是一个Apache软件基金会旗下以ApacheLicense协议开源的实际兼容于JDK1.5和JDK1.6的Java程序运行平台，这个介绍相当拗口。它包含自己的虚拟机和Java库，用户可以在上面运行Eclipse、Tomcat、Maven等常见的Java程序，但是……它没有通过TCK认证，所以我们不得不用那么一长串拗口的语言来介绍它，而不能用一句“Apache的JDK”来说明。如果一个公司要宣布自己的运行平台“兼容于Java语言”，那就必须要通过TCK（TechnologyCompatibilityKit）的兼容性测试，Apache基金会曾要求Sun公司提供TCK的使用授权，但是一直遭到拒绝，直到Oracle收购了Sun公司之后，双方关系越闹越僵，最终导致Apache愤然退出JCP（JavaCommunityProcess）组织，这是近代Java社区最严重的一次分裂。在Sun把JDK开源形成OpenJDK之后，ApacheHarmony开源的优势被极大地削弱，甚至连Harmony项目的最大参与者IBM公司也宣布辞去Harmony项目管理主席的职位，参与OpenJDK项目的开发。虽然Harmony没有真正大规模商业运用过，但是它的许多代码（基本上是Java库部分的代码）被吸纳进IBM的JDK7实现以及GoogleAndroidSDK之中，尤其是对Android的发展起了很大推动作用。说到Android，这个时下最热门的移动数码设备平台在最近3年间的发展所取得的成果已经远远超越了JavaME在过去十多年所获得的成果，Android让Java语言真正走进了移动数码设备领域，只是走的并非Sun公司原本想象的那一条路。DalvikVM是Android平台的核心组成部分之一，它名字来源于冰岛一个名为Dalvik的小渔村。DalvikVM并不是一个Java虚拟机，它没有遵循Java虚拟机规范，不能直接执行Java的class文件，使用寄存器架构而不是JVM中常见的栈架构。但是它与Java却又有着千丝万缕的联系，它执行dex（DalvikExecutable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的JavaAPI等等。目前DalvikVM随着Android一起处于迅猛发展阶段，在Android2.2中已提供即时编译器实现，执行性能有了很大的提高。没有成功，但并非失败：MircosoftJVM及其他在十几年的Java虚拟机发展历程中，除去上面介绍那些被大规模商业应用过的Java虚拟机外，还有许多虚拟机是不为人知或者曾经绚丽过但最终湮灭的。我们以其中Mircorsoft公司的JVM来介绍一下。也许Java程序员听起来可能会觉得惊讶，微软曾经是Java技术的铁杆支持者。在Java语言诞生的初期（1996年～1998年，以JDK1.2发布之前为分界），它的主要的应用之一是在浏览器中运行JavaApplets程序，微软为了在IE3中支持JavaApplets应用而开发了自己的Java虚拟机，虽然这款虚拟机只有Windows平台的版本（这很正常吧？），但却是当时Windows下性能最好的Java虚拟机，它在1997和1998连续两年获得了《PCMagazine》杂志的“编辑选择奖”。但好景不长，在1997年10月，Sun公司正式以侵犯商标、不正当竞争等罪名控告微软，在随后对微软公司的垄断调查之中，这款虚拟机也曾作为证据之一被呈送法庭。这场官司的结果是微软赔偿2000万美金给Sun，承诺终止其Java虚拟机的发展，并逐步在产品中移除Java虚拟机相关功能。我们试想一下，如果当年Sun没有起诉微软公司，微软继续保持着对Java技术的热情，那Java的世界会变得更好还是更坏？.NET技术是否会发展起来？但历史是没有如果的。其他在本文中没有介绍到的Java虚拟机还包括有（当然，应该还有很多笔者所不知道的）：?JamVM： /blog/858009",2013/6/7
948,中信BBS论坛,张杰,http://180.168.156.212:2262/wecenter/?/article/8334,最新热帖：根据回帖次数进行统计最新发帖：显示最新发的帖子，如果该帖子被回复过那么将不属于最新帖子。,2013/6/7
949,帖子呈现规则问题,杨木江,http://180.168.156.212:2262/wecenter/?/article/8333,1、最新热帖规则是什么，什么样的帖子会被定义了最新热帖，我都看了快一周了，热帖榜单根本就没变化2、最新发帖，规则是什么，新建的帖子只要有回复就不是新帖了，这个逻辑应该不对吧建议热帖采用如下规则：假定用户访问周期介于T1到TN，TN=N*T1，用户访问频率在T1到TN之间线性分布。设文章在每个时间TX里获得的访问量为TXPV，设计系数A=(N-1)/N使用计算式T1PV*A^(N-1)+T2PV*A^(N-2)+T3PV*A^(N-3)+……+TNPV=∑TXPV*A^(N-X)来计算随时间衰减的关注度。,2013/6/7
950,Oracle中的nologging,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8332,"Oracle数据库有联机重做日志，这个日志是记录对数据库所做的修改，比如插入，删除，更新数据等，对这些操作都会记录在联机重做日志里。一般数据库至少要有2个联机重做日志组。当一个联机重做日志组被写满的时候，就会发生日志切换，这时联机重做日志组2成为当前使用的日志，当联机重做日志组2写满的时候，又会发生日志切换，去写联机重做日志组1，就这样反复进行。如果数据库处于非归档模式,联机日志在切换时就会丢弃.而在归档模式下，当发生日志切换的时候，被切换的日志会进行归档。比如，当前在使用联机重做日志1，当1写满的时候，发生日志切换，开始写联机重做日志2，这时联机重做日志1的内容会被拷贝到另外一个指定的目录下。这个目录叫做归档目录，拷贝的文件叫归档重做日志。数据库使用归档方式运行时才可以进行灾难性恢复。归档日志模式和非归档日志模式的区别非归档模式只能做冷备份,并且恢复时只能做完全备份.最近一次完全备份到系统出错期间的数据不能恢复.归档模式可以做热备份,并且可以做增量备份,可以做部分恢复.用ARCHIVELOGLIST可以查看期模式状态时归档模式还是非归档模式.改变归档模式到非归档模式:1)SQL>SHUTDOWNNORMAL/IMMEDIATE;2)SQL>STARTMOUNT;3)SQL>ALTERDATABASENOARCHIVELOG;4)SQL>ALTERDATABASEOPEN;启用自动归档:LOG_ARCHIVE_START=TRUE归档模式下,日志文件组不允许被覆盖(重写),当日志文件写满之后,如果没有进行手动归档,那么系统将挂起,知道归档完成为止.这时只能读而不能写.运行过程中关闭和重启归档日志进程SQL>ARCHIVELOGSTOPSQL>ARCHIVELOGSTART手动归档:LOG_ARCHIVE_START=FALSE归档当前日志文件SQL>ALTERSYSTEMARCHIVELOGCURRENT;归档序号为052的日志文件SQL>ALTERSYSTEMARCHIVELOGSEQUENCE052;归档所有日志文件SQL>ALTERSYSTEMARCHIVELOGALL;改变归档日志目标SQL>ALTERSYSTEMARCHIVELOGCURRENTTO'&PATH';1------------------------------------------------------某DBA告诉我这样可以不写LOG：alerttablenamenologgin;insertintotablename(select...)注意：insert语句后面必须是‘select...’语句，否则无效2------------------------------------------------------NOLOGING选项只是在direct-load模式下才不写redolog,nomalDML无效3------------------------------------------------------altertabletb_txn_lognologging，然后改回来altertabletb_txn_loglogging这种模式会影响联机交易4------------------------------------------------------insertintotest1nologgingselect*fromdba_objectsaltertabletest1nologginginsertintotest1select*fromdba_objects5------------------------------------------------------关于nologging的用法有许多朋友误已写SQL或把表的属性加NOLOGGING，就可以不采成日志。这是一个误解。在数据迁移或大量的数据insert入库时，由于大量数据的insert或修改，经常引起redologsync的等待，造成数据库性能缓慢。因为许多朋友对NOLOGGING的误解，所以许多人在insert数据时,在SQL后加nologging，想通过该用法使操作不采生日记录。但无效果。这里讨论nologging的具体用法：数据库操作，只有如下几种情况下不产成redo记录：１、用sql*load的directload方式时，不采用redo记录２、用insert的direct方式，即在append方式insert(insertappend可以实现直接路径加载，速度比常规加载方式快很多。但有一点需要注意:insertappend时在表上加“6”类型的Exclusive锁，会阻塞表上的所有DML语句。因此在有业务运行的情况下要慎重使用.在使用了append选项以后，insert数据会直接加到表的最后面，而不会在表的空闲块中插入数据。使用append会增加数据插入的速度。的作用是在表的高水位上分配空间,不再使用表的extent中的空余空间append属于directinsert,归档模式下append+tablenologging会大量减少日志,非归档模式append会大量减少日志,append方式插入只会产生很少的undo不去寻找freelist中的freeblock,直接在tableHWM上面加入数据。)３、createtable....asselect４、createindex５、altertable...movepartition６、altertable...splitpartition７、alterindex...splitpartition８、alterindex...rebuild９、alterindex...rebuildpartition１０、INSERT,UPDATE,andDELETEonLOBsinNOCACHENOLOGGINGmodestoredoutofline",2013/6/7
951,发帖太难,杨木江,http://180.168.156.212:2262/wecenter/?/article/8331,主题中排版超难的，大虾们，能不能改进一下呀,2013/6/6
952,我们能否如此开发,杨木江,http://180.168.156.212:2262/wecenter/?/article/8330,开发犹如建房，需要标准、规范，需要设计、施工，需要检查、验收，需要推广、销售，需要维护、保养。以下我将以建房为例来阐述我心中的开发过程，该过程只是建房过程中的一个片段，并不包含房屋的整个生命周期。参与角色TMT：负责标准、规范的制定负责指导、检查SA：负责设计负责选择、修正、扩展材料研发中心：负责材料的设计、生产、保养维护负责样板房设计、施工、保养维护负责基础设施的设计、生产、保养维护项目组：负责建筑施工开始建房步骤一TMT发布标准、规范：房屋建筑制图统一标准建筑模数协调统一标准建筑设计防火规范湿陷性黄土地区建筑规范工业企业照明设计标准动力机器基础计规范建筑物防雷设计规范建筑隔声测量规范普通混凝土长期性能和耐久性能试验方法住宅设计规范人防工程施工及验收规范构筑物抗震设计规范地基与基础工程施工及验收规范钢结构工程施工及验收规范组合钢模板技术规范土工合成材料应用技术规范住宅隔声标准住宅厨房及相关设备基本参数电梯主参数及较厢、井道、机房的型式与尺寸平开钢门基本尺寸系列房屋接管验收标准住宅电梯的配置与选择电梯的操作装置、信号及附件等等步骤二：研发中心根据发布的标准、规范设计生产基础设施及建筑材料，有条件的应该搭建样板房样板房：中信-光典四期：一室一厅一卫、两室一厅一卫、三室两厅两卫中信-标准建筑一期：毛坯房、简装房、精装房基础设施：地基浇注配套设施（架构）供电设施、供水设施、天然气管道（各平台产品：云基）建筑材料（组件构件：灵器）：钢筋、沥青、合成树脂、开关、插座、各种灯、各种灯泡等木材、竹材、石材、水泥、混凝土、金属、砖瓦、陶瓷、玻璃、工程塑料、复合材料等各种涂料、油漆、镀层、贴面、各色瓷砖、具有特殊效果的玻璃等防水、防潮、防火、阻燃、隔音、隔热、保湿、密封等各种电器、各种家具、各种厨具、各种卫具等步骤三：SA根据各专业领域特点结合TMT发布的标准、规范发布更加严格的标准、规范；同时自身从事的领域来选择、修正并扩展样板房、基础设施或建筑材料标准、规范：地下工程防水技术规范小型石油库及汽车加油站计规范古建筑木结构维护与加固技术规范多层厂房楼盖抗微振设计规范蓄滞洪区建筑工程技术规范旅游旅馆建筑热工与空气调节节能设计标准等等样板房：中信-光典四期（浙江风格）中信-司法系统标准建筑一期基础设施：弱电设施、供暖设施、安防设施等建筑材料：加粗钢筋、速凝水泥、空心砖、特殊开关等防火木材、隔热瓷砖等钢筋、沥青、合成树脂、开关、插座、各种灯、各种灯泡等木材、竹材、石材、水泥、混凝土、金属、砖瓦、陶瓷、玻璃、工程塑料、复合材料等各种电器、各种家具、各种厨具、各种卫具等步骤四：项目组根据SA及TMT发布的标准、规范，使用已有的样板房、基础设施及建筑材料迅速施工完成房屋的建设工作方案一：使用中信-光典四期（浙江风格）样板房，将其所有材料换成防火材料方案二：使用中信-标准建筑一期简装房，并在其基础上进行重新装修改造,2013/6/4
953,日志,王锡民,http://180.168.156.212:2262/wecenter/?/article/8329,为什么我的日志快捷方式找不到了，另如何添加快捷方式？进入添加快捷方式页面怎么无法添加？,2013/6/3
954,推荐一个很牛的网站http://www.infomall.cn,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8328,该网站被称为中国WEB信息博物馆（WebInformall），详细介绍参见 改网站的建立为天量Web信息的归档保存迈出了坚实的一步。,2013/5/15
955,Oracle 热备份,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8327,"--=======================--Oracle热备份--=======================Oracle热备份是指数据库处于open状态下，对数据库的数据文件、控制文件、参数文件、密码文件等进行一系列备份操作。热备是基于用户管理备份恢复的一种方式，也是除了RMAN备份之外较为常用的一种备份方式。一、热备的过程冻结块头-->控制SCN在备份时不发生变化进行物理拷贝解冻块头-->让SCN可以变化(当对SCN解冻后，系统会自动更新SCN至最新的状态)二、基于数据库的热备alterdatabasebeginbackup;拷贝所有的datafile到备份目录alterdatabaseendbackup;三、基于表空间的热备altertablespacetablespace_namebeginbackup;拷贝tablespace_name表空间的数据文件到备份目录altertablespacetablespace_nameendbackup;altertablespacetablespace_namebeginbackup时完成的任务检查点事件发生，检查点通知DBWn将该表空间上所有的脏数据被写入到磁盘在数据文件头部冻结当前检查点事件发生时的SCN号所有发生变化数据块的完整镜像(修改前后)被写入到redolog中允许该表空间内数据的正常读写建议使用基于表空间的热备，这样将尽可能的减少对系统性能的影响四、控制文件的热备alterdatabasebackupcontrolfileto''[reuse];--控制文件的完整备份alterdatabasebackupcontrolfiletotraceas''--用于创建控制文件的语句，丢失了部分信息控制文件发生变化情况alterdatabase[add|drop]logfilealterdatabase[add|drop]logfilememberalterdatabase[add|drop]logfilegroupalterdatabase[archivelog|noarchivelog]alterdatabaserenamefilecreatetablespacealtertablespace[add|rename]datafilealtertablespace[readwrite|readonly]droptablespace更多关于控制文件请参考：Oracle控制文件五、参数文件的热备createpfilefromspfile;createpfile=''fromspfile;更多关于参数文件请参考：Oracle参数文件六、临时表空间的数据文件、日志文件不需要备份--查看临时表空间SQL>selecttablespace_namefromdba_temp_files;TABLESPACE_NAME------------------------------TEMP--查看临时表空间的数据文件SQL>selectnamefromv$tempfile;NAME------------------------------------------------------/u01/app/oracle/oradata/orcl/temp01.dbf--将临时表空间置为备份模式，收到了错误的提示SQL>altertablespacetempbeginbackup;altertablespacetempbeginbackup*ERRORatline1:ORA-03217:invalidoptionforalterofTEMPORARYTABLESPACE--将临时表空间置为备份模式，收到了错误的提示SQL>altertemporarytablespacetempbeginbackup;altertemporarytablespacetempbeginbackup*ERRORatline1:ORA-00940:invalidALTERcommand七、热备脚本1.基于数据库热备的脚本SQL>hocat/tmp/tmphotbak.sql;setfeedbackoffsetheadingoffsetverifyoffsettrimspooloffsetpagesize0setlinesize200definedir='/u01/app/oracle/hotbak'definescript='/tmp/hotbak.sql'spool&scriptselect'hocp'||name||'&dir'fromv$datafile;spooloffalterdatabasebeginbackup;start&scriptalterdatabaseendbackup;alterdatabasebackupcontrolfileto'&dir/controlbak.ctl';createpfile='&dir/initorcl.ora'fromspfile;SQL>start/tmp/tmphotbak.sql;--执行该脚本即可对数据库进行热备2.基于表空间热备的脚本SQL>hocat/tmp/tmphotbak_tb.sqlsetfeedbackoffsetheadingoffsetverifyoffsettrimspooloffsetpagesize0setlinesize200definedir='/u01/app/oracle/hotbak'definescript='/tmp/hotbak_tb.sql'horm&scripthorm&dir/*spool&scriptselect'altertablespace'||tablespace_name||'beginbackup;'||chr(10)||'hocp'||file_name||'&dir'||chr(10)||'altertablespace'||tablespace_name||'endbackup;'fromdba_data_filesorderbytablespace_name;spooloffstart&scriptalterdatabasebackupcontrolfileto'&dir/controlbak.ctl';createpfile='&dir/initorcl.ora'fromspfile;SQL>start/tmp/tmphotbak.sql;--执行该脚本即可对数据库基于表空间进行热备八、备份的相关视图v$backupSQL>descv$backup;NameNull?Type----------------------------------------------------------------------FILE#NUMBERSTATUSVARCHAR2(18)CHANGE#NUMBER--记录备份时的SCN号TIMEDATESQL>select*fromv$backup;--状态为NOTACTIVE,此时没有任何数据处于备份状态FILE#STATUSCHANGE#TIME-----------------------------------------------1NOTACTIVE100674716-AUG-102NOTACTIVE100679316-AUG-103NOTACTIVE100672916-AUG-104NOTACTIVE100680716-AUG-105NOTACTIVE100671716-AUG-10SQL>altertablespaceusersbeginbackup;--对表空间users进行热备Tablespacealtered.SQL>select*fromv$backup;--对应的file#为的处于ACTIVE状态FILE#STATUSCHANGE#TIME-----------------------------------------------1NOTACTIVE100674716-AUG-102NOTACTIVE100679316-AUG-103NOTACTIVE100672916-AUG-104ACTIVE100685216-AUG-105NOTACTIVE100671716-AUG-10--备份时发生断电或意外故障的恢复--假定users表空间目前置于beginbakup模式，系统断电SQL>altertablespaceusersbeginbackup;Tablespacealtered.--在另一个会话中强制关闭数据库SQL>shutdownabort;ORACLEinstanceshutdown.--启动后收到错误提示SQL>startupORACLEinstancestarted.TotalSystemGlobalArea469762048bytesFixedSize1220048bytesVariableSize92275248bytesDatabaseBuffers373293056bytesRedoBuffers2973696bytesDatabasemounted.ORA-01113:file4needsmediarecoveryORA-01110:datafile4:'/u01/app/oracle/oradata/orcl/users01.dbf'--查看备份视图，文件此时处于活动状态SQL>select*fromv$backup;FILE#STATUSCHANGE#TIME-----------------------------------------------1NOTACTIVE100695816-AUG-102NOTACTIVE100698316-AUG-103NOTACTIVE100694316-AUG-104ACTIVE100707216-AUG-105NOTACTIVE100693116-AUG-10--使用endbackup来终止备份SQL>alterdatabasedatafile4endbackup;--此处也可以使用recoverdatafile4来完成恢复Databasealtered.SQL>alterdatabaseopen;Databasealtered.SQL>select*fromdual;D-X",2013/5/6
956,Oracle 冷备份,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8326,"--======================--Oracle冷备份--======================一、冷备份数据库在关闭状态下完成所有物理系统文件拷贝的过程，也称脱机备份适合于非归档模式下，数据库处于一致性状态二、步骤首先在运行的库中得到数据库运行的所有的物理文件位置，然后在计划内关闭数据库(shutdown)再执行拷贝物理文家到备份路径或备份设备备份完成后立即启动数据库让其提供正常的服务三、冷备脚本的写法首先应该在相关视图里查出数据库的数据文件，日志文件，控制文件，临时文件所在的位置注意：不要直接把oradata下的cp就行了，因为生产库里各个文件通常分布在不同的磁盘，不同的地方，所以在去视图里获得真实路径--查看实例和数据库的相关信息SQL>selectinstance_name,version,status,archiver,database_statusfromv$instance;INSTANCE_NAMEVERSIONSTATUSARCHIVEDATABASE_STATUS---------------------------------------------------------------------orcl10.2.0.1.0OPENSTOPPEDACTIVESQL>selectdbid,name,log_modefromv$database;DBIDNAMELOG_MODE-------------------------------1242732291ORCLNOARCHIVELOG--查看数据文件及状态信息SQL>selectfile_name,tablespace_name,status,online_statusfromdba_data_files;FILE_NAMETABLESPACESTATUSONLINE_---------------------------------------------------------------------------------/u01/app/oracle/oradata/orcl/undotbs01.dbfUNDOTBS1AVAILABLEONLINE/u01/app/oracle/oradata/orcl/system01.dbfSYSTEMAVAILABLESYSTEM/u01/app/oracle/oradata/orcl/sysaux01.dbfSYSAUXAVAILABLEONLINE/u01/app/oracle/oradata/orcl/users01.dbfUSERSAVAILABLEONLINE/u01/app/oracle/oradata/orcl/example01.dbfEXAMPLEAVAILABLEONLINE/u01/app/oracle/oradata/orcl/tbs1_1.dbfTBS1AVAILABLEONLINE/u01/app/oracle/oradata/orcl/tbs1_2.dbfTBS1AVAILABLEONLINE--查看数据文件SQL>selectnamefromv$datafile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/orcl/system01.dbf/u01/app/oracle/oradata/orcl/undotbs01.dbf/u01/app/oracle/oradata/orcl/sysaux01.dbf/u01/app/oracle/oradata/orcl/users01.dbf/u01/app/oracle/oradata/orcl/example01.dbf/u01/app/oracle/oradata/orcl/tbs1_1.dbf/u01/app/oracle/oradata/orcl/tbs1_2.dbf--查看临时文件SQL>selectnamefromv$tempfile;NAME--------------------------------------------------------------------------------/u01/app/oracle/oradata/orcl/temp01.dbf--查看日志文件SQL>selectmemberfromv$logfile;MEMBER------------------------------------------------------------/u01/app/oracle/oradata/orcl/redo2a.rdo/u01/app/oracle/oradata/orcl/redo2b.rdo/u01/app/oracle/oradata/orcl/redo1a.rdo/u01/app/oracle/oradata/orcl/redo3a.rdo/u01/app/oracle/oradata/orcl/redo3b.rdo/u01/app/oracle/oradata/orcl/redo1b.rdo--查看控制文件SQL>selectnamefromv$controlfile;NAME------------------------------------------------------------/u01/app/oracle/oradata/orcl/control01.ctl/u01/app/oracle/oradata/orcl/control02.ctl--创建备份目录SQL>homkdir/u01/app/oracle/coolbak--使用连接符生成复制文件命令SQL>select'hocp'||name||'/u01/app/oracle/coolbak'fromv$controlfile;'HOCP'||NAME||'/U01/APP/ORACLE/COOLBAK'----------------------------------------------------------------------------------hocp/u01/app/oracle/oradata/orcl/control01.ctl/u01/app/oracle/coolbakhocp/u01/app/oracle/oradata/orcl/control02.ctl/u01/app/oracle/coolbakSQL>save/tmp/tmpbak.sql;--将上面的输入保存为tmpbak.sqlCreatedfile/tmp/tmpbak.sqlSQL>hovim/tmp/tmpbak.sql--编辑tmpbak.sql,将下面的内容输入到tmpbak.sqlsetfeedbackoffsetheadingoffsetverifyoffsettrimspooloffsetpagesize0setlinesize200definedir='/u01/app/oracle/coolbak'definescript='/tmp/coolbak.sql'spool&scriptselect'hocp'||name||'&dir'fromv$controlfileunionallselect'hocp'||name||'&dir'fromv$datafileunionallselect'hocp'||member||'&dir'fromv$logfileunionallselect'hocp'||name||'&dir'fromv$tempfile/createpfile='&dir/initorcl.ora'fromspfile;hocp/u01/app/oracle/10g/dbs/orapworcl&dirspooloffshutdownimmediatestart&scripthorm&scriptstartup--执行tmpbak.sqlSQL>@/tmp/tmpbak.sql;--执行过程及数据库启动略--启动后查看备份的文件SQL>hols/u01/app/oracle/coolbakcontrol01.ctlorapworclredo2b.rdosystem01.dbfusers01.dbfcontrol02.ctlredo1a.rdoredo3a.rdotbs1_1.dbfexample01.dbfredo1b.rdoredo3b.rdotbs1_2.dbfinitorcl.oraredo2a.rdosysaux01.dbfundotbs01.dbf四、总结优点冷备模式下概念易于理解，即将需要备份的文件复制到安全的位置操作比较简单，不需要太多的干预容易恢复到某个时间点上(只需将文件再拷贝回去)能与归档方法相结合，作数据库“最新状态”的恢复。缺点备份时，数据库必须处于一致性关闭状态只能提供到某一时间点的恢复备份时速度比较慢，尤其是数据量大性能影响比较大不能实现基于表和用户级别的数据恢复",2013/5/6
957,Oracle 归档日志,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8325,"--====================--Oracle归档日志--====================Oracle可以将联机日志文件保存到多个不同的位置，将联机日志转换为归档日志的过程称之为归档。相应的日志被称为归档日志。一、归档日志是联机重做日志组文件的一个副本包含redo记录以及一个唯一的logsequencenumber对日志组中的一个日志文件进行归档，如果该组其中一个损坏，则另一个可用的日志将会被归档对于归档模式的日志切换，当日志归档完成后，下一个日志才能被覆盖或重新使用自动归档功能如开启，则后台进程arcn在日志切换时自动完成归档，否则需要手动归档归档日志用途恢复数据库更新standby数据库使用LogMiner提取历史日志的相关信息二、日志的两种模式1.非归档模式不适用与生产数据库创建数据库时，缺省的日志管理模式为非归档模式当日志切换，检查点产生后，联机重做日志文件即可被重新使用联机日志被覆盖后，介质恢复仅仅支持到最近的完整备份不支持联机备份表空间，一个表空间损坏将导致整个数据库不可用，需要删除掉损坏的表空间或从备份恢复对于操作系统级别的数据库备份需要将数据库一致性关闭应当备份所有的数据文件、控制文件(单个)、参数文件、密码文件、联机日志文件(可选)2.归档模式能够对联机日志文件进行归档，生产数据库强烈建议归档在日志切换时，下一个即将被写入日志组必须归档完成之后，日志组才可以使用归档日志的Logsequencenumber信息会记录到控制文件之中必须有足够的磁盘空间用于存放归档日志Oracle9i需要设置参数log_archive_start=true才能够进行自动归档备份与恢复支持热备份，且当某个非系统表空间损坏，数据库仍然处于可用状态，且支持在线恢复使用归档日志能够实现联机或脱机时点恢复(即可以恢复到指定的时间点、指定的归档日志或指定的SCN)三、两种模式的切换设置及手动归档1.非归档到归档模式a.一致性关闭数据库(shutdown[immediate|transactional|normal])b.启动到mount阶段(startupmount)c.切换到归档模式(alterdatabasearchivelog[manual])d.切换到open阶段(alterdatabaseopen)e.对数据做一个完整备份(fullbackup)--演示非归档到归档模式SQL>ARCHIVELOGLIST--查看数据库是否处于归档模式DatabaselogmodeNoArchiveModeAutomaticarchivalDisabledArchivedestinationUSE_DB_RECOVERY_FILE_DESTOldestonlinelogsequence14Currentlogsequence16SQL>SELECTlog_modeFROMv$database;--查看数据库是否处于归档模式LOG_MODE------------NOARCHIVELOGSQL>SHUTDOWNIMMEDIATE;--一致性关闭数据库Databaseclosed.Databasedismounted.ORACLEinstanceshutdown.SQL>STARTUPMOUNT;--启动到mount状态ORACLEinstancestarted.TotalSystemGlobalArea251658240bytesFixedSize1218796bytesVariableSize75499284bytesDatabaseBuffers171966464bytesRedoBuffers2973696bytesDatabasemounted.SQL>ALTERDATABASEARCHIVELOG;--切换到自动归档模式Databasealtered.SQL>ALTERDATABASEOPEN;--切换到open状态Databasealtered.SQL>ARCHIVELOGLIST;--查看数据库的归档状态DatabaselogmodeArchiveMode--已置为归档模式AutomaticarchivalEnabled--对日志进行自动归档ArchivedestinationUSE_DB_RECOVERY_FILE_DESTOldestonlinelogsequence14Nextlogsequencetoarchive16Currentlogsequence16--备份数据库步骤省略2.归档模式切换到非归档模式(步骤同非归档到归档模式仅仅是c步骤使用alterdatabasenoarchivelog，演示省略)a.一致性关闭数据库(shutdown[immediate|transactional|normal])b.启动到mount阶段(startupmount)c.切换到归档模式(alterdatabasenoarchivelog)d.切换到open阶段(alterdatabaseopen)e.对数据做一个完整备份(fullbackup)3.手动归档手动归档时需要将日志模式切换为alterdatabasearchivelogmanual再使用altersystemarchivelogcurrent|all实现归档更多手动归档命令：ALTERSYSTEMarchive_log_clause注意:手动归档模式下不支持stanby数据库在alterdatabasearchivelog模式下也可以实现对日志的归档SQL>ALTERDATABASEARCHIVELOGMANUAL;--将日志模式切换为手工归档模式Databasealtered.SQL>ALTERDATABASEOPEN;--打开数据库Databasealtered.SQL>ALTERSYSTEMARCHIVELOGCURRENT;--对当前的日志进行归档(建议在mount阶段完成)Systemaltered.SQL>ALTERSYSTEMARCHIVELOGALL;--对所有的日志进行归档altersystemarchivelogall*ERRORatline1:ORA-00271:therearenologsthatneedarchiving--没有需要归档的日志4.归档进程的调整通过设置LOG_ARCHIVE_MAX_PROCESSES参数，可以指定数据库规定所需初始化的进程数，缺省的归档进程数为2一般情况下不需要修改该参数，Oracle会根据归档情况自动启动额外的归档进程也可以动态的增加或减少归档进程数，比如有些业务在月底需要进行大量归档，平时则归档较少，对此可以动态修改修改方法ALTERSYSTEMSETLOG_ARCHIVE_MAX_PROCESSES=3;5.配置归档(两种归档位置配置方法)a.归档到本机且少于等于两个归档位置设置LOG_ARCHIVE_DEST和LOG_ARCHIVE_DUPLEX_DEST参数altersystemsetlog_archive_dest='/u01/app/oracle/archivelog1'scope=spfile;altersystemsetlog_archive_duplex_dest='/u01/app/oracle/archivelog2'scope=spfile;b.归档到本机或远程主机设置LOG_ARCHIVE_DEST_n参数,n最大值为10altersystemsetlog_archive_dest_1='LOCATION=/u01/app/oracle/archivelog3';altersystemsetlog_archive_dest_2='SERVICE=standby1';对于远程归档位置,SERVICE选项需要指定远程数据库的网络服务名(在tnsnames.ora文件中配置)LOG_ARCHIVE_DEST_n的两个常用选项MANADATORY|OPTIONAL:MANADATORY表示归档必须成功复制到目的路径之后，联机重做日志才能被复用，OPTIONAL正好相反REOPEN：指定归档失败后指定间隔多少时间重试归案，缺省的为300秒示例：log_archive_dest_1='LOCATION=/u01/app/oracle/archivelog3manadatoryreopen=600'log_archive_dest_2='SERVICE=standby1manadatoryreopen'c.两种归档方法异同(前者log_archive_dest、log_archive_duplex_dest，后者log_archive_dest_n)两者都可以归档到本机，后者可以归档到远程主机，前者不支持该功能前者最多配置两个归档位置，后者可以配置10个归档位置两者互不兼容，要么使用前者，要么使用后者使用后者归档到本地时需要增加LOCATION选项，备份到远程主机需要使用SERVICE选项但上述两种方式未指定路径时，归档日志位于db_recovery_file_dest缺省为$ORACLE_BASE/flash_recovey_aread.归档日志命名格式设置LOG_ARCHIVE_FORMAT参数，Unix下的缺省设置为LOG_ARCHIVE_FORMAT=%t_%s_%r.dbf%s:日志序列号:%S:日志序列号(带有前导)%t:重做线程编号.%T:重做线程编号(带有前导)%a:活动ID号%d:数据库ID号%rRESETLOGS的ID值.altersystemsetlog_archive_format='arch_%t_%s_%r.arc';e.归档位置状态Valid/Invalid--磁盘位置及服务名等是否有效Enabled/Disabled--磁盘位置的可用状态及数据库能否使用该归档位置Active/Inactive--访问归档目的地是否有异常f.归档成功的最小个数(使用参数log_archive_min_succeed_dest=n)altersystemsetlog_archive_min_succeed_dest=2;--缺省为1联机重做日志组能够被覆盖的前提所有强制路径归档位置成功实现归档归档目的地的成功归档的个数大于或等于上述参数设定的值当强制个数大于该参数设定的个数，则以强制个数为准当强制个数小于该参数设定的个数，则可选的成功归档路径加上强制的归档路径个数至少等于该参数设定值g.控制归档的可用性(使用参数log_archive_dest_state_n)altersystemsetlog_archive_dest_state_1=enable|deferenable-->缺省状态，可以在该归档位置进行归档defer-->禁用该归档位置h.演示归档路径配置及查看归档进程，归档位置状态SQL>ARCHIVELOGLIST;--查看日志是否处于归档状态DatabaselogmodeArchiveModeAutomaticarchivalEnabledArchivedestinationUSE_DB_RECOVERY_FILE_DESTOldestonlinelogsequence24Nextlogsequencetoarchive26Currentlogsequence26SQL>hops-ef|grepora_arc--查看归档进程是否已启动oracle40621011:43?00:00:00ora_arc0_orcloracle40641011:43?00:00:00ora_arc1_orclSQL>SHOWPARAMETERARCHIVE--查看归档路径是否已设置，为空值表示未设置NAMETYPEVALUE-----------------------------------------------------------------------------archive_lag_targetinteger0log_archive_configstringlog_archive_deststringlog_archive_dest_1stringlog_archive_dest_10stringlog_archive_dest_2stringlog_archive_dest_3stringlog_archive_dest_4stringlog_archive_dest_5stringlog_archive_dest_6stringlog_archive_dest_7stringNAMETYPEVALUE-----------------------------------------------------------------------------log_archive_dest_8stringlog_archive_dest_9stringlog_archive_dest_state_1stringenablelog_archive_dest_state_10stringenablelog_archive_dest_state_2stringenablelog_archive_dest_state_3stringenablelog_archive_dest_state_4stringenablelog_archive_dest_state_5stringenablelog_archive_dest_state_6stringenablelog_archive_dest_state_7stringenablelog_archive_dest_state_8stringenableNAMETYPEVALUE-----------------------------------------------------------------------------log_archive_dest_state_9stringenablelog_archive_duplex_deststringlog_archive_formatstring%t_%s_%r.dbflog_archive_local_firstbooleanTRUElog_archive_max_processesinteger2log_archive_min_succeed_destinteger1log_archive_startbooleanFALSE--该参数在9i中使用log_archive_traceinteger0remote_archive_enablestringtruestandby_archive_deststring?/dbs/archSQL>altersystemsetlog_archive_dest='/u01/app/oracle/archivelog1'scope=spfile;Systemaltered.SQL>altersystemsetlog_archive_duplex_dest='/u01/app/oracle/archivelog2'scope=spfile;Systemaltered.SQL>altersystemsetlog_archive_format='arch_%t_%s_%r.arc'scope=spfile;--设定完毕后需要重新启动实例，在此省略关闭启动信息SQL>hols/u01/app/oracle/archivelog1--查看归档路径下是否存在文件或文件夹SQL>hols/u01/app/oracle/archivelog2--查看归档路径下是否存在文件或文件夹SQL>altersystemarchivelogcurrent;--手动进行归档Systemaltered.SQL>hols-l/u01/app/oracle/archivelog1--在指定的文件夹archivelog1已产生归档日志total18224-rw-------1oracleoinstall18636800Jul2820:39arch_1_26_724852763.arcSQL>hols-l/u01/app/oracle/archivelog2--在指定的文件夹archivelog2已产生归档日志total18224-rw-------1oracleoinstall18636800Jul2820:39arch_1_26_724852763.arcSQL>homkdir/u01/app/oracle/archivelog3--创建新的归档路径SQL>homkdir/u01/app/oracle/archivelog4--创建新的归档路径SQL>altersystemsetlog_archive_dest_1='location=/u01/app/oracle/archivelog3'2scope=spfile;Systemaltered.SQL>altersystemsetlog_archive_dest_2='location=/u01/app/oracle/archivelog4'2scope=spfile;Systemaltered.SQL>shutdownimmediate;--关闭实例Databaseclosed.Databasedismounted.ORACLEinstanceshutdown.SQL>startup--启动实例后，收到错误提示表明两种归档方式不兼容ORA-16019:cannotuseLOG_ARCHIVE_DEST_1withLOG_ARCHIVE_DESTorLOG_ARCHIVE_DUPLEX_DEST--关于上述设置导致的错误处理请参照：又一例SPFILE设置错误导致数据库无法启动SPFILE错误导致数据库无法启动--下面是正确的处理办法，应当先将一种归档方式路径置空，此处是将log_archive_dest置空SQL>altersystemsetlog_archive_dest=''scope=spfile;Systemaltered.--此处是将log_archive_duplex_dest置空SQL>altersystemsetlog_archive_duplex_dest=''scope=spfile;Systemaltered.--接下来再设定log_archive_dest_1，log_archive_dest_2SQL>altersystemsetlog_archive_dest_1='location=/u01/app/oracle/archivelog3'2scope=spfile;Systemaltered.SQL>altersystemsetlog_archive_dest_2='location=/u01/app/oracle/archivelog4'2scope=spfile;Systemaltered.--由于没有配置standby服务器，所以省略配置到远程主机--设定完毕后需要重新启动实例，此时系统能正常启动，在此省略关闭启动信息SQL>altersystemarchivelogcurrent;--进行手动归档Systemaltered.SQL>hols-l/u01/app/oracle/archivelog3/--查看归档日志total27752-rw-------1oracleoinstall28382208Aug213:46arc_1_38_724852763.arcSQL>hols-l/u01/app/oracle/archivelog4/--查看归档日志total27752-rw-------1oracleoinstall28382208Aug213:45arc_1_38_724852763.arcSQL>coldest_nameformata20;SQL>coldestinationformata30;SQL>selectdest_name,status,archiver,destination,2log_sequence,reopen_secs,transmit_mode,process3fromv$archive_dest;--查看归档目的地的相关状态信息DEST_NAMESTATUSARCHIVERDESTINATIONLOG_SEQUENCEREOPEN_SECSTRANSMIT_MODPROCESS---------------------------------------------------------------------------------------------------------------LOG_ARCHIVE_DEST_1VALIDARCH/u01/app/oracle/archivelog3/38300SYNCHRONOUSARCHLOG_ARCHIVE_DEST_2VALIDARCH/u01/app/oracle/archivelog4/38300SYNCHRONOUSARCHLOG_ARCHIVE_DEST_3INACTIVEARCH00SYNCHRONOUSARCH-----------------------------------------------------------------------------------------------------------------------SQL>altersystemsetlog_archive_dest_state_2=defer;--停用log_archive_dest_state_2Systemaltered.SQL>showparameterlog_archive_dest_stateNAMETYPEVALUE--------------------------------------------------------------log_archive_dest_state_1stringenablelog_archive_dest_state_10stringenablelog_archive_dest_state_2stringDEFER--该路径显示为deferlog_archive_dest_state_3stringenablelog_archive_dest_state_4stringenablelog_archive_dest_state_5stringenablelog_archive_dest_state_6stringenablelog_archive_dest_state_7stringenablelog_archive_dest_state_8stringenablelog_archive_dest_state_9stringenableSQL>altersystemarchivelogcurrent;--手动归档Systemaltered.SQL>hols-l/u01/app/oracle/archivelog3;--可以看出archivelog3比archivelog4多出几个归档文件total124772--建议将多出文件件的使用系统命令复制到archivelog4-rw-------1oracleoinstall28382208Aug213:46arc_1_38_724852763.arc-rw-------1oracleoinstall1788416Aug220:41arc_1_39_724852763.arc-rw-------1oracleoinstall30257664Aug222:21arc_1_40_724852763.arc-rw-------1oracleoinstall30257664Aug222:22arc_1_41_724852763.arc-rw-------1oracleoinstall30257664Aug222:22arc_1_42_724852763.arc-rw-------1oracleoinstall6647296Aug222:23arc_1_43_724852763.arcSQL>hols-l/u01/app/oracle/archivelog4;total29504-rw-------1oracleoinstall28382208Aug213:45arc_1_38_724852763.arc-rw-------1oracleoinstall1788416Aug220:41arc_1_39_724852763.arcSQL>altersystemsetlog_archive_dest_state_2=enable;--启用log_archive_dest_state_2Systemaltered.SQL>altersystemarchivelogcurrent;--手动归档Systemaltered.SQL>hols-l/u01/app/oracle/archivelog3;--启用后出现了相同的arc_1_44_724852763.arc文件total124856-rw-------1oracleoinstall28382208Aug213:46arc_1_38_724852763.arc-rw-------1oracleoinstall1788416Aug220:41arc_1_39_724852763.arc-rw-------1oracleoinstall30257664Aug222:21arc_1_40_724852763.arc-rw-------1oracleoinstall30257664Aug222:22arc_1_41_724852763.arc-rw-------1oracleoinstall30257664Aug222:22arc_1_42_724852763.arc-rw-------1oracleoinstall6647296Aug222:23arc_1_43_724852763.arc-rw-------1oracleoinstall81408Aug222:25arc_1_44_724852763.arcSQL>hols-l/u01/app/oracle/archivelog4;total29588-rw-------1oracleoinstall28382208Aug213:45arc_1_38_724852763.arc-rw-------1oracleoinstall1788416Aug220:41arc_1_39_724852763.arc-rw-------1oracleoinstall81408Aug222:25arc_1_44_724852763.arc四、归档日志相关视图v$archived_log-->从控制文件中获得归档的相关信息v$archive_dest-->归档路径及状态v$log_history-->控制文件中日志的历史信息v$database-->查看数据库是否处于归档状态v$archive_processes-->归档相关的后台进程信息命令:archiveloglistSQL>selectname,sequence#,registrar,standby_dest,archived,status2fromv$archived_log;NAMESEQUENCE#REGISTRSTAARCS-------------------------------------------------------------------------------/u01/app/oracle/archivelog4/arc_1_38_724852763.arc38FGRDNOYESA/u01/app/oracle/archivelog3/arc_1_39_724852763.arc39ARCHNOYESA/u01/app/oracle/archivelog4/arc_1_39_724852763.arc39ARCHNOYESA/u01/app/oracle/archivelog3/arc_1_40_724852763.arc40ARCHNOYESA/u01/app/oracle/archivelog3/arc_1_41_724852763.arc41ARCHNOYESA/u01/app/oracle/archivelog3/arc_1_42_724852763.arc42ARCHNOYESA/u01/app/oracle/archivelog3/arc_1_43_724852763.arc43ARCHNOYESA/u01/app/oracle/archivelog3/arc_1_44_724852763.arc44FGRDNOYESA/u01/app/oracle/archivelog4/arc_1_44_724852763.arc44FGRDNOYESA",2013/5/6
958,IT人网站上看到的一篇好文章：屌丝CEO傅盛的三次逆袭,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8324,希望对大家有所启发和帮助屌丝CEO傅盛的三次逆袭-IT人.mht,2013/5/6
959,可以加一个每季度技术问题的展示和进度么？,何锦晔,http://180.168.156.212:2262/wecenter/?/article/8323,可以加一个每季度技术问题的展示和进度么？这样可以随时看到公司的技术问题，结合提交功能可以看到技术问题解决的进度。,2013/5/3
960,Chrome Packaged Apps,陈雷,http://180.168.156.212:2262/wecenter/?/article/8322,"网上看到一篇使用Chrome做离线应用的文章，使用这样的技术貌似可以脱离浏览器，只跟Chrome的某个版本相关。本文原文链接： on”的文件。这个文件主要是需要描述应用的一些相关信息，比如应用名，需要使用的权限等，与Extension采用的一样的格式，这里有详细的说明：linkSecond:使用HTML5的相关技术实现相应的功能，有各种各样的API能够供你使用。在这里，你完全可以使用web开发的使用的做法，只不过要记住现在是在写一个本地应用就行了，要留意有些操作为了安全是无法直接实现。Third:使用最新版本的ChromeCanary（我用的是Version24.0.1286.0canary），在工具——>扩展的页面中，打开开发者模式,选择Loadunpackedextension…Fourth：慢慢体验其惊奇之处吧。下面是来自GoogleChromeGithub上的Diff的界面截图SomeLinksChrome官方文档：ChromePackagedApps，在这里你可以找到详细的开发文档。DemosApp:Chromeappsamples，在这里你可以找到相当丰富的API使用Demo",2013/5/3
961,"外出登记提交以后,发觉写错日期了,如何修改,或者删除重写申请呢",汪永康,http://180.168.156.212:2262/wecenter/?/article/8321,如题,2013/5/2
962,外出登记与工作日志整合在一起，但是选择“日志”类型后，外出登录相关隐藏项没有隐藏完整,陈雷,http://180.168.156.212:2262/wecenter/?/article/8320,外出登记与工作日志整合在一起，但是选择“日志”类型后，外出登录相关隐藏项没有隐藏完整，还漏了部分。我的浏览器是ie8.,2013/5/2
963,目前论坛的版块设置过于技术化，有一些市场营销、管理、感想之类的帖子没有地方发,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8319,还可以增加七嘴八舌板块，反正实名制的，应该不会乱发。,2013/5/2
964,中信BBS新增栏目了,张杰,http://180.168.156.212:2262/wecenter/?/article/8318,目前新版OA的BBS论坛中增加了最新发帖、最新回复。,2013/4/28
965,新版OA首页增加了“统一管理”栏目,张杰,http://180.168.156.212:2262/wecenter/?/article/8317,新版OA首页增加了“统一管理”栏目,2013/4/28
966,mvc设计模式概述,张杰,http://180.168.156.212:2262/wecenter/?/article/8316,MVC设计模式是一个存在于服务器表达层的模型，它将应用分开，改变应用之间的高度耦合，其中MVC是Model-View-Control的简称，即模型-视图-控制器。,2013/4/28
967,生日祝福太简单了吧？,孙建兵,http://180.168.156.212:2262/wecenter/?/article/8315,看不到谁给的祝福，也没有祝福的话语，貌似过了本周再也看不到祝福的数字了。,2013/4/28
968,外出登记,张春岩,http://180.168.156.212:2262/wecenter/?/article/8314,哪位大侠给我培训一下，新版OA，怎么登记外出。:?::?::?::?::?::?::?::?::?:,2013/4/17
969,话说我们公司内网终端的安全,戴旭宏,http://180.168.156.212:2262/wecenter/?/article/8313,话说~近日在公司内网某服务器上部署了一下企业版的360~对部分终端进行了一下扫描~然后。。。就蛋疼了~发这个帖子不是想证明什么~而是让更多的公司同事注意对自己平时的工作机能加以爱护和注重应用上的安全。谢谢2670741366004725767.jpg2670731366005017431.jpg2670731366004977966.jpg,2013/4/15
970,主页上的每个版块点了一遍，反馈几个问题,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8312,先不要急于开发新功能，把现有几个板块搞搞好。,2013/4/15
971,FPA性格色彩测试,戴旭宏,http://180.168.156.212:2262/wecenter/?/article/8311,用“红、蓝、黄、绿”四色代替人的性格类型，借助一幅幅美妙的图画来解析多变的人生；通过对“性格色彩密码”的解读，帮助你学会以“有‘色’眼睛”洞察人性，增强对人生的洞察力，并修炼个性，从而掌握自己的命运。测试指导语选择答案时，请注意以下事项：*选择最能符合你的选项。*所有问题的答案没有好坏或对错之分，先完成对你较容易选择的题目，困难的随后再选，不要停顿。*请选择让你“最自然的”“最舒服的”反应，而非“最好的”“最适合的”。换句话讲，你回答的问题是“我是谁”，而不是“我该是谁”或“我想是谁”。4色性格测试解析.rar,2013/4/7
972,最新版的ERMS需求规范,杨安荣,http://180.168.156.212:2262/wecenter/?/article/8310,人大电子文件研究中心多位档案专家的力作，历经4年完成，目前已经基本定稿ERMS电子文件管理系统功能要求（待发布稿）.pdf,2013/4/2
973,有哪位大虾想挑战一下自己的英文水平，给你个机会，英文版ISO 26102,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8309,该标准目前尚处于表决阶段，所以肯定没有中文版，我好不容易才搞到手，你们当思来之不易啊ISO_PDTR_26102_(V3.3)（文件管理-电子文件的长期保存需求）.pdf,2013/4/1
974,有多少系统或站点是用mongo的（转）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8308,做java开发有几年了---命苦的IT程序猿最近几个月做了十几个mongo数据库的站点项目都是千万级别到上亿级别的数据从sqlserver2008数据库全部转到mongo数据库（如book.youboy.com），大家可以去体验下mongo的性能从对非关系型一点都不懂到2个多月把全部的mongo数据库这块硬骨头啃下来，底层完全改了，皮都脱了一层林子大了，什么鸟都有，要收版权费，没办法mongo性能确实比sqlserver的强大，最起码安全，防注入点不用考虑太多，也发现有人总是搞些注入的东西在裤子里搞笑，可能一天没搞下来连续几天一直在测试，可能不知道我是用了非关系型的数据库我两台数据库服务器撑10个站点的数据库，没做mongo集群，CPU和IO都非常低，一天一个站点日流量10万IP都没什么问题，站点的布局也一样，性能确实高发现mongo也有些致命方面的问题如：数据count时候，从百万条数据找几十条出来进行分页查询的时候,2013/3/23
975,win7下MongoDB数据库安装（转）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8307,"1.下载Windows版本的MongoDB数据库到官方的下载页面下载mongodb的windows版本，32位还是64位根据自己的情况自行选择，下载地址： downloads2.安装准备将下载的压缩包解压缩并放置到你想放置的位置，在目录下建立一个叫做DB的文件夹和一个log.txt的文件DB文件夹用于存储数据库log.txt用于记录MongoDB的日志3.安装MongoDB这里讲的方法是将MongoDB安装为Windows的服务的方式，打开windows的命令行（注意：请使用个管理员权限启动命令行）并移动到你MongoDB目录下的Bin文件夹，我这里演示的路径是d:\DEV\ENV\mongodb输入下列命令可将MongoDB注册为Windows服务：mongod.exe--install--logpath=D:\DEV\ENV\mongodb\log.txt--dbpath=D:\DEV\ENV\mongodb\DB--install参数是设定安装为服务器--logpath参数是设定日志文件的路径,log.txt是在上一步建立好的文件--dbpath参数是设定数据库文件的存放路径，DB文件夹在上一步骤已经创建好netstartmongodb即可启动mongodb服务启动后，再到命令行输入mongo看到MongoDB已经启动成功，安装就完成了，很简单。",2013/3/23
976,NoSQL数据库探讨之一 － 为什么要用非关系数据库？（转）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8306,随着互联网web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。而传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如：1、Highperformance-对数据库高并发读写的需求web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如像JavaEye网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。2、HugeStorage-对海量数据的高效率存储和访问的需求类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。3、HighScalability&&HighAvailability-对数据库的高可扩展性和高可用性的需求在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像webserver和appserver那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？在上面提到的“三高”需求面前，关系数据库遇到了难以克服的障碍，而对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地，例如：1、数据库事务一致性需求很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求也不高。因此数据库事务管理成了数据库高负载下一个沉重的负担。2、数据库的写实时性和读实时性需求对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说我（JavaEye的robbin）发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。3、对复杂的SQL查询，特别是多表关联查询的需求任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询，特别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。因此，关系数据库在这些越来越多的应用场景下显得不那么合适了，为了解决这类问题的非关系数据库应运而生，现在这两年，各种各样非关系数据库，特别是键值数据库(Key-ValueStoreDB)风起云涌，多得让人眼花缭乱。前不久国外刚刚举办了NoSQLConference，各路NoSQL数据库纷纷亮相，加上未亮相但是名声在外的，起码有超过10个开源的NoSQLDB，例如：Redis，TokyoCabinet，Cassandra，Voldemort，MongoDB，Dynomite，HBase，CouchDB，Hypertable，Riak，Tin，Flare，Lightcloud，KiokuDB，Scalaris，Kai，ThruDB，......这些NoSQL数据库，有的是用C/C++编写的，有的是用Java编写的，还有的是用Erlang编写的，每个都有自己的独到之处，看都看不过来了，我(robbin)也只能从中挑选一些比较有特色，看起来更有前景的产品学习和了解一下。这些NoSQL数据库大致可以分为以下的三类：一、满足极高读写性能需求的Kye-Value数据库：Redis，TokyoCabinet，Flare高性能Key-Value数据库的主要特点就是具有极高的并发读写性能，Redis，TokyoCabinet，Flare，这3个Key-ValueDB都是用C编写的，他们的性能都相当出色，但出了出色的性能，他们还有自己独特的功能：1、RedisRedis是一个很新的项目，刚刚发布了1.0版本。Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是我知道的性能最快的Key-ValueDB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存List链表和Set集合的数据结构，而且还支持对List进行各种操作，例如从List两端push和pop数据，取List区间，排序等等，对Set支持各种集合的并集交集操作，此外单个value的最大限制是1GB，不像memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的memcached来用。Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，并且它没有原生的可扩展机制，不具有scale（可扩展）能力，要依赖客户端来实现分布式读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。目前使用Redis的网站有github，EngineYard。2、TokyoCabinet和TokoyTyrantTC和TT的开发者是日本人MikioHirabayashi，主要被用在日本最大的SNS网站mixi.jp上，TC发展的时间最早，现在已经是一个非常成熟的项目，也是Kye-Value数据库领域最大的热点，现在被广泛的应用在很多很多网站上。TC是一个高性能的存储引擎，而TT提供了多线程高并发服务器，性能也非常出色，每秒可以处理4-5万次读写操作。TC除了支持Key-Value存储之外，还支持保存Hashtable数据类型，因此很像一个简单的数据库表，并且还支持基于column的条件查询，分页查询和排序功能，基本上相当于支持单表的基础查询功能了，所以可以简单的替代关系数据库的很多操作，这也是TC受到大家欢迎的主要原因之一，有一个Ruby的项目miyazakiresistance将TT的hashtable的操作封装成和ActiveRecord一样的操作，用起来非常爽。TC/TT在mixi的实际应用当中，存储了2000万条以上的数据，同时支撑了上万个并发连接，是一个久经考验的项目。TC在保证了极高的并发读写性能的同时，具有可靠的数据持久化机制，同时还支持类似关系数据库表结构的hashtable以及简单的条件，分页和排序操作，是一个很棒的NoSQL数据库。TC的主要缺点是在数据量达到上亿级别以后，并发写数据性能会大幅度下降，NoSQL:IfOnlyItWasThatEasy提到，他们发现在TC里面插入1.6亿条2-20KB数据的时候，写入性能开始急剧下降。看来是当数据量上亿条的时候，TC性能开始大幅度下降，从TC作者自己提供的mixi数据来看，至少上千万条数据量的时候还没有遇到这么明显的写入性能瓶颈。这个是TimYang做的一个Memcached，Redis和TokyoTyrant的简单的性能评测，仅供参考3、FlareTC是日本第一大SNS网站mixi开发的，而Flare是日本第二大SNS网站green.jp开发的，有意思吧。Flare简单的说就是给TC添加了scale功能。他替换掉了TT部分，自己另外给TC写了网络服务器，Flare的主要特点就是支持scale能力，他在网络服务端之前添加了一个nodeserver，来管理后端的多个服务器节点，因此可以动态添加数据库服务节点，删除服务器节点，也支持failover。如果你的使用场景必须要让TC可以scale，那么可以考虑flare。flare唯一的缺点就是他只支持memcached协议，因此当你使用flare的时候，就不能使用TC的table数据结构了，只能使用TC的key-value数据结构存储。二、满足海量存储需求和访问的面向文档的数据库：MongoDB，CouchDB面向文档的非关系数据库主要解决的问题不是高性能的并发读写，而是保证海量数据存储的同时，具有良好的查询性能。MongoDB是用C++开发的，而CouchDB则是Erlang开发的：1、MongoDBMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bjson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。Mongo主要解决的是海量数据的访问效率问题，根据官方的文档，当数据量达到50GB以上的时候，Mongo的数据库访问速度是MySQL的10倍以上。Mongo的并发读写效率不是特别出色，根据官方提供的性能测试表明，大约每秒可以处理0.5万－1.5次读写请求。对于Mongo的并发读写性能，我（robbin）也打算有空的时候好好测试一下。因为Mongo主要是支持海量数据存储的，所以Mongo还自带了一个出色的分布式文件系统GridFS，可以支持海量的数据存储，但我也看到有些评论认为GridFS性能不佳，这一点还是有待亲自做点测试来验证了。最后由于Mongo可以支持复杂的数据结构，而且带有强大的数据查询功能，因此非常受到欢迎，很多项目都考虑用MongoDB来替代MySQL来实现不是特别复杂的Web应用，比方说whywemigratedfromMySQLtoMongoDB就是一个真实的从MySQL迁移到MongoDB的案例，由于数据量实在太大，所以迁移到了Mongo上面，数据查询的速度得到了非常显著的提升。MongoDB也有一个ruby的项目MongoMapper，是模仿Merb的DataMapper编写的MongoDB的接口，使用起来非常简单，几乎和DataMapper一模一样，功能非常强大易用。2、CouchDBCouchDB现在是一个非常有名气的项目，似乎不用多介绍了。但是我却对CouchDB没有什么兴趣，主要是因为CouchDB仅仅提供了基于HTTPREST的接口，因此CouchDB单纯从并发读写性能来说，是非常糟糕的，这让我立刻抛弃了对CouchDB的兴趣。三、满足高可扩展性和可用性的面向分布式计算的数据库：Cassandra，Voldemort面向scale能力的数据库其实主要解决的问题领域和上述两类数据库还不太一样，它首先必须是一个分布式的数据库系统，由分布在不同节点上面的数据库共同构成一个数据库服务系统，并且根据这种分布式架构来提供online的，具有弹性的可扩展能力，例如可以不停机的添加更多数据节点，删除数据节点等等。因此像Cassandra常常被看成是一个开源版本的GoogleBigTable的替代品。Cassandra和Voldemort都是用Java开发的：1、CassandraCassandra项目是Facebook在2008年开源出来的，随后Facebook自己使用Cassandra的另外一个不开源的分支，而开源出来的Cassandra主要被Amazon的Dynamite团队来维护，并且Cassandra被认为是Dynamite2.0版本。目前除了Facebook之外，twitter和digg.com都在使用Cassandra。Cassandra的主要特点就是它不是一个数据库，而是由一堆数据库节点共同构成的一个分布式网络服务，对Cassandra的一个写操作，会被复制到其他节点上去，对Cassandra的读操作，也会被路由到某个节点上面去读取。对于一个Cassandra群集来说，扩展性能是比较简单的事情，只管在群集里面添加节点就可以了。我看到有文章说Facebook的Cassandra群集有超过100台服务器构成的数据库群集。Cassandra也支持比较丰富的数据结构和功能强大的查询语言，和MongoDB比较类似，查询功能比MongoDB稍弱一些，twitter的平台架构部门领导EvanWeaver写了一篇文章介绍Cassandra： /art...ndra/，有非常详细的介绍。Cassandra以单个节点来衡量，其节点的并发读写性能不是特别好，有文章说评测下来Cassandra每秒大约不到1万次读写请求，我也看到一些对这个问题进行质疑的评论，但是评价Cassandra单个节点的性能是没有意义的，真实的分布式数据库访问系统必然是n多个节点构成的系统，其并发性能取决于整个系统的节点数量，路由效率，而不仅仅是单节点的并发负载能力。2、VoldemortVoldemort是个和Cassandra类似的面向解决scale问题的分布式数据库系统，Cassandra来自于Facebook这个SNS网站，而Voldemort则来自于Linkedin这个SNS网站。说起来SNS网站为我们贡献了n多的NoSQL数据库，例如Cassandar，Voldemort，TokyoCabinet，Flare等等。Voldemort的资料不是很多，因此我没有特别仔细去钻研，Voldemort官方给出Voldemort的并发读写性能也很不错，每秒超过了1.5万次读写。从Facebook开发Cassandra，Linkedin开发Voldemort，我们也可以大致看出国外大型SNS网站对于分布式数据库，特别是对数据库的scale能力方面的需求是多么殷切。前面我（robbin）提到，web应用的架构当中，web层和app层相对来说都很容易横向扩展，唯有数据库是单点的，极难scale，现在Facebook和Linkedin在非关系型数据库的分布式方面探索了一条很好的方向，这也是为什么现在Cassandra这么热门的主要原因。如今，NoSQL数据库是个令人很兴奋的领域，总是不断有新的技术新的产品冒出来，改变我们已经形成的固有的技术观念，我自己（robbin）稍微了解了一些，就感觉自己深深的沉迷进去了，可以说NoSQL数据库领域也是博大精深的，我（robbin）也只能浅尝辄止，我（robbin）写这篇文章既是自己一点点钻研心得，也是抛砖引玉，希望吸引对这个领域有经验的朋友来讨论和交流。从我（robbin）个人的兴趣来说，分布式数据库系统不是我能实际用到的技术，因此不打算花时间深入，而其他两个数据领域（高性能NoSQLDB和海量存储NoSQLDB）都是我很感兴趣的，特别是Redis，TT/TC和MongoDB这3个NoSQL数据库，因此我接下来将写三篇文章分别详细介绍这3个数据库。,2013/3/23
977,结合struts和hibernate谈J2EE架构的数据表示（转自iteye）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8305,"在struts+hibernate这种结构中，是不应该把Hibernate产生的PO直接传递给JSP的，不管他是Iterator，还是List，这是一个设计错误。我来谈谈在J2EE架构中各层的数据表示方法：Web层的数据表示是FormBean，数据来源于HTMLFormPOST业务层的数据表示是VO持久层的数据表示是PO，其数据来源于数据库，持久层的数据表示例如CMP在一个规范的J2EE架构中，不同层的数据表示应该被限制在层内，而不应该扩散到其它层，这样可以降低层间的耦合性，提高J2EE架构整体的可维护性和可扩展性。比如说Web层的逻辑进行了修改，那么只需要修改FormBean的结构，而不需要触动业务层和持久层的代码修改。同样滴，当数据库表进行了小的调整，那么也只需要修改持久层数据表示，而不需要触动业务层代码和Web层代码。不过由于Hibernate的强大功能，例如动态生成PO，PO的状态管理可以脱离Session，使得在应用了Hibernate的J2EE框架中，PO完全可以充当VO，因此我们下面把PO和VO合并，统称为PO。先来谈谈ActionFormBean和持久层的PO之间的重大区别。在简单的应用中，ActionFormBean和PO几乎是没有区别，所以很多人干脆就是用ActionFormBean来充当PO，于是ActionFormBean从JSP页面到Servlet控制层再到业务层，然后穿过持久层，最后一直映射到数据库表。真是一竿子捅到了底！但是在复杂的应用中，ActionFormBean和PO是分离的，他们也不可能一样。ActionFormBean是和网页里面的Form表单一一对应的，Form里面有什么元素，Bean里面就有什么属性。而PO和数据库表对应，因此如果数据库表不修改，那么PO也不会修改，如果页面的流程和数据库表字段对应关系不一致，那么你又如何能够使用ActionFormBean来取代PO呢？比如说吧，用户注册页面要求注册用户的基本信息，因此HTMLForm里面包含了基本信息属性，于是你需要一个ActionFormBean来一一对应(注意：是一一对应)，每个Bean属性对应一个文本框或者选择框什么的。而用户这个持久对象呢？他的属性和ActionFormBean有什么明显不同呢？他会有一些ActionFormBean所没有的集合属性，比如说用户的权限属性，用户的组属性，用户的帖子等等。另外还有可能的是在ActionFormBean里面有3个属性，分别是用户的FirstName,MiddleName,LastName，而在我的User这个持久对象中就是一个Name对象属性。假设我的注册页面原来只要你提供FirstName，那么ActionFormBean就这一个属性，后来我要你提供全名，你要改ActionFormBean，加两个属性。但是这个时候PO是不应该修改滴，因为数据库没有改。那么在一个完整的J2EE系统中应该如何进行合理的设计呢？JSP(View)--->ActionFormBean(Module)--->Action(Control)ActionFormBean是Web层的数据表示，它和HTML页面Form对应，只要Web页面的操作流程发生改变，它就要相应的进行修改，它不应该也不能被传递到业务层和持久层，否则一旦页面修改，会一直牵连到业务层和持久层的大面积的代码进行修改，对于软件的可维护性和可扩展性而言，是一个灾难，Actiont就是他的边界，到此为止！Action(WebControl)--->BusinessBean--->DAO--->ORM--->DB而PO则是业务层和持久层的数据表示，它在业务层和持久层之间进行流动，他不应该也不能被传递到Web层的View中去，而ActionServlet就是他的边界，到此为止！然后来看一看整个架构的流程：当用户通过浏览器访问网页，提交了一个页面。于是Action拿到了这个FormBean，他会把FormBean属性读出来，然后构造一个PO对象，再调用业务层的Bean类，完成了注册操作，重定向到成功页面。而业务层Bean收到这个PO对象之后，调用DAO接口方法，进行持久对象的持久化操作。当用户查询某个会员的信息的时候，他用全名进行查询，于是Action得到一个UserNameFormBean包括了3个属性，分别是firstname,middlename,lastname，然后Action把UserNameFormBean的3个属性读出来，构造Name对象，再调用业务Bean，把Name对象传递给业务Bean，进行查询。业务Bean取得Name(注意:Name对象只是User的一个属性)对象之后调用DAO接口，返回一个User的PO对象，注意这个User不同于在Web层使用的UserFormBean，他有很多集合属性滴。然后业务Bean把User对象返回给Action。Action拿到User之后，把User的基本属性取出(集合属性如果不需要就免了)，构造UserFormBean，然后把UserFormBeanrequest.setAttribute(...)，然后重定向到查询结果页面。查询页面拿到request对象里面的ActionFormBean，自动调用tag显示之。总结：FormBean是Web层的数据表示，他不能被传递到业务层；PO是持久层的数据表示，在特定情况下，例如Hibernate中，他可以取代VO出现在业务层，但是不管PO还是VO都必须限制在业务层内使用，最多到达Web层的Control，绝不能被扩散到View去。FormBean和PO之间的数据转化是在Action中进行滴。BTW:JDO1.x还不能像Hibernate功能这样强大，PO不能脱离持久层，所以必须在业务层使用VO，因此必须在业务层进行大量的VO和PO的转化操作，相对于Hibernate来说，编程比较烦琐。当然咯，理论是一回事，实际操作也不一定非要这样干，你可以自行取舍，在实际项目中灵活一点，增加一点badsmell，提高开发效率。只不过在大型项目中最好还是严丝合缝，不然的话，改版的时候会痛苦的很滴。",2013/3/23
978,spring入门编程问题集锦,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8304,"我写的一篇文章，希望对spring初学者有所帮助：1、如何学习Spring？你可以通过下列途径学习spring：(1)spring下载包中doc目录下的MVC-step-by-step和sample目录下的例子都是比较好的spring开发的例子。(2)AppFuse集成了目前最流行的几个开源轻量级框架或者工具Ant,XDoclet,Spring,Hibernate(iBATIS),JUnit,Cactus,StrutsTestCase,Canoo'sWebTest,StrutsMenu,DisplayTagLibrary,OSCache,JSTL,Struts。你可以通过AppFuse源代码来学习spring。AppFuse网站： （中文版，未全部翻译）还有就是多实践吧。",2013/3/23
979,hibernate二级缓存攻略（转自iteye）,周倩,http://180.168.156.212:2262/wecenter/?/article/8303,"很多人对二级缓存都不太了解，或者是有错误的认识，我一直想写一篇文章介绍一下hibernate的二级缓存的，今天终于忍不住了。我的经验主要来自hibernate2.1版本，基本原理和3.0、3.1是一样的，请原谅我的顽固不化。hibernate的session提供了一级缓存，每个session，对同一个id进行两次load，不会发送两条sql给数据库，但是session关闭的时候，一级缓存就失效了。二级缓存是SessionFactory级别的全局缓存，它底下可以使用不同的缓存类库，比如ehcache、oscache等，需要设置hibernate.cache.provider_class，我们这里用ehcache，在2.1中就是hibernate.cache.provider_class=net.sf.hibernate.cache.EhCacheProvider如果使用查询缓存，加上hibernate.cache.use_query_cache=true缓存可以简单的看成一个Map，通过key在缓存里面找value。Class的缓存对于一条记录，也就是一个PO来说，是根据ID来找的，缓存的key就是ID，value是POJO。无论list，load还是iterate，只要读出一个对象，都会填充缓存。但是list不会使用缓存，而iterate会先取数据库selectid出来，然后一个id一个id的load，如果在缓存里面有，就从缓存取，没有的话就去数据库load。假设是读写缓存，需要设置：<cacheusage=""read-write""/>如果你使用的二级缓存实现是ehcache的话，需要配置ehcache.xml<cachename=""com.xxx.pojo.Foo""maxElementsInMemory=""500""eternal=""false""timeToLiveSeconds=""7200""timeToIdleSeconds=""3600""overflowToDisk=""true""/>其中eternal表示缓存是不是永远不超时，timeToLiveSeconds是缓存中每个元素（这里也就是一个POJO）的超时时间，如果eternal=""false""，超过指定的时间，这个元素就被移走了。timeToIdleSeconds是发呆时间，是可选的。当往缓存里面put的元素超过500个时，如果overflowToDisk=""true""，就会把缓存中的部分数据保存在硬盘上的临时文件里面。每个需要缓存的class都要这样配置。如果你没有配置，hibernate会在启动的时候警告你，然后使用defaultCache的配置，这样多个class会共享一个配置。当某个ID通过hibernate修改时，hibernate会知道，于是移除缓存。这样大家可能会想，同样的查询条件，第一次先list，第二次再iterate，就可以使用到缓存了。实际上这是很难的，因为你无法判断什么时候是第一次，而且每次查询的条件通常是不一样的，假如数据库里面有100条记录，id从1到100，第一次list的时候出了前50个id，第二次iterate的时候却查询到30至70号id，那么30-50是从缓存里面取的，51到70是从数据库取的，共发送1+20条sql。所以我一直认为iterate没有什么用，总是会有1+N的问题。（题外话：有说法说大型查询用list会把整个结果集装入内存，很慢，而iterate只selectid比较好，但是大型查询总是要分页查的，谁也不会真的把整个结果集装进来，假如一页20条的话，iterate共需要执行21条语句，list虽然选择若干字段，比iterate第一条selectid语句慢一些，但只有一条语句，不装入整个结果集hibernate还会根据数据库方言做优化，比如使用mysql的limit，整体看来应该还是list快。）如果想要对list或者iterate查询的结果缓存，就要用到查询缓存了查询缓存首先需要配置hibernate.cache.use_query_cache=true如果用ehcache，配置ehcache.xml，注意hibernate3.0以后不是net.sf的包名了<cachename=""net.sf.hibernate.cache.StandardQueryCache""maxElementsInMemory=""50""eternal=""false""timeToIdleSeconds=""3600""timeToLiveSeconds=""7200""overflowToDisk=""true""/><cachename=""net.sf.hibernate.cache.UpdateTimestampsCache""maxElementsInMemory=""5000""eternal=""true""overflowToDisk=""true""/>然后query.setCacheable(true);//激活查询缓存query.setCacheRegion(""myCacheRegion"");//指定要使用的cacheRegion，可选第二行指定要使用的cacheRegion是myCacheRegion，即你可以给每个查询缓存做一个单独的配置，使用setCacheRegion来做这个指定，需要在ehcache.xml里面配置它：<cachename=""myCacheRegion""maxElementsInMemory=""10""eternal=""false""timeToIdleSeconds=""3600""timeToLiveSeconds=""7200""overflowToDisk=""true""/>如果省略第二行，不设置cacheRegion的话，那么会使用上面提到的标准查询缓存的配置，也就是net.sf.hibernate.cache.StandardQueryCache对于查询缓存来说，缓存的key是根据hql生成的sql，再加上参数，分页等信息（可以通过日志输出看到，不过它的输出不是很可读，最好改一下它的代码）。比如hql：fromCatcwherec.namelike?生成大致如下的sql：select*fromcatcwherec.namelike?参数是""tiger%""，那么查询缓存的key*大约*是这样的字符串（我是凭记忆写的，并不精确，不过看了也该明白了）：select*fromcatcwherec.namelike?,parameter:tiger%这样，保证了同样的查询、同样的参数等条件下具有一样的key。现在说说缓存的value，如果是list方式的话，value在这里并不是整个结果集，而是查询出来的这一串ID。也就是说，不管是list方法还是iterate方法，第一次查询的时候，它们的查询方式很它们平时的方式是一样的，list执行一条sql，iterate执行1+N条，多出来的行为是它们填充了缓存。但是到同样条件第二次查询的时候，就都和iterate的行为一样了，根据缓存的key去缓存里面查到了value，value是一串id，然后在到class的缓存里面去一个一个的load出来。这样做是为了节约内存。可以看出来，查询缓存需要打开相关类的class缓存。list和iterate方法第一次执行的时候，都是既填充查询缓存又填充class缓存的。这里还有一个很容易被忽视的重要问题，即打开查询缓存以后，即使是list方法也可能遇到1+N的问题！相同条件第一次list的时候，因为查询缓存中找不到，不管class缓存是否存在数据，总是发送一条sql语句到数据库获取全部数据，然后填充查询缓存和class缓存。但是第二次执行的时候，问题就来了，如果你的class缓存的超时时间比较短，现在class缓存都超时了，但是查询缓存还在，那么list方法在获取id串以后，将会一个一个去数据库load！因此，class缓存的超时时间一定不能短于查询缓存设置的超时时间！如果还设置了发呆时间的话，保证class缓存的发呆时间也大于查询的缓存的生存时间。这里还有其他情况，比如class缓存被程序强制evict了，这种情况就请自己注意了。另外，如果hql查询包含select字句，那么查询缓存里面的value就是整个结果集了。当hibernate更新数据库的时候，它怎么知道更新哪些查询缓存呢？hibernate在一个地方维护每个表的最后更新时间，其实也就是放在上面net.sf.hibernate.cache.UpdateTimestampsCache所指定的缓存配置里面。当通过hibernate更新的时候，hibernate会知道这次更新影响了哪些表。然后它更新这些表的最后更新时间。每个缓存都有一个生成时间和这个缓存所查询的表，当hibernate查询一个缓存是否存在的时候，如果缓存存在，它还要取出缓存的生成时间和这个缓存所查询的表，然后去查找这些表的最后更新时间，如果有一个表在生成时间后更新过了，那么这个缓存是无效的。可以看出，只要更新过一个表，那么凡是涉及到这个表的查询缓存就失效了，因此查询缓存的命中率可能会比较低。Collection缓存需要在hbm的collection里面设置<cacheusage=""read-write""/>假如class是Cat，collection叫children，那么ehcache里面配置<cachename=""com.xxx.pojo.Cat.children""maxElementsInMemory=""20""eternal=""false""timeToIdleSeconds=""3600""timeToLiveSeconds=""7200""overflowToDisk=""true""/>Collection的缓存和前面查询缓存的list一样，也是只保持一串id，但它不会因为这个表更新过就失效，一个collection缓存仅在这个collection里面的元素有增删时才失效。这样有一个问题，如果你的collection是根据某个字段排序的，当其中一个元素更新了该字段时，导致顺序改变时，collection缓存里面的顺序没有做更新。缓存策略只读缓存（read-only）：没有什么好说的读/写缓存（read-write）:程序可能要的更新数据不严格的读/写缓存（nonstrict-read-write）：需要更新数据，但是两个事务更新同一条记录的可能性很小，性能比读写缓存好事务缓存（transactional）：缓存支持事务，发生异常的时候，缓存也能够回滚，只支持jta环境，这个我没有怎么研究过读写缓存和不严格读写缓存在实现上的区别在于，读写缓存更新缓存的时候会把缓存里面的数据换成一个锁，其他事务如果去取相应的缓存数据，发现被锁住了，然后就直接取数据库查询。在hibernate2.1的ehcache实现中，如果锁住部分缓存的事务发生了异常，那么缓存会一直被锁住，直到60秒后超时。不严格读写缓存不锁定缓存中的数据。使用二级缓存的前置条件你的hibernate程序对数据库有独占的写访问权，其他的进程更新了数据库，hibernate是不可能知道的。你操作数据库必需直接通过hibernate，如果你调用存储过程，或者自己使用jdbc更新数据库，hibernate也是不知道的。hibernate3.0的大批量更新和删除是不更新二级缓存的，但是据说3.1已经解决了这个问题。这个限制相当的棘手，有时候hibernate做批量更新、删除很慢，但是你却不能自己写jdbc来优化，很郁闷吧。SessionFactory也提供了移除缓存的方法，你一定要自己写一些JDBC的话，可以调用这些方法移除缓存，这些方法是：voidevict(ClasspersistentClass)Evictallentriesfromthesecond-levelcache.voidevict(ClasspersistentClass,Serializableid)Evictanentryfromthesecond-levelcache.voidevictCollection(StringroleName)Evictallentriesfromthesecond-levelcache.voidevictCollection(StringroleName,Serializableid)Evictanentryfromthesecond-levelcache.voidevictQueries()Evictanyqueryresultsetscachedinthedefaultquerycacheregion.voidevictQueries(StringcacheRegion)Evictanyqueryresultsetscachedinthenamedquerycacheregion.不过我不建议这样做，因为这样很难维护。比如你现在用JDBC批量更新了某个表，有3个查询缓存会用到这个表，用evictQueries(StringcacheRegion)移除了3个查询缓存，然后用evict(ClasspersistentClass)移除了class缓存，看上去好像完整了。不过哪天你添加了一个相关查询缓存，可能会忘记更新这里的移除代码。如果你的jdbc代码到处都是，在你添加一个查询缓存的时候，还知道其他什么地方也要做相应的改动吗？----------------------------------------------------总结：不要想当然的以为缓存一定能提高性能，仅仅在你能够驾驭它并且条件合适的情况下才是这样的。hibernate的二级缓存限制还是比较多的，不方便用jdbc可能会大大的降低更新性能。在不了解原理的情况下乱用，可能会有1+N的问题。不当的使用还可能导致读出脏数据。如果受不了hibernate的诸多限制，那么还是自己在应用程序的层面上做缓存吧。在越高的层面上做缓存，效果就会越好。就好像尽管磁盘有缓存，数据库还是要实现自己的缓存，尽管数据库有缓存，咱们的应用程序还是要做缓存。因为底层的缓存它并不知道高层要用这些数据干什么，只能做的比较通用，而高层可以有针对性的实现缓存，所以在更高的级别上做缓存，效果也要好些吧。",2013/3/23
980,Hibernate的批量删除的效率分析（转自iteye）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8299,"Hibernate作为ORM，有一个ORM固有的问题，就是由于为了持久对象的同步，不能够使用批量删除和批量更新的sql，只能按照主键一条条来操作。因此效率相对JDBC来说是比较低的。然而事情也并不总是那么绝望，只要你对Hibernate进行优化，也可以得到相当满意的速度。Java代码1.session.delete(""fromCatascwhere..."");;session.delete(""fromCatascwhere..."");;该语句实际上发送sql：Java代码1.==>selectid,name,sex,weightfromcat;2.==>deletefromcatwhereid=?==>selectid,name,sex,weightfromcat;==>deletefromcatwhereid=?Hibernate先查询数据，确实要消耗一些时间，但是select只读操作和insert，delete，update这些数据库修改操作在速度上有一个以上的数量级的差距。所以Hibernate虽然查询数据要多耗时，但是消耗的这点时间影响不是很大，主要是内存消耗的多。而delete的速度，我们知道调节Hibernate的BatchSize可以提供大大提高insert,delete和update的速度。我的测试：Oracle817，ojdbc14.jar表记录1万条，全部删除。JDBC:sql语句Java代码1.deletefromcatdeletefromcat速度：平均6sHibernate:Java代码1.session.delete(""fromCatasc"");;session.delete(""fromCatasc"");;BatchSize=0速度：25sBatchSize=50速度：6s批量删除和批量更新建议用JDBC，这是一个原则，当然有的时候可能必须用Hibernate来批量更新和批量删除，那么这个时候我想说的就是，Hibernate批量更新和删除效率并非传说中的那么差，只要优化的好，速度也非常快。",2013/3/23
981,如何学习Hibernate（转自iteye）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8302,Hibernate入门容易，掌握精通我也不敢自夸。我第一遍看Hibernate文档的时候也觉得很吃力，但不是因为Hibernate难掌握而感到吃力，是因为Hibernate文档处处都是持久层设计的经验和最佳实践。Hibernate文档准确的来说，绝大部分内容都在讲对象的持久层设计，而不是简单的Hibernate使用，使用问题查Javadoc就够了。所以学习Hibernate，主要是在学习持久层的设计模式，如果你把Hibernate文档都看完了，还整天只会提那些Hibernate的配置问题，Hibernate的类调用问题，我觉得这样的人还没有真正的入门，算是白学了。我对Hibernate的那些配置也不是特别纯熟，每次写hbm，都要对照文档一点点的检查；类调用参数也不太记得，写代码也要Javadoc随时备查。但是我在学习Hibernate的时候即集中所有精力来理解Hibernate的运行原理，集中精力来掌握持久层设计应该把握的原则和技巧，这些才对我是最重用的东西。毫不夸张的说，学习完Hibernate，我对JDBC的编程也提高了一大截，更不要说对于J2EE架构的持久层的框架设计，基本上是了然于胸了，即使将来换了API，不用Hibernate的，改用JDO，Castor什么的，这些经验一样照用。学习Hibernate主要不是在学习Hibernat怎么配置，用工具怎么生成hbm文件，如果你把重点放在这里，基本上等于白学了Hibernate。Hibernate的精华在于无与伦比的灵巧的对象持久层设计，这些持久层设计经验不会因为你不用Hibernate而丧失掉，我自己学习Hibernate，已经明显感觉到对持久层设计能力已经长了很多经验值了，这些经验甚至不光可以用在Java上，用在.net上也是一样。所以Hibernate配置的学习，我只是简单看看，用的时候知道到那里去查就行了，一堆复杂的生成工具我根本就看都不去看，这样算下来，掌握Hibernate的配置，可以用Hibernate来替代JDBC写程序，不过花上3天时间就足够了。我想3天时间对你来说不算很奢侈的学习代价吧。为什么我这么强调学习Hibernate的对象持久层设计理念呢？那就看你的理想是想一辈子做一个程序员呢？还是想向更高的方向发展呢？从纯做技术的角度来说，职业发展的最高点是“系统架构师”，BillGates不是还叫做微软的首席系统架构师吗？SystemArchitect职位需要的是你的学习和领悟能力，如果你不能把学习Hibernate得到的设计经验运用到其它地方，那么你是失败的，也没有资格做SystemArchitect。不管JDO也好，Hibernate也好，TopLink也好，CocoBase也好，还是Castor，还是什么Torque，OJB，软件的使用和配置方法可以各异，但本质上都是ORM，都是对JDBC的对象持久层封装，所以万变不离其宗，如果你完整的学习和掌握Hibernate花了1个月的时间，那么你再学习OJB的时间不应该超过1个星期，因为你已经把对象持久层设计都了然于胸了，你需要的只是熟悉一下OJB的API和配置罢了，至于怎么运用OJB进行持久层的开发你早就已经熟悉了。所以当你掌握了两种以上的ORM，你应该能够不拘于使用的ORM软件的限制，设计出适合于你的项目的持久层来，这才是SystemArchitect的水准。用金庸小说来打个比方来说吧，张无忌学太极剑，只记剑意，不记剑招，这才是真正的高手，而低手就只会去学习剑招，而不去领会剑招背后蕴含的剑意，所以一辈子都是低手，永远不能真正学会太极剑。所以周颠看到张三丰第二次演示太极剑，招式完全不同就以为是另一套东西，其实本质上都一样。学习Hibernate也不要舍本逐末的去学各种五花八门的工具，重点掌握它的对象持久层设计理念。,2013/3/23
982,最佳J2EE方案讨论之O-R Mapping：hibernate v.s. CMP[转自guty],郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8301,"该文转自gutyO-RMappingJ2EE的标准是CMPEntityBean，而实际应用中受到诟病最多的也是它。我们化了整整半年时间研究CMP2.0的开发方法，目前总算能够将代码量减少到70%，并且有希望减少到90%。我曾经很满足现有的成绩，但是当我真正地阅读了hibernate后，对CMP2.0的信心彻底动摇了。hibernate至少比CMP2.0有以下优点：1.兼容性。规范一模一样，实现各有不同，这是CMP的现状。用第三方O-RMapping工具可以解决这个问题。2.保护智力投资。在了解了Orion,Weblogic,JBoss的CMP实现后，我不愿意再去学习Websphere或者Resin的实现了。3.性能。a.localv.s.remote，hibernate、JDO、Castor都是本地调用，CMP2.0虽然也有Local接口，但是Web层还是需要通过Remote接口访问EJB层的数据,序列化、网络调用、创建大量的对象，都是性能降低的原因。b.transaction，J2EE提出了一个全新的事务模型（method-baseddescriptor)，对程序员的开发确实是个“简化”，记得一本教程建议所有的EJB方法都用Required。但这样的结果是什么？性能极度降低！互锁！没有办法，我们只有再去调节各个方法的Transaction属性，然后又出现新的互锁...新的事务模型是不成功的。它试图简化问题，却引入了更为严重的问题。各家厂商的Transaction实现也不尽相同，有的支持OptimisticLock，有的在VM中同步Entity对象，又是兼容性的一大敌。hibernate没有试图创造一个更新的模式，相反，它沿用了传统数据库的Transaction编程模式，在对J2EE的Transaction伤透脑筋后看到它，真是十分亲切，感觉自己确实在编程，而不是碰运气填代码了。4.动态Query。EntityBean很难实现动态Query，这是因为它基于代码自动生成技术，即最终的执行代码是在部署编译时生成的。hibernate则有根本的改变，它基于reflection机制，运行时动态Query是很自然的事。另外，hibernate几乎支持所有的SQL语法，传统数据库可以做的它就可以做。5.发展速度。Ihaveadream,有一天EntityBean会变得很好。但至少目前来看，EntityBean是一个不完善的产品，它是大公司政治斗争和妥协的产品，而且习惯性将一些问题“无限期搁置”，典型的例子就是Query（之所以不提其他问题，是因为其他都是EntityBean的致命伤：））形成强烈反差的是，hibernate的核心程序员只有一人，但它改进的速度确是EntityBean无法企及的。6.继承和多态。OO语言的精华在EntityBean这里是行不通的，我曾经自我安慰将EntityBean看做一个“内存中的数据表”，才找到了一点平衡。但当我看到hibernate时，又开始不平衡了。另外，CMP2.0也有一些缺点是可以弥补的。1.代码维护。大量的接口文件和配置文件，开发和维护的工作量很大。解决途径：采用xdoclet,可以自动产生众多的接口和配置文件，甚至facade,delegate等高级模式。至少目前来看，hibernate的缺点有：1.代码维护hibernate提供了自动生成mapping文件“框架”的工具，但还需要手工调节。而这类开发，能想到的最佳模式就是xdoclet的（代码+注释）的模式了。幸好，hibernate的程序员已经向xdoclet项目增加了hibernate的模块。现在需要的是等待xdoclet的下一个release。结论：hibernate至少从文档上超越了EntityBean很多，我要学习hibernate。",2013/3/23
983,为什么Hibernate如此成功！（转自iteye）,郭晶晶,http://180.168.156.212:2262/wecenter/?/article/8300,“为什么Hibernate如此成功！” 这篇文章是GavinKing写的，非常有趣，充分体现了Hibernate的设计理念，我粗略的意译如下：下面是对Hibernate开发工作的个人想法，正是这些工作使得Hibernate如此迅速的得到广泛的欢迎。1、飞快的版本发布保持活跃的开发速度，经常进行版本发布，甚至几天之内就从前一个版本开发到下一个版本。这样是保证软件远离Bug的最好的办法，也可以让用户感到很放心，确信Hibernate的开发十分活跃，另外这样做也有一大好处，就是可以发现哪些功能是用户真正需要的。2、回归测试我想现在整个Java社区一定都很重视自动回归测试。如果软件的功能和设计有比较大的修改，那么一个综合性的testsuite对于软件可维护性和稳定性来说实在是太重要了。我们应该有这样的意识：如果对软件的一个新功能没有进行回归测试，我们根本就不该去做它。3、把一个功能做到最好要么不做，要做，就一定做到最好。那些我们做不到最好的功能，我们根本不去做，扔给其他软件去做吧。4、避免过度设计浪费大量的时间和精力进行软件功能的抽象和扩充软件的灵活性，还不如多花点时间来解决你的用户面临的实际问题呢！简单一点!软件能跑起来就OK，不要尝试去解决你的用户根本不关心的问题。就算你的软件设计的不够优雅也没有关系，反正还是initial阶段嘛！以后再refactor，你应该关注的问题是及时的把有用的功能给做出来。5、集权在你需要由民主投票来下决定之前，至少你已经把软件轮廓做好了。软件开发需要由一两个开明的人来领导，这样可以保证软件开发的连贯性而不至于产生太大的分歧，可以保证开发团队集中火力把要实现的功能做到最好。我觉得，OSS软件最大的风险就是意见不统一，摊子铺的太大，结果最后搞的什么都没有做好。（译者按：非常赞同，凡是成功的OSS软件，都是在某个牛人已经把软件做好了之后，发布出来，然后由大家往里面添加功能的，并且在牛人的领导下不断进步。缺乏牛人的OSS软件都不算很成功，比如Mozilla）6、文档没有什么比文档更重要的了。如果你的用户不知道你的软件有这么一个功能，就等于没有这个功能，干脆把它去掉得了，省得给源代码增加复杂度。7、避免标准化好的标准可以带来软件的互用性和可移植性，坏的标准能够窒息软件创新！“支持XXX标准”根本就不是真实的用户需求，特别是当这个XXX标准是那些在其位不谋其政“所谓”的专家委员会制订出来的。（译者按：莫非指Sun，IBM等几个bigname？）最好的软件是在不断的尝试，不断的出错，不断的经验积累的过程中产生的。事实上的标准往往更加贴近用户需求。8、10分钟之内把Hibernate跑起来潜在的Hibernate的用户在他们下载了Hibernate，第一次使用的时候根本就不可能花半个小时那么多时间来安装、配置和troubleshooting，他们早就丧失了对Hibernate的兴趣了。我们的口号就是新用户（假设有足够的JDBC知识）5分钟之内把Hibernate的Demo跑起来，而他们能够在1个小时之内写出“HelloWorld”式的最简单的Hibernate程序并且正常运行。9、开发人员的责任感用户总是不可避免的碰到问题，开发团队有责任有义务提供帮助。用户让我们知道了文档的漏洞，用户让我们知道了测试用例的小bug。此外，没有用户来用我们的Hibernate，我们还开发它做什么，不是浪费时间吗！有个关于bug的笑话：用户根本不介意发现新功能的bug（译者按：Windows的用户好像都是如此），只要你能迅速的改掉bug。“责任感”意味着bug修复应该在1周之内。从收到bug报告到bug修复代码提交到CVS上要做到平均在24小时左右，这才是一个理想的目标。10、易用的、可更新的wiki网页（译者按：wiki是Hibernate网站用的一个web发布框架）,2013/3/23
984,一目飘过,余礼华,http://180.168.156.212:2262/wecenter/?/article/8298,:):):)路过，一目飘走。。。。。。,2013/3/13
985,快捷方式设置页面显示很缓慢,余礼华,http://180.168.156.212:2262/wecenter/?/article/8293,"快捷方式设置页面显示很缓慢,约等了10几秒才出来.",2013/3/12
986,给寿星送祝福功能建议完善.,余礼华,http://180.168.156.212:2262/wecenter/?/article/8292,"目前给当日寿星送上祝福,不能输入具体的祝福语,仅仅是数字加1,希望可以送上个性的祝福语.",2013/3/12
987,报修联系单无法提交!,余礼华,http://180.168.156.212:2262/wecenter/?/article/8291,"报修联系单无法提交!提示:*""分管部门领导/助理审核确认""节点没有合法的审批人！",2013/3/12
988,"""财务报销""快捷方式点击报错",章洁,http://180.168.156.212:2262/wecenter/?/article/8290,"新增加快捷方式:""财务报销"",点击后报错.电子地图.xls",2013/3/12
989,BBS主题发表的输入框太短,娄会兵,http://180.168.156.212:2262/wecenter/?/article/8297,BBS主题发表的输入框太短，稍微超一点的主题会显示不全。。,2013/3/11
